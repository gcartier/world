;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Shaders
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is WorldScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2014
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See http://github.com/gcartier/world for details.


(module world.shaders jazz


(import (world.fog)
        (world.support))


;;;
;;;; Default
;;;


(definition (build-default-vs)
  (string-append
    #<<SHADER
#version 140

void main()
{
    gl_Position = vec4(1.0, 1.0, 1.0, 1.0);
}
SHADER
))


(definition (build-default-fs)
  (string-append
    #<<SHADER
#version 140
 
out vec4 fragColor;

void main()
{
    fragColor = vec4(1.0, 1.0, 1.0, 1.0);
}
SHADER
))


(definition public default-vs
  #f)

(definition public default-fs
  #f)


(definition public (build-default-shaders)
  (set! default-vs (build-default-vs))
  (set! default-fs (build-default-fs)))


;;;
;;;; Interface
;;;


(definition (build-interface-vs)
  (string-append
    #<<SHADER
#version 140

uniform mat4 projection_matrix;

in vec3 vertex_coord;
in vec3 texture_coord;

out vec3 final_texture_coord;

void main()
{
    gl_Position = projection_matrix * vec4(vertex_coord, 1.0);
    final_texture_coord = texture_coord;
}
SHADER
))


(definition (build-interface-fs)
  (string-append
    #<<SHADER
#version 140

uniform sampler2D texture_sampler;

in vec3 final_texture_coord;

out vec4 fragColor;

void main()
{
    fragColor = texture(texture_sampler, vec2(final_texture_coord.x, final_texture_coord.y));
}
SHADER
))


(definition public interface-vs
  #f)

(definition public interface-fs
  #f)


(definition public (build-interface-shaders)
  (set! interface-vs (build-interface-vs))
  (set! interface-fs (build-interface-fs)))


;;;
;;;; Skybox
;;;


(definition (build-skybox-vs)
  (string-append
    #<<SHADER
#version 140

uniform mat4 projection_matrix;
uniform mat4 view_matrix;

in vec3 vertex_coord;

out vec3 texCoord;

void main()
{
    gl_Position = projection_matrix * view_matrix * vec4(vertex_coord, 1.0);
  
    texCoord = vertex_coord;
}
SHADER
))


(definition (build-skybox-fs)
  (string-append
    #<<SHADER
#version 140

uniform samplerCube cubemap;

in vec3 texCoord;

out vec4 fragColor;

void main()
{
    fragColor = texture(cubemap, texCoord);
}
SHADER
))


(definition public skybox-vs
  #f)

(definition public skybox-fs
  #f)


(definition public (build-skybox-shaders)
  (set! skybox-vs (build-skybox-vs))
  (set! skybox-fs (build-skybox-fs)))


;;;
;;;; Skeletal Animation
;;;


(definition (skeletal-header)
(if (get-animations?)
#<<SHADER
uniform int use_bones;
uniform mat4 bone_matrices[200];
SHADER
""))


(definition (skeletal-setup)
  (if (get-animations?)
#<<SHADER
vec4 skeletal_pos;
vec3 skeletal_normal;
if (use_bones != 0)
{
    mat4 boneTransform = bone_matrices[int(bone_id)];
    skeletal_pos = boneTransform * vec4(vertex_coord, 1.0);
    skeletal_normal = (boneTransform * vec4(normal, 0.0)).xyz;
}
else
{
    skeletal_pos = vec4(vertex_coord, 1.0);
    skeletal_normal = normal;
}
SHADER

#<<SHADER
    vec4 skeletal_pos = vec4(vertex_coord, 1.0);
    vec3 skeletal_normal = normal;
SHADER
))


;;;
;;;; Baked Light
;;;


(definition (baked-light minecraft?)
  (if (not minecraft?)
#<<SHADER
    vec4 baked_light = vec4(lighting, 1.0);
SHADER
      
#<<SHADER
    float blocklight = lighting.x * 1.2;
    float skylight = lighting.y;
    float ambience = lighting.z;
    float lighttime = daylight_whatthefuck * 11. + 4.;
    float dimmer = lighttime / 15.;
    skylight = skylight * dimmer;
    float light;
    if (player_glow < 0.)
        light = blocklight + skylight;
    else
    {
        float z = distance(player_coord, vertex_coord);
        light = blocklight + skylight + ambience * min(60, player_glow / z);
    }
    light = pow(.8, (60. - light) / 5.);
    vec4 baked_light = vec4(light, light, light, 1.0);
SHADER
)
)


;;;
;;;; Mesh Color
;;;


(definition (build-mesh-color-vs)
  (string-append
    #<<SHADER
#version 140

uniform mat4 projection_matrix;
uniform mat4 view_matrix;
uniform mat4 model_matrix;
uniform int moment;
uniform vec4 color;

in vec3 vertex_coord;
in vec3 normal;
in float bone_id;
SHADER

(skeletal-header)

#<<SHADER
out vec4 final_color;

void main()
{
SHADER

(skeletal-setup)

#<<SHADER
    gl_Position = projection_matrix * view_matrix * model_matrix * skeletal_pos;
    final_color = color;
}
SHADER
))


(definition public (build-mesh-color-fs)
  (string-append
    #<<SHADER
#version 140

uniform int moment;

in vec4 final_color;

out vec4 fragColor;

void main()
{
    vec4 transparency = vec4(1., 1., 1., (moment == 0) ? 1. : .25);
    fragColor = final_color * transparency;
}
SHADER
))


(definition public mesh-color-vs
  #f)

(definition public mesh-color-fs
  #f)


(definition public (build-color-shaders)
  (set! mesh-color-vs (build-mesh-color-vs))
  (set! mesh-color-fs (build-mesh-color-fs)))


;;;
;;;; Mesh Phong
;;;


(definition (build-mesh-phong-vs minecraft?)
  (string-append
    #<<SHADER
#version 140

struct Light
{
   vec4 ambient;
   vec4 diffuse;
   vec4 specular;
   vec4 position;
   vec4 halfVector;
   vec3 spotDirection;
   float spotExponent;
   float spotCutoff;
   float spotCosCutoff;
   float constantAttenuation;
   float linearAttenuation;
   float quadraticAttenuation;
};

struct Material
{
   vec4 emission;
   vec4 ambient;
   vec4 diffuse;
   vec4 specular;
   float shininess;
};

#define MAX_LIGHTS 8

uniform mat4 projection_matrix;
uniform mat4 view_matrix;
uniform mat4 model_matrix;
uniform int moment;
uniform vec4 ambient_color;
SHADER

(if minecraft?
    #<<SHADER
uniform float daylight_whatthefuck;
uniform float player_glow;
uniform vec3 player_coord;
SHADER

"")

#<<SHADER
uniform vec4 sun_color;
uniform vec3 sun_coord;
uniform int lights_count;
uniform Light lights[MAX_LIGHTS];
uniform Material front_material;

in vec3 vertex_coord;
in vec3 normal;
in vec3 texture_coord;
in float bone_id;
in vec3 lighting;
SHADER

(skeletal-header)

#<<SHADER
out vec4 final_light;
out vec3 final_texture_coord;

void main()

SHADER

"{"

(skeletal-setup)

#<<SHADER
    mat3 model_normal = mat3(model_matrix);
    mat4 eye_matrix = view_matrix * model_matrix;
    vec3 v = vec3(eye_matrix * skeletal_pos);

    vec3 N = skeletal_normal;

    vec3 eyes = -v;
    vec3 L, li;
    float attenuation, specular, distanceSquare, attterm;
    float lambertTerm;
    N = normalize(N);
    vec3 R;
    vec3 E = normalize(eyes);
    
    final_light = ambient_color;
    li = sun_coord - vertex_coord;
    L = normalize(li);
    lambertTerm = dot(model_normal*N, L);
    if (lambertTerm > 0.0)
    {
        final_light += sun_color * lambertTerm;
    }
SHADER

(baked-light minecraft?)

#<<SHADER
    final_light += baked_light;
    
    // Will not work if view_matrix contains non-uniform scaling
    mat3 normalMatrix = mat3(view_matrix);
    N = normalMatrix * model_normal * skeletal_normal;
    N = normalize(N);

    for (int i=0;
         i<lights_count;
         i++)
    {
        Light light = lights[i];
        vec3 lightPosition = vec3(eye_matrix * vec4(light.position.xyz, 1));
        li = lightPosition - v;
        L = normalize(li);
        distanceSquare = dot(li,li);
        attterm = (light.constantAttenuation + light.linearAttenuation*sqrt(distanceSquare) + light.quadraticAttenuation*distanceSquare);
        if (attterm <= 0) attterm = 1.0;
        attenuation = 1.0 / attterm;
        if (attenuation > 1.0) attenuation = 1.0;
        lambertTerm = dot(N, L);
        final_light += light.ambient * front_material.ambient;
        
        if (lambertTerm > 0.0)
        {
           final_light += light.diffuse *
                       front_material.diffuse *
                       lambertTerm * attenuation;
                     
           R = reflect(-L, N);
           specular = pow(max(dot(R, E), 0.0),
                         front_material.shininess);
           final_light += (light.specular) *
                       front_material.specular *
                       specular*attenuation;
        }
    }
    if (final_light.x > 1.0) final_light.x = 1.0;
    if (final_light.y > 1.0) final_light.y = 1.0;
    if (final_light.z > 1.0) final_light.z = 1.0;
    if (final_light.w > 1.0) final_light.w = 1.0;
    gl_Position = projection_matrix * eye_matrix * skeletal_pos;
    final_texture_coord = texture_coord;

SHADER

"}"
))


(definition (build-mesh-phong-fs texture-arrays? fog? wet?)
  (string-append
    #<<SHADER
#version 140

SHADER

(if texture-arrays?
#<<SHADER
uniform sampler2DArray texture_sampler;

SHADER

#<<SHADER
uniform sampler2D texture_sampler;

SHADER
)

(if fog?
#<<SHADER
// GLFC-wait-this-is-really-slow-on-mac
// uniform vec4 fog_color;
// uniform float fog_density;

const vec4 fog_color = vec4(0.8, 0.8, 0.8, 1.0);
const float fog_density = .003;

SHADER
"")

(if wet?
#<<SHADER
// GLFC-wait-this-is-really-slow-on-mac
// uniform vec4 wet_color;

const vec4 wet_color = vec4(0.8, 0.8, 0.8, 1.0);

SHADER
"")

#<<SHADER
uniform int moment;
uniform float daylight_whatthefuck;
uniform float alpha_cut;

in vec4 final_light;
in vec3 final_texture_coord;

out vec4 fragColor;

void main()
SHADER

"{"

(if texture-arrays?
#<<SHADER
    fragColor = final_light * texture(texture_sampler, final_texture_coord);
SHADER

#<<SHADER
    fragColor = final_light * texture(texture_sampler, final_texture_coord.xy);
SHADER
)

#<<SHADER
    if (fragColor.a < alpha_cut)
        discard;
SHADER

(if fog?
#<<SHADER
    // z-buffer visualisation
    // float z = 1.0 - (gl_FragCoord.z / gl_FragCoord.w) / 100.0;
    // fragColor = vec4(z, z, z, 1.0);
    
    const float LOG2 = 1.442695;
    float z = gl_FragCoord.z / gl_FragCoord.w;
    // adjust fog density between 1. for day and .5 for night
    float density = fog_density * (daylight_whatthefuck * 0.7 + 0.3);
    float fogFactor = exp2( -density *
                             density *
                             z *
                             z *
                             LOG2 );
    fogFactor = clamp(fogFactor, 0.8, 1.0);

    fragColor = mix(fog_color, fragColor, fogFactor);
SHADER
"")

(if wet?
#<<SHADER
    fragColor = mix(wet_color, fragColor, .75);
SHADER
"")

#<<SHADER
    vec4 transparency = vec4(1., 1., 1., (moment == 0) ? 1. : .3);
    fragColor = fragColor * transparency;
    
SHADER

"}"
))


(definition public mesh-phong-vs
  #f)

(definition public mesh-minecraft-vs
  #f)


(definition public mesh-phong-fs
  #f)

(definition public mesh-wet-fs
  #f)


(definition public (build-phong-shaders)
  (let ((texture-arrays? (get-texture-arrays?))
        (fog? (get-fog?)))
    ;; vertex
    (set! mesh-phong-vs (build-mesh-phong-vs #f))
    (set! mesh-minecraft-vs (build-mesh-phong-vs #t))
    ;; fragment
    (set! mesh-phong-fs (build-mesh-phong-fs texture-arrays? fog? #f))
    (set! mesh-wet-fs (build-mesh-phong-fs texture-arrays? #f #t))))


;;;
;;;; Mesh Occlusion
;;;


(definition (build-mesh-occlusion-vs)
  (string-append
    #<<SHADER
#version 140

uniform mat4 projection_matrix;
uniform mat4 view_matrix;
uniform mat4 model_matrix;
uniform float daylight_whatthefuck;

in vec3 vertex_coord;
in vec3 lighting;
uniform float player_glow;
uniform vec3 player_coord;
SHADER

#<<SHADER
out vec4 final_light;

void main()

SHADER

"{"

(baked-light #t)

#<<SHADER
    final_light = baked_light;
    
    if (final_light.x > 1.0) final_light.x = 1.0;
    if (final_light.y > 1.0) final_light.y = 1.0;
    if (final_light.z > 1.0) final_light.z = 1.0;
    if (final_light.w > 1.0) final_light.w = 1.0;
    gl_Position = projection_matrix * view_matrix * model_matrix * vec4(vertex_coord, 1.0);

SHADER

"}"
))


(definition (build-mesh-occlusion-fs)
  (string-append
    #<<SHADER
#version 140

in vec4 final_light;

out vec4 fragColor;

void main()
SHADER

"{"

#<<SHADER
    fragColor = final_light;
SHADER

"}"
))


(definition public mesh-occlusion-vs
  #f)

(definition public mesh-occlusion-fs
  #f)


(definition public (build-occlusion-shaders)
  (set! mesh-occlusion-vs (build-mesh-occlusion-vs))
  (set! mesh-occlusion-fs (build-mesh-occlusion-fs)))


;;;
;;;; Mesh Frame
;;;


(definition (build-mesh-frame-vs square?)
  (string-append
    #<<SHADER
#version 140

/*
    Input: The vertex position and vertex ins p1_3d and p2_3d which
    are the positions of neighbouring vertices.

    Output:   dist a vector of distances from the vertex to the three edges of
    the triangle. Clearly only one of these distance is non-zero. For vertex 0
    in a triangle dist = (distance to opposite edge, 0, 0) on exit. The distance
    is multiplied by w. This is to negate perspective correction.
    
    http://www2.imm.dtu.dk/~jab/Wireframe
*/
uniform vec2 WIN_SCALE;
uniform mat4 projection_matrix;
uniform mat4 view_matrix;
uniform mat4 model_matrix;
uniform int moment;
in vec3 vertex_coord;
in vec3 normal;
in float bone_id;
in float swizz;
in vec3 neighbor1;
in vec3 neighbor2;

out vec3 dist;
SHADER

(skeletal-header)

(if square?
#<<SHADER
out vec3 ignore;
SHADER

"")

#<<SHADER

void main()

SHADER

"{"

(skeletal-setup)

(if (get-animations?)
#<<SHADER
vec4 skeletal_neighbor1;
vec4 skeletal_neighbor2;
if (use_bones != 0)
{
    mat4 boneTransform = bone_matrices[int(bone_id)];
    skeletal_neighbor1 = boneTransform * vec4(neighbor1, 1.0);
    skeletal_neighbor2 = boneTransform * vec4(neighbor2, 1.0);
}
else
{
    skeletal_neighbor1 = vec4(neighbor1, 1.0);
    skeletal_neighbor2 = vec4(neighbor2, 1.0);
}
SHADER

#<<SHADER
vec4 skeletal_neighbor1 = vec4(neighbor1, 1.0);
vec4 skeletal_neighbor2 = vec4(neighbor2, 1.0);
SHADER
)

#<<SHADER
    vec4 pos = skeletal_pos;
    vec4 p1_3d = skeletal_neighbor1;
    vec4 p2_3d = skeletal_neighbor2;

    // Compute the vertex position in the usual fashion.
    gl_Position = projection_matrix * view_matrix * model_matrix * pos;
    vec4 p1_3d_ = projection_matrix * view_matrix * model_matrix * p1_3d;
    vec4 p2_3d_ = projection_matrix * view_matrix * model_matrix * p2_3d;

    // p0, p1 and p2 are the 2D positions of the vertices.
    vec2 p0 = gl_Position.xy/gl_Position.w;
    vec2 p1 = p1_3d_.xy / p1_3d_.w;
    vec2 p2 = p2_3d_.xy / p2_3d_.w;

    // Project p1 and p2 and compute the vectors v1 = p1-p0 and v2 = p2-p0
    vec2 v1 = WIN_SCALE*(p1 - p0);
    vec2 v2 = WIN_SCALE*(p2 - p0);

    // Compute 2D area of triangle.
    float area2 = abs(v1.x*v2.y - v1.y * v2.x);

    // Compute distance from vertex to line in 2D coords
    float h = area2/length(v1-v2);
SHADER

(if square?
#<<SHADER
    float d01 = distance(pos, p1_3d);
    float d02 = distance(pos, p2_3d);
    float d12 = distance(p1_3d, p2_3d);
    float i;
    if (d12 >= d01 && d12 >= d02)
        i = -1.0;
    else
        i = 0.;
SHADER

"")

#<<SHADER
    // ---
    // The swizz variable tells us which of the three vertices
    // we are dealing with. The ugly comparisons would not be needed if
    // swizz was an int.

    if (swizz<0.1)
    {
        dist = vec3(h,0,0);
SHADER

(if square?
#<<SHADER
        ignore = vec3(i,0,0);
SHADER

"")

#<<SHADER
    }
    else if (swizz<1.1)
    {
        dist = vec3(0,h,0);
SHADER

(if square?
#<<SHADER
        ignore = vec3(0,i,0);
SHADER

"")

#<<SHADER
    }
    else
    {
        dist = vec3(0,0,h);
SHADER

(if square?
#<<SHADER
        ignore = vec3(0,0,i);
SHADER

"")

#<<SHADER
    }

    // ----
    // Quick fix to defy perspective correction

    dist *= gl_Position.w;
SHADER

(if square?
#<<SHADER
    ignore *= gl_Position.w;
SHADER

"")

"}"
))


(definition (build-mesh-frame-fs square? distance?)
  (string-append
    #<<SHADER
#version 140

uniform int moment;
uniform vec4 WIRE_COL;
uniform vec4 FILL_COL;
SHADER

@wait
(if distance?
#<<SHADER
uniform float EYE_HEIGHT;
SHADER

"")

#<<SHADER
in vec3 dist;
SHADER

(if square?
#<<SHADER
in vec3 ignore;
SHADER

"")

#<<SHADER

out vec4 fragColor;

void main()

SHADER

"{"

#<<SHADER
    // Undo perspective correction.
    vec3 dist_vec = dist * gl_FragCoord.w;
SHADER

(if square?
#<<SHADER
    vec3 ignore_vec = ignore * gl_FragCoord.w;
SHADER

"")

(if (not square?)
#<<SHADER
    // Compute the shortest distance to the edge
    float d = min(dist_vec[0], min(dist_vec[1], dist_vec[2]));
SHADER

#<<SHADER
    float d;
    if (ignore_vec[0] < 0.)
        d = min(dist_vec[1], dist_vec[2]);
    else if (ignore_vec[1] < 0.)
        d = min(dist_vec[0], dist_vec[2]);
    else if (ignore_vec[2] < 0.)
        d = min(dist_vec[0], dist_vec[1]);
    else
        d = 100.;
SHADER
)

#<<SHADER
    // Compute line intensity and then fragment color
    float I = exp2(-2.0*d*d);
    
    vec4 wire_col = WIRE_COL;
    vec4 fill_col = FILL_COL;
    // if (moment != 0)
    // {
    //    wire_col = mix(fog_color, wire_col, .6);
    //    fill_col = mix(fog_color, fill_col, .3);
    // }
    vec4 transparency = vec4(1., 1., 1., (moment == 0) ? 1. : .25);
    wire_col = wire_col * transparency;
    fill_col = fill_col * transparency;
  
SHADER

(if (not distance?)
#<<SHADER
    fragColor = I*wire_col + (1.0 - I)*fill_col;
SHADER

#<<SHADER
    float A = exp(-d);
    vec4 WIRE_ALP = vec4(0., 0., 0., 1.);
    
    // Reduce moire patterns
    float z = gl_FragCoord.z / gl_FragCoord.w;
    I = (I / z) * 7.5;
    
  //  float zhorizontal = sqrt(max(z*z - (EYE_HEIGHT*EYE_HEIGHT / 1.3), 0));
  //  I = min((I / (1. + zhorizontal)) * 7.5, 1);
    
  //  fragColor = I*wire_col + (1.0 - I)*fill_col;
  //  fragColor = I*vec4(wire_col.xyz, 0.) + A*WIRE_ALP + (1.0 - I)*fill_col;
    fragColor = I*wire_col + (1.0 - I)*fill_col;
SHADER
)

"}"
))


(definition public mesh-wireframe-vs
  #f)

(definition public mesh-squareframe-vs
  #f)

(definition public mesh-playerframe-vs
  #f)

(definition public mesh-floorframe-vs
  #f)


(definition public mesh-wireframe-fs
  #f)

(definition public mesh-squareframe-fs
  #f)

(definition public mesh-playerframe-fs
  #f)

(definition public mesh-floorframe-fs
  #f)


(definition public (build-frame-shaders)
  (set! mesh-wireframe-vs   (build-mesh-frame-vs #f))
  (set! mesh-squareframe-vs (build-mesh-frame-vs #t))
  (set! mesh-playerframe-vs (build-mesh-frame-vs #t))
  (set! mesh-floorframe-vs  (build-mesh-frame-vs #t))
  (set! mesh-wireframe-fs   (build-mesh-frame-fs #f #f))
  (set! mesh-squareframe-fs (build-mesh-frame-fs #t #f))
  (set! mesh-playerframe-fs (build-mesh-frame-fs #t #f))
  (set! mesh-floorframe-fs  (build-mesh-frame-fs #t #t)))


;;;
;;;; Texture Normalize
;;;


(definition (texture-macros)
  (if (get-texture-arrays?)
  #<<SHADER

#define TEXSAMPLER sampler2DArray
#define TEXBOUNDS uniform vec4 texture_bounds[384];
#define TEXCOORD vec3
#define TEX2D texture
#define TEXUV(u,v) vec3(u,v,final_texture_coord.z)

SHADER

  #<<SHADER

#define TEXSAMPLER sampler2D
#define TEXBOUNDS uniform vec4 texture_bounds[384];
#define TEXCOORD vec3
#define TEX2D texture
#define TEXUV(u,v) vec2(u,v)

SHADER
))


(definition (normalize-header uniform-size?)
  (if uniform-size?
  #<<SHADER
float texx;
float texy;
float texu;
float texv;
SHADER
      
  #<<SHADER
vec4 texbounds;
float texleft;
float textop;
float texright;
float texbottom;
float texwidth;
float texheight;
float texx;
float texy;
float texu;
float texv;
SHADER
))


(definition (normalize-uv uniform-size?)
  (if uniform-size?
  #<<SHADER
    texx = final_texture_coord.x;
    texy = final_texture_coord.y;
SHADER

  #<<SHADER
    texbounds = texture_bounds[int(final_texture_coord.z)];
    texleft = texbounds.x;
    textop = texbounds.y;
    texright = texbounds.z;
    texbottom = texbounds.w;
    texwidth = texright - texleft;
    texheight = texbottom - textop;
    texx = (final_texture_coord.x-texleft) / texwidth;
    texy = 1 - (final_texture_coord.y-textop) / texheight;
SHADER
))


(definition (denormalize-uv uniform-size?)
  (if uniform-size?
      ""
    
  #<<SHADER
    texu = fract(texu);
    texv = fract(texv);
    texu = texu*texwidth+texleft;
    texv = texv*texheight+textop;
SHADER
))


;;;
;;;; Mesh Texture
;;;


(definition public (build-mesh-texture-vs)
  (string-append
    #<<SHADER
#version 140

SHADER

(texture-macros)

#<<SHADER
uniform mat4 projection_matrix;
uniform mat4 view_matrix;
uniform mat4 model_matrix;
uniform TEXSAMPLER texture_sampler;

in vec3 vertex_coord;
in vec3 normal;
in vec3 texture_coord;
in float bone_id;
SHADER

(skeletal-header)

#<<SHADER
out TEXCOORD final_texture_coord;

void main()
{
SHADER

(skeletal-setup)

#<<SHADER
    gl_Position = projection_matrix * view_matrix * model_matrix * skeletal_pos;
    final_texture_coord = texture_coord;
}
SHADER
))


(definition public (build-mesh-texture-fs)
  (string-append
    #<<SHADER
#version 140

SHADER

(texture-macros)

#<<SHADER
uniform TEXSAMPLER texture_sampler;

in TEXCOORD final_texture_coord;

out vec4 fragColor;

void main()
{
    fragColor = final_light * TEX2D(texture_sampler, TEXUV(final_texture_coord.x, final_texture_coord.y));
}
SHADER
))


;;;
;;;; Mesh Radial Blur
;;;


;; Radial Blur by iq (2009)

(definition public (build-mesh-radial-blur-fs uniform-size?)
  (string-append
    #<<SHADER
#version 140

SHADER

(texture-macros)

#<<SHADER
uniform float time;
uniform TEXSAMPLER texture_sampler;
TEXBOUNDS

in TEXCOORD final_texture_coord;

out vec4 fragColor;
SHADER

(normalize-header uniform-size?)

#<<SHADER
vec3 deform(in vec2 p)
{
    vec2 uv;

    vec2 q = vec2(sin(1.1*time+p.x),sin(1.2*time+p.y));

    float a = atan(q.y,q.x);
    float r = sqrt(dot(q,q));

    uv.x = sin(0.0+1.0*time)+p.x*sqrt(r*r+1.0);
    uv.y = sin(0.6+1.1*time)+p.y*sqrt(r*r+1.0);
    
    texu = uv.x*.5;
    texv = uv.y*.5;
SHADER

(denormalize-uv uniform-size?)

#<<SHADER
    return TEX2D(texture_sampler,TEXUV(texu,texv)).xyz;
}

void main()
{
SHADER

(normalize-uv uniform-size?)

#<<SHADER
    vec2 p = -1.0 + 2.0 * vec2(texx, texy);
    vec2 s = p;

    vec3 total = vec3(0.0);
    vec2 d = (vec2(0.0,0.0)-p)/40.0;
    float w = 1.0;
    for (int i=0;
         i<40;
         i++)
    {
        vec3 res = deform(s);
        res = smoothstep(0.1,1.0,res*res);
        total += w*res;
        w *= .99;
        s += d;
    }
    total /= 40.0;
    float r = 1.5/(1.0+dot(p,p));
    fragColor = vec4(total*r,1.0);
}
SHADER
))


;;;
;;;; Mesh Motion Blur
;;;


;; Motion Blur by iq (2009)

(definition public (build-mesh-motion-blur-fs uniform-size?)
  (string-append
    #<<SHADER
#version 140

SHADER

(texture-macros)

#<<SHADER
uniform float time;
uniform TEXSAMPLER texture_sampler;
TEXBOUNDS

in TEXCOORD final_texture_coord;

out vec4 fragColor;
SHADER

(normalize-header uniform-size?)

#<<SHADER
vec3 deform(in vec2 p, float scale)
{
    vec2 uv;
   
    float mtime = scale+time;
    float a = atan(p.y,p.x);
    float r = sqrt(dot(p,p));
    float s = r * (1.0+0.5*cos(mtime*1.7));

    uv.x = .1*mtime +.05*p.y+.05*cos(-mtime+a*3.0)/s;
    uv.y = .1*mtime +.05*p.x+.05*sin(-mtime+a*3.0)/s;

    float w = 0.8-0.2*cos(mtime+3.0*a);

    texu = uv.x;
    texv = uv.y;
SHADER

(denormalize-uv uniform-size?)

#<<SHADER
    vec3 res = TEX2D(texture_sampler,TEXUV(texu,texv)).xyz*w;
    return res*res;

}

void main()
{
SHADER

(normalize-uv uniform-size?)

#<<SHADER
    vec2 p = -1.0 + 2.0 * vec2(texx, texy);
    vec3 total = vec3(0.0);
    float w = 0.0;
    for (int i=0;
         i<20;
         i++)
    {
        vec3 res = deform(p,w);
        total += res;
        w += 0.02;
    }
    total /= 20.0;

    fragColor = vec4(3.0*total,1.0);
}
SHADER
))


;;;
;;;; Mesh Water
;;;


;; Water by Viktor Korsun (BIT_TEK) (2012)

(definition public (build-mesh-water-fs uniform-size?)
  (string-append
    #<<SHADER
#version 140

SHADER

(texture-macros)

#<<SHADER
uniform TEXSAMPLER texture_sampler;
TEXBOUNDS
uniform float time;
uniform float daylight_whatthefuck;

const float PI = 3.1415926535897932;

in TEXCOORD final_texture_coord;

out vec4 fragColor;

//speed
const float speed = 0.2;
const float speed_x = 0.3;
const float speed_y = 0.3;

// geometry
const float intensity = 3.;
const int steps = 8;
const float frequency = 4.0;
const int angle = 7; // better when a prime

// reflection and emboss
const float delta = 20.;
const float intence = 400.;
const float emboss = 0.3;
SHADER

(normalize-header uniform-size?)

#<<SHADER
//---------- crystals effect

float col(vec2 coord)
{
    float delta_theta = 2.0 * PI / float(angle);
    float col = 0.0;
    float theta = 0.0;
    for (int i = 0;
         i < steps;
         i++)
    {
      vec2 adjc = coord;
      theta = delta_theta*float(i);
      adjc.x += cos(theta)*time*speed + time * speed_x;
      adjc.y -= sin(theta)*time*speed - time * speed_y;
      col = col + cos((adjc.x*cos(theta) - adjc.y*sin(theta))*frequency)*intensity;
    }

    return cos(col);
}

//---------- main

void main()
{
SHADER

(normalize-uv uniform-size?)

#<<SHADER
    vec2 p = vec2(texx, texy), c1 = p, c2 = p;
    float cc1 = col(c1);

    c2.x += 1/delta;
    float dx = emboss*(cc1-col(c2))/delta;

    c2.x = p.x;
    c2.y += 1/delta;
    float dy = emboss*(cc1-col(c2))/delta;

    c1.x += dx;
    c1.y = -(c1.y+dy);

    float alpha = 1.+dot(dx,dy)*intence;

    texu = c1.x;
    texv = c1.y;
SHADER

(denormalize-uv uniform-size?)

#<<SHADER
    fragColor = TEX2D(texture_sampler,TEXUV(texu,texv))*(1.0);
    // adjust light between 1. for day and .2 for night
    float light = daylight_whatthefuck * 0.8 + 0.2;
    fragColor = fragColor * vec4(light, light, light, 1.);
}
SHADER
))


;;;
;;;; Mesh Julia
;;;


;; Julia by iq (2009)

(definition public (build-mesh-julia-fs uniform-size?)
  (string-append
    #<<SHADER
#version 140

SHADER

(texture-macros)

#<<SHADER
uniform float time;
TEXBOUNDS

in TEXCOORD final_texture_coord;

out vec4 fragColor;
SHADER

(normalize-header uniform-size?)

#<<SHADER
void main()
{
SHADER

(normalize-uv uniform-size?)

#<<SHADER
    vec2 p = -1.0 + 2.0 * vec2(texx, texy);
    vec2 cc = vec2(cos(.25*time), sin(.25*time*1.423));

    float dmin = 1000.0;
    vec2 z  = p*vec2(1.33,1.0);
    for (int i=0;
         i<64;
         i++)
    {
        z = cc + vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y);
        float m2 = dot(z,z);
        if (m2>100.0) break;
        dmin=min(dmin,m2);
        }

    float color = sqrt(sqrt(dmin))*0.7;
    fragColor = vec4(color,color,color,1.0);
}
SHADER
))


;;;
;;;; Mesh Sierpinski
;;;


;; Sierpinski by Lars Huttar (2010)

(definition public (build-mesh-sierpinski-fs uniform-size?)
  (string-append
    #<<SHADER
#version 140

SHADER

(texture-macros)

#<<SHADER
uniform float time;
uniform TEXSAMPLER texture_sampler;
TEXBOUNDS

in TEXCOORD final_texture_coord;

out vec4 fragColor;
SHADER

(normalize-header uniform-size?)

#<<SHADER
// Set color at the current fragment, with given coords
// and whether it should be "hole" or not.
void setColor(vec2 coord, bool isHole) {
    if (isHole)
        fragColor = vec4(TEX2D(texture_sampler, TEXUV(final_texture_coord.x,final_texture_coord.y)).xyz, 1.0);
    else
        fragColor = vec4(coord.x, 0.5, coord.y, 1.0);
}

// Sierpinski carpet - with anti-holes!
// Maybe call it "Sierpinski tablecloth". If it doesn't already have a name.
void main()
{
SHADER

(normalize-uv uniform-size?)

#<<SHADER
    ivec2 sectors;
    vec2 coordOrig = vec2(texx, texy);
    const int lim = 5;
    // Toggle between "carpet" and "tablecloth" every 3 seconds.
    bool doInverseHoles = (mod(time, 6.0) < 3.0);
    
    /* If you want it to spin, just to prove that it is redrawing
    the carpet every frame: */
    vec2 center = vec2(0.5, 0.5);
    mat2 rotation = mat2(
        vec2(cos(time), sin(time)),
        vec2(-sin(time), cos(time))
    );
    vec2 coordRot = rotation * (coordOrig - center) + center;
    // rotation can put us out of bounds
    if (coordRot.x < 0.0 || coordRot.x > 1.0 ||
        coordRot.y < 0.0 || coordRot.y > 1.0) {
        setColor(coordOrig, true);
        return;
    }

    vec2 coordIter = coordRot;
    bool isHole = false;
    
    for (int i=0;
         i < lim;
         i++)
    {
        sectors = ivec2(floor(coordIter.xy * 3.0));
        if (sectors.x == 1 && sectors.y == 1) {
            if (doInverseHoles) {
                isHole = !isHole;
            } else {
                setColor(coordOrig, true);
                return;
            }
        }

        if (i + 1 < lim) {
            // map current sector to whole carpet
            coordIter.xy = coordIter.xy * 3.0 - vec2(sectors.xy);
        }
    }
    
    setColor(isHole ? coordOrig : coordRot, isHole);
}
SHADER
))


;;;
;;;; Mesh Multitexture
;;;


;; Multitexture by iq (2009)

(definition public (build-mesh-multitexture-fs uniform-size?)
  (string-append
    #<<SHADER
#version 140

SHADER

(texture-macros)

#<<SHADER
uniform float time;
uniform TEXSAMPLER texture_sampler;
TEXBOUNDS

in TEXCOORD final_texture_coord;

out vec4 fragColor;
SHADER

(normalize-header uniform-size?)

#<<SHADER
void main()
{
SHADER

(normalize-uv uniform-size?)

#<<SHADER
    vec2 p = -1.0 + 2.0 * vec2(texx, texy);
    // a rotozoom
    vec2 cst = vec2(cos(.5*time), sin(.5*time));
    mat2 rot = 0.5*cst.x*mat2(cst.x,-cst.y,cst.y,cst.x);
    
    vec2 tmp = rot*p;
    texu = tmp.x;
    texv = tmp.y;
SHADER

(denormalize-uv uniform-size?)

#<<SHADER
    vec3 col1 = TEX2D(texture_sampler,TEXUV(texu,texv)).xyz;

    tmp = 0.5*p+sin(0.1*time);
    texu = tmp.x;
    texv = tmp.y;
SHADER

(denormalize-uv uniform-size?)

#<<SHADER
    // scroll
    vec3 col2 = TEX2D(texture_sampler,TEXUV(texu,texv)).xyz;

    // blend layers
    vec3 col = col2*col1;

    fragColor = vec4(col,1.0);
}
SHADER
))


;;;
;;;; Mesh Kaleidoscope
;;;


;; Kaleidoscope by iq (2009)

(definition public (build-mesh-kaleidoscope-fs uniform-size?)
  (string-append
    #<<SHADER
#version 140

SHADER

(texture-macros)

#<<SHADER
uniform float time;
uniform TEXSAMPLER texture_sampler;
TEXBOUNDS

in TEXCOORD final_texture_coord;

out vec4 fragColor;
SHADER

(normalize-header uniform-size?)

#<<SHADER
void main()
{
SHADER

(normalize-uv uniform-size?)

#<<SHADER
    vec2 p = -1.0 + 2.0 * vec2(texx, texy);
    vec2 uv;
   
    float a = atan(p.y,p.x);
    float r = sqrt(dot(p,p));

    uv.x =          7.0*a/3.1416;
    uv.y = -time+ sin(7.0*r+time) + .7*cos(time+7.0*a);

    float w = .5+.5*(sin(time+7.0*r)+ .7*cos(time+7.0*a));

    texu = uv.x*.5;
    texv = uv.y*.5;
SHADER

(denormalize-uv uniform-size?)

#<<SHADER
    vec3 col = TEX2D(texture_sampler,TEXUV(texu,texv)).xyz;

    fragColor = vec4(col*w,1.0);
}
SHADER
))


;;;
;;;; Mesh Tunnel
;;;


;; Tunnel by iq (2009)

(definition public (build-mesh-tunnel-fs uniform-size?)
  (string-append
    #<<SHADER
#version 140

SHADER

(texture-macros)

#<<SHADER
uniform float time;
uniform TEXSAMPLER texture_sampler;
TEXBOUNDS

in TEXCOORD final_texture_coord;

out vec4 fragColor;
SHADER

(normalize-header uniform-size?)

#<<SHADER
void main()
{
SHADER

(normalize-uv uniform-size?)

#<<SHADER
    vec2 p = -1.0 + 2.0 * vec2(texx, texy);
    vec2 uv;
   
    float a = atan(p.y,p.x);
    float r = sqrt(dot(p,p));

    uv.x = .75*time+.1/r;
    uv.y = a/3.1416;

    texu = uv.x;
    texv = uv.y;
SHADER

(denormalize-uv uniform-size?)

#<<SHADER
    vec3 col = TEX2D(texture_sampler,TEXUV(texu,texv)).xyz;

    fragColor = vec4(col*r,1.0);
}
SHADER
))


;;;
;;;; Mesh Square Tunnel
;;;


;; Square Tunnel by iq (2009)

(definition public (build-mesh-square-tunnel-fs uniform-size?)
  (string-append
    #<<SHADER
#version 140

SHADER

(texture-macros)

#<<SHADER
uniform float time;
uniform TEXSAMPLER texture_sampler;
TEXBOUNDS

in TEXCOORD final_texture_coord;

out vec4 fragColor;
SHADER

(normalize-header uniform-size?)

#<<SHADER
void main()
{
SHADER

(normalize-uv uniform-size?)

#<<SHADER
    vec2 p = -1.0 + 2.0 * vec2(texx, texy);
    vec2 uv;

    float r = pow(pow(p.x*p.x,16.0) + pow(p.y*p.y,16.0), 1.0/32.0);
    uv.x = .5*time + 0.5/r;
    uv.y = 1.0*atan(p.y,p.x)/3.1416;

    texu = uv.x;
    texv = uv.y;
SHADER

(denormalize-uv uniform-size?)

#<<SHADER
    vec3 col = TEX2D(texture_sampler,TEXUV(texu,texv)).xyz;

    fragColor = vec4(col*r*r*r,1.0);
}
SHADER
))


;;;
;;;; Mesh Fly
;;;


;; Fly by iq (2009)

(definition public (build-mesh-fly-fs uniform-size?)
  (string-append
    #<<SHADER
#version 140

SHADER

(texture-macros)

#<<SHADER
uniform float time;
uniform TEXSAMPLER texture_sampler;
TEXBOUNDS

in TEXCOORD final_texture_coord;

out vec4 fragColor;
SHADER

(normalize-header uniform-size?)

#<<SHADER
void main()
{
SHADER

(normalize-uv uniform-size?)

#<<SHADER
    vec2 p = -1.0 + 2.0 * vec2(texx, texy);
    vec2 uv;

    float an = time*.25;

    float x = p.x*cos(an)-p.y*sin(an);
    float y = p.x*sin(an)+p.y*cos(an);
     
    uv.x = .25*x/abs(y);
    uv.y = .20*time + .25/abs(y);

    texu = uv.x;
    texv = uv.y;
SHADER

(denormalize-uv uniform-size?)

#<<SHADER
    fragColor = vec4(TEX2D(texture_sampler,TEXUV(texu,texv)).xyz * y*y, 1.0);
}
SHADER
))


;;;
;;;; Mesh Pulse
;;;


;; Pulse by Danguafer/Silexars (2010)

(definition public (build-mesh-pulse-fs uniform-size?)
  (string-append
    #<<SHADER
#version 140

SHADER

(texture-macros)

#<<SHADER
uniform float time;
uniform TEXSAMPLER texture_sampler;
TEXBOUNDS

in TEXCOORD final_texture_coord;

out vec4 fragColor;
SHADER

(normalize-header uniform-size?)

#<<SHADER
void main()
{
SHADER

(normalize-uv uniform-size?)

#<<SHADER
    vec2 halfres = vec2(0.5, 0.5);
    vec2 cPos = vec2(texx, texy);

    cPos.x -= 0.5*halfres.x*sin(time/2.0)+0.3*halfres.x*cos(time)+halfres.x;
    cPos.y -= 0.4*halfres.y*sin(time/5.0)+0.3*halfres.y*cos(time)+halfres.y;
    float cLength = length(cPos);

    vec2 uv = vec2(texx, texy)+(cPos/cLength)*sin(cLength/30.0-time*10.0)/25.0;
    
    texu = uv.x;
    texv = uv.y;
SHADER

(denormalize-uv uniform-size?)

#<<SHADER
    vec3 col = TEX2D(texture_sampler,TEXUV(texu,texv)).xyz*50.0/cLength;

    fragColor = vec4(col,1.0);
}
SHADER
))


;;;
;;;; Mesh Transformation
;;;


(definition public mesh-texture-vs
  #f)

(definition public mesh-texture-fs
  #f)

(definition public mesh-radial-blur-fs
  #f)

(definition public mesh-motion-blur-fs
  #f)

(definition public mesh-water-fs
  #f)

(definition public mesh-julia-fs
  #f)

(definition public mesh-sierpinski-fs
  #f)

(definition public mesh-multitexture-fs
  #f)

(definition public mesh-kaleidoscope-fs
  #f)

(definition public mesh-tunnel-fs
  #f)

(definition public mesh-square-tunnel-fs
  #f)

(definition public mesh-fly-fs
  #f)

(definition public mesh-pulse-fs
  #f)


(definition public (build-transformation-shaders)
  (set! mesh-texture-vs (build-mesh-texture-vs))
  (set! mesh-texture-fs (build-mesh-texture-fs))
  (set! mesh-radial-blur-fs (build-mesh-radial-blur-fs #t))
  (set! mesh-motion-blur-fs (build-mesh-motion-blur-fs #t))
  (set! mesh-water-fs (build-mesh-water-fs #t))
  (set! mesh-julia-fs (build-mesh-julia-fs #t))
  (set! mesh-sierpinski-fs (build-mesh-sierpinski-fs #t))
  (set! mesh-multitexture-fs (build-mesh-multitexture-fs #t))
  (set! mesh-kaleidoscope-fs (build-mesh-kaleidoscope-fs #t))
  (set! mesh-tunnel-fs (build-mesh-tunnel-fs #t))
  (set! mesh-square-tunnel-fs (build-mesh-square-tunnel-fs #t))
  (set! mesh-fly-fs (build-mesh-fly-fs #t))
  (set! mesh-pulse-fs (build-mesh-pulse-fs #t)))


;;;
;;;; PP
;;;


@wait
(definition public (build-pp-vs)
  (string-append
    #<<SHADER
#version 140

uniform sampler2D fbo_texture;

in vec2 vertex_coord;

out vec2 final_texture_coord;

out vec4 fragColor;
 
void main()
{
  gl_Position = vec4(vertex_coord, 0.0, 1.0);
  final_texture_coord = (vertex_coord + 1.0) / 2;
}
SHADER
))


@wait
(definition public (build-pp-fs)
  (string-append
    #<<SHADER
#version 140

uniform sampler2D fbo_texture;

in vec2 final_texture_coord;

void main()
{
  float offsetX = 1.0 / 2400.0;
  float offsetY = 1.0 / 1600.0;
  vec4 color = texture(fbo_texture, vec2(final_texture_coord.x              , final_texture_coord.y))+
               texture(fbo_texture, vec2(final_texture_coord.x+offsetX      , final_texture_coord.y))+
               texture(fbo_texture, vec2(final_texture_coord.x              , final_texture_coord.y+offsetY))+
               texture(fbo_texture, vec2(final_texture_coord.x+(offsetX)    , final_texture_coord.y+offsetY));
               // texture(fbo_texture, vec2(final_texture_coord.x+(offsetX*2.0), final_texture_coord.y+offsetY))+
               // texture(fbo_texture, vec2(final_texture_coord.x              , final_texture_coord.y+(offsetY*2.0)))+
               // texture(fbo_texture, vec2(final_texture_coord.x+(offsetX)    , final_texture_coord.y+(offsetY*2.0)))+
               // texture(fbo_texture, vec2(final_texture_coord.x+(offsetX*2.0), final_texture_coord.y+(offsetY*2.0)));
               
  fragColor = color * 0.25;
}
SHADER
)))
