;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Shaders
;;;


(module world.shaders jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (world.foreign)
        (world.shader)
        (time))


;;;
;;;; Default
;;;


(definition public default-vs
  #<<SHADER
#version 120

void main()
{
    gl_Position = ftransform();
}
SHADER
)


(definition public default-fs
  #<<SHADER
#version 120
 
void main()
{
    gl_FragColor = vec4(1.0,1.0,1.0,1.0);
}
SHADER
)


;;;
;;;; T
;;;


(definition public t-vs
  #<<SHADER
#version 120


void main() {

	gl_TexCoord[0] = gl_MultiTexCoord0;
	gl_Position = ftransform();
}
SHADER
)


(definition public t-fs
  #<<SHADER
#version 120
 
uniform sampler2D tex;

void main()
{
	vec4 color = texture2D(tex, gl_TexCoord[0].st);
	gl_FragColor = color;
}
SHADER
)


;;;
;;;; PP
;;;


(definition public pp-vs
  #<<SHADER
#version 120

attribute vec2 v_coord;
uniform sampler2D fbo_texture;
varying vec2 f_texcoord;
 
void main(void) {
  gl_Position = vec4((v_coord), 0.0, 1.0);
  f_texcoord = (v_coord +1.0) / 2;
}
SHADER
)


(definition public pp-fs
  #<<SHADER
#version 120
 
uniform sampler2D fbo_texture;
varying vec2 f_texcoord;

void main(void) {
  float offsetX = 1.0/2400.0;
  float offsetY = 1.0/1600.0;           
  vec4 color = texture2D(fbo_texture, vec2(f_texcoord.x              , f_texcoord.y))+
               texture2D(fbo_texture, vec2(f_texcoord.x+offsetX      , f_texcoord.y))+
               texture2D(fbo_texture, vec2(f_texcoord.x              ,f_texcoord.y+offsetY))+
               texture2D(fbo_texture, vec2(f_texcoord.x+(offsetX)    ,f_texcoord.y+offsetY));
               //texture2D(fbo_texture, vec2(f_texcoord.x+(offsetX*2.0),f_texcoord.y+offsetY))+
               //texture2D(fbo_texture, vec2(f_texcoord.x              ,f_texcoord.y+(offsetY*2.0)))+
               //texture2D(fbo_texture, vec2(f_texcoord.x+(offsetX)    ,f_texcoord.y+(offsetY*2.0)))+
               //texture2D(fbo_texture, vec2(f_texcoord.x+(offsetX*2.0),f_texcoord.y+(offsetY*2.0)));
               
  gl_FragColor = color * 0.25;
}
SHADER
)


;;;
;;;; Block
;;;


(definition public block-vs
  #<<SHADER
#version 120

attribute vec3 v_coord;
attribute vec3 v_coordtex;
uniform sampler2D block_texture;
varying vec2 f_texcoord;
 
void main(void) {
                 
  gl_Position = gl_ModelViewProjectionMatrix * vec4(v_coord,1.0);
  f_texcoord = vec2(v_coordtex.x, v_coordtex.y);
}
SHADER
)


(definition public block-fs
  #<<SHADER
#version 120
 
uniform sampler2D block_texture;
varying vec2 f_texcoord;

void main(void) {               
  gl_FragColor = texture2D(block_texture, f_texcoord);
}
SHADER
)


;;;
;;;; Phong
;;;


(definition public phong-vs
  #<<SHADER
#version 120

varying vec3 N, L0, L1, L2, L3, L4, v;
attribute vec3 v_coord;
attribute vec3 v_coordtex;
attribute vec3 norm;
uniform sampler2D block_texture;
varying vec2 f_texcoord;

void main()
{	
	N = gl_NormalMatrix * norm;

	v = vec3(gl_ModelViewMatrix * vec4(v_coord,1.0));

	L0 = vec3(gl_LightSource[0].position.xyz - v);
    L1 = vec3(gl_LightSource[1].position.xyz - v);
    L2 = vec3(gl_LightSource[2].position.xyz - v);
    L3 = vec3(gl_LightSource[3].position.xyz - v);

	gl_Position = gl_ModelViewProjectionMatrix * vec4(v_coord,1.0);
    f_texcoord = v_coordtex.xy;
}

SHADER
)



(definition public phong-nlights-vs
  #<<SHADER
#version 120

varying vec3 N, L0, L1, L2, L3, L4, v;
uniform int num_lights;
attribute vec3 v_coord;
attribute vec3 v_coordtex;
attribute vec3 norm;
uniform sampler2D block_texture;
varying vec2 f_texcoord;

void main()
{	
	N = gl_NormalMatrix * norm;

	v = vec3(gl_ModelViewMatrix * vec4(v_coord,1.0));
    
    if(num_lights > 0) {
	L0 = vec3(gl_LightSource[0].position.xyz - v);
        if(num_lights > 1) {
    L1 = vec3(gl_LightSource[1].position.xyz - v);         
        if(num_lights > 2) {
    L2 = vec3(gl_LightSource[2].position.xyz - v);         
        if(num_lights > 3) {
    L3 = vec3(gl_LightSource[3].position.xyz - v);
        }
        }
        }
    }

	gl_Position = gl_ModelViewProjectionMatrix * vec4(v_coord,1.0);
    f_texcoord = v_coordtex.xy;
}

SHADER
)


(definition public phong-nlights-fs
  #<<SHADER
#version 120

varying vec3 N, L0, L1, L2, L3, L4, v;
uniform sampler2D block_texture;
uniform int num_lights;
varying vec2 f_texcoord;

void main (void)
{
	vec4 final_color =  vec4(0.0,0.0,0.0,1.0);
							
	vec3 N = normalize(N);
	vec3 L0 = normalize(L0);
    vec3 L1 = normalize(L1);
    vec3 L2 = normalize(L2);
    vec3 L3 = normalize(L3);
	vec3 eyes = -v;
    float invertlights = 1.0/num_lights;	
    float attenuation;
 
	float lambertTerm;
 
    if(num_lights > 0)
    {
     attenuation = 2000.0 / dot(gl_LightSource[0].position.xyz - v,gl_LightSource[0].position.xyz - v);
      if(attenuation > 1.0) attenuation = 1.0;
    lambertTerm = dot(N,L0);
	
	if(lambertTerm > 0.0)
	{
        final_color += gl_LightSource[0].ambient*invertlights*gl_FrontMaterial.ambient*attenuation;
		final_color += gl_LightSource[0].diffuse  * 
                       gl_FrontMaterial.diffuse *
		               lambertTerm * attenuation;	
		
		vec3 E = normalize(eyes);
		vec3 R = reflect(-L0, N);
		float specular = pow( max(dot(R, E), 0.0), 
		                 gl_FrontMaterial.shininess);
		final_color += (gl_LightSource[0].specular) * 
                       gl_FrontMaterial.specular *
		               specular*attenuation;
	}
    }
 
    if(num_lights > 1)
    {
     attenuation = 2000.0 / dot(gl_LightSource[1].position.xyz - v,gl_LightSource[1].position.xyz - v);
      if(attenuation > 1.0) attenuation = 1.0;
 	lambertTerm = dot(N,L1);
	
	if(lambertTerm > 0.0)
	{
        
        final_color += gl_LightSource[1].ambient*invertlights*gl_FrontMaterial.ambient*attenuation;
		final_color += gl_LightSource[1].diffuse * 
                       gl_FrontMaterial.diffuse *
		               lambertTerm * attenuation;	
		
		vec3 E = normalize(eyes);
		vec3 R = reflect(-L1, N);
		float specular = pow( max(dot(R, E), 0.0), 
		                 gl_FrontMaterial.shininess);
		final_color += (gl_LightSource[1].specular) * 
                       gl_FrontMaterial.specular *
		               specular * attenuation;
	}
    }
  
    if(num_lights > 2)
    {
     attenuation = 2000.0 / dot(gl_LightSource[2].position.xyz - v,gl_LightSource[2].position.xyz - v);
      if(attenuation > 1.0) attenuation = 1.0;
  	lambertTerm = dot(N,L2);
	
	if(lambertTerm > 0.0)
	{
        final_color += gl_LightSource[2].ambient*invertlights*gl_FrontMaterial.ambient*attenuation;
		final_color += gl_LightSource[2].diffuse * 
                       gl_FrontMaterial.diffuse *
		               lambertTerm*attenuation;	
		
		vec3 E = normalize(eyes);
		vec3 R = reflect(-L2, N);
		float specular = pow( max(dot(R, E), 0.0), 
		                 gl_FrontMaterial.shininess);
		final_color += (gl_LightSource[2].specular) * 
                       gl_FrontMaterial.specular *
		               specular*attenuation;
	}
    }
    
    if(num_lights > 3)
    {
     attenuation = 2000.0 / dot(gl_LightSource[3].position.xyz - v,gl_LightSource[3].position.xyz - v);
      if(attenuation > 1.0) attenuation = 1.0;
   	lambertTerm = dot(N,L3);
	
	if(lambertTerm > 0.0)
	{
        final_color += gl_LightSource[3].ambient*invertlights*gl_FrontMaterial.ambient*attenuation;
		final_color += gl_LightSource[3].diffuse * 
                       gl_FrontMaterial.diffuse *
		               lambertTerm*attenuation;	
		
		vec3 E = normalize(eyes);
		vec3 R = reflect(-L3, N);
		float specular = pow( max(dot(R, E), 0.0), 
		                 gl_FrontMaterial.shininess);
		final_color += (gl_LightSource[3].specular) * 
                       gl_FrontMaterial.specular *
		               specular*attenuation;
	}
    }


	gl_FragColor = final_color * texture2D(block_texture, f_texcoord);			
}

SHADER
)

)
