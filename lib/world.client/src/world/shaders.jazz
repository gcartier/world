;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Shaders
;;;


(module world.shaders jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (world.foreign)
        (world.shader)
        (time))


;;;
;;;; Default
;;;


(definition public default-vs
  #<<SHADER
#version 130

precision mediump float;
void main()
{
    gl_Position = ftransform();
}
SHADER
)


(definition public default-fs
  #<<SHADER
#version 130
 
precision mediump float;
void main()
{
    gl_FragColor = vec4(1.0,1.0,1.0,1.0);
}
SHADER
)


;;;
;;;; T
;;;


(definition public t-vs
  #<<SHADER
#version 130

precision mediump float;
uniform int overlay;

void main() {

	gl_TexCoord[0] = gl_MultiTexCoord0;
	gl_Position = ftransform();
}
SHADER
)


(definition public t-fs
  #<<SHADER
#version 130

precision mediump float;
uniform sampler2D tex;
uniform int overlay;

void main()
{
	vec4 color = texture2D(tex, gl_TexCoord[0].st);
    if(overlay != 1)
        color += vec4(0.0,0.0,0.0,0.6);
        
	gl_FragColor = color;
}
SHADER
)


;;;
;;;; PP
;;;


(definition public pp-vs
  #<<SHADER
#version 130

precision mediump float;
attribute vec2 v_coord;
uniform sampler2D fbo_texture;
varying vec2 f_texcoord;
 
void main(void) {
  gl_Position = vec4((v_coord), 0.0, 1.0);
  f_texcoord = (v_coord +1.0) / 2;
}
SHADER
)


(definition public pp-fs
  #<<SHADER
#version 130
precision mediump float;
uniform sampler2D fbo_texture;
varying vec2 f_texcoord;

void main(void) {
  float offsetX = 1.0/2400.0;
  float offsetY = 1.0/1600.0;
  vec4 color = texture2D(fbo_texture, vec2(f_texcoord.x              , f_texcoord.y))+
               texture2D(fbo_texture, vec2(f_texcoord.x+offsetX      , f_texcoord.y))+
               texture2D(fbo_texture, vec2(f_texcoord.x              ,f_texcoord.y+offsetY))+
               texture2D(fbo_texture, vec2(f_texcoord.x+(offsetX)    ,f_texcoord.y+offsetY));
               //texture2D(fbo_texture, vec2(f_texcoord.x+(offsetX*2.0),f_texcoord.y+offsetY))+
               //texture2D(fbo_texture, vec2(f_texcoord.x              ,f_texcoord.y+(offsetY*2.0)))+
               //texture2D(fbo_texture, vec2(f_texcoord.x+(offsetX)    ,f_texcoord.y+(offsetY*2.0)))+
               //texture2D(fbo_texture, vec2(f_texcoord.x+(offsetX*2.0),f_texcoord.y+(offsetY*2.0)));
               
  gl_FragColor = color * 0.25;
}
SHADER
)


;;;
;;;; Block
;;;


(definition public block-vs
  #<<SHADER
#version 130
precision mediump float;
attribute vec3 v_coord;
attribute vec3 v_coordtex;
uniform sampler2D block_texture;
varying vec2 f_texcoord;
 
void main(void) {
                 
  gl_Position = gl_ModelViewProjectionMatrix * vec4(v_coord,1.0);
  f_texcoord = vec2(v_coordtex.x, v_coordtex.y);
}
SHADER
)


(definition public block-fs
  #<<SHADER
#version 130
precision mediump float; 
uniform sampler2D block_texture;
varying vec2 f_texcoord;

void main(void) {
  gl_FragColor = texture2D(block_texture, f_texcoord);
}
SHADER
)


;;;
;;;; Phong
;;;


(definition public phong-vs
  #<<SHADER
#version 130
precision mediump float;
varying vec3 N, L0, L1, L2, L3, L4, v;
attribute vec3 v_coord;
attribute vec3 v_coordtex;
attribute vec3 norm;
uniform sampler2D block_texture;
varying vec2 f_texcoord;

void main()
{
	N = gl_NormalMatrix * norm;

	v = vec3(gl_ModelViewMatrix * vec4(v_coord,1.0));

	L0 = vec3(gl_LightSource[0].position.xyz - v);
    L1 = vec3(gl_LightSource[1].position.xyz - v);
    L2 = vec3(gl_LightSource[2].position.xyz - v);
    L3 = vec3(gl_LightSource[3].position.xyz - v);

	gl_Position = gl_ModelViewProjectionMatrix * vec4(v_coord,1.0);
    f_texcoord = v_coordtex.xy;
}

SHADER
)


(definition public phong-nlights-vs
  #<<SHADER
#version 130
precision mediump float;
uniform int num_lights;
uniform int edit_mode;
varying vec4 final_color;
attribute vec3 v_coord;
attribute vec3 v_coordtex;
attribute vec3 norm;
uniform sampler2D block_texture;
varying vec2 f_texcoord;

void main()
{
	vec3 N = gl_NormalMatrix * norm;

	vec3 v = vec3(gl_ModelViewMatrix * vec4(v_coord,1.0));
    
    final_color =  vec4(0.0,0.0,0.0,1.0);

	vec3 eyes = -v;
    float invertlights = 1.0/num_lights;
    vec3 L, li;
    float attenuation, specular, distance, attterm;
	float lambertTerm;
	N = normalize(N);
    vec3 R;
    vec3 E = normalize(eyes);
    
    for(int i=0; i<num_lights && i<8; i++)
    {
        li = gl_LightSource[i].position.xyz - v;
        L = normalize(li);
        distance = dot(li,li);
        attterm = (gl_LightSource[i].constantAttenuation + gl_LightSource[i].linearAttenuation*sqrt(distance) + gl_LightSource[i].quadraticAttenuation*distance);
        if(attterm <= 0) attterm = 1.0;
        attenuation = 1.0/attterm;
        if(attenuation > 1.0) attenuation = 1.0;
        lambertTerm = dot(N,L);
        final_color += gl_LightSource[i].ambient*gl_FrontMaterial.ambient;
        if(lambertTerm > 0.0)
	    {
		   final_color += gl_LightSource[i].diffuse  *
                       gl_FrontMaterial.diffuse *
		               lambertTerm * attenuation;
		   R = reflect(-L, N);
		   specular = pow( max(dot(R, E), 0.0),
		                 gl_FrontMaterial.shininess);
		   final_color += (gl_LightSource[i].specular) *
                       gl_FrontMaterial.specular *
		               specular*attenuation;
	    }
    }
    if(final_color.x > 1.0) final_color.x = 1.0;
    if(final_color.y > 1.0) final_color.y = 1.0;
    if(final_color.z > 1.0) final_color.z = 1.0;
	gl_Position = gl_ModelViewProjectionMatrix * vec4(v_coord,1.0);
    f_texcoord = v_coordtex.xy; 
}

SHADER
)


(definition public phong-nlights-fs
  #<<SHADER
#version 130
precision mediump float;
uniform sampler2D block_texture;
uniform int edit_mode;
varying vec4 final_color;
uniform int num_lights;
varying vec2 f_texcoord;

void main (void)
{
	gl_FragColor = final_color * texture2D(block_texture, (f_texcoord+1.0));
}

SHADER
)


(definition public phong-nlights-obj-vs
  #<<SHADER
#version 130
precision mediump float;
uniform mat4 modelmat;
uniform int num_lights;
uniform int edit_mode;
varying vec4 final_color;
attribute vec3 v_coord;
attribute vec3 v_coordtex;
attribute vec3 norm;
uniform sampler2D block_texture;
varying vec2 f_texcoord;

void main()
{
	vec3 N = gl_NormalMatrix * norm;

	vec3 v = vec3(gl_ModelViewMatrix * modelmat* vec4(v_coord,1.0));
    
    final_color =  vec4(0.0,0.0,0.0,1.0);

	vec3 eyes = -v;
    float invertlights = 1.0/num_lights;
    vec3 L, li;
    float attenuation, specular, distance, attterm;
	float lambertTerm;
	N = normalize(N);
    vec3 R;
    vec3 E = normalize(eyes);
    
    for(int i=0; i<num_lights && i<8; i++)
    {
        li = gl_LightSource[i].position.xyz - v;
        L = normalize(li);
        distance = dot(li,li);
        attterm = (gl_LightSource[i].constantAttenuation + gl_LightSource[i].linearAttenuation*sqrt(distance) + gl_LightSource[i].quadraticAttenuation*distance);
        if(attterm <= 0) attterm = 1.0;
        attenuation = 1.0/attterm;
        if(attenuation > 1.0) attenuation = 1.0;
        lambertTerm = dot(N,L);
        final_color += gl_LightSource[i].ambient*gl_FrontMaterial.ambient;
        if(lambertTerm > 0.0)
	    {
		   final_color += gl_LightSource[i].diffuse  *
                       gl_FrontMaterial.diffuse *
		               lambertTerm * attenuation;
		   R = reflect(-L, N);
		   specular = pow( max(dot(R, E), 0.0),
		                 gl_FrontMaterial.shininess);
		   final_color += (gl_LightSource[i].specular) *
                       gl_FrontMaterial.specular *
		               specular*attenuation;
	    }
    }
    if(final_color.x > 1.0) final_color.x = 1.0;
    if(final_color.y > 1.0) final_color.y = 1.0;
    if(final_color.z > 1.0) final_color.z = 1.0;
	gl_Position = (gl_ModelViewProjectionMatrix) *modelmat* vec4(v_coord,1.0);
    f_texcoord = v_coordtex.xy; 
}

SHADER
)









)
