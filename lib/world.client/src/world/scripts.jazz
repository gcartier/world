;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Scripts
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte


(module world.scripts jazz


(import (gaea.geometry)
        (world)
        (world.context)
        (world.settings)
        (world.support))


(class Foo extends Object
  
  (method override (initialize self a b)
    ))

(define a
  #f)

(define (foo a b)
  (+ a b))

@conflict
(definition public (test)
  @comment
  (with-tracking 'unit
    (lambda ()
      (set! a (foo 1. 2.))         ;; ___F64BOX
      (set! a (cons 1 2))          ;; ___CONS
      (set! a (box 1))             ;; ___BOX
                                   ;; ___MAKEPROMISE *****
      @todo
      (continuation-capture        ;; ___MAKECONTINUATION *****
        (lambda (cont)
          (set! a cont)))
                                   ;; ___MAKESYMBOL *****
                                   ;; ___MAKEKEYWORD *****
                                   ;; ___MAKEWILL *****
      @todo
      (let ((x 1))                 ;; ___ALLOC_CLO *****
        (set! a (lambda (y)
                  (+ x y))))
      (set! a (list 1 2))          ;; ___BEGIN_ALLOC_LIST
      (set! a (string #\a #\b))    ;; ___BEGIN_ALLOC_STRING
      (set! a (u8vector 1 2))      ;; ___BEGIN_ALLOC_U8VECTOR
      (set! a (f64vector 1. 2.))   ;; ___BEGIN_ALLOC_F64VECTOR
      (set! a (vector 1 2))        ;; ___BEGIN_ALLOC_VECTOR
      @todo
      (make-serialized 1 2)        ;; ___BEGIN_ALLOC_STRUCTURE *****
      (set! a (values 1 2))        ;; ___BEGIN_ALLOC_VALUES
      ;; _kernel.scm
      (set! a (make-vector 2))
      (set! a (make-vector 2 'a))
      (set! a (make-u8vector 2))
      (set! a (make-f64vector 2))
      (set! a (make-string 2))
      (set! a (make-table))
      (set! a (make-mutex))
      (set! a (make-condition-variable))
      @todo
      (set! a (make-thread foo))   ;; doesn't work because it allocates other objects
      (set! a (make-will #f foo))
      @todo
      (set! a (make-parameter #f)) ;; doesn't work
      ;; jazz
      (set! a (allocate-vector 2))
      (set! a (allocate-u8vector 2))
      (set! a (allocate-f64vector 2))
      (set! a (new Point 1 2))     ;; allocate
      (set! a (new Foo 1 2))       ;; new
      ))
  ;; reset
  (reset-allocations)
  ;; caches
  (get-categorized-steps)
  ;; render
  ;@comment
  (let ((world (current-world)))
    (with-tracking 'render
      (lambda ()
        (render-frame world))))
  ;; visual
  ;@comment
  (let ((zone (current-zone))
        (me (current-me)))
    (let ((sector (element-sector zone me)))
      (set-visual-uptodate? sector #f)
      (with-tracking 'visual
        (lambda ()
          (instantiate-visual sector)))))
  ;; physical
  ;@comment
  (let ((zone (current-zone))
        (me (current-me)))
    (let ((sector (element-sector zone me)))
      (set-physical-uptodate? sector #f)
      (with-tracking 'physical
        (lambda ()
          (instantiate-physical sector #f)))))
  ;; tick
  ;@comment
  (let ()
    (define (doit (track? #f))
      (let ((me (current-me)))
        (set-position me (vertex& 0. 4. 0.))
        (let ((commands (new Commands))
              (time (current-seconds))
              (elapse .05))
          (define (tick)
            (tick-actor me commands time elapse #t 'slide))
          
          (move-forward commands)
          (if track?
              (with-tracking 'tick
                (lambda ()
                  (tick)))
            (tick)))))
    ;; empty pass
    (doit)
    (doit #t))
  ;; animate
  ;@comment
  (let ((me (current-me)))
    (let ((time (current-seconds))
          (elapse .05))
      (with-tracking 'animate
        (lambda ()
          (animate me elapse))))))


;;;
;;;; Camera
;;;


;; - rename previous-mouses to last-mouses!?
;; - replace last-point and last-time by using previous-mouses
;; - could we more generally, hook at the camera change and smooth every camera change!?
;;   - hummm not so sure anymore. moving the mouse is a jerky process, whereas the other camera jerkyness
;;   - are probably more due to bugs that should be identified and corrected. if that's the case then rename to mouse-smoothing
;; - going horizontal, waiting a bit like .2 and going down looks really bad. need something more continuous than only considering scalar < 0
;; - we should take the angle between the movements instead of the scalar product so we can do a test like (> 30 degree) for example

(definition ppond 1.)
(definition public (movecamera world new-point new-time last-point last-time previous-mouses)
  (define (scalarproduct a <Point$fl$> b <Point$fl$>) <fl>
    (+ (* (get-h a) (get-h b)) (* (get-v a) (get-v b))))
  
  (let ((poschange (nu- new-point last-point))
        (elapse (- new-time last-time)))
    ;; a try for moving the mouse, waiting a long time and starting again can behave a bit strangely because of large elapse
    (when (> elapse .25)
      (set! previous-mouses '()))
    (let ((delta (if (or (not (get-camera-smoothing?)) (null? previous-mouses))
                     poschange
                   (let ((dirchange (if (null? (cdr previous-mouses)) -1. (scalarproduct (cast <Point$fl$> poschange) (cast <Point$fl$> (nu- last-point (caadr previous-mouses)))))))
                     ;; can still be a bit jerky when going from .5 to 1. all of a sudden
                     (let ((ponderation (if (and (< (norm poschange) 25. @a-try 5.)
                                                 (>= dirchange 0.))
                                            .5
                                          1.)))
                       (when (/= ponderation ppond)
                         ;(terminal ponderation (norm poschange) dirchange)
                         ;(bell)
                         (set! ppond ponderation))
                       ;(terminal ponderation elapse (norm poschange))
                       (bind (furthest-point . furthest-time) (last previous-mouses)
                         (let ((time-delta (- new-time furthest-time)))
                           (if (= time-delta 0.)
                               poschange
                             (nu+ (nu* (nu- new-point furthest-point) (* (/ elapse time-delta) (- 1. ponderation)))
                                  (nu* poschange ponderation))))))))))
      (let ((dx (get-h delta))
            (dy (get-v delta)))
        (mouse-track world elapse dx dy)))))


;;;
;;;; Memory
;;;


@test-memory (
(definition public (test1)
  (define (meg bytes)
    (fxround (/ (cast <fl> bytes) 1024. 1024.)))
  
  (gc)
  (gc)
  (bind-values (last-gc-heap-size last-gc-alloc last-gc-live last-gc-movable last-gc-nonmovable) (process-memory)
    (terminal (meg last-gc-live) (meg last-gc-movable) (meg last-gc-nonmovable))))


(definition public (test2)
  (setup-memory)
  (outline-unit 'world.test.z)
  (display-message (current-world) "Memory setup"))


(definition public (test3)
  (setup-memory-test)
  @w
  (snapshot-heap))


(definition public (test4)
  (let ((unit-name 'jazz.language.runtime.homogeneous @w 'world.test.x))
    (setup-outline-hook 'world.test.x @w unit-name)
    ;(load-unit 'world.test.x)
    (snapshot-heap)
    ;(setup-memory-debug)
    (analyse-incoming @unit-name: unit-name)
    (display-message (current-world) "Memory setup")))


(definition public (test5)
  (setup-memory-debug)
  (display-message (current-world) "Memory setup")
  (load-unit 'jazz.ui.event.Focus-Event)
  (outline-unit 'jazz.ui.event.Focus-Event))


(definition public (test6)
  (load-unit 'world.test.y)
  (setup-memory-compare))


(definition public (test7)
  (load-unit 'world.test.y)
  (setup-memory-compare present: 'container))


(definition public (test8)
  @w
  (analyse-incoming))


(definition public (test9)
  (analyse-regions))


(definition public (test0)
  (analyse-types threshold: 50)))


;;;
;;;; Test
;;;


(definition public (test1-script)
  (dispatch-to 'world.test1-script "test/test1"))


(definition public (test2-script)
  (dispatch-to 'world.test2-script "test/test2"))


(definition public (test3-script)
  (dispatch-to 'world.test3-script "test/test3"))


(definition public (test4-script)
  (dispatch-to 'world.test4-script "test/test4"))


(definition public (test5-script)
  (dispatch-to 'world.test5-script "test/test5"))


(definition public (test6-script)
  (dispatch-to 'world.test6-script "test/test6"))


(definition public (test7-script)
  (dispatch-to 'world.test7-script "test/test7"))


(definition public (test8-script)
  (dispatch-to 'world.test8-script "test/test8"))


(definition public (test9-script)
  (dispatch-to 'world.test9-script "test/test9"))


(definition public (test0-script)
  (dispatch-to 'world.test0-script "test/test0"))


;;;
;;;; Dispatch
;;;


(definition protected (dispatch-to name default)
  (let ((world (current-world)))
    (let ((to (world-setting name default)))
      (cond ((not to)
             (bell))
            ((string? to)
             (execute-script world to))
            (else
             (error "Invalid test setting: {a}" to))))))


;;;
;;;; Convert
;;;


(definition protected (->player/camera properties)
  (let ((player (->player properties))
        (camera (->camera properties)))
    (append player (list camera))))


(definition protected (->player properties)
  (let ((pos (getf properties start-position:))
        (sight (getf properties start-sight:))
        (up (getf properties start-up:)))
    (let ((lookat (lookat sight up (cross-normal sight up))))
      `(<Player> position: ,pos lookat: ,lookat))))


(definition protected (->camera properties)
  (let ((pos (getf properties start-eye:))
        (sight (getf properties start-eye-sight:))
        (up (getf properties start-eye-up:)))
    (let ((lookat (lookat sight up (cross-normal sight up))))
      `(<Camera> position: ,pos lookat: ,lookat)))))
