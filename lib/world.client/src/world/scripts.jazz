;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Scripts
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte


(module world.scripts jazz


(import (jazz.application)
        (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.motion)
        (world.settings)
        (world.syntax (phase syntax)))


;; - rename previous-mouses to last-mouses!?
;; - replace last-point and last-time by using previous-mouses
;; - could we more generally, hook at the camera change and smooth every camera change!?
;;   - hummm not so sure anymore. moving the mouse is a jerky process, whereas the other camera jerkyness
;;   - are probably more due to bugs that should be identified and corrected. if that's the case then rename to mouse-smoothing
;; - going horizontal, waiting a bit like .2 and going down looks really bad. need something more continuous than only considering scalar < 0
;; - we should take the angle between the movements instead of the scalar product so we can do a test like (> 30 degree) for example

(definition ppond 1.)
(definition public (movecamera world new-point new-time last-point last-time previous-mouses)
  (define (scalarproduct a <Point$fl$> b <Point$fl$>) <fl>
    (+ (* (get-h~ a) (get-h~ b)) (* (get-v~ a) (get-v~ b))))
  
  (let ((poschange (nu- new-point last-point))
        (elapse (- new-time last-time)))
    ;; a try for moving the mouse, waiting a long time and starting again can behave a bit strangely because of large elapse
    (when (> elapse .25)
      (set! previous-mouses '()))
    (let ((delta (if (or (not (get-camera-smoothing?)) (null? previous-mouses))
                     poschange
                   (let ((dirchange (if (null? (cdr previous-mouses)) -1. (scalarproduct poschange (nu- last-point (caadr previous-mouses))))))
                     ;; can still be a bit jerky when going from .5 to 1. all of a sudden
                     (let ((ponderation (if (and (< (norm poschange) 25. @a-try 5.)
                                                 (>= dirchange 0.))
                                            .5
                                          1.)))
                       (when (/= ponderation ppond)
                         ;(terminal ponderation (norm poschange) dirchange)
                         ;(bell)
                         (set! ppond ponderation))
                       ;(terminal ponderation elapse (norm poschange))
                       (bind (furthest-point . furthest-time) (last previous-mouses)
                         (let ((time-delta (- new-time furthest-time)))
                           (if (= time-delta 0.)
                               poschange
                             (nu+ (nu* (nu- new-point furthest-point) (* (/ elapse time-delta) (- 1. ponderation)))
                                  (nu* poschange ponderation))))))))))
      (let ((dx (get-h~ delta))
            (dy (get-v~ delta)))
        (mouse-track~ world elapse dx dy)))))


;;;
;;;; Memory
;;;


@test-memory (
(definition public (test1)
  (define (meg bytes)
    (fxround (/ (cast <fl> bytes) 1024. 1024.)))
  
  (gc)
  (gc)
  (receive (last-gc-heap-size last-gc-alloc last-gc-live last-gc-movable last-gc-nonmovable) (process-memory)
    (terminal (meg last-gc-live) (meg last-gc-movable) (meg last-gc-nonmovable))))


(definition public (test2)
  (setup-memory)
  (outline-unit 'world.test.z)
  (display-message~ (current-world) "Memory setup"))


(definition public (test3)
  (setup-memory-test)
  @w
  (snapshot-heap))


(definition public (test4)
  (let ((unit-name 'jazz.language.runtime.homogeneous @w 'world.test.x))
    (setup-outline-hook 'world.test.x @w unit-name)
    ;(load-unit 'world.test.x)
    (snapshot-heap)
    ;(setup-memory-debug)
    (analyse-incoming @unit-name: unit-name)
    (display-message~ (current-world) "Memory setup")))


(definition public (test5)
  (setup-memory-debug)
  (display-message~ (current-world) "Memory setup")
  (load-unit 'jazz.ui.event.Focus-Event)
  (outline-unit 'jazz.ui.event.Focus-Event))


(definition public (test6)
  (load-unit 'world.test.y)
  (setup-memory-compare))


(definition public (test7)
  (load-unit 'world.test.y)
  (setup-memory-compare present: 'container))


(definition public (test8)
  @w
  (analyse-incoming))


(definition public (test9)
  (analyse-regions))


(definition public (test0)
  (analyse-types threshold: 50)))


;;;
;;;; Test
;;;


(definition public (test1)
  (dispatch-to (world-setting 'world.test1 'test1)))


(definition public (test2)
  (dispatch-to (world-setting 'world.test2 'test2)))


(definition public (test3)
  (dispatch-to (world-setting 'world.test3 'test3)))


(definition public (test4)
  (dispatch-to (world-setting 'world.test4 'test4)))


(definition public (test5)
  (dispatch-to (world-setting 'world.test5 'test5)))


(definition public (test6)
  (dispatch-to (world-setting 'world.test6 'test6)))


(definition public (test7)
  (dispatch-to (world-setting 'world.test7 'test7)))


(definition public (test8)
  (dispatch-to (world-setting 'world.test8 'test8)))


(definition public (test9)
  (dispatch-to (world-setting 'world.test9 'test9)))


(definition public (test0)
  (dispatch-to (world-setting 'world.test0 'test0)))


;;;
;;;; Dispatch
;;;


(definition (dispatch-to to)
  (let ((world (current-world)))
    (cond ((not to)
           (bell))
          ((symbol? to)
           (let ((profile (get-profile~ (get-application))))
             (if profile
                 (let ((dispatch (find-dispatch (class-of profile) to)))
                   (if dispatch
                       (dispatch profile)
                     (display-error~ world (format "Unable to find method {a} in profile" to))
                     (bell)))
               (bell))))
          ((string? to)
           (execute-script~ world to))
          (else
           (error "Invalid test setting: {a}" to))))))
