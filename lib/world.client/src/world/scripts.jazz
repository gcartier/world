;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Scripts
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte


(module world.scripts jazz


(import (jazz.application)
        (jazz.syntax (phase syntax))
        (jazz.tracker)
        (profiler)
        (world)
        (world.audio)
        (world.autoload)
        (world.commands)
        (world.generation)
        (world.geometry)
        (world.motion)
        (world.settings)
        (world.syntax (phase syntax)))


(class Foo extends Object
  
  (method override (initialize a b)
    ))

(define a
  #f)

(define (foo a b)
  (+ a b))

(definition public (test)
  @comment
  (with-tracking 'unit
    (lambda ()
      (set! a (foo 1. 2.))         ;; ___F64BOX
      (set! a (cons 1 2))          ;; ___CONS
      (set! a (box 1))             ;; ___BOX
                                   ;; ___MAKEPROMISE *****
      @todo
      (continuation-capture        ;; ___MAKECONTINUATION *****
        (lambda (cont)
          (set! a cont)))
                                   ;; ___MAKESYMBOL *****
                                   ;; ___MAKEKEYWORD *****
                                   ;; ___MAKEWILL *****
      @todo
      (let ((x 1))                 ;; ___ALLOC_CLO *****
        (set! a (lambda (y)
                  (+ x y))))
      (set! a (list 1 2))          ;; ___BEGIN_ALLOC_LIST
      (set! a (string #\a #\b))    ;; ___BEGIN_ALLOC_STRING
      (set! a (u8vector 1 2))      ;; ___BEGIN_ALLOC_U8VECTOR
      (set! a (f64vector 1. 2.))   ;; ___BEGIN_ALLOC_F64VECTOR
      (set! a (vector 1 2))        ;; ___BEGIN_ALLOC_VECTOR
      @todo
      (make-serialized 1 2)        ;; ___BEGIN_ALLOC_STRUCTURE *****
      (set! a (values 1 2))        ;; ___BEGIN_ALLOC_VALUES
      ;; _kernel.scm
      (set! a (make-vector 2))
      (set! a (make-vector 2 'a))
      (set! a (make-u8vector 2))
      (set! a (make-f64vector 2))
      (set! a (make-string 2))
      (set! a (make-table))
      (set! a (make-mutex))
      (set! a (make-condition))
      @todo
      (set! a (make-thread foo))   ;; doesn't work because it allocates other objects
      (set! a (make-will #f foo))
      @todo
      (set! a (make-parameter #f)) ;; doesn't work
      ;; jazz
      (set! a (allocate-vector 2))
      (set! a (allocate-u8vector 2))
      (set! a (allocate-f64vector 2))
      (set! a (new Point 1 2))     ;; allocate
      (set! a (new Foo 1 2))       ;; new
      ))
  ;; reset
  (reset-allocations)
  ;; caches
  (get-categorized-steps)
  ;; render
  ;@comment
  (let ((world (current-world)))
    (with-tracking 'render
      (lambda ()
        (render-world~ world))))
  ;; generate
  @comment
  (let ((zone (current-zone))
        (me (current-me)))
    (let ((sector (element-sector~ zone me)))
      (with-generate-mutex
        (lambda ()
          (set-visual-uptodate?~ sector #f)
          (with-tracking 'generate
            (lambda ()
              (generate-sector sector 'visual)))))))
  ;; tick
  @comment
  (let ()
    (define (doit (track? #f))
      (let ((me (current-me)))
        (set-position~ me (vertex& 0. 4. 0.))
        (let ((commands (new Commands))
              (time (current-seconds))
              (elapse .05))
          (define (tick)
            (tick-actor~ me commands time elapse exit #t 'slide))
          
          (move-forward~ commands)
          (continuation-capture
            (lambda (exit)
              (if track?
                  (with-tracking 'tick
                    (lambda ()
                      (tick)))
                (tick)))))))
    ;; empty pass
    (doit)
    (doit #t))
  ;; animate
  @comment
  (let ((me (current-me)))
    (let ((time (current-seconds))
          (elapse .05))
      (with-tracking 'animate
        (lambda ()
          (animate~ me elapse))))))


;;;
;;;; Camera
;;;


;; - rename previous-mouses to last-mouses!?
;; - replace last-point and last-time by using previous-mouses
;; - could we more generally, hook at the camera change and smooth every camera change!?
;;   - hummm not so sure anymore. moving the mouse is a jerky process, whereas the other camera jerkyness
;;   - are probably more due to bugs that should be identified and corrected. if that's the case then rename to mouse-smoothing
;; - going horizontal, waiting a bit like .2 and going down looks really bad. need something more continuous than only considering scalar < 0
;; - we should take the angle between the movements instead of the scalar product so we can do a test like (> 30 degree) for example

(definition ppond 1.)
(definition public (movecamera world new-point new-time last-point last-time previous-mouses)
  (define (scalarproduct a <Point$fl$> b <Point$fl$>) <fl>
    (+ (* (get-h~ a) (get-h~ b)) (* (get-v~ a) (get-v~ b))))
  
  (let ((poschange (nu- new-point last-point))
        (elapse (- new-time last-time)))
    ;; a try for moving the mouse, waiting a long time and starting again can behave a bit strangely because of large elapse
    (when (> elapse .25)
      (set! previous-mouses '()))
    (let ((delta (if (or (not (get-camera-smoothing?)) (null? previous-mouses))
                     poschange
                   (let ((dirchange (if (null? (cdr previous-mouses)) -1. (scalarproduct poschange (nu- last-point (caadr previous-mouses))))))
                     ;; can still be a bit jerky when going from .5 to 1. all of a sudden
                     (let ((ponderation (if (and (< (norm poschange) 25. @a-try 5.)
                                                 (>= dirchange 0.))
                                            .5
                                          1.)))
                       (when (/= ponderation ppond)
                         ;(terminal ponderation (norm poschange) dirchange)
                         ;(bell)
                         (set! ppond ponderation))
                       ;(terminal ponderation elapse (norm poschange))
                       (bind (furthest-point . furthest-time) (last previous-mouses)
                         (let ((time-delta (- new-time furthest-time)))
                           (if (= time-delta 0.)
                               poschange
                             (nu+ (nu* (nu- new-point furthest-point) (* (/ elapse time-delta) (- 1. ponderation)))
                                  (nu* poschange ponderation))))))))))
      (let ((dx (get-h~ delta))
            (dy (get-v~ delta)))
        (mouse-track~ world elapse dx dy)))))


;;;
;;;; Memory
;;;


@test-memory (
(definition public (test1)
  (define (meg bytes)
    (fxround (/ (cast <fl> bytes) 1024. 1024.)))
  
  (gc)
  (gc)
  (bind-values (last-gc-heap-size last-gc-alloc last-gc-live last-gc-movable last-gc-nonmovable) (process-memory)
    (terminal (meg last-gc-live) (meg last-gc-movable) (meg last-gc-nonmovable))))


(definition public (test2)
  (setup-memory)
  (outline-unit 'world.test.z)
  (display-message~ (current-world) "Memory setup"))


(definition public (test3)
  (setup-memory-test)
  @w
  (snapshot-heap))


(definition public (test4)
  (let ((unit-name 'jazz.language.runtime.homogeneous @w 'world.test.x))
    (setup-outline-hook 'world.test.x @w unit-name)
    ;(load-unit 'world.test.x)
    (snapshot-heap)
    ;(setup-memory-debug)
    (analyse-incoming @unit-name: unit-name)
    (display-message~ (current-world) "Memory setup")))


(definition public (test5)
  (setup-memory-debug)
  (display-message~ (current-world) "Memory setup")
  (load-unit 'jazz.ui.event.Focus-Event)
  (outline-unit 'jazz.ui.event.Focus-Event))


(definition public (test6)
  (load-unit 'world.test.y)
  (setup-memory-compare))


(definition public (test7)
  (load-unit 'world.test.y)
  (setup-memory-compare present: 'container))


(definition public (test8)
  @w
  (analyse-incoming))


(definition public (test9)
  (analyse-regions))


(definition public (test0)
  (analyse-types threshold: 50)))


;;;
;;;; Test
;;;


(definition public (test1)
  (dispatch-to (world-setting 'world.test1 'test1)))


(definition public (test2)
  (dispatch-to (world-setting 'world.test2 'test2)))


(definition public (test3)
  (dispatch-to (world-setting 'world.test3 'test3)))


(definition public (test4)
  (dispatch-to (world-setting 'world.test4 'test4)))


(definition public (test5)
  (dispatch-to (world-setting 'world.test5 'test5)))


(definition public (test6)
  (dispatch-to (world-setting 'world.test6 'test6)))


(definition public (test7)
  (dispatch-to (world-setting 'world.test7 'test7)))


(definition public (test8)
  (dispatch-to (world-setting 'world.test8 'test8)))


(definition public (test9)
  (dispatch-to (world-setting 'world.test9 'test9)))


(definition public (test0)
  (dispatch-to (world-setting 'world.test0 'test0)))


;;;
;;;; Dispatch
;;;


(definition (dispatch-to to)
  (let ((world (current-world)))
    (cond ((not to)
           (bell))
          ((symbol? to)
           (let ((profile (get-profile~ (get-application))))
             (if profile
                 (let ((dispatch (find-dispatch (class-of profile) to)))
                   (if dispatch
                       (dispatch profile)
                     (display-error~ world (format "Unable to find method {a} in profile" to))
                     (bell)))
               (bell))))
          ((string? to)
           (execute-script~ world to))
          (else
           (error "Invalid test setting: {a}" to))))))
