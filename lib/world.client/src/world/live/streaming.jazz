;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Live Streaming
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.live.streaming jazz


(import (jazz.component)
        (jazz.event)
        (jazz.graphic)
        (jazz.io)
        (jazz.json)
        (jazz.network.websocket)
        (jazz.stream)
        (jazz.stream.syntax (phase syntax))
        (jazz.syntax (phase syntax))
        (jazz.view)
        (world)
        (world.audio)
        (world.autoload)
        (world.circle)
        (world.client.udp)
        (world.context)
        (world.settings)
        (world.streamer)
        (world.task)
        (world.udp)
        (world.video))


(definition protected twitch-server
  (world-setting 'twitch.server #f))

(definition protected twitch-key
  (world-setting 'twitch.key #f))


(definition protected twitch-music-device
  (world-setting 'twitch.music-device #f))


(definition protected live-streaming-framerate
  (world-setting 'world.live-streaming-framerate 30))

(definition protected live-streaming-bitrate
  (world-setting 'world.live-streaming-bitrate 4096))


(definition protected live-streaming?
  #f)

(definition protected live-scene
  #f)

(definition protected live-pipeline
  #f)

(definition protected live-free-pipelines
  '())


(definition protected live-mic-pipeline
  #f)

(definition protected live-audio-pipeline
  #f)

(definition protected live-music-stream
  #f)

(definition protected live-music-pipeline
  #f)

(definition protected live-video-pipeline
  #f)


;;;
;;;; Streaming
;;;


(definition public (live-streaming)
  (if (not live-streaming?)
      (start-live-streaming 'starting)
    (stop-live-streaming)))


(definition public (live-start)
  (if (not live-streaming?)
      (start-live-streaming 'starting)
    (replace-scene 'starting)))


(definition public (live-pause)
  (if (not live-streaming?)
      (start-live-streaming 'paused)
    (replace-scene 'paused)))


(definition public (live-resume)
  (if (not live-streaming?)
      (start-live-streaming 'screen)
    (replace-scene 'screen)))


(definition public (live-end)
  (if (not live-streaming?)
      (start-live-streaming 'ended)
    (replace-scene 'ended)))


(definition (start-live-streaming scene)
  (let ((world (current-world)))
    (cond ((not twitch-server)
           (display-error world "Missing world.twitch-server setting"))
          ((not twitch-key)
           (display-error world "Missing world.twitch-key setting"))
          ((not (acquire-microphone-pipeline))
           (display-error world "Unable to acquire microphone"))
          ((not (setup-music-device))
           (display-error world "Unable to find music device"))
          (else
           (let ((err (setup-scenes)))
             (if err
                 (display-error world (format "Unable to find {a}" err))
               (start-chatbot)
               (start-update)
               (start-streaming scene)))))))


(definition (stop-live-streaming)
  (stop-chatbot)
  (stop-update)
  (stop-streaming))


;;;
;;;; Pipeline
;;;


(definition (link-proxies sink-pipeline src-pipeline name)
  (with-unref ((src-proxy (gst_bin_get_by_name src-pipeline name)))
    (g_object_set_pointer src-proxy "proxysink" (gst_bin_get_by_name sink-pipeline name))))

(definition (unlink-proxies src-pipeline name)
  (with-unref ((src-proxy (gst_bin_get_by_name_aux src-pipeline name)))
    (when src-proxy
      (g_object_set_pointer src-proxy "proxysink" #f))))


(definition (offset-pad sink-pipeline src-pipeline name)
  (let ((sink-running (gst_pipeline_get_running_time sink-pipeline)))
    (let ((offset (- sink-running)))
      (with-unref ((src (gst_bin_get_by_name src-pipeline name)))
        (with-unref ((pad (gst_element_get_static_pad src "src")))
          (gst_pad_set_offset pad offset))))))

(definition (offset-running sink-pipeline src-pipeline name)
  (let ((sink-running (gst_pipeline_get_running_time sink-pipeline))
        (src-running (gst_pipeline_get_running_time src-pipeline)))
    (let ((offset (- src-running sink-running)))
      (with-unref ((src (gst_bin_get_by_name src-pipeline name)))
        (with-unref ((pad (gst_element_get_static_pad src "src")))
          (gst_pad_set_offset pad offset))))))


(definition (free-pipeline? pipeline)
  (memq? pipeline live-free-pipelines))


(definition (add-free pipeline)
  (set! live-free-pipelines (append! live-free-pipelines (list pipeline))))

(definition (remove-free pipeline)
  (set! live-free-pipelines (remove! pipeline live-free-pipelines)))


(definition (release-free pipeline)
  (when (free-pipeline? pipeline)
    (gst_bin_release pipeline)
    (remove-free pipeline)))


;;;
;;;; Mic
;;;


(definition (replace-mic mic free?)
  (unless (eq? mic live-mic-pipeline)
    (unlink-proxies live-pipeline "micproxy")
    (release-free live-mic-pipeline)
    (link-proxies mic live-pipeline "micproxy")
    (gst_element_set_state mic GST_STATE_PLAYING)
    (offset-running mic live-pipeline "micproxy")
    (set! live-mic-pipeline mic)
    (when free?
      (add-free mic))))


;;;
;;;; Audio
;;;


(definition (make-silence name)
  (let ((silence
          (gst-pipeline
            "audiotestsrc is-live=true wave=silence name=src"
            "audio/x-raw, format=S16LE, layout=interleaved, rate=48000, channels=2"
            (tie "proxysink name={name}proxy"))))
    (gst_object_set_name silence (tie "live.{name}"))
    silence))


(definition (replace-audio audio free?)
  (unless (eq? audio live-audio-pipeline)
    (unlink-proxies live-pipeline "audioproxy")
    (release-free live-audio-pipeline)
    (link-proxies audio live-pipeline "audioproxy")
    (gst_element_set_state audio GST_STATE_PLAYING)
    (offset-running audio live-pipeline "audioproxy")
    (set! live-audio-pipeline audio)
    (when free?
      (add-free audio))))


;;;
;;;; Music
;;;


(definition protected effective-music-device
  #f)

(definition (setup-music-device)
  (if (not twitch-music-device)
      (begin
        (set! effective-music-device #f)
        #t)
    (let ((provider (name->microphone-provider twitch-music-device)))
      (cond ((not provider)
             (set! effective-music-device #f)
             #f)
            (else
             (set! effective-music-device (get-identifier provider))
             #t)))))


(definition protected (music-quieter)
  (let ((world (current-world)))
    (let ((output (locate-music-output)))
      (if (not output)
          (display-error world "No music playing")
        (let ((volume (max 0. (- (get-volume output) .1))))
          (let ((stream (get-stream (get-channel output))))
            (let ((video-output (get-video-output stream)))
              (let ((circle-view (get-root (get-interface-pane video-output))))
                (let ((volume-view (child circle-view 'volume)))
                  (set-volume output volume)
                  (setup-knob volume-view volume)
                  (invalidate-view volume-view)
                  (display-status world (format "{r precision: 1}" volume)))))))))))


(definition protected (music-louder)
  (let ((world (current-world)))
    (let ((output (locate-music-output)))
      (if (not output)
          (display-error world "No music playing")
        (let ((volume (min 1. (+ (get-volume output) .1))))
          (let ((stream (get-stream (get-channel output))))
            (let ((video-output (get-video-output stream)))
              (let ((circle-view (get-root (get-interface-pane video-output))))
                (let ((volume-view (child circle-view 'volume)))
                  (set-volume output volume)
                  (setup-knob volume-view volume)
                  (invalidate-view volume-view)
                  (display-status world (format "{r precision: 1}" volume)))))))))))


(definition protected (music-pause)
  (let ((world (current-world)))
    (let ((output (locate-music-output)))
      (if (not output)
          (display-error world "No music playing")
        (let ((stream (get-stream (get-channel output))))
          (let ((video-output (get-video-output stream)))
            (let ((circle-view (get-root (get-interface-pane video-output))))
              (let ((paused? (toggle-paused circle-view)))
                (let ((title (if paused? "Music paused" "Music playing"))
                      (color (if paused? {Color Red} {Color Green})))
                  (display-message world title color: color))))))))))


(definition (make-music)
  (and effective-music-device
       (let ((music
               (gst-pipeline
                 (tie "osxaudiosrc device={effective-music-device} name=src")
                 "audioconvert"
                 "audioresample"
                 "audio/x-raw, format=S16LE, layout=interleaved, rate=48000, channels=2"
                 "proxysink name=musicproxy")))
         (gst_object_set_name music "live.music")
         music)))


(definition protected (stop-music)
  (when live-music-pipeline
    (unlink-proxies live-pipeline "musicproxy")
    (release-free live-music-pipeline)
    (set! live-music-pipeline #f)
    (set! live-music-stream #f)))


(definition protected (replace-music)
  (let ((world (current-world)))
    (let ((music-output (locate-music-output)))
      (stop-music)
      (let ((music (if music-output (get-bin music-output) (make-silence "music"))))
        (link-proxies music live-pipeline "musicproxy")
        (gst_element_set_state music GST_STATE_PLAYING)
        (offset-running music live-pipeline "musicproxy")
        (set! live-music-stream (and music-output (get-stream (get-channel music-output))))
        (set! live-music-pipeline music)
        (when (not music-output)
          (add-free music))
        music))))


(definition protected (stop-live-music stream)
  (when (eq? live-music-stream stream)
    (stop-music)))


(definition protected (replace-live-music)
  (when live-streaming?
    (replace-music)))


;;;
;;;; Video
;;;


(definition (make-starting)
  (let ((location (parse (table-ref scene-images 'starting))))
    (let ((pipeline
            (gst-pipeline "filesrc name=src"
                          "pngdec"
                          "videoconvert"
                          "imagefreeze is-live=true"
                          "video/x-raw, format=I420, width=2992, height=1934, framerate=30/1, multiview-mode=(string)mono"
                          "proxysink name=videoproxy")))
      (gst_object_set_name pipeline "live.video")
      (with-unref ((filesrc (gst_bin_get_by_name pipeline "src")))
        (g_object_set_utf-8-string filesrc "location" location))
      pipeline)))


(definition (make-paused)
  (let ((location (parse (table-ref scene-images 'paused))))
    (let ((pipeline
            (gst-pipeline "filesrc name=src"
                          "pngdec"
                          "videoconvert"
                          "imagefreeze is-live=true"
                          "video/x-raw, format=I420, width=2992, height=1934, framerate=30/1, multiview-mode=(string)mono"
                          "proxysink name=videoproxy")))
      (gst_object_set_name pipeline "live.video")
      (with-unref ((filesrc (gst_bin_get_by_name pipeline "src")))
        (g_object_set_utf-8-string filesrc "location" location))
      pipeline)))


(definition (make-screen)
  (let ((screen
          (gst-pipeline
            "avfvideosrc capture-screen=true capture-screen-cursor=true capture-screen-mouse-clicks=true name=src"
            "videoconvert"
            "video/x-raw, format=I420, width=2992, height=1934, framerate=30/1, multiview-mode=(string)mono"
            "proxysink name=videoproxy")))
    (gst_object_set_name screen "live.video")
    screen))


(definition (make-ended)
  (let ((location (parse (table-ref scene-images 'ended))))
    (let ((pipeline
            (gst-pipeline "filesrc name=src"
                          "pngdec"
                          "videoconvert"
                          "imagefreeze is-live=true"
                          "video/x-raw, format=I420, width=2992, height=1934, framerate=30/1, multiview-mode=(string)mono"
                          "proxysink name=videoproxy")))
      (gst_object_set_name pipeline "live.video")
      (with-unref ((filesrc (gst_bin_get_by_name pipeline "src")))
        (g_object_set_utf-8-string filesrc "location" location))
      pipeline)))


(definition protected (replace-video video free?)
  (unless (eq? video live-video-pipeline)
    (unlink-proxies live-pipeline "videoproxy")
    (release-free live-video-pipeline)
    (link-proxies video live-pipeline "videoproxy")
    (gst_element_set_state video GST_STATE_PLAYING)
    (offset-running video live-pipeline "videoproxy")
    (set! live-video-pipeline video)
    (when free?
      (add-free video))))


;;;
;;;; Scene
;;;


(definition scene-images
  (make-table test: eq?))


(definition (setup-scenes)
  (define (setup name path)
    (let ((file (new-file {Directory Documents} path)))
      (cond ((not (exists? file))
             path)
            (else
             (table-set! scene-images name file)
             #f))))
  
  (or (setup 'starting "scenes/starting.png")
      (setup 'paused   "scenes/paused.png")
      (setup 'ended    "scenes/ended.png")))


(definition (replace-live)
  )


(definition (replace-starting)
  (let ((mic (make-silence "mic"))
        (audio (make-silence "audio"))
        (video (make-starting)))
    (replace-mic mic #t)
    (replace-audio audio #t)
    (replace-video video #t)
    (set! live-scene 'starting)))


(definition (replace-paused)
  (let ((mic (make-silence "mic"))
        (audio (make-silence "audio"))
        (video (make-paused)))
    (replace-mic mic #t)
    (replace-audio audio #t)
    (replace-video video #t)
    (set! live-scene 'paused)))


(definition (replace-screen)
  (let ((mic microphone-pipeline)
        (audio (get-pipeline (cache-audio)))
        (video (make-screen)))
    (replace-mic mic #f)
    (replace-audio audio #f)
    (replace-video video #t)
    (set! live-scene 'screen)))


(definition (replace-ended)
  (let ((mic (make-silence "mic"))
        (audio (make-silence "audio"))
        (video (make-ended)))
    (replace-mic mic #t)
    (replace-audio audio #t)
    (replace-video video #t)
    (set! live-scene 'ended)))


(definition protected (replace-scene scene)
  (case scene
    ((starting) (replace-starting))
    ((paused) (replace-paused))
    ((screen) (replace-screen))
    ((ended) (replace-ended))))


;;;
;;;; Live
;;;


(definition protected save-dir
  {Directory Documents "videos"})


(definition (make-live mic audio music video)
  (create-directories save-dir)
  (let ((framerate live-streaming-framerate)
        (bitrate live-streaming-bitrate)
        (rtmp-location (tie "{twitch-server}/{twitch-key}"))
        (file-location (parse (timestamped-file save-dir #f "mp4"))))
    (let ((live
            (gst-pipeline
              "proxysrc name=videoproxy"
              (tie "vtenc_h264 bitrate={screen-share-live-bitrate} name=enc")
              "video/x-h264, stream-format=(string)avc"
              "tee name=tee"
              "queue"
              "flvmux enforce-increasing-timestamps=false streamable=true name=flvmux"
              "rtmp2sink name=rtmpsink"
              (list
                "proxysrc name=micproxy"
                "queue"
                "mixer.")
              (list
                "proxysrc name=audioproxy"
                "queue"
                "mixer.")
              (list
                "audiomixer ignore-inactive-pads=true min-upstream-latency=40000000 latency=100000000 name=mixer"
                "audio/x-raw, format=S16LE, layout=interleaved, rate=48000, channels=2"
                "tee name=saveaudio"
                "queue"
                "audiomixer ignore-inactive-pads=true min-upstream-latency=40000000 latency=100000000 name=livemixer"
                "audio/x-raw, format=S16LE, layout=interleaved, rate=48000, channels=2"
                "audioconvert"
                "avenc_aac"
                "flvmux.")
              (list
                "proxysrc name=musicproxy"
                "queue"
                "livemixer.")
              (list
                "saveaudio."
                "queue"
                "audioconvert"
                "avenc_aac"
                "savemux.")
              (list
                "tee."
                "video/x-h264"
                "queue max-size-time=200000000"
                "qtmux name=savemux"
                (tie "filesink name=filesink")))))
      (gst_object_set_name live "live")
      (with-unref ((rtmpsink (gst_bin_get_by_name live "rtmpsink"))
                   (filesink (gst_bin_get_by_name live "filesink")))
        (g_object_set_utf-8-string rtmpsink "location" rtmp-location)
        (g_object_set_utf-8-string filesink "location" file-location))
      (when mic
        (link-proxies mic live "micproxy"))
      (when audio
        (link-proxies audio live "audioproxy"))
      (when music
        (link-proxies music live "musicproxy"))
      (link-proxies video live "videoproxy")
      (when mic
        (gst_element_set_state mic GST_STATE_PLAYING))
      (when audio
        (gst_element_set_state audio GST_STATE_PLAYING))
      (when music
        (gst_element_set_state music GST_STATE_PLAYING))
      (gst_element_set_state video GST_STATE_PLAYING)
      (when mic
        (offset-pad mic live "micproxy"))
      (when audio
        (offset-pad audio live "audioproxy"))
      (when music
        (offset-pad music live "musicproxy"))
      (offset-pad video live "videoproxy")
      (gst_element_set_state live GST_STATE_PLAYING)
      live)))


(definition (stream-starting)
  (let ((music-output (locate-music-output)))
    (let ((mic (make-silence "mic"))
          (audio (make-silence "audio"))
          (music (if music-output (get-bin music-output) (make-silence "music")))
          (video (make-starting)))
      (let ((live (make-live mic audio music video)))
        (set-live-streaming? #t)
        (set! live-scene 'starting)
        (set! live-pipeline live)
        (set! live-free-pipelines (if music-output (list mic audio video) (list mic audio music video)))
        (set! live-mic-pipeline mic)
        (set! live-audio-pipeline audio)
        (set! live-music-stream (and music-output (get-stream (get-channel music-output))))
        (set! live-music-pipeline music)
        (set! live-video-pipeline video)))))


(definition (stream-paused)
  (let ((music-output (locate-music-output)))
    (let ((mic (make-silence "mic"))
          (audio (make-silence "audio"))
          (music (if music-output (get-bin music-output) (make-silence "music")))
          (video (make-paused)))
      (let ((live (make-live mic audio music video)))
        (set-live-streaming? #t)
        (set! live-scene 'paused)
        (set! live-pipeline live)
        (set! live-free-pipelines (if music-output (list mic audio video) (list mic audio music video)))
        (set! live-mic-pipeline mic)
        (set! live-audio-pipeline audio)
        (set! live-music-stream (and music-output (get-stream (get-channel music-output))))
        (set! live-music-pipeline music)
        (set! live-video-pipeline video)))))


(definition (stream-screen)
  (cache-audio)
  (let ((music-output (locate-music-output)))
    (let ((mic microphone-pipeline)
          (audio (get-pipeline (cache-audio)))
          (music (if music-output (get-bin music-output) (make-silence "music")))
          (video (make-screen)))
      (let ((live (make-live mic audio music video)))
        (set-live-streaming? #t)
        (set! live-scene 'screen)
        (set! live-pipeline live)
        (set! live-free-pipelines (if music-output (list video) (list music video)))
        (set! live-mic-pipeline mic)
        (set! live-audio-pipeline audio)
        (set! live-music-stream (and music-output (get-stream (get-channel music-output))))
        (set! live-music-pipeline music)
        (set! live-video-pipeline video)))))


(definition (stream-ended)
  (let ((music-output (locate-music-output)))
    (let ((mic (make-silence "mic"))
          (audio (make-silence "audio"))
          (music (if music-output (get-bin music-output) (make-silence "music")))
          (video (make-ended)))
      (let ((live (make-live mic audio music video)))
        (set-live-streaming? #t)
        (set! live-scene 'ended)
        (set! live-pipeline live)
        (set! live-free-pipelines (if music-output (list mic audio video) (list mic audio music video)))
        (set! live-mic-pipeline mic)
        (set! live-audio-pipeline audio)
        (set! live-music-stream (and music-output (get-stream (get-channel music-output))))
        (set! live-music-pipeline music)
        (set! live-video-pipeline video)))))


(definition protected (start-streaming scene)
  (case scene
    ((starting) (stream-starting))
    ((paused) (stream-paused))
    ((screen) (stream-screen))
    ((ended) (stream-ended))))


(definition protected (stop-streaming)
  (unlink-proxies live-pipeline "micproxy")
  (unlink-proxies live-pipeline "audioproxy")
  (unlink-proxies live-pipeline "musicproxy")
  (unlink-proxies live-pipeline "videoproxy")
  (gst_element_send_event live-pipeline (gst_event_new_eos))
  (or (wait-eos live-pipeline)
      (tell 'did 'not 'receive 'eos 'message))
  (for-each (lambda (pipeline)
              (when pipeline
                (gst_bin_release pipeline)))
            live-free-pipelines)
  (gst_bin_release live-pipeline)
  (set! live-scene #f)
  (set! live-pipeline #f)
  (set! live-free-pipelines '())
  (set-live-streaming? #f))


(definition protected (set-live-streaming? flag)
  (let ((world (current-world)))
    (set! live-streaming? flag)
    (update-state-visible? world)
    (display-on/off world "Live streaming" live-streaming?)))


;;;
;;;; Chat
;;;


;; twitch token --user-token --scopes "user:read:chat user:write:chat"


(definition BOT_USER_ID
  (world-setting 'twitch.chatbot-userid #f))

(definition CLIENT_ID
  (world-setting 'twitch.chatbot-clientid #f))

(definition CLIENT_SECRET
  (world-setting 'twitch.chatbot-clientsecret #f))

(definition OAUTH_TOKEN
  (world-setting 'twitch.chatbot-token #f))

(definition REFRESH_TOKEN
  (world-setting 'twitch.chatbot-refresh-token #f))

(definition CHAT_CHANNEL_USER_ID
  (world-setting 'twitch.chatbot-channel-userid #f))

(definition chat-commands
  (world-setting 'twitch.chatbot-commands #f))


(definition chatbot-thread
  #f)

(definition chatbot-port
  #f)

(definition chatbot-token
  #f)


(definition (start-chatbot)
  (let ((ctx (make-tls-context)))
    (let ((conn (open-tcp-client (list
                                   address: "eventsub.wss.twitch.tv"
                                   port-number: 443
                                   eol-encoding: 'cr-lf
                                   tls-context: ctx))))
      (let ((thread
              (new-thread
                (lambda ()
                  (let ((token (refresh-token)))
                    (set! chatbot-token token)
                    (format conn "GET /ws HTTP/1.1{%}")
                    (format conn "Host: eventsub.wss.twitch.tv{%}")
                    (format conn "Sec-WebSocket-Version: 13{%}")
                    (format conn "Sec-WebSocket-Key: KsdA5iqIpLtQH8DmsoX6og=={%}")
                    (format conn "Connection: keep-alive, Upgrade{%}")
                    (format conn "Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2{%}")
                    (format conn "Upgrade: websocket{%}")
                    (format conn "{%}")
                    (force-output conn)
                    (let (loop)
                      (let ((line (read-line conn)))
                        (if (equal? line "")
                            (run-chatbot conn)
                          (loop))))))
                'live-chat)))
        (set! chatbot-thread thread)
        (set! chatbot-port conn)
        (thread-start! thread)))))


(definition (stop-chatbot)
  (exit-thread chatbot-thread)
  (close-port chatbot-port)
  (set! chatbot-thread #f)
  (set! chatbot-port #f))


(definition protected (refresh-token)
  (let ((world (current-world)))
    (let ((data (string-append
                  #"grant_type=refresh_token&refresh_token="#
                  REFRESH_TOKEN
                  #"&client_id="#
                  CLIENT_ID
                  #"&client_secret="#
                  CLIENT_SECRET)))
      (let ((port (open-process
                    (list
                      path: "/usr/bin/curl"
                      arguments: (list
                                   "--silent"
                                   "--request" "POST"
                                   ;; -H 'Content-Type: application/x-www-form-urlencoded' \
                                   "--data" data
                                   "https://id.twitch.tv/oauth2/token")))))
        (let ((status (process-status port)))
          (if (= status 0)
              (let ((response (string->json (read-line port))))
                (table-ref response "access_token"))
            (display-error "Unable to connect to twitch")
            #f))))))


(definition (validate-token)
  (let ((world (current-world)))
    (let ((port (open-process
                  (list
                    path: "/usr/bin/curl"
                    arguments: (list
                                 "--silent"
                                 "--request" "GET"
                                 "--header" (string-append "Authorization: OAuth " chatbot-token)
                                 "https://id.twitch.tv/oauth2/validate")))))
      (let ((status (process-status port)))
        (if (= status 0)
            (let ((response (string->json (read-line port))))
              (let ((status (table-ref response "status" #f)))
                (if (and status (/= status 200))
                    (display-error world "Token is not valid"))))
          (display-error "Unable to connect to twitch")
          #f)))))


(definition (read-chatbot conn)
  (let ((frame (read-frame-unsafe 0 conn)))
    (case (get-optype frame)
      ((ping)
       (let ((data (get-payload frame)))
         (write-frame-unsafe 'pong data #t conn))
       #f)
      ((text)
       (let ((payload (get-payload frame)))
         (let ((text (unmask frame)))
           (and (> (u8vector-length text) 0)
                (call-with-input-u8vector (list init: text readtable: json-readtable)
                  (lambda (port)
                    (read-json port)))))))
      (else
       #f))))


(definition (run-chatbot conn)
  (declare (proper-tail-calls))
  (let (loop)
    (let ((json (read-chatbot conn)))
      (when json
        (process-chatbot json)))
    (loop)))


(definition (process-chatbot json)
  (let ((metadata (table-ref json "metadata")))
    (let ((message-type (table-ref metadata "message_type")))
      (cond ((equal? message-type "session_welcome")
             (let ((session-id (table-ref (table-ref (table-ref json "payload") "session") "id")))
               (register-eventsub session-id)))
            ((equal? message-type "session_keepalive"))
            ((equal? message-type "notification")
             (let ((subscription-type (table-ref metadata "subscription_type")))
               (cond ((equal? subscription-type "channel.chat.message")
                      (process-message json)))))))))


(definition (process-message json)
  (let ((event (table-ref (table-ref json "payload") "event")))
    (let ((chatter (table-ref event "chatter_user_login"))
          (message (table-ref (table-ref event "message") "text")))
      (delay-event
        (lambda ()
          (with-task-mutex
            (lambda ()
              (show-chat-message (current-world) chatter 'live message)))))
      (let ((trimmed (trim-whitespace message)))
        (cond ((equal? trimmed "!music")
               (music-command))
              (chat-commands
               (let ((pair (assoc trimmed chat-commands)))
                 (when pair
                   (let ((message (cdr pair)))
                     (send-chat-message message))))))))))


(definition (register-eventsub session-id)
  (let ((world (current-world)))
    (let ((data (string-append
                  #"{"type":"channel.chat.message","version":"1","condition":{"broadcaster_user_id":""#
                  CHAT_CHANNEL_USER_ID
                  #"","user_id":""#
                  BOT_USER_ID
                  #""},"transport":{"method":"websocket","session_id":""#
                  session-id
                  #""}}"#)))
      (let ((port (open-process
                    (list
                      path: "/usr/bin/curl"
                      arguments: (list
                                   "--silent"
                                   "--request" "POST"
                                   "--header" (string-append "Authorization: Bearer " chatbot-token)
                                   "--header" (string-append "Client-Id: " CLIENT_ID)
                                   "--header" "Content-Type: application/json"
                                   "--data" data
                                   "https://api.twitch.tv/helix/eventsub/subscriptions")
                      show-console: #f))))
        (let ((status (process-status port)))
          (if (= status 0)
              (let ((response (string->json (read-line port))))
                (let ((status (table-ref response "status" #f)))
                  (if (and status (/= status 202))
                      (display-error world "Failed to subscribe to channel.chat.message"))))
            (display-error "Unable to connect to twitch")
            #f))))))


(definition protected (send-chat-message message)
  (let ((world (current-world)))
    (let ((data (string-append
                  #"{"broadcaster_id":""#
                  CHAT_CHANNEL_USER_ID
                  #"","sender_id":""#
                  BOT_USER_ID
                  #"","message":""#
                  message
                  #""}"#)))
      (let ((port (open-process
                    (list
                      path: "/usr/bin/curl"
                      arguments: (list
                                   "--silent"
                                   "--request" "POST"
                                   "--header" (string-append "Authorization: Bearer " chatbot-token)
                                   "--header" (string-append "Client-Id: " CLIENT_ID)
                                   "--header" "Content-Type: application/json"
                                   "--data" data
                                   "https://api.twitch.tv/helix/chat/messages")
                      show-console: #f))))
        (let ((status (process-status port)))
          (if (= status 0)
              (let ((response (string->json (read-line port))))
                (let ((status (table-ref response "status" #f)))
                  (if (and status (/= status 200))
                      (display-error world "Failed to send chat message"))))
            (display-error "Unable to connect to twitch")
            #f))))))


;;;
;;;; Command
;;;


(definition (music-command)
  (if (not live-music-stream)
      (send-chat-message "No music playing")
    (send-chat-message (get-name live-music-stream))))


;;;
;;;; Update
;;;


(definition protected live-viewer-count
  #f)


(definition update-initial-delay
  10.)

(definition update-delay
  60.)


(definition update-thread
  #f)


(definition (start-update)
  (let ((thread
          (new-thread
            (lambda ()
              (declare (proper-tail-calls))
              (let ((done? (thread-receive update-initial-delay #f)))
                (if done?
                    (set! update-thread #f)
                  (process-update)
                  (let (loop)
                    (let ((done? (thread-receive update-delay #f)))
                      (if done?
                          (set! update-thread #f)
                        (process-update)
                        (loop)))))))
            'live-update)))
    (set! live-viewer-count #f)
    (set! update-thread thread)
    (thread-start! thread)))


(definition (stop-update)
  (thread-send update-thread #t))


(definition protected (process-update)
  (let ((world (current-world)))
    (let ((port (open-process
                  (list
                    path: "/usr/bin/curl"
                    arguments: (list
                                 "--silent"
                                 "--request" "GET"
                                 "--header" (string-append "Authorization: Bearer " chatbot-token)
                                 "--header" (string-append "Client-Id: " CLIENT_ID)
                                 "https://api.twitch.tv/helix/streams?user_login=togethersphere")))))
      (let ((status (process-status port)))
        (if (= status 0)
            (let ((response (string->json (read-line port))))
              (let ((data (table-ref response "data")))
                (if (null? data)
                    (set! live-viewer-count #f)
                  (let ((stream (car data)))
                    (let ((viewer-count (table-ref stream "viewer_count")))
                      (set! live-viewer-count viewer-count))))))
          (display-error "Unable to connect to twitch")
          #f))))))
