;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Live Streaming
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.live.streaming jazz


(import (jazz.event)
        (jazz.io)
        (jazz.json)
        (jazz.network.websocket)
        (jazz.stream)
        (jazz.stream.syntax (phase syntax))
        (jazz.syntax (phase syntax))
        (world)
        (world.audio)
        (world.autoload)
        (world.circle)
        (world.client.udp)
        (world.context)
        (world.settings)
        (world.streamer)
        (world.task)
        (world.udp)
        (world.video))


(definition public (live-streaming)
  (if (not live-streaming?)
      (start-live-streaming)
    (stop-live-streaming)))


(definition (start-live-streaming)
  (start-chatbot)
  (start-streaming))


(definition (stop-live-streaming)
  (stop-chatbot)
  (stop-streaming))


;;;
;;;; Streaming
;;;


(definition protected twitch-server
  (world-setting 'twitch.server #f))

(definition protected twitch-key
  (world-setting 'twitch.key #f))


(definition protected twitch-starting-soon
  (world-setting 'twitch.starting-soon #f))

(definition protected twitch-music-device
  (world-setting 'twitch.music-device #f))


(definition protected live-streaming-framerate
  (world-setting 'world.live-streaming-framerate 30))

(definition protected live-streaming-bitrate
  (world-setting 'world.live-streaming-bitrate 4096))


(definition protected live-streaming?
  #f)

(definition protected live-streaming-kind
  #f)

(definition protected live-streaming-pipeline
  #f)

(definition protected live-streaming-pipelines
  '())


(definition protected effective-music-device
  #f)

(definition (setup-music-device)
  (if (not twitch-music-device)
      (begin
        (set! effective-music-device #f)
        #t)
    (let ((provider (name->microphone-provider twitch-music-device)))
      (cond ((not provider)
             (set! effective-music-device #f)
             #f)
            (else
             (set! effective-music-device (get-identifier provider))
             #t)))))


(definition protected (set-live-streaming? flag)
  (let ((world (current-world)))
    (set! live-streaming? flag)
    (update-state-visible? world)
    (display-on/off world "Live streaming" live-streaming?)))


(definition protected videos-dir
  {Directory Documents "videos"})


(definition (link-proxies sink-pipeline src-pipeline name)
  (with-unref ((micsrc (gst_bin_get_by_name src-pipeline name)))
    (g_object_set_pointer micsrc "proxysink" (gst_bin_get_by_name sink-pipeline name))))


(definition (offset-pad sink-pipeline src-pipeline name)
  (let ((pipeline-running (gst_pipeline_get_running_time sink-pipeline)))
    (let ((offset (- pipeline-running)))
      (with-unref ((src (gst_bin_get_by_name src-pipeline name)))
        (with-unref ((pad (gst_element_get_static_pad src "src")))
          (gst_pad_set_offset pad offset))))))


(definition (make-mic)
  (let ((mic
          (gst-pipeline
            "osxaudiosrc name=src"
            "proxysink name=micproxy")))
    (gst_object_set_name mic "live.mic")
    mic))


(definition (make-audio)
  (let ((audio
          (gst-pipeline
            "audiotestsrc is-live=true wave=silence volume=.05 name=src"
            "audio/x-raw, format=S16LE, layout=interleaved, rate=48000, channels=2"
            "proxysink name=audioproxy")))
    (gst_object_set_name audio "live.audio")
    audio))


(definition (make-music)
  (and effective-music-device
       (let ((music
               (gst-pipeline
                 (tie "osxaudiosrc device={effective-music-device} name=src")
                 "audioconvert"
                 "audioresample"
                 "audio/x-raw, format=S16LE, layout=interleaved, rate=48000, channels=2"
                 "proxysink name=musicproxy")))
         (gst_object_set_name music "live.music")
         music)))


@soon
(definition (make-soon)
  (and twitch-starting-soon
       (exists? twitch-starting-soon)
       (let ((location (parse twitch-starting-soon)))
         (let ((soon
                 (gst-pipeline
                   "filesrc name=src"
                   "jpegdec"
                   "videoconvertscale"
                   "imagefreeze"
                   (tie "vtenc_h264 bitrate={screen-share-live-bitrate} name=enc")
                   "video/x-h264, stream-format=(string)avc"
                   "proxysink name=screenproxy")))
           (gst_object_set_name soon "live.soon")
           (with-unref ((filesrc (gst_bin_get_by_name soon "src")))
             (g_object_set_utf-8-string filesrc "location" location))
           soon))))


(definition (make-screen)
  (let ((screen
          (gst-pipeline
            "avfvideosrc capture-screen=true capture-screen-cursor=true capture-screen-mouse-clicks=true name=src"
            (tie "video/x-raw, framerate={screen-share-live-framerate}/1")
            (tie "vtenc_h264 bitrate={screen-share-live-bitrate} name=enc")
            "video/x-h264, stream-format=(string)avc"
            "proxysink name=screenproxy")))
    (gst_object_set_name screen "live.screen")
    screen))


(definition (make-live mic audio music screen)
  (create-directories videos-dir)
  (let ((framerate live-streaming-framerate)
        (bitrate live-streaming-bitrate)
        (rtmp-location (tie "{twitch-server}/{twitch-key}"))
        (file-location (parse (timestamped-file videos-dir #f "mp4"))))
    (let ((live
            (gst-pipeline
              "proxysrc name=screenproxy"
              "h264parse"
              "tee name=tee"
              "queue"
              "flvmux enforce-increasing-timestamps=false streamable=true name=flvmux"
              "rtmp2sink name=rtmpsink"
              (and audio
                   (list
                     "proxysrc name=audioproxy"
                     "queue"
                     "mixer."))
              (and mic
                   (list
                     "proxysrc name=micproxy"
                     "queue"
                     "mixer."))
              (and (not music)
                   (list
                     "audiomixer min-upstream-latency=40000000 latency=100000000 name=mixer"
                     "tee name=videoaudio"
                     "queue"
                     "audioconvert"
                     "avenc_aac"
                     "flvmux."))
              (and music
                   (list
                     "audiomixer min-upstream-latency=40000000 latency=100000000 name=mixer"
                     "tee name=videoaudio"
                     "queue"
                     "audiomixer min-upstream-latency=40000000 latency=100000000 name=livemixer"
                     "audioconvert"
                     "avenc_aac"
                     "flvmux."))
              (and music
                   (list
                     "proxysrc name=musicproxy"
                     "queue"
                     "livemixer."))
              (list
                "videoaudio."
                "queue"
                "audioconvert"
                "avenc_aac"
                "videomux.")
              (list
                "tee."
                "video/x-h264"
                "queue max-size-time=200000000"
                "qtmux name=videomux"
                (tie "filesink name=filesink")))))
      (gst_object_set_name live "live")
      (with-unref ((rtmpsink (gst_bin_get_by_name live "rtmpsink"))
                   (filesink (gst_bin_get_by_name live "filesink")))
        (g_object_set_utf-8-string rtmpsink "location" rtmp-location)
        (g_object_set_utf-8-string filesink "location" file-location))
      (when mic
        (link-proxies mic live "micproxy"))
      (when audio
        (link-proxies audio live "audioproxy"))
      (when music
        (link-proxies music live "musicproxy"))
      (link-proxies screen live "screenproxy")
      (when mic
        (gst_element_set_state mic GST_STATE_PLAYING))
      (when audio
        (gst_element_set_state audio GST_STATE_PLAYING))
      (when music
        (gst_element_set_state music GST_STATE_PLAYING))
      (gst_element_set_state screen GST_STATE_PLAYING)
      (when mic
        (offset-pad mic live "micproxy"))
      (when audio
        (offset-pad audio live "audioproxy"))
      (when music
        (offset-pad music live "musicproxy"))
      (offset-pad screen live "screenproxy")
      (gst_element_set_state live GST_STATE_PLAYING)
      live)))


@soon
(definition (stream-soon)
  (let ((kind 'soon)
        (music (make-music))
        (soon (make-soon)))
    (let ((live (make-live #f #f music soon)))
      (set-live-streaming? #t)
      (set! live-streaming-kind kind)
      (set! live-streaming-pipeline live)
      (set! live-streaming-pipelines (list music soon)))))


(definition (stream-free)
  (let ((kind 'free)
        (mic (make-mic))
        (audio (make-audio))
        (music (make-music))
        (screen (make-screen)))
    (let ((live (make-live mic audio music screen)))
      (set-live-streaming? #t)
      (set! live-streaming-kind kind)
      (set! live-streaming-pipeline live)
      (set! live-streaming-pipelines (list mic audio music screen)))))


@circle-streaming-needs-server-to-stream
(definition (stream-circle)
  (cache-audio)
  (play (stream-screen "Screen" live?: #t))
  (let ((kind 'circle)
        (mic microphone-pipeline)
        (audio (get-pipeline (cache-audio)))
        (music (locate-music-pipeline))
        (screen (get-pipeline (get-src (get-pipeline (locate-screen-channel (locate-screen-stream)))))))
    (let ((live (make-live mic audio music screen)))
      (set-live-streaming? #t)
      (set! live-streaming-kind kind)
      (set! live-streaming-pipeline live)
      (set! live-streaming-pipelines (list music)))))


(definition protected (start-streaming)
  (let ((world (current-world)))
    (cond ((not twitch-server)
           (display-error world "Missing world.twitch-server setting"))
          ((not twitch-key)
           (display-error world "Missing world.twitch-key setting"))
          ((not (setup-music-device))
           (display-error world "Unable to find music device"))
          (else
           (stream-free))
          @circle-streaming-needs-server-to-stream (
          ((not current-circle-name)
           (stream-free))
          ((not (acquire-microphone-pipeline))
           (display-error world "You need to turn on your microphone to live stream"))
          ((locate-screen-stream)
           (display-error world "You need to turn off screen share to live stream"))
          (else
           (stream-circle))))))


(definition protected (stop-streaming)
  (gst_element_send_event live-streaming-pipeline (gst_event_new_eos))
  ;; quick hack as somehow waiting for eos doesn't ensure
  ;; all data has been processed and saved to the filesink
  (sleep 1)
  (for-each (lambda (pipeline)
              (when pipeline
                (gst_bin_release pipeline)))
            live-streaming-pipelines)
  (gst_bin_release live-streaming-pipeline)
  @circle-streaming-needs-server-to-stream
  (when (eq? live-streaming-kind 'circle)
    (let ((stream (locate-screen-stream)))
      (when stream
        (close-send-stream (current-udp) stream))))
  (set! live-streaming-kind #f)
  (set! live-streaming-pipeline #f)
  (set! live-streaming-pipelines '())
  (set-live-streaming? #f))


;;;
;;;; Chatbot
;;;


;; twitch token --user-token --scopes "user:read:chat user:write:chat"


(definition BOT_USER_ID
  (world-setting 'twitch.chatbot-userid #f))

(definition CLIENT_ID
  (world-setting 'twitch.chatbot-clientid #f))

(definition CLIENT_SECRET
  (world-setting 'twitch.chatbot-clientsecret #f))

(definition OAUTH_TOKEN
  (world-setting 'twitch.chatbot-token #f))

(definition REFRESH_TOKEN
  (world-setting 'twitch.chatbot-refresh-token #f))

(definition CHAT_CHANNEL_USER_ID
  (world-setting 'twitch.chatbot-channel-userid #f))

(definition chat-commands
  (world-setting 'twitch.chatbot-commands #f))


(definition chatbot-thread
  #f)

(definition chatbot-port
  #f)

(definition chatbot-token
  #f)


(definition (start-chatbot)
  (let ((ctx (make-tls-context)))
    (let ((conn (open-tcp-client (list
                                   address: "eventsub.wss.twitch.tv"
                                   port-number: 443
                                   eol-encoding: 'cr-lf
                                   tls-context: ctx))))
      (let ((thread
              (new-thread
                (lambda ()
                  (let ((token (refresh-token)))
                    (set! chatbot-token token)
                    (format conn "GET /ws HTTP/1.1{%}")
                    (format conn "Host: eventsub.wss.twitch.tv{%}")
                    (format conn "Sec-WebSocket-Version: 13{%}")
                    (format conn "Sec-WebSocket-Key: KsdA5iqIpLtQH8DmsoX6og=={%}")
                    (format conn "Connection: keep-alive, Upgrade{%}")
                    (format conn "Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2{%}")
                    (format conn "Upgrade: websocket{%}")
                    (format conn "{%}")
                    (force-output conn)
                    (let (loop)
                      (let ((line (read-line conn)))
                        (if (equal? line "")
                            (run-chatbot conn)
                          (loop))))))
                'chatbot)))
        (set! chatbot-thread thread)
        (set! chatbot-port conn)
        (thread-start! thread)))))


(definition (stop-chatbot)
  (exit-thread chatbot-thread)
  (close-port chatbot-port)
  (set! chatbot-thread #f)
  (set! chatbot-port #f))


(definition protected (refresh-token)
  (let ((world (current-world)))
    (let ((data (string-append
                  #"grant_type=refresh_token&refresh_token="#
                  REFRESH_TOKEN
                  #"&client_id="#
                  CLIENT_ID
                  #"&client_secret="#
                  CLIENT_SECRET)))
      (let ((port (open-process
                    (list
                      path: "/usr/bin/curl"
                      arguments: (list
                                   "--silent"
                                   "--request" "POST"
                                   ;; -H 'Content-Type: application/x-www-form-urlencoded' \
                                   "--data" data
                                   "https://id.twitch.tv/oauth2/token")))))
        (let ((status (process-status port)))
          (if (= status 0)
              (let ((response (string->json (read-line port))))
                (table-ref response "access_token"))
            (display-error "Unable to connect to twitch")
            #f))))))


(definition (validate-token)
  (let ((world (current-world)))
    (let ((port (open-process
                  (list
                    path: "/usr/bin/curl"
                    arguments: (list
                                 "--silent"
                                 "--request" "GET"
                                 "--header" (string-append "Authorization: OAuth " chatbot-token)
                                 "https://id.twitch.tv/oauth2/validate")))))
      (let ((status (process-status port)))
        (if (= status 0)
            (let ((response (string->json (read-line port))))
              (let ((status (table-ref response "status" #f)))
                (if (and status (/= status 200))
                    (display-error world "Token is not valid"))))
          (display-error "Unable to connect to twitch")
          #f)))))


(definition (read-chatbot conn)
  (let ((frame (read-frame-unsafe 0 conn)))
    (case (get-optype frame)
      ((ping)
       (let ((data (get-payload frame)))
         (write-frame-unsafe 'pong data #t conn))
       #f)
      ((text)
       (let ((payload (get-payload frame)))
         (let ((text (unmask frame)))
           (and (> (u8vector-length text) 0)
                (call-with-input-u8vector (list init: text readtable: json-readtable)
                  (lambda (port)
                    (read-json port)))))))
      (else
       #f))))


(definition (run-chatbot conn)
  (declare (proper-tail-calls))
  (let (loop)
    (let ((json (read-chatbot conn)))
      (when json
        (process-chatbot json)))
    (loop)))


(definition (process-chatbot json)
  (let ((metadata (table-ref json "metadata")))
    (let ((message-type (table-ref metadata "message_type")))
      (cond ((equal? message-type "session_welcome")
             (let ((session-id (table-ref (table-ref (table-ref json "payload") "session") "id")))
               (register-eventsub session-id)))
            ((equal? message-type "session_keepalive"))
            ((equal? message-type "notification")
             (let ((subscription-type (table-ref metadata "subscription_type")))
               (cond ((equal? subscription-type "channel.chat.message")
                      (process-message json)))))))))


(definition (process-message json)
  (let ((event (table-ref (table-ref json "payload") "event")))
    (let ((chatter (table-ref event "chatter_user_login"))
          (message (table-ref (table-ref event "message") "text")))
      (delay-event
        (lambda ()
          (with-task-mutex
            (lambda ()
              (show-chat-message (current-world) chatter 'live message)))))
      (when chat-commands
        (let ((trimmed (trim-whitespace message)))
          (let ((pair (assoc trimmed chat-commands)))
            (when pair
              (let ((message (cdr pair)))
                (send-chat-message message)))))))))


(definition (register-eventsub session-id)
  (let ((world (current-world)))
    (let ((data (string-append
                  #"{"type":"channel.chat.message","version":"1","condition":{"broadcaster_user_id":""#
                  CHAT_CHANNEL_USER_ID
                  #"","user_id":""#
                  BOT_USER_ID
                  #""},"transport":{"method":"websocket","session_id":""#
                  session-id
                  #""}}"#)))
      (let ((port (open-process
                    (list
                      path: "/usr/bin/curl"
                      arguments: (list
                                   "--silent"
                                   "--request" "POST"
                                   "--header" (string-append "Authorization: Bearer " chatbot-token)
                                   "--header" (string-append "Client-Id: " CLIENT_ID)
                                   "--header" "Content-Type: application/json"
                                   "--data" data
                                   "https://api.twitch.tv/helix/eventsub/subscriptions")
                      show-console: #f))))
        (let ((status (process-status port)))
          (if (= status 0)
              (let ((response (string->json (read-line port))))
                (let ((status (table-ref response "status" #f)))
                  (if (and status (/= status 202))
                      (display-error world "Failed to subscribe to channel.chat.message"))))
            (display-error "Unable to connect to twitch")
            #f))))))


(definition protected (send-chat-message message)
  (let ((world (current-world)))
    (let ((data (string-append
                  #"{"broadcaster_id":""#
                  CHAT_CHANNEL_USER_ID
                  #"","sender_id":""#
                  BOT_USER_ID
                  #"","message":""#
                  message
                  #""}"#)))
      (let ((port (open-process
                    (list
                      path: "/usr/bin/curl"
                      arguments: (list
                                   "--silent"
                                   "--request" "POST"
                                   "--header" (string-append "Authorization: Bearer " chatbot-token)
                                   "--header" (string-append "Client-Id: " CLIENT_ID)
                                   "--header" "Content-Type: application/json"
                                   "--data" data
                                   "https://api.twitch.tv/helix/chat/messages")
                      show-console: #f))))
        (let ((status (process-status port)))
          (if (= status 0)
              (let ((response (string->json (read-line port))))
                (let ((status (table-ref response "status" #f)))
                  (if (and status (/= status 200))
                      (display-error world "Failed to send chat message"))))
            (display-error "Unable to connect to twitch")
            #f)))))))
