;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Circles
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.circle jazz


(import (jazz.action)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.markup)
        (jazz.opengl.window)
        (jazz.view)
        (world)
        (world.audio)
        (world.camera)
        (world.client.tier)
        (world.client.udp)
        (world.context)
        (world.devel)
        (world.geometry)
        (world.global)
        (world.hook)
        (world.interface)
        (world.interface.sheet)
        (world.pane)
        (world.scriptum)
        (world.skybox)
        (world.task)
        (world.udp)
        (world.video)
        (world.window)
        (world.zone))


;;;
;;;; Video
;;;


(definition protected (video-outputs)
  (get-ordered-outputs (current-video)))

(definition protected (video-count)
  (length (video-outputs)))


;;;
;;;; Layout
;;;


(definition (active-geometry count)
  (if (eq? video-layout 'focus)
      (focus-geometry count)
    (circle-geometry count)))


(definition (circle-geometry count)
  (let ((target (vertex 0. -2.5 0.)))
    (define (general-formula)
      (let ((c1 (length (circle-positions count))))
        (let ((c2 (* c1 c1))
              (c3 (* c1 c1 c1))
              (c-sq (sqrt c1)))
          (values target
                  (+ (* c-sq 13.) (- (* c1 1.6) (* c2 .004)))
                  (+ (/ 47 c-sq) (* 0.15 c1) (* .001 c2))
                  20.
                  (if (= count c1)
                      5.
                    (if (even? c1)
                        (- 5.2 (* c1 0.013))
                      5.))))))
    
    (case count
      ((0) (values (vertex 0. 0.5 0.) 10.  1. 35.  .521))
      ((1) (values (vertex 0. 0.5 0.) 12.  1. 35.  .521))
      ((2) (values (vertex 0. 0.5 0.) 12.  1. 35.  .521))
      ((3) (values (vertex 0. 1.5 0.) 19.  4. 35. 6.283))
      ((4) (values (vertex 0. -1.8 0.) 40. 14. 20. 4.754))
      ((5) (values (vertex 0. -2.3 0.) 38. 15. 25. 4.95))
      ((6) (values (vertex 0. -2.3 0.) 46. 16. 20. 5.23))
      ((7) (values (vertex 0. -2.3 0.) 44. 13. 26. 4.94))
      (else (general-formula)))))


(definition (focus-geometry count)
  (case count
    ((0)  (values (vertex 0. 19.7 0.) 150.   0.  20. 0.))
    ((1)  (values (vertex 0. 25. 0.)  160.  10.  20. 6.81))
    ((2)  (values (vertex 0. 25. 0.)  160.  10.  20. 6.81))
    ((3)  (values (vertex 0. 25. 0.)  160.   2.  20. 6.28))
    ((4)  (values (vertex 0. 64. 0.)  167. -19.8 20  1.3))
    ((5)  (values (vertex 0. 80. 0.)  164. -27.7 20. 0.))
    ((6)  (values (vertex 0. 75. 0.)  170. -25.  20. 0.2))
    ((7)  (values (vertex 0. 60. 0.)  172. -17.6 20. 0.2))
    ((8)  (values (vertex 0. 60. 0.)  179. -17.2 20. 0.))
    ((9)  (values (vertex 0. 60. 0.)  191. -16.3 20. 0.))
    ((10) (values (vertex 0. 60. 0.)  196. -16.  20. 0.))
    ((11) (values (vertex 0. 60. 0.)  204. -15.5 20. 0.))
    ((12) (values (vertex 0. 53. 0.)  205. -12.  20. 0.))
    ((13) (values (vertex 0. 45. 0.)  206. -8.   20. 0.))
    ((14) (values (vertex 0. 40. 0.)  206. -5.6  20. 0.))
    ((15) (values (vertex 0. 36. 0.)  210. -3.35 20. 0.))
    ((16) (values (vertex 0. 36. 0.)  215. -3.05 20. 0.))
    ((17) (values (vertex 0. 35. 0.)  221. -2.15 20. 0.))
    ((18) (values (vertex 0. 35. 0.)  226. -1.8  20. 0.))
    ((19) (values (vertex 0. 34. 0.)  229. -1.1  20. 0.))
    ((20) (values (vertex 0. 33. 0.)  235. -0.24 20. 0.))
    (else
     (let ((cnt (cast <fl> count)))
       (values (vertex 0. (* cnt (/ 33. 20.)) 0.)
               (* cnt (/ 235. 20.)) 
               (/ cnt 10.)
               20.
               0.)))))


(definition public (circle-update-camera count)
  (receive (target radius elevation fov angle) (active-geometry count)
    (position-camera target radius elevation fov angle)
    (set! camera-angle (normalize-angle angle))))


(definition (calculate-positions count)
  (define (calculate circle-size front-group back-group spacing)
    (assert (= count (+ front-group back-group))
      (let ((pos1 1)
            (pos2 front-group)
            (pos3 (+ front-group 2))
            (pos4 (+ front-group 2 back-group))
            (accumulator 0))
        (map (lambda (n)
               (if (or (and (>= n pos1) (<= n pos2))
                       (and (>= n pos3) (<= n pos4)))
                   (+ n accumulator)
                 (set! accumulator (- accumulator 1))
                 #f))
             (naturals 0 circle-size)))))
  
  (if (eq? video-layout 'focus)
      (focus-positions count)
    (circle-positions count)))


(definition (circle-positions count)
  (case count
    ((1)  (list #f #f #f 0  #f #f))
    ((2)  (list #f #f #f 0  1  #f))
    ((3)  (list #f #f #f 0  1  2  #f #f))
    ((4)  (list #f 0  1  #f 2  3))
    ((5)  (list #f 0  1  2  #f 3  4))
    @w((6)  (list #f 0  1  2  #f 3  4  5))
    ((6)  (list #f 0  1  2  3  #f  4  5))
    ((7)  (list #f 0  1  2  3  #f 4  5  6))
    ((8)  (list #f 0  1  2  3  4  #f 5  6  7))
    @w(
    ((9)  (list #f 0  1  2  3  4  #f 5  6  7  8))
    ((10) (list #f 0  1  2  3  4  5  #f 6  7  8  9))
    ((11) (list #f 0  1  2  3  4  5  6  #f 7  8  9  10))
    ((12) (list #f 0  1  2  3  4  5  6  #f 7  8  9  10  11)))
    (else
     (naturals 0 count))))


(definition (focus-positions count)
  (case count
    ((1 2 3 4) (circle-positions count))
    (else
     (naturals 0 count))))


(definition public (circle-placements count)
  (let ((positions (calculate-positions count)))
    (let ((circle-size (length positions)))
      (collect (lambda (pos)
                 (and pos
                      (let ((rank (find-rank pos positions)))
                        (circle-placement count circle-size rank))))
               positions))))


(definition (circle-placement count circle-size n)
  (cons
    (* 10. (circle-radius circle-size))
    (* (/ PI*2 (cast <fl> circle-size)) (cast <fl> n))))


(definition protected (circle-radius count)
  (/ (cast <fl> count) PI*2))


;;;
;;;; Camera
;;;


(definition protected camera-angle
  2.0)

(definition protected camera-speed
  0.1)

(definition protected camera-tick
  #f)


(definition public (circle-install-camera)
  (let ((window (current-window))
        (zone (current-zone)))
    (unless camera-tick
      (set! camera-tick (lambda (elapse)
                          (with-exception-catcher
                            (lambda (exc)
                              (terminal (exception-reason exc)))
                            (lambda ()
                              (circle-path-camera elapse)))))
      (register-tick zone camera-tick)
      ;; removes tearing in the pathing
      (maybe-enable-vsync window)
      (circle-path-camera 0.))))


(definition public (circle-uninstall-camera)
  (let ((window (current-window))
        (zone (current-zone)))
    (when camera-tick
      (unregister-tick zone camera-tick)
      (maybe-disable-vsync window)
      (set! camera-tick #f))))


(definition (position-camera target radius elevation fov angle)
  (let ((world (current-world)))
    (let ((angle (- PI/2 angle)))
      (let ((x (cos angle))
            (z (sin angle)))
        (let ((flat (vertex+ target (vertex-scalar*& (vertex x 0. z) radius))))
          (let ((pos (vertex+ flat (vertex 0. elevation 0.))))
            (let ((dir (vertex-normalize (vertex-& target pos)))
                  (dir-flat (vertex-normalize (vertex-& target flat))))
              (let ((vert-angle (vector-angle dir dir-flat)))
                (let ((sight dir-flat)
                      (eye (get-eye world))
                      (up (get-world-up world)))
                  (let ((right (cross-product sight up)))
                    (let ((lookat (lookat sight up right)))
                      (set-perspective-fov eye fov)
                      (prepare-projection eye)
                      (free-motion world feedback?: #f)
                      (set-lookat eye (rotate-lookat-vertical& lookat (- vert-angle)))
                      (set-position eye pos)
                      (derive-target eye)
                      (camera-update eye))))))))))))


(definition protected (circle-restore-fov)
  (let ((world (current-world)))
    (let ((eye (get-eye world)))
      (set-perspective-fov eye 45.)
      (prepare-projection eye))))


(definition camera-target-angle
  #f)

(definition camera-target-speed
  #f)


(definition (circle-path-camera elapse)
  (unless sleeping?
    (let ((count (video-count)))
      (when (> count 3)
        (let ((speed (or camera-target-speed camera-speed)))
          (let ((proposed-angle (+ camera-angle (* elapse speed))))
            (when camera-target-angle
              (let ((not-crossing-zero? (< (abs (- camera-angle camera-target-angle)) PI)))
                (let ((normal-proposed (if not-crossing-zero?
                                           proposed-angle
                                         (normalize-angle (+ proposed-angle PI))))
                      (normal-target (if not-crossing-zero?
                                        camera-target-angle
                                      (normalize-angle (+ camera-target-angle PI)))))
                  (when (or (and (> camera-target-speed 0.) (>= normal-proposed normal-target))
                            (and (< camera-target-speed 0.) (<= normal-proposed normal-target)))
                    (circle-uninstall-camera)
                    (set! proposed-angle camera-target-angle)
                    (set! camera-target-angle #f)
                    (set! camera-target-speed #f)))))
            (circle-position-camera count proposed-angle)))))))


(definition (circle-position-camera count new-angle)
  (receive (target radius elevation fov angle) (active-geometry count)
    (position-camera target radius elevation fov new-angle))
  (set! camera-angle (normalize-angle new-angle)))


(definition public (circle-toggle-camera)
  (if camera-tick             
      (circle-uninstall-camera)
    (circle-install-camera)))


(definition public (circle-left-rotation)
  (set! camera-speed (abs camera-speed)))

(definition public (circle-right-rotation)
  (set! camera-speed (* -1 (abs camera-speed))))

(definition public (circle-increase-speed)
  (when (< camera-speed .75)
    (set! camera-speed (* camera-speed 1.5))))

(definition public (circle-decrease-speed)
  (when (> camera-speed .02)
    (set! camera-speed (/ camera-speed 1.5))))


(definition (focused-angle output)
  (let ((ordered-outputs (video-outputs)))
    (let ((count (length ordered-outputs))
          (rank (find-rank output ordered-outputs)))
      (when (> count 3)
        (let ((positions (calculate-positions count)))
          (let ((new-rank (cast <fl> (find-rank rank positions)))
                (circle-size (cast <fl> (length positions))))
            (* PI*2 (/ new-rank circle-size))))))))


(definition public (circle-goto-focus output)
  (let ((count (video-count)))
    (when (> count 3)
      (let ((new-angle (focused-angle output)))
        (circle-position-camera count new-angle)))))


(definition public (circle-switch-focus output (test? #f))
  (if (and speakers-xp? test?)
      (begin
        (change-focused-output (current-video) output)
        (update-interface-matrices (current-video)))
    (when (> (video-count) 3)
      (let ((new-angle (focused-angle output)))
        (let ((not-crossing-zero? (< (abs (- camera-angle new-angle)) PI)))
          (let ((current-angle (if not-crossing-zero?
                                   camera-angle
                                 (normalize-angle (+ camera-angle PI))))
                (target-angle (if not-crossing-zero?
                                  new-angle
                                (normalize-angle (+ new-angle PI)))))
            (if (> target-angle current-angle)
                (set! camera-target-speed 5.)
              (set! camera-target-speed -5.))
            (set! camera-target-angle new-angle)
            (circle-install-camera)))))
    (when (eq? video-layout 'focus)
      (change-focused-output (current-video) output))))


;;;
;;;; View
;;;


(definition protected checkerboard-interface?
  #f)

(definition protected (set-checkerboard-interface? flag)
  (set! checkerboard-interface? flag))


(definition protected debug-media?
  #f)

(definition protected (set-debug-media? flag)
  (set! debug-media? flag))


(class Circle-View extends View
  
  
  (slot output initialize #f accessors generate)
  
  
  (form
    (<install>
      (<Pause-View>  name: stream-pause  position: {Point 10 673} size: {Dimension 40 40} visible?: #f)
      (<Seek-View>   name: stream-seek   position: {Point 70 673} size: {Dimension 250 40} visible?: #f)
      (<Volume-View> name: stream-volume position: {Point 350 673} size: {Dimension 50 40} visible?: #f)
      (<Volume-View> name: volume        position: {Point 1100 673} size: {Dimension 180 40} visible?: #f)))
  
  
  (method protected (update self)
    (when (streaming-channel? self)
      (set-visible? (child self 'stream-pause) #t)
      (set-visible? (child self 'stream-seek) #t)
      (set-visible? (child self 'stream-volume) #t)
      (set-stream? (child self 'stream-volume) #t))
    (update-volume self))
  
  
  (method protected (update-volume self)
    (when (find-audio-ouput self)
      (set-visible? (child self 'volume) #t)))
  
  
  (method (streaming-channel? self)
    (let ((channel (get-channel output)))
      (and channel
           (eq? (get-source-kind (get-stream channel)) 'stream))))
  
  
  (method public (find-audio-ouput self)
    (let ((video-channel (get-channel output)))
      (and video-channel
           (let ((audio-channel (locate-stream-audio-channel (get-stream video-channel))))
             (and audio-channel
                  (find-output (current-audio) (get-no audio-channel)))))))
  
  
  (method override (draw self surface context)
    (let ((video (current-video))
          (audio (current-audio))
          (interface (current-interface))
          (client (current-client))
          (udp (current-udp)))
      (define (determine-output-name output)
        (let ((channel (get-channel output)))
          (if (not channel)
              "Me"
            (let ((stream (get-stream channel)))
              (if (eq? (get-source-kind stream) 'live)
                  (get-sender stream)
                (get-name stream))))))
      
      (define (audio-off? output)
        (if (eq? output (get-self-output video))
            (not (mic-playing? client))
          (let ((audio-output (find-audio-ouput self)))
            (or (not audio-output)
                (eq? (get-stream-state audio-output) 'off)))))
      
      (when checkerboard-interface?
        (set-font surface {Font font-name: tahoma point-size: 18 shadow: thin})
        (loop (for i from 0 below 16)
              (loop (for j from 0 below 9)
                    (let ((h (* i 80))
                          (v (* j 80)))
                      (let ((color (cycle-debug-color!)))
                        (let ((alpha-color (new Color red: (get-red color) green: (get-green color) blue: (get-blue color) alpha: .5)))
                          (fill-rect surface (new Rect h v (+ h 80) (+ v 80)) alpha-color)))
                      (draw-text surface (+ h 22) (+ v 30) (format "{a}, {a}" (+ i 1) (+ j 1)) {Color White})))))
      (when debug-media?
        (set-font surface {Font font-name: tahoma point-size: 32 shadow: thin})
        (let ((channel (or (get-channel output) (get-camera-channel client))))
          (draw-text surface 10 10 (format "{a} #{a}" (reference-name (get-name (class-of output))) (object->serial output)) {Color World-Ochre})
          (when channel
            (let ((stream (get-stream channel)))
              (draw-text surface 10 55 (format "{a} #{a}" (reference-name (get-name (class-of channel))) (object->serial channel)) {Color World-Ochre})
              (draw-text surface 45 100 (format "Sender: {a}" (get-sender stream)) {Color World-Red})
              (draw-text surface 45 145 (format "Name: {a}" (get-name stream)) {Color World-Red})
              (draw-text surface 45 190 (format "Kind: {a}" (get-source-kind stream)) {Color World-Red})
              (draw-text surface 45 235 (format "Resolution: {a}x{a}" (get-width (get-resolution channel)) (get-height (get-resolution channel))) {Color World-Red})
              (draw-text surface 45 280 (format "Framerate: {a}" (get-framerate channel)) {Color World-Red})
              (draw-text surface 45 325 (format "Bitrate: {a}" (get-bitrate channel)) {Color World-Red})))))
      (let ((name (determine-output-name output)))
        (cond ((eq? (get-stream-state output) 'drawn)
               (set-font surface {Font font-name: tahoma point-size: 36 shadow: thin})
               (let ((extent (get-text-extent surface name))
                     (streaming? (streaming-channel? self)))
                 (let ((pos {Point 0 0})
                       (offset (new Point 6 (- 720 (get-height extent) 5))))
                   (let ((h (+ (get-h pos) (get-h offset) (if streaming? 5 0)))
                         (v (+ (get-v pos) (get-v offset) (if streaming? -60 0))))
                     (draw-text surface h v name (if streaming? {Color World-Ochre} {Color White}))
                     (when (audio-off? output)
                       (set-color surface {Color Dark-Red})
                       (set-line-width surface 3)
                       (line surface h (+ v (get-height extent)) (+ h (get-width extent)) v))))))
              (else
               (let ((pos {Point 0 0})
                     (size {Dimension 1280 720})
                     (rect {Rect 0 0 1280 720}))
                 (fill-rect surface (inflate-rect rect -1 -1) {Color red: 30 green: 30 blue: 30 alpha: .7})
                 (frame-rect surface rect {Color Dim-Gray})
                 (set-font surface {Font font-name: tahoma point-size: 48 hint-style: slight hint-metrics: on})
                 (let ((extent (get-text-extent surface name)))
                   (let ((offset (center extent size)))
                     (let ((h (+ (get-h pos) (get-h offset)))
                           (v (+ (get-v pos) (get-v offset))))
                       (draw-text surface h v name {Color White})
                       (when (audio-off? output)
                         (set-color surface {Color Dark-Red})
                         (set-line-width surface 3)
                         (line surface h (+ v (get-height extent)) (+ h (get-width extent)) v)))))))))))
  
  
  (method override (mouse-down self evt)
    (when (memq? video-layout '(circle focus))
      (circle-switch-focus output #t)))
  
  
  (method override (double-click self evt)
    (when (memq? video-layout '(circle focus))
      (circle-switch-focus output #f))))


;;;
;;;; Pause
;;;


(class Pause-View extends View
  
  
  (property paused? initialize #f accessors generate)
  
  
  (method override (draw self surface context)
    (cond (paused?
           (set-color surface {Color White})
           (set-line-width surface 1.5)
           (loop (for n from 0 to 18)
                 (let ((half (- 18 n)))
                   (line surface (+ 16 n) (- 18 half) (+ 16 n) (+ 18 half)))))
          (else
           (fill-rect surface (new Rect 5 0 16 36) {Color White})
           (fill-rect surface (new Rect 24 0 35 36) {Color White}))))
  
  
  (method override (mouse-up self evt)
    (let ((client (current-client)))
      (let ((output (get-output parent)))
        (let ((stream (get-stream (get-channel output))))
          (stream-action client (get-no stream) (if paused? 'play 'pause) '()))))
    (set! paused? (not paused?))
    (invalidate-view self)))


;;;
;;;; Seek
;;;


(class Seek-View extends View
  
  
  (method override (draw self surface context)
    (fill-rect surface (new Rect 0 15 250 21) {Color White})
    (fill-rect surface (new Rect 200 3 206 33) {Color White}))
  
  
  (method override (mouse-down self evt)
    )
  
  
  (method override (mouse-up self evt)
    ))


;;;
;;;; Volume
;;;


(class Volume-View extends View
  
  
  (property stream? initialize #f accessors generate)
  (property muted?  initialize #f accessors generate)
  (property volume  initialize 1. accessors generate)
  
  
  (slot mouse? initialize #f)
  
  
  (method override (draw self surface context)
    (fill-rect surface (new Rect 0 10 16 26) {Color White})
    (set-color surface {Color White})
    (set-line-width surface 1.5)
    (loop (for n from 1 to 10)
          (line surface (+ 16 n) (- 10 n) (+ 16 n) (+ 26 n)))
    (stroke surface)
    (set-line-width surface 4)
    (let ((angle 1.2))
    (arc surface 28 18 10 -1.2 1.2)
    (fill surface)
    (set-line-width surface 5)
    (arc surface 28 18 17 -1.375 1.3)
    (stroke surface))
    (when muted?
      (set-color surface {Color Dark-Red})
      (set-line-width surface 4)
      (line surface 0 36 46 0))
    (unless stream?
      (fill-rect surface (new Rect 60 15 160 21) {Color White})
      (when volume
        (let ((h (+ 60 (fxround (* volume 80.)))))
          (fill-rect surface (new Rect (+ h 10) 15 160 21) {Color red: 160 green: 160 blue: 160})
          (ellipse surface (new Rect h 8 (+ h 20) 28) {Color White} {Color White})))))
  
  
  (method override (mouse-down self evt)
    (let ((h (get-h evt)))
      (when (>= h 56)
        (set! mouse? #t)
        (adjust-muted? self #f)
        (adjust-volume self h))))
  
  
  (method override (mouse-up self evt)
    (let ((h (get-h evt)))
      (when (< h 56)
        (set! mouse? #f)
        (adjust-muted? self (not muted?)))))
  
  
  (method (adjust-muted? self flag)
    (set! muted? flag)
    (if stream?
        (let ((client (current-client)))
          (let ((output (get-output parent)))
            (let ((stream (get-stream (get-channel output))))
              (stream-action client (get-no stream) (if muted? 'mute 'unmute) '()))))
      (let ((audio-output (find-audio-ouput parent)))
        (when audio-output
          (if muted?
              (mute audio-output)
            (unmute audio-output)))))
    (invalidate-view self))
  
  
  (method (adjust-volume self h)
    (let ((vol (/ (cast <fl> (- (max 60 (min 160 h)) 60)) 100.)))
      (set! volume vol)
      (let ((audio-output (find-audio-ouput parent)))
        (when audio-output
          (set-volume audio-output volume)))
      (invalidate-view self)))
  
  
  (method override (drag-move self evt)
    (when (and mouse? (not stream?))
      (adjust-volume self (get-h evt))))))
