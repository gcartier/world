;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Circles
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.circle jazz


(import (jazz.geometry)
        (jazz.opengl.window)
        (jazz.action)
        (world)
        (world.camera)
        (world.context)
        (world.devel)
        (world.interface)
        (world.geometry)
        (world.global)
        (world.hook)
        (world.scriptum)
        (world.skybox)
        (world.task)
        (world.video)
        (world.window)
        (world.zone))


;;;
;;;; Video
;;;


(definition protected (video-outputs)
  (get-ordered-outputs (current-video)))

(definition protected (video-count)
  (length (video-outputs)))


;;;
;;;; Layout
;;;


(definition (active-geometry count)
  (if video-focus?
      (focus-geometry count)
    (circle-geometry count)))


(definition (circle-geometry count)
  (let ((target (vertex 0. -2.5 0.)))
    (define (general-formula)
      (let ((cg-count (length (circle-positions count))))
        (values target
                (- (* 7.2 cg-count) (* .13 (* cg-count cg-count))) 
                (- 21. (* cg-count 0.4))
                20.
                (if (= count cg-count)
                    5.
                  (if (even? cg-count)
                      (- 5.2 (* cg-count 0.013))
                    5.)))))
    
    (case count
      ((0) (values (vertex 0. 0.5 0.) 10.  1. 35.  .521))
      ((1) (values (vertex 0. 0.5 0.) 12.  1. 35.  .521))
      ((2) (values (vertex 0. 0.5 0.) 12.  1. 35.  .521))
      ((3) (values (vertex 0. 1.5 0.) 19.  4. 35. 6.283))
      ((4) (values (vertex 0. -1.8 0.) 40. 14. 20. 4.754))
      ((5) (values (vertex 0. -2.3 0.) 38. 15. 25. 4.95))
      ((6) (values (vertex 0. -2.3 0.) 46. 16. 20. 5.23))
      @w((6) (values (vertex 0. -2.3 0.) 46. 13. 20. 4.76))
      ((7) (values (vertex 0. -2.3 0.) 44. 13. 26. 4.94))
      (else
       (general-formula)))))


(definition (focus-geometry count)
  (case count
    ((0)  (values (vertex 0. 19.7 0.) 150.   0.  20. 0.))
    ((1)  (values (vertex 0. 25. 0.)  160.  10.  20. 6.81))
    ((2)  (values (vertex 0. 25. 0.)  160.  10.  20. 6.81))
    ((3)  (values (vertex 0. 25. 0.)  160.   2.  20. 6.28))
    ((4)  (values (vertex 0. 64. 0.)  167. -19.8 20  1.3))
    ((5)  (values (vertex 0. 80. 0.)  164. -27.7 20. 0.))
    ((6)  (values (vertex 0. 75. 0.)  170. -25.  20. 0.2))
    ((7)  (values (vertex 0. 60. 0.)  172. -17.6 20. 0.2))
    ((8)  (values (vertex 0. 60. 0.)  179. -17.2 20. 0.))
    ((9)  (values (vertex 0. 60. 0.)  191. -16.3 20. 0.))
    ((10) (values (vertex 0. 60. 0.)  196. -16.  20. 0.))
    ((11) (values (vertex 0. 60. 0.)  204. -15.5 20. 0.))
    ((12) (values (vertex 0. 53. 0.)  205. -12.  20. 0.))
    ((13) (values (vertex 0. 45. 0.)  206. -8.   20. 0.))
    ((14) (values (vertex 0. 40. 0.)  206. -5.6  20. 0.))
    ((15) (values (vertex 0. 36. 0.)  210. -3.35 20. 0.))
    ((16) (values (vertex 0. 36. 0.)  215. -3.05 20. 0.))
    ((17) (values (vertex 0. 35. 0.)  221. -2.15 20. 0.))
    ((18) (values (vertex 0. 35. 0.)  226. -1.8  20. 0.))
    ((19) (values (vertex 0. 34. 0.)  229. -1.1  20. 0.))
    ((20) (values (vertex 0. 33. 0.)  235. -0.24 20. 0.))
    (else
     (let ((cnt (cast <fl> count)))
       (values (vertex 0. (* cnt (/ 33. 20.)) 0.)
               (* cnt (/ 235. 20.)) 
               (/ cnt 10.)
               20.
               0.)))))


(definition public (circle-update-camera count)
  (receive (target radius elevation fov angle) (active-geometry count)
    (position-camera target radius elevation fov angle)
    (set! camera-angle (normalize-angle angle))))


(definition (calculate-positions count)
  (define (calculate circle-size front-group back-group spacing)
    (assert (= count (+ front-group back-group))
      (let ((pos1 1)
            (pos2 front-group)
            (pos3 (+ front-group 2))
            (pos4 (+ front-group 2 back-group))
            (accumulator 0))
        (map (lambda (n)
               (if (or (and (>= n pos1) (<= n pos2))
                       (and (>= n pos3) (<= n pos4)))
                   (+ n accumulator)
                 (set! accumulator (- accumulator 1))
                 #f))
             (naturals 0 circle-size)))))
  
  (if video-focus?
      (focus-positions count)
    (circle-positions count)))


(definition (circle-positions count)
  (case count
    ((1)  (list #f #f #f 0  #f #f))
    ((2)  (list #f #f #f 0  1  #f))
    ((3)  (list #f #f #f 0  1  2  #f #f))
    ((4)  (list #f 0  1  #f 2  3))
    ((5)  (list #f 0  1  2  #f 3  4))
    @w((6)  (list #f 0  1  2  #f 3  4  5))
    ((6)  (list #f 0  1  2  3  #f  4  5))
    ((7)  (list #f 0  1  2  3  #f 4  5  6))
    ((8)  (list #f 0  1  2  3  4  #f 5  6  7))
    @w(
    ((9)  (list #f 0  1  2  3  4  #f 5  6  7  8))
    ((10) (list #f 0  1  2  3  4  5  #f 6  7  8  9))
    ((11) (list #f 0  1  2  3  4  5  6  #f 7  8  9  10))
    ((12) (list #f 0  1  2  3  4  5  6  #f 7  8  9  10  11)))
    (else
     (naturals 0 count))))


(definition (focus-positions count)
  (case count
    ((1 2 3 4) (circle-positions count))
    (else
     (naturals 0 count))))


(definition public (circle-placements count)
  (let ((positions (calculate-positions count)))
    (let ((circle-size (length positions)))
      (collect (lambda (pos)
                 (and pos
                      (let ((rank (find-rank pos positions)))
                        (circle-placement count circle-size rank))))
               positions))))


(definition (circle-placement count circle-size n)
  (cons
    (* 10. (circle-radius circle-size))
    (* (/ PI*2 (cast <fl> circle-size)) (cast <fl> n))))


(definition protected (circle-radius count)
  (/ (cast <fl> count) PI*2))


;;;
;;;; Camera
;;;


(definition protected camera-angle
  2.0)

(definition protected camera-speed
  0.1)

(definition protected camera-tick
  #f)


(definition public (circle-install-camera)
  (let ((window (current-window))
        (zone (current-zone)))
    (unless camera-tick
      (set! camera-tick (lambda (elapse)
                          (with-exception-catcher
                            (lambda (exc)
                              (terminal (exception-reason exc)))
                            (lambda ()
                              (circle-path-camera elapse)))))
      (register-tick zone camera-tick)
      ;; removes tearing in the pathing
      (enable-vsync window)
      (circle-path-camera 0.))))


(definition public (circle-uninstall-camera)
  (let ((window (current-window))
        (zone (current-zone)))
    (when camera-tick
      (unregister-tick zone camera-tick)
      (disable-vsync window)
      (set! camera-tick #f))))


(definition (position-camera target radius elevation fov angle)
  (let ((world (current-world)))
    (let ((angle (- PI/2 angle)))
      (let ((x (cos angle))
            (z (sin angle)))
        (let ((flat (vertex+ target (vertex-scalar*& (vertex x 0. z) radius))))
          (let ((pos (vertex+ flat (vertex 0. elevation 0.))))
            (let ((dir (vertex-normalize (vertex-& target pos)))
                  (dir-flat (vertex-normalize (vertex-& target flat))))
              (let ((vert-angle (vector-angle dir dir-flat)))
                (let ((sight dir-flat)
                      (eye (get-eye world))
                      (up (get-world-up world)))
                  (let ((right (cross-product sight up)))
                    (let ((lookat (lookat sight up right)))
                      (set-perspective-fov eye fov)
                      (prepare-projection eye)
                      (free-motion world feedback?: #f)
                      (set-lookat eye (rotate-lookat-vertical& lookat (- vert-angle)))
                      (set-position eye pos)
                      (derive-target eye)
                      (camera-update eye))))))))))))


(definition protected (circle-restore-fov)
  (let ((world (current-world)))
    (let ((eye (get-eye world)))
      (set-perspective-fov eye 45.)
      (prepare-projection eye))))


(definition camera-target-angle
  #f)

(definition camera-target-speed
  #f)


(definition (circle-path-camera elapse)
  (unless sleeping?
    (let ((count (video-count)))
      (when (> count 3)
        (let ((speed (or camera-target-speed camera-speed)))
          (let ((proposed-angle (+ camera-angle (* elapse speed))))
            (when camera-target-angle
              (let ((not-crossing-zero? (< (abs (- camera-angle camera-target-angle)) PI)))
                (let ((normal-proposed (if not-crossing-zero?
                                           proposed-angle
                                         (normalize-angle (+ proposed-angle PI))))
                      (normal-target (if not-crossing-zero?
                                        camera-target-angle
                                      (normalize-angle (+ camera-target-angle PI)))))
                  (when (or (and (> camera-target-speed 0.) (>= normal-proposed normal-target))
                            (and (< camera-target-speed 0.) (<= normal-proposed normal-target)))
                    (circle-uninstall-camera)
                    (set! proposed-angle camera-target-angle)
                    (set! camera-target-angle #f)
                    (set! camera-target-speed #f)))))
            (set! camera-angle (normalize-angle proposed-angle))
            (receive (target radius elevation fov angle) (active-geometry count)
              (position-camera target radius elevation fov camera-angle))))))))


(definition public (circle-toggle-camera)
  (if camera-tick             
      (circle-uninstall-camera)
    (circle-install-camera)))


(definition public (circle-left-rotation)
  (set! camera-speed (abs camera-speed)))

(definition public (circle-right-rotation)
  (set! camera-speed (* -1 (abs camera-speed))))

(definition public (circle-increase-speed)
  (when (< camera-speed .75)
    (set! camera-speed (* camera-speed 1.5))))

(definition public (circle-decrease-speed)
  (when (> camera-speed .02)
    (set! camera-speed (/ camera-speed 1.5))))


(definition public (circle-switch-focus output)
  (let ((ordered-outputs (video-outputs)))
    (let ((count (length ordered-outputs))
          (rank (find-rank output ordered-outputs)))
      (when (> count 3)
        (let ((positions (calculate-positions count)))
          (let ((new-rank (cast <fl> (find-rank rank positions)))
                (circle-size (cast <fl> (length positions))))
            (let ((new-angle (* PI*2 (/ new-rank circle-size))))
              (let ((not-crossing-zero? (< (abs (- camera-angle new-angle)) PI)))
                (let ((current-angle (if not-crossing-zero?
                                         camera-angle
                                       (normalize-angle (+ camera-angle PI))))
                      (target-angle (if not-crossing-zero?
                                        new-angle
                                      (normalize-angle (+ new-angle PI)))))
                  (if (> target-angle current-angle)
                      (set! camera-target-speed 5.)
                    (set! camera-target-speed -5.))
                  (set! camera-target-angle new-angle)
                  (circle-install-camera)))))))
      (when video-focus?
        (change-focused-output (current-video) output)))))

)
