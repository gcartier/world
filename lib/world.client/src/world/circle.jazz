;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Circles
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.circle jazz


(import (jazz.action)
        (jazz.application)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.handler)
        (jazz.io)
        (jazz.markup)
        (jazz.math)
        (jazz.opengl.window)
        (jazz.platform)
        (jazz.stream)
        (jazz.stream.syntax (phase syntax))
        (jazz.text)
        (jazz.ui)
        (jazz.view)
        (world)
        (world.audio)
        (world.camera)
        (world.client.actions)
        (world.client.tier)
        (world.client.udp)
        (world.context)
        (world.devel)
        @bazoo
        (world.entity)
        (world.geometry)
        (world.global)
        (world.hook)
        (world.interface)
        (world.interface.sheet)
        (world.interface.text)
        (world.media)
        (world.pane)
        (world.scriptum)
        (world.settings)
        (world.skybox)
        (world.sound)
        (world.support)
        (world.task)
        (world.time)
        (world.udp)
        (world.video)
        (world.window)
        (world.zone))


(definition package bound-output
  #f)

(definition package (bind-output)
  (set! bound-output #t))

(definition package (unbind-output)
  (set! bound-output #f))


;;;
;;;; Video
;;;


(definition protected (video-outputs)
  (get-ordered-outputs (current-video)))

(definition protected (video-count)
  (length (video-outputs)))


;;;
;;;; Layout
;;;


(definition (active-geometry count)
  (if (eq? video-layout 'focus)
      (focus-geometry count)
    (circle-geometry count)))


(definition (circle-geometry count)
  (let ((target (vertex 0. -2.5 0.)))
    (define (general-formula)
      (let ((c1 (length (circle-positions count))))
        (let ((c2 (* c1 c1))
              (c3 (* c1 c1 c1))
              (c-sq (sqrt c1)))
          (values target
                  (+ (* c-sq 13.) (- (* c1 1.6) (* c2 .004)))
                  (+ (/ 47. c-sq) (* 0.15 c1) (* .001 c2))
                  20.
                  (if (= count c1)
                      5.
                    (if (even? c1)
                        (- 5.2 (* c1 0.013))
                      5.))))))
    
    @bazoo
    (define (general-formula-zone)
      (let ((c1 (length (circle-positions count))))
        (let ((c2 (* c1 c1))
              (c3 (* c1 c1 c1))
              (c-sq (sqrt c1)))
          (values target
                  (+ (* c-sq 7.) (- (* c1 1.6) (* c2 .004)))
                  (+ (/ 35. c-sq) (* 0.15 c1) (* .001 c2))
                  35.
                  (if (= count c1)
                      5.
                    (if (even? c1)
                        (- 5.2 (* c1 0.013))
                      5.))))))
    
    @bazoo
    (general-formula-zone)
    (case count
      ((0) (values (vertex 0. 0.5 0.) 10.  1. 35.  .521))
      ((1) (values (vertex 0. 0.5 0.) 12.  1. 35.  .521))
      ((2) (values (vertex 0. 0.5 0.) 12.  1. 35.  .521))
      ((3) (values (vertex 0. -1.8 0.) 45. 15. 18. 1.58))
      ((4) (values (vertex 0. -1.8 0.) 40. 14. 20. 4.754))
      ((5) (values (vertex 0. -2.3 0.) 38. 15. 25. 4.95))
      ((6) (values (vertex 0. -2.3 0.) 46. 16. 20. 5.14))
      ((7) (values (vertex 0. -2.3 0.) 44. 13. 26. 4.94))
      (else (general-formula)))))


(definition (focus-geometry count)
  (case count
    ((0)  (values (vertex 0. 19.7 0.) 150.   0.  20. 0.))
    ((1)  (values (vertex 0. 25. 0.)  160.  10.  20. 6.81))
    ((2)  (values (vertex 0. 25. 0.)  160.  10.  20. 6.81))
    ((3)  (values (vertex 0. 64. 0.)  167. -19.8 20  1.58))
    ((4)  (values (vertex 0. 64. 0.)  167. -19.8 20  1.3))
    ((5)  (values (vertex 0. 80. 0.)  164. -27.7 20. 0.))
    ((6)  (values (vertex 0. 75. 0.)  170. -25.  20. 0.2))
    ((7)  (values (vertex 0. 60. 0.)  172. -17.6 20. 0.2))
    ((8)  (values (vertex 0. 60. 0.)  179. -17.2 20. 0.))
    ((9)  (values (vertex 0. 60. 0.)  191. -16.3 20. 0.))
    ((10) (values (vertex 0. 60. 0.)  196. -16.  20. 0.))
    ((11) (values (vertex 0. 60. 0.)  204. -15.5 20. 0.))
    ((12) (values (vertex 0. 53. 0.)  205. -12.  20. 0.))
    ((13) (values (vertex 0. 45. 0.)  206. -8.   20. 0.))
    ((14) (values (vertex 0. 40. 0.)  206. -5.6  20. 0.))
    ((15) (values (vertex 0. 36. 0.)  210. -3.35 20. 0.))
    ((16) (values (vertex 0. 36. 0.)  215. -3.05 20. 0.))
    ((17) (values (vertex 0. 35. 0.)  221. -2.15 20. 0.))
    ((18) (values (vertex 0. 35. 0.)  226. -1.8  20. 0.))
    ((19) (values (vertex 0. 34. 0.)  229. -1.1  20. 0.))
    ((20) (values (vertex 0. 33. 0.)  235. -0.24 20. 0.))
    (else
     (let ((cnt (cast <fl> count)))
       (values (vertex 0. (* cnt (/ 33. 20.)) 0.)
               (* cnt (/ 235. 20.)) 
               (/ cnt 10.)
               20.
               0.)))))


(definition public (circle-update-camera count)
  (receive (target radius elevation fov angle) (active-geometry count)
    (position-camera target radius elevation fov angle)
    (set! camera-angle (normalize-angle angle))))


(definition (calculate-positions count)
  (if (eq? video-layout 'focus)
      (focus-positions count)
    (circle-positions count)))


(definition (circle-positions count)
  (case count
    ((1)  '(#f #f #f 0  #f #f))
    ((2)  '(#f #f #f 0  1  #f))
    ((3)  '(#f 0  1  #f (2 . 0.5) #f))
    ((4)  '(#f 0  1  #f 2  3))
    ((5)  '(#f 0  1  2  #f 3  4))
    ((6)  '(#f 0  1  2  3  #f  4  5))
    ((7)  '(#f 0  1  2  3  #f 4  5  6))
    ((8)  '(#f 0  1  2  3  4  #f 5  6  7))
    (else
     (naturals 0 count))))


(definition (focus-positions count)
  (case count
    ((1 2 3 4) (circle-positions count))
    (else
     (naturals 0 count))))


(definition public (circle-placements count)
  (let ((positions (calculate-positions count)))
    (collect (lambda (info)
               (and info
                    (let ((pos (if (pair? info) (car info) info)))
                      (circle-placement pos positions))))
             positions)))


(definition (circle-placement pos positions)
  (let ((circle-size (length positions)))
    (cons
      (* 10. (circle-radius circle-size))
      (calculate-angle pos positions))))


(definition protected (circle-radius count)
  (/ (cast <fl> count) PI*2))


(definition protected (calculate-angle pos positions)
  (let ((rank (find-rank pos positions key: (lambda (info) (if (pair? info) (car info) info)))))
    (let ((info (element positions rank))) 
      (let ((adjustment (if (pair? info) (cdr info) 0.))
            (circle-size (length positions)))
        (let ((slice (/ PI*2 (cast <fl> circle-size))))
          (let ((angle (* slice (cast <fl> rank))))
            (+ angle (* slice adjustment))))))))


;;;
;;;; Camera
;;;


(definition protected camera-angle
  2.0)

(definition protected camera-speed
  0.1)

(definition protected camera-tick
  #f)


(definition public (circle-install-camera)
  (let ((window (current-window))
        (zone (current-zone)))
    (unless camera-tick
      (set! camera-tick (lambda (elapse)
                          (with-exception-catcher
                            (lambda (exc)
                              (terminal (exception-reason exc)))
                            (lambda ()
                              (circle-path-camera elapse)))))
      (register-tick zone camera-tick)
      ;; removes tearing in the pathing
      (maybe-enable-vsync window)
      (circle-path-camera 0.))))


(definition public (circle-uninstall-camera)
  (let ((window (current-window))
        (zone (current-zone)))
    (when camera-tick
      (unregister-tick zone camera-tick)
      (maybe-disable-vsync window)
      (set! camera-tick #f))))


(definition (position-camera target radius elevation fov angle)
  ;; quick hack
  (set! target (vertex+ target (vertex 0. 7. 0.) @bazoo (vertex 0. 3. 0.)))
  (let ((world (current-world)))
    (let ((angle (- PI/2 angle)))
      (let ((x (cos angle))
            (z (sin angle)))
        (let ((flat (vertex+ target (vertex-scalar*& (vertex x 0. z) radius))))
          (let ((pos (vertex+ flat (vertex 0. elevation 0.))))
            (let ((dir (vertex-normalize (vertex-& target pos)))
                  (dir-flat (vertex-normalize (vertex-& target flat))))
              (let ((vert-angle (vector-angle dir dir-flat)))
                (let ((sight dir-flat)
                      (eye (get-eye world))
                      (up (get-world-up world)))
                  (let ((right (cross-product sight up)))
                    (let ((lookat (lookat sight up right)))
                      (set-perspective-fov eye fov)
                      (prepare-projection eye)
                      (free-motion world feedback?: #f)
                      (set-lookat eye (rotate-lookat-vertical& lookat (- vert-angle)))
                      (set-position eye pos @bazoo (vertex+& circle-center pos))
                      (derive-target eye)
                      (camera-update eye))))))))))))


(definition protected (restore-fov)
  (let ((world (current-world)))
    (let ((eye (get-eye world)))
      (set-perspective-fov eye 45.)
      (prepare-projection eye))))


(definition camera-target-angle
  #f)

(definition camera-target-speed
  #f)


(definition (circle-path-camera elapse)
  (unless sleeping?
    (let ((count (video-count)))
      (when (> count circle-max-fixed)
        (let ((speed (or camera-target-speed camera-speed)))
          (let ((proposed-angle (+ camera-angle (* elapse speed))))
            (when camera-target-angle
              (let ((not-crossing-zero? (< (abs (- camera-angle camera-target-angle)) PI)))
                (let ((normal-proposed (if not-crossing-zero?
                                           proposed-angle
                                         (normalize-angle (+ proposed-angle PI))))
                      (normal-target (if not-crossing-zero?
                                        camera-target-angle
                                      (normalize-angle (+ camera-target-angle PI)))))
                  (when (or (and (> camera-target-speed 0.) (>= normal-proposed normal-target))
                            (and (< camera-target-speed 0.) (<= normal-proposed normal-target)))
                    (circle-uninstall-camera)
                    (set! proposed-angle camera-target-angle)
                    (set! camera-target-angle #f)
                    (set! camera-target-speed #f)))))
            (circle-position-camera count proposed-angle)))))))


(definition (circle-position-camera count new-angle)
  (receive (target radius elevation fov angle) (active-geometry count)
    (position-camera target radius elevation fov new-angle))
  (set! camera-angle (normalize-angle new-angle)))


(definition public (circle-toggle-camera)
  (if camera-tick             
      (circle-uninstall-camera)
    (circle-install-camera)))


(definition public (circle-left-rotation)
  (set! camera-speed (* -1 (abs camera-speed))))

(definition public (circle-right-rotation)
  (set! camera-speed (abs camera-speed)))

(definition public (circle-increase-speed)
  (when (< (abs camera-speed) .75)
    (set! camera-speed (* camera-speed 1.5))))

(definition public (circle-decrease-speed)
  (when (> (abs camera-speed) .02)
    (set! camera-speed (/ camera-speed 1.5))))


(definition (focused-angle output)
  (let ((ordered-outputs (video-outputs)))
    (let ((count (length ordered-outputs)))
      (when (> count circle-max-fixed)
        (let ((positions (calculate-positions count))
              (pos (find-rank output ordered-outputs)))
          ;; quick hack until i have time to figure out bug
          (and pos
               (calculate-angle pos positions)))))))


(definition public (circle-goto-focus output)
  (let ((count (video-count)))
    (when (> count circle-max-fixed)
      (let ((new-angle (focused-angle output)))
        ;; quick hack until i have time to figure out bug
        (when new-angle
          (circle-position-camera count new-angle))))))


(definition public (circle-switch-focus output (test? #f))
  (if (and speakers-xp? test?)
      (begin
        (change-focused-output (current-video) output)
        (update-interface-matrices (current-video)))
    (when (> (video-count) circle-max-fixed)
      (let ((new-angle (focused-angle output)))
        ;; quick hack until i have time to figure out bug
        (when new-angle
          (let ((not-crossing-zero? (< (abs (- camera-angle new-angle)) PI)))
            (let ((current-angle (if not-crossing-zero?
                                     camera-angle
                                   (normalize-angle (+ camera-angle PI))))
                  (target-angle (if not-crossing-zero?
                                    new-angle
                                  (normalize-angle (+ new-angle PI)))))
              (if (> target-angle current-angle)
                  (set! camera-target-speed 5.)
                (set! camera-target-speed -5.))
              (set! camera-target-angle new-angle)
              (circle-install-camera))))))
    (change-focused-output (current-video) output)))


(definition public (circle-left)
  (let ((count (video-count)))
    (when (> count circle-max-fixed)
      (circle-left-rotation)
      (circle-install-camera))))


(definition public (circle-right)
  (let ((count (video-count)))
    (when (> count circle-max-fixed)
      (circle-right-rotation)
      (circle-install-camera))))


(definition public (circle-up)
  (let ((count (video-count)))
    (when (> count circle-max-fixed)
      (circle-increase-speed))))


(definition public (circle-down)
  (let ((count (video-count)))
    (when (> count circle-max-fixed)
      (circle-decrease-speed))))


(definition public (circle-return)
  (let ((count (video-count)))
    (when (> count circle-max-fixed)
      (circle-toggle-camera))))


(definition public (circle-backspace)
  (circle-home))


(definition public (circle-home)
  (let ((count (video-count)))
    (circle-uninstall-camera)
    (circle-update-camera count)
    (bind-camera)
    (unbind-output)))


;;;
;;;; Push to talk
;;;


(definition protected push-to-talk-tick
  #f)

(definition protected talking?
  #f)


(definition public (push-to-talk?)
  push-to-talk-tick)


(definition public (toggle-push-to-talk)
  (let ((world (current-world)))
    (if (not push-to-talk-tick)
        (install-push-to-talk)
      (uninstall-push-to-talk))
    (display-on/off world "Push to talk" push-to-talk-tick)))


(definition public (install-push-to-talk)
  (let ((client (current-client))
        (zone (current-zone)))
    (unless push-to-talk-tick
      (set! talking? #f)
      (set! push-to-talk-tick tick-push-to-talk)
      (mute-microphone)
      (register-tick zone push-to-talk-tick)
      (invalidate-self-output client))))


(definition public (uninstall-push-to-talk)
  (let ((client (current-client))
        (zone (current-zone)))
    (when push-to-talk-tick
      (unregister-tick zone push-to-talk-tick)
      (unmute-microphone)
      (set! push-to-talk-tick #f)
      (set! talking? #f)
      (invalidate-self-output client))))


(definition (tick-push-to-talk elapse)
  (when application-active?
    (if (and (null? (modifiers-keys))
             (key-down? #\space))
        (unless talking?
          (play-ambient-sound "warcraft/user/uChatScrollButton" volume: .2)
          (unmute-microphone)
          (set! talking? #t))
      (when talking?
        (play-ambient-sound "warcraft/user/uChatScrollButton" volume: .15)
        (mute-microphone)
        (set! talking? #f)))))


(definition (mute-microphone)
  (let ((client (current-client)))
    (when (mic-on? client)
      (let ((mic-channel (get-mic-channel client)))
        (let ((src (get-src (get-pipeline mic-channel))))
          (mute src))))))


(definition (unmute-microphone)
  (let ((client (current-client)))
    (when (mic-on? client)
      (let ((mic-channel (get-mic-channel client)))
        (let ((src (get-src (get-pipeline mic-channel))))
          (unmute src))))))


;;;
;;;; Circle-Stone
;;;


@bazoo
(class Circle-Stone extends Entity)


;;;
;;;; Checkerboard
;;;


(definition protected checkerboard-interface?
  #f)

(definition protected (set-checkerboard-interface? flag)
  (set! checkerboard-interface? flag))


(definition protected (draw-checkerboard-interface surface (alpha: alpha .5))
  (loop (for i from 0 below 16)
        (loop (for j from 0 below 9)
              (let ((h (* i 80))
                    (v (* j 80)))
                (let ((color (cycle-debug-color!)))
                  (let ((alpha-color (new Color red: (get-red color) green: (get-green color) blue: (get-blue color) alpha: alpha)))
                    (fill-rect surface (new Rect h v (+ h 80) (+ v 80)) alpha-color)))
                (draw-text surface (+ h 22) (+ v 30) (format "{a}, {a}" (+ i 1) (+ j 1)) {Color White})))))


;;;
;;;; Pane
;;;


(class Circle-Pane extends Sheet-Pane
  
  
  (slot output initialize #f accessors generate)
  
  
  ;; quicky
  (hub circle-mode?)
  (hub focus-mode?)
  (method override (mousable? self)
    (and (nextmethod self)
         (let ((together (together:current-together)))
           (or (circle-mode? together)
               (focus-mode? together)))))
  
  
  @COLLABO ;; all this is buggy
  (method override (mousable? self)
    (and (nextmethod self)
         bound-camera?))
  
  
  @COLLABO ;; all this is buggy
  (method override (mousable-down self x y)
    (if (and bound-camera? (memq? video-layout '(circle focus)))
        (when (memq? video-layout '(circle focus))
          (circle-switch-focus output #t))
      (nextmethod self x y)))
  
  
  @COLLABO ;; all this is buggy
  (method override (mousable-double self x y)
    (if (and bound-camera? (memq? video-layout '(circle focus)))
        (when (memq? video-layout '(circle focus))
          (circle-switch-focus output #t))
      (nextmethod self x y)))
  
  
  (method override (mousable-look-at? self)
    #f))


;;;
;;;; View
;;;


(definition protected debug-stream
  #f)

(definition protected (set-debug-stream what)
  (set! debug-stream what))


;; quick solution
(definition protected server-streaming
  (make-table test: equal?))

(definition protected (register-server-streaming location)
  (table-set! server-streaming (filename-name location) #t))

(definition protected (unregister-server-streaming location)
  (table-set! server-streaming (filename-name location)))

(definition protected (server-streaming? name)
  (table-ref server-streaming name #f))


(definition protected (streaming-audio? audio-output)
  (let ((channel (get-channel audio-output)))
    (and channel
         (neq? (get-source-kind channel) 'live))))


(definition protected (unmuted-audios (ignore: ignore #f))
  (let ((audio (current-audio)))
    (collect-if (lambda (audio-output)
                  (and (streaming-audio? audio-output)
                       (not (muted? audio-output))
                       (or (not ignore)
                           (neq? audio-output ignore))))
                (table-values (get-outputs audio)))))


(definition protected (audio->circle-view output)
  (let ((channel (get-channel output)))
    (and channel
         (let ((video-channel (locate-stream-video-channel (get-stream channel))))
           (and video-channel
                (let ((output (find-output (current-video) (get-no video-channel))))
                  (and output
                       (get-root (get-interface-pane output)))))))))


(definition (navigation-bar-color circle-view)
  (if (eq? circle-view (active-focus))
      {Color red: .005 green: .484 blue: .918}
    {Color White}))
      

(interface Circleable
  
  
  (method public virtual abstract (update self output)))


(class Circle-View extends View implements Circleable
  
  
  (slot output initialize #f accessors generate)
  
  
  (form
    (<install>
      (<Pause-View>  name: stream-pause position: {Point 10 673} size: {Dimension 40 40} visible?: #f)
      (<Seek-View>   name: stream-seek  position: {Point 70 673} size: {Dimension 252 40} visible?: #f)
      (<Mute-View>   name: stream-mute  position: {Point 351 673} size: {Dimension 50 40} visible?: #f)
      (<Mute-View>   name: mute         position: {Point 1100 673} size: {Dimension 50 40} visible?: #f)
      (<Volume-View> name: volume       position: {Point 1150 673} size: {Dimension 120 40} visible?: #f)))
  
  
  (method override (focus-actions self)
    (cons (find-actions 'together-circle)
          (nextmethod self)))
  
  
  (method override (update self out)
    (set! output out)
    (set-output (get-player self) out)
    (when (streaming-channel? self)
      (set-visible? (child self 'stream-pause) #t)
      (set-visible? (child self 'stream-seek) #t)
      (setup-seek (child self 'stream-seek) output)
      (set-stream? (child self 'stream-mute) #t))
    (setup-audio self))
  
  
  (method protected (setup-audio self)
    (let ((audio-output (find-audio-output self)))
      (when audio-output
        (when (and (streaming-audio? audio-output)
                   (not-null? (unmuted-audios ignore: audio-output)))
          (mute audio-output)
          (set-muted? (child self 'mute) #t))
        (setup-knob (child self 'volume) (get-volume audio-output))
        (when (not (audio-off? self))
          (when (streaming-channel? self)
            (set-visible? (child self 'stream-mute) #t))
          (set-visible? (child self 'mute) #t)
          (set-visible? (child self 'volume) #t)))))
  
  
  (method protected (invalidate-audio self)
    (let ((audio-output (find-audio-output self)))
      (when audio-output
        (let ((visible? (not (audio-off? self))))
          (when (streaming-channel? self)
            (set-visible? (child self 'stream-mute) visible?))
          (set-visible? (child self 'mute) visible?)
          (set-visible? (child self 'volume) visible?)))))
  
  
  (method (streaming-channel? self)
    (let ((channel (get-channel output)))
      (or (and (is? channel UDP-Receive-Channel)
               (server-streaming? (get-name (get-stream channel))))
          (and (is? channel UDP-Send-Channel)
               (eq? (get-source-kind (get-stream channel)) 'stream)))))
  
  
  (method public (find-audio-output self)
    (let ((video-channel (get-channel output)))
      (and video-channel
           (let ((audio-channel (locate-stream-audio-channel (get-stream video-channel))))
             (and audio-channel
                  (find-output (current-audio) (get-no audio-channel)))))))
  
  
  (method protected (audio-off? self)
    (let ((video (current-video))
          (client (current-client)))
      (if (eq? output (get-self-output video))
          (not (mic-on? client))
        (let ((audio-output (find-audio-output self)))
          (or (not audio-output)
              (eq? (get-stream-state audio-output) 'off))))))
  
  
  (method override (draw self surface context)
    (let ((video (current-video))
          (audio (current-audio))
          (interface (current-interface))
          (client (current-client))
          (udp (current-udp)))
      (let ((channel (get-channel output)))
        (define (determine-output-name output)
          (cond ((not channel)
                 (if (push-to-talk?)
                     "Me (Push to talk)"
                   "Me"))
                ((eq? (get-source-kind channel) 'screen)
                 (if (is? channel UDP-Send-Channel)
                     "You are now sharing your screen"
                   (format "{a}'s screen" (get-sender (get-stream channel)))))
                (else
                 (filename-base (effective-name (get-stream channel))))))
        
        (define (effective-audio-off?)
          (and (audio-off? self)
               (not (and channel
                         (eq? (get-source-kind channel) 'screen)
                         (is? channel UDP-Send-Channel)))))
        
        (when checkerboard-interface?
          (draw-checkerboard-interface surface))
        (let ((name (determine-output-name output)))
          (when (get-stream-disconnected? output)
            (set! name (format "{a} (disconnected)" name)))
          (cond ((eq? (get-stream-state output) 'drawn)
                 (set-font surface {Font font-name: tahoma point-size: 36 shadow: thin})
                 (let ((extent (get-text-extent surface name))
                       (streaming? (streaming-channel? self)))
                   (let ((pos {Point 0 0})
                         (offset (new Point 6 (- 720 (get-height extent) 5))))
                     (let ((h (+ (get-h pos) (get-h offset) (if streaming? 5 0)))
                           (v (+ (get-v pos) (get-v offset) (if streaming? -60 0))))
                       (draw-text surface h v name (if streaming? {Color World-Ochre} {Color White}))
                       (when (effective-audio-off?)
                         (set-color surface {Color Dark-Red})
                         (set-line-width surface 3)
                         (line surface h (+ v (get-height extent)) (+ h (get-width extent)) v))))))
                (else
                 (let ((pos {Point 0 0})
                       (size {Dimension 1280 720})
                       (rect {Rect 0 0 1280 720}))
                   (fill-rect surface (inflate-rect rect -1 -1) {Color red: 30 green: 30 blue: 30 alpha: .7})
                   (frame-rect surface rect {Color Dim-Gray})
                   (set-font surface {Font font-name: tahoma point-size: 48 hint-style: slight hint-metrics: on})
                   (let ((extent (get-text-extent surface name)))
                     (let ((offset (center extent size)))
                       (let ((h (+ (get-h pos) (get-h offset)))
                             (v (+ (get-v pos) (get-v offset))))
                         (draw-text surface h v name {Color White})
                         (when (effective-audio-off?)
                           (set-color surface {Color Dark-Red})
                           (set-line-width surface 3)
                           (line surface h (+ v (get-height extent)) (+ h (get-width extent)) v)))))))))
        (when (and debug-stream video-interface?)
          (let ((rect {Rect 0 0 1280 720}))
            (fill-rect surface rect {Color Black alpha: 0.5}))
          (set-font surface {Font font-name: tahoma point-size: 32 shadow: thin})
          (case debug-stream
            ((media)
             (draw-text surface 10 10 (format "{a} #{a}" (reference-name (get-name (class-of output))) (object->serial output)) {Color World-Ochre})
             (let ((channel (or (get-channel output) (let ((stream (get-live-stream client)))
                                                       (and stream
                                                            (locate-level-channel stream (get-level output)))))))
               (when channel
                 (let ((stream (get-stream channel))
                       (rank 0))
                   (define (draw text color)
                     (let ((h (if (= rank 0) 10 45))
                           (v (+ 55 (* rank 45))))
                       (draw-text surface h v text color)
                       (increase! rank)))
                   
                   (define (present-rate rate)
                     (cond ((not rate)
                            "N/A")
                           ((integer? rate)
                            (->string rate))
                           (else
                            (format "{r precision: 1}" rate))))
                   
                   (draw (format "{a} #{a}" (reference-name (get-name (class-of channel))) (object->serial channel)) {Color World-Ochre})
                   (draw (format "Sender: {a}" (get-sender stream)) {Color World-Red})
                   (draw (format "Name: {a}" (get-name stream)) {Color World-Red})
                   (draw (format "Kind: {a}" (get-source-kind stream)) {Color World-Red})
                   (draw (format "Resolution: {a}x{a}" (get-width (get-resolution channel)) (get-height (get-resolution channel))) {Color World-Red})
                   (draw (format "Framerate: {a}{? ({r precision: 1})~}" (present-rate (get-framerate channel)) (get-frequency (get-rate output))) {Color World-Red})
                   (draw (format "Bitrate: {a}" (present-rate (get-bitrate channel))) {Color World-Red})
                   (when (is? channel UDP-Receive-Channel)
                     (draw (format "Insert: {?{r precision: 1}~}" (get-frequency (get-insert-rate channel))) {Color World-Red})
                     (draw (format "Process: {?{r precision: 1}~}" (get-frequency (get-process-rate channel))) {Color World-Red}))
                   (when (is? channel UDP-Send-Channel)
                     (let ((src (get-src (get-pipeline channel))))
                       (when (is? src Camera-Video-Src)
                         (let ((port (open-output-string)))
                           (for-each (lambda (consumer)
                                       (when (is? consumer Camera-Video-Consumer)
                                         (let ((rate (get-frequency (get-rate consumer))))
                                           (when rate
                                             (format port " {r precision: 1}" rate)))))
                                     (get-sinks src))
                           (let ((rates (get-output-string port)))
                             (draw (format "Send: {a}" rates) {Color World-Red}))))))))))
            ((flow)
             (set-font surface {Font font-name: tahoma point-size: 32 shadow: thin})
             (draw-text surface 10 10 (format "{a} #{a}" (reference-name (get-name (class-of output))) (object->serial output)) {Color World-Ochre})
             (let ((audio-output (find-audio-output self)))
               (when audio-output
                 (let ((monitor (get-monitor audio-output))
                       (rank 0))
                   (define (draw text color)
                     (let ((h (if (= rank 0) 10 45))
                           (v (+ 55 (* rank 45))))
                       (draw-text surface h v text color)
                       (increase! rank)))
                   
                   (draw (format "{a} #{a}" (reference-name (get-name (class-of audio-output))) (object->serial audio-output)) {Color World-Ochre})
                   (draw (format "System clock: {a}" (get-systemclock-name monitor)) {Color World-Orange})
                   (draw (format "Audio clock: {a}" (get-audioclock-name monitor)) {Color World-Orange})
                   (draw (format "Origin rate: {r precision: 4}" (get-originclock-rate monitor)) {Color World-Red})
                   (draw (format "Real rate: {r precision: 4}" (get-realclock-rate monitor)) {Color World-Red})
                   (draw (format "Monotonic rate: {r precision: 4}" (get-monotonicclock-rate monitor)) {Color World-Red})
                   (draw (format "System rate: {r precision: 4}" (get-systemclock-rate monitor)) {Color World-Red})
                   (draw (format "Audio rate: {r precision: 4}" (get-audioclock-rate monitor)) {Color World-Red}))))))))))
  
  
  ;; COLLABO
  (method override (mouse-down self evt)
    (acquire-capture self)
    (acquire-focus self)
    (when (memq? video-layout '(circle focus))
      (circle-switch-focus output #t)))
  
  
  ;; COLLABO
  (method override (double-click self evt)
    (when (memq? video-layout '(circle focus))
      (circle-switch-focus output #t)))
  
  
  ;; COLLABO
  (method override (drag-up self evt . rest)
    (release-capture self))
  
  
  (method override (focus-gained self)
    (nextmethod self)
    (invalidate-view self)
    (invalidate-texture (get-interface-pane output)))
  
  
  (method override (focus-lost self)
    (nextmethod self)
    (invalidate-view self)
    (invalidate-texture (get-interface-pane output)))
  
  
  (method protected (toggle-paused self)
    (let ((pause-view (child self 'stream-pause)))
      (when (get-visible? pause-view)
        (toggle-paused pause-view))))
  
  
  (method protected (seek-backward self)
    (let ((seek-view (child self 'stream-seek)))
      (if (not (get-visible? seek-view))
          (circle-left)
        (let ((pause-view (child self 'stream-pause)))
          (unless (get-paused? pause-view)
            (toggle-paused pause-view)))
        (seek-backward seek-view))))
  
  
  (method protected (seek-forward self)
    (let ((seek-view (child self 'stream-seek)))
      (if (not (get-visible? seek-view))
          (circle-right)
        (let ((pause-view (child self 'stream-pause)))
          (unless (get-paused? pause-view)
            (toggle-paused pause-view)))
        (seek-forward seek-view)))))


(class Together-View-Actions extends World-Actions

  
  (form
    (<install>                                 title: "View"
      (<World-Action-Item> name: toggle-paused title: "Toggle paused" shortcut: {Shortcut Space})
      (<World-Action-Item> name: seek-backward title: "Seek backward" shortcut: {Shortcut Left})
      (<World-Action-Item> name: seek-forward  title: "Seek forward" shortcut: {Shortcut Right}))))


;;;
;;;; Pause
;;;


(class Pause-View extends View
  
  
  (property paused? initialize #f accessors generate)
  
  
  (method override (draw self surface context)
    (cond (paused?
           (set-color surface {Color White})
           (set-line-width surface 1.5)
           (loop (for n from 0 to 18)
                 (let ((half (- 18 n)))
                   (line surface (+ 16 n) (- 18 half) (+ 16 n) (+ 18 half)))))
          (else
           (fill-rect surface (new Rect 5 0 16 36) {Color White})
           (fill-rect surface (new Rect 24 0 35 36) {Color White}))))
  
  
  (method override (mouse-up self evt)
    (toggle-paused self))
  
  
  (method protected (toggle-paused self)
    (set! paused? (not paused?))
    (set-paused? (brother self 'stream-seek) paused?)
    (let ((output (get-output parent)))
      (let ((stream (get-stream (get-channel output)))
            (action (if paused? 'pause 'play)))
        (if (is? stream UDP-Send-Stream)
            (let ((action-proc (get-action-proc stream)))
              (action-proc stream action '()))
          (let ((client (current-client)))
            (let ((stream (get-stream (get-channel output))))
              (stream-action client (get-no stream) action '()))))))
    (invalidate-view self)))


;;;
;;;; Seek
;;;


;; play -> pause     : pause on, seek on
;; pause -> play     : pause off, seek off
;; seek in play      : seek on -> seek -> seek off
;; seek in pause     : pause off -> seek -> pause on
;; navigate in pause : pause off -> navigate -> pause on


(class Seek-View extends View
  
  
  (property seek initialize 0. accessors generate)
  
  
  (slot paused?   initialize #f getter generate)
  (slot tracking? initialize #f getter generate)
  (slot start     initialize #f getter generate)
  (slot end       initialize #f getter generate)
  (slot duration  initialize #f getter generate)
  (slot elapsed   initialize #f getter generate)
  (slot preserved-threshold)
  (slot preserved-sync)
  
  
  (method protected (setup-seek self output)
    (let ((channel (get-channel output)))
      (let ((metadata (get-metadata channel)))
        (let ((start (getf metadata start:))
              (end (getf metadata end:)))
          (when (and start end)
            (let ((duration (- end start)))
              (set! self.start (timestamp->flonum start))
              (set! self.end (timestamp->flonum end))
              (set! self.duration (timestamp->flonum duration))
              (set-seek-callback output
                (lambda (dts)
                  (seek-update self dts)))))))))
  
  
  (method override (draw self surface context)
    (set-line-width surface 3)
    (fill-rect surface (new Rect 1 15 251 21) (navigation-bar-color parent))
    (let ((h (seek->h self seek)))
      (fill-rect surface (new Rect (+ h 10) 15 251 21) {Color red: 160 green: 160 blue: 160})
      (ellipse surface (new Rect (- h 10) 8 (+ h 10) 28) {Color White} {Color White}))
    @wait
    (when elapsed
      (set-font surface {Font font-name: tahoma point-size: 18 shadow: thin})
      (draw-text surface 0 -5 (present-duration elapsed compact?: #t) {Color White})))
  
  
  (method protected (seek->h self s)
    (+ 12 (fxround (* s (- 250. 22.)))))
  
  
  (method protected (seek-update self dts)
    (let ((current-h (seek->h self seek)))
      (set! elapsed (- (timestamp->flonum dts) start))
      (set! seek (/ elapsed duration))
      (when (and video-interface? (/= (seek->h self seek) current-h))
        (invalidate-view self))))
  
  
  (method override (mouse-down self evt)
    (set! tracking? #t)
    (acquire-capture self)
    (acquire-focus parent)
    (if paused?
        (paused-off self)
      (seeking-on self))
    (adjust-seek self (get-h evt)))
  
  
  (method override (drag-move self evt)
    (when tracking?
      (adjust-seek self (get-h evt))))
  
  
  (method override (drag-up self evt . rest)
    (when tracking?
      (invoke-action self 'seek (list #f))
      (if paused?
          (paused-on self)
        (seeking-off self))
      (release-capture self)
      (set! tracking? #f)))
  
  
  (method (adjust-seek self h)
    (let ((range (cast <fl> (max 0 (min 228 (- h 12))))))
      (let ((s (/ range 228.)))
        (when (/= s seek)
          (set! seek s)
          (invoke-action self 'seek (list s))
          (invalidate-view self)))))
  
  
  (method (invoke-action self action arguments)
    (let ((output (get-output parent)))
      (let ((stream (get-stream (get-channel output))))
        (if (is? stream UDP-Send-Stream)
            (let ((action-proc (get-action-proc stream)))
              (action-proc stream action arguments))
          (let ((client (current-client)))
            (stream-action client (get-no stream) action arguments))))))
  
  
  (method protected (set-paused? self flag)
    (set! paused? flag)
    (cond (paused?
           (paused-on self)
           (seeking-on self))
          (else
           (seeking-off self)
           (paused-off self))))
  
  
  (method protected (seek-backward self)
    (when paused?
      (with-playing self
        (lambda ()
          (invoke-action self 'backward '())))))
  
  
  (method protected (seek-forward self)
    (when paused?
      (with-playing self
        (lambda ()
          (invoke-action self 'forward '())))))
  
  
  (method protected (seeking-on self)
    (let ((output (get-output parent)))
      (let ((stream (get-stream (get-channel output))))
        (when (is? stream UDP-Send-Stream)
          ;; no min-threshold-time and no sync during seek
          (with-unref ((queue (gst_bin_get_by_name (get-color-pipeline output) "queue"))
                       (appsink (gst_bin_get_by_name (get-color-pipeline output) "sink")))
            (set! preserved-threshold (g_object_get_uint64 queue "min-threshold-time"))
            (g_object_set_uint64 queue "min-threshold-time" 0)
            (set! preserved-sync (g_object_get_boolean appsink "sync"))
            (g_object_set_boolean appsink "sync" #f))))))
  
  
  (method protected (seeking-off self)
    (let ((output (get-output parent)))
      (let ((stream (get-stream (get-channel output))))
        (when (is? stream UDP-Send-Stream)
          (with-unref ((queue (gst_bin_get_by_name (get-color-pipeline output) "queue"))
                       (appsink (gst_bin_get_by_name (get-color-pipeline output) "sink")))
            (g_object_set_uint64 queue "min-threshold-time" preserved-threshold)
            (g_object_set_boolean appsink "sync" preserved-sync))))))
  
  
  (method (with-playing self thunk)
    (paused-off self)
    (thunk)
    ;; quick hack give a bit of time for frame to be processed
    (sleep .025)
    (paused-on self))
  
  
  (method (paused-on self)
    (let ((output (get-output parent)))
      (let ((stream (get-stream (get-channel output))))
        (when (is? stream UDP-Send-Stream)
          (gst_element_set_state_blocking (get-color-pipeline output) GST_STATE_PAUSED)))))
  
  
  (method (paused-off self)
    (let ((output (get-output parent)))
      (let ((stream (get-stream (get-channel output))))
        (when (is? stream UDP-Send-Stream)
          (gst_element_set_state_blocking (get-color-pipeline output) GST_STATE_PLAYING))))))


;;;
;;;; Mute
;;;


(class Mute-View extends View
  
  
  (property stream? initialize #f accessors generate)
  (property muted?  initialize #f accessors generate)
  
  
  (method override (draw self surface context)
    (fill-rect surface (new Rect 0 10 16 26) {Color White})
    (set-color surface {Color White})
    (set-line-width surface 1.5)
    (loop (for n from 1 to 10)
          (line surface (+ 16 n) (- 10 n) (+ 16 n) (+ 26 n)))
    (stroke surface)
    (set-line-width surface 4)
    (let ((angle 1.2))
    (arc surface 28 18 10 -1.2 1.2)
    (fill surface)
    (set-line-width surface 5)
    (arc surface 28 18 17 -1.375 1.3)
    (stroke surface))
    (when muted?
      (set-color surface {Color Dark-Red})
      (set-line-width surface 4)
      (line surface 0 36 46 0)))
  
  
  (method override (mouse-up self evt)
    (adjust-muted? self (not muted?)))
  
  
  (method protected (adjust-muted? self flag)
    (set! muted? flag)
    (if stream?
        (let ((client (current-client)))
          (let ((output (get-output parent)))
            (let ((stream (get-stream (get-channel output))))
              (stream-action client (get-no stream) (if muted? 'mute 'unmute) '()))))
      (let ((audio-output (find-audio-output parent)))
        (when audio-output
          (if muted?
              (mute audio-output)
            (unless (shift-down?)
              (when (streaming-audio? audio-output)
                (for-each (lambda (output)
                            (mute output)
                            (let ((circle-view (audio->circle-view output)))
                              (when circle-view
                                (let ((mute-view (child circle-view 'mute)))
                                  (set-muted? mute-view #t)
                                  (invalidate-view mute-view)))))
                          (unmuted-audios ignore: audio-output))))
            (unmute audio-output)))))
    (invalidate-view self)))


;;;
;;;; Volume
;;;


(class Volume-View extends View
  
  
  (property knob initialize #f accessors generate)
  
  
  (slot tracking? initialize #f)
  
  
  (method protected (setup-knob self vol)
    (set! knob (- 1. (* (- 1. vol) (- 1. vol)))))
  
  
  (method override (draw self surface context)
    (set-line-width surface 3)
    (fill-rect surface (new Rect 10 15 110 21) (navigation-bar-color parent))
    (when knob
      (let ((h (+ 20 (fxround (* knob 80.)))))
        (fill-rect surface (new Rect (+ h 10) 15 110 21) {Color red: 160 green: 160 blue: 160})
        (ellipse surface (new Rect (- h 10) 8 (+ h 10) 28) {Color White} {Color White}))))
  
  
  (method override (mouse-down self evt)
    (set! tracking? #t)
    (acquire-capture self)
    (acquire-focus parent)
    (adjust-knob self (get-h evt)))
  
  
  (method override (drag-move self evt)
    (when tracking?
      (adjust-knob self (get-h evt))))
  
  
  (method override (drag-up self evt . rest)
    (when tracking?
      (release-capture self)
      (set! tracking? #f)))

  
  (method (adjust-knob self h)
    (let ((mute-view (find-component parent 'mute)))
      (when (and mute-view (get-muted? mute-view))
        (adjust-muted? mute-view #f)))
    (let ((range (cast <fl> (max 0 (min 80 (- h 20))))))
      (set! knob (/ range 80.))
      (let ((audio-output (find-audio-output parent))
            (asymptotic-volume (- 1. (nthroot (- 1. knob) 3.))))
        (when audio-output
          (set-volume audio-output asymptotic-volume)))
      (invalidate-view self))))


;;;
;;;; Text-Panel
;;;


(class Circle-Text-Panel extends Layout-View implements Circleable
  
  
  (form
    (<install>                       layout-type: fill
      (<Circle-Text-View> name: text)))
  
  
  (method override (update self out)
    (set-output (locate self 'text) out)
    (set-output (get-player self) out)))


;;;
;;;; Text-View
;;;


(class Circle-Text-View extends World-Text-View
  
  
  (property output initialize #f accessors generate)
  
  
  (method override (new-model self)
    (new Text-Model wrap?: #t left-padding: 1 top-padding: 1))
    
  
  (method override (install self rest)
    (nextmethod self rest)
    (add-style self 'Entry {Text-Style Text-Base font: {Font font-name: tahoma point-size: 24.5 shadow: thin} color: {Color World-Purple}})
    (set-default-style model {Text-Style Entry}))))
