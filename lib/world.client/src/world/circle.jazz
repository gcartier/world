;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Circles
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.circle jazz


(import (jazz.action)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.markup)
        (jazz.opengl.window)
        (jazz.text)
        (jazz.ui)
        (jazz.view)
        (world)
        (world.audio)
        (world.camera)
        (world.client.tier)
        (world.client.udp)
        (world.context)
        (world.devel)
        (world.geometry)
        (world.global)
        (world.hook)
        (world.interface)
        (world.interface.sheet)
        (world.interface.text)
        (world.pane)
        (world.scriptum)
        (world.skybox)
        (world.task)
        (world.udp)
        (world.video)
        (world.window)
        (world.zone))


(definition package bound-output
  #f)

(definition package (bind-output)
  (set! bound-output #t))

(definition package (unbind-output)
  (set! bound-output #f))


;;;
;;;; Video
;;;


(definition protected (video-outputs)
  (get-ordered-outputs (current-video)))

(definition protected (video-count)
  (length (video-outputs)))


;;;
;;;; Layout
;;;


(definition (active-geometry count)
  (if (eq? video-layout 'focus)
      (focus-geometry count)
    (circle-geometry count)))


(definition (circle-geometry count)
  (let ((target (vertex 0. -2.5 0.)))
    (define (general-formula)
      (let ((c1 (length (circle-positions count))))
        (let ((c2 (* c1 c1))
              (c3 (* c1 c1 c1))
              (c-sq (sqrt c1)))
          (values target
                  (+ (* c-sq 13.) (- (* c1 1.6) (* c2 .004)))
                  (+ (/ 47 c-sq) (* 0.15 c1) (* .001 c2))
                  20.
                  (if (= count c1)
                      5.
                    (if (even? c1)
                        (- 5.2 (* c1 0.013))
                      5.))))))
    
    (case count
      ((0) (values (vertex 0. 0.5 0.) 10.  1. 35.  .521))
      ((1) (values (vertex 0. 0.5 0.) 12.  1. 35.  .521))
      ((2) (values (vertex 0. 0.5 0.) 12.  1. 35.  .521))
      ;;((3) (values (vertex 0. -1.8 0.) 40. 15. 20. 1.92))
      ((3) (values (vertex 0. -2.3 0.) 34. 14. 25. 1.92))
      ((4) (values (vertex 0. -1.8 0.) 40. 14. 20. 4.754))
      ((5) (values (vertex 0. -2.3 0.) 38. 15. 25. 4.95))
      ((6) (values (vertex 0. -2.3 0.) 46. 16. 20. 5.23))
      ((7) (values (vertex 0. -2.3 0.) 44. 13. 26. 4.94))
      (else (general-formula)))))


(definition (focus-geometry count)
  (case count
    ((0)  (values (vertex 0. 19.7 0.) 150.   0.  20. 0.))
    ((1)  (values (vertex 0. 25. 0.)  160.  10.  20. 6.81))
    ((2)  (values (vertex 0. 25. 0.)  160.  10.  20. 6.81))
    ((3)  (values (vertex 0. 64. 0.)  167. -19.8 20  1.3))
    ((4)  (values (vertex 0. 64. 0.)  167. -19.8 20  1.3))
    ((5)  (values (vertex 0. 80. 0.)  164. -27.7 20. 0.))
    ((6)  (values (vertex 0. 75. 0.)  170. -25.  20. 0.2))
    ((7)  (values (vertex 0. 60. 0.)  172. -17.6 20. 0.2))
    ((8)  (values (vertex 0. 60. 0.)  179. -17.2 20. 0.))
    ((9)  (values (vertex 0. 60. 0.)  191. -16.3 20. 0.))
    ((10) (values (vertex 0. 60. 0.)  196. -16.  20. 0.))
    ((11) (values (vertex 0. 60. 0.)  204. -15.5 20. 0.))
    ((12) (values (vertex 0. 53. 0.)  205. -12.  20. 0.))
    ((13) (values (vertex 0. 45. 0.)  206. -8.   20. 0.))
    ((14) (values (vertex 0. 40. 0.)  206. -5.6  20. 0.))
    ((15) (values (vertex 0. 36. 0.)  210. -3.35 20. 0.))
    ((16) (values (vertex 0. 36. 0.)  215. -3.05 20. 0.))
    ((17) (values (vertex 0. 35. 0.)  221. -2.15 20. 0.))
    ((18) (values (vertex 0. 35. 0.)  226. -1.8  20. 0.))
    ((19) (values (vertex 0. 34. 0.)  229. -1.1  20. 0.))
    ((20) (values (vertex 0. 33. 0.)  235. -0.24 20. 0.))
    (else
     (let ((cnt (cast <fl> count)))
       (values (vertex 0. (* cnt (/ 33. 20.)) 0.)
               (* cnt (/ 235. 20.)) 
               (/ cnt 10.)
               20.
               0.)))))


(definition public (circle-update-camera count)
  (receive (target radius elevation fov angle) (active-geometry count)
    (position-camera target radius elevation fov angle)
    (set! camera-angle (normalize-angle angle))))


(definition (calculate-positions count)
  (define (calculate circle-size front-group back-group spacing)
    (assert (= count (+ front-group back-group))
      (let ((pos1 1)
            (pos2 front-group)
            (pos3 (+ front-group 2))
            (pos4 (+ front-group 2 back-group))
            (accumulator 0))
        (map (lambda (n)
               (if (or (and (>= n pos1) (<= n pos2))
                       (and (>= n pos3) (<= n pos4)))
                   (+ n accumulator)
                 (set! accumulator (- accumulator 1))
                 #f))
             (naturals 0 circle-size)))))
  
  (if (eq? video-layout 'focus)
      (focus-positions count)
    (circle-positions count)))


(definition (circle-positions count)
  (case count
    ((1)  (list #f #f #f 0  #f #f))
    ((2)  (list #f #f #f 0  1  #f))
    @w((3)  (list #f #f #f 0  1  2  #f #f))
    ((3)  (list #f 0  1  #f   2))
    ((4)  (list #f 0  1  #f 2  3))
    ((5)  (list #f 0  1  2  #f 3  4))
    @w((6)  (list #f 0  1  2  #f 3  4  5))
    ((6)  (list #f 0  1  2  3  #f  4  5))
    ((7)  (list #f 0  1  2  3  #f 4  5  6))
    ((8)  (list #f 0  1  2  3  4  #f 5  6  7))
    @w(
    ((9)  (list #f 0  1  2  3  4  #f 5  6  7  8))
    ((10) (list #f 0  1  2  3  4  5  #f 6  7  8  9))
    ((11) (list #f 0  1  2  3  4  5  6  #f 7  8  9  10))
    ((12) (list #f 0  1  2  3  4  5  6  #f 7  8  9  10  11)))
    (else
     (naturals 0 count))))


(definition (focus-positions count)
  (case count
    ((1 2 3 4) (circle-positions count))
    (else
     (naturals 0 count))))


(definition public (circle-placements count)
  (let ((positions (calculate-positions count)))
    (let ((circle-size (length positions)))
      (collect (lambda (pos)
                 (and pos
                      (let ((rank (find-rank pos positions)))
                        (circle-placement count circle-size rank))))
               positions))))


(definition (circle-placement count circle-size n)
  (cons
    (* 10. (circle-radius circle-size))
    (* (/ PI*2 (cast <fl> circle-size)) (cast <fl> n))))


(definition protected (circle-radius count)
  (/ (cast <fl> count) PI*2))


;;;
;;;; Camera
;;;


(definition protected camera-angle
  2.0)

(definition protected camera-speed
  0.1)

(definition protected camera-tick
  #f)


(definition public (circle-install-camera)
  (let ((window (current-window))
        (zone (current-zone)))
    (unless camera-tick
      (set! camera-tick (lambda (elapse)
                          (with-exception-catcher
                            (lambda (exc)
                              (terminal (exception-reason exc)))
                            (lambda ()
                              (circle-path-camera elapse)))))
      (register-tick zone camera-tick)
      ;; removes tearing in the pathing
      (maybe-enable-vsync window)
      (circle-path-camera 0.))))


(definition public (circle-uninstall-camera)
  (let ((window (current-window))
        (zone (current-zone)))
    (when camera-tick
      (unregister-tick zone camera-tick)
      (maybe-disable-vsync window)
      (set! camera-tick #f))))


(definition (position-camera target radius elevation fov angle)
  (let ((world (current-world)))
    (let ((angle (- PI/2 angle)))
      (let ((x (cos angle))
            (z (sin angle)))
        (let ((flat (vertex+ target (vertex-scalar*& (vertex x 0. z) radius))))
          (let ((pos (vertex+ flat (vertex 0. elevation 0.))))
            (let ((dir (vertex-normalize (vertex-& target pos)))
                  (dir-flat (vertex-normalize (vertex-& target flat))))
              (let ((vert-angle (vector-angle dir dir-flat)))
                (let ((sight dir-flat)
                      (eye (get-eye world))
                      (up (get-world-up world)))
                  (let ((right (cross-product sight up)))
                    (let ((lookat (lookat sight up right)))
                      (set-perspective-fov eye fov)
                      (prepare-projection eye)
                      (free-motion world feedback?: #f)
                      (set-lookat eye (rotate-lookat-vertical& lookat (- vert-angle)))
                      (set-position eye pos)
                      (derive-target eye)
                      (camera-update eye))))))))))))


(definition protected (circle-restore-fov)
  (let ((world (current-world)))
    (let ((eye (get-eye world)))
      (set-perspective-fov eye 45.)
      (prepare-projection eye))))


(definition camera-target-angle
  #f)

(definition camera-target-speed
  #f)


(definition (circle-path-camera elapse)
  (unless sleeping?
    (let ((count (video-count)))
      (when (> count circle-max-fixed)
        (let ((speed (or camera-target-speed camera-speed)))
          (let ((proposed-angle (+ camera-angle (* elapse speed))))
            (when camera-target-angle
              (let ((not-crossing-zero? (< (abs (- camera-angle camera-target-angle)) PI)))
                (let ((normal-proposed (if not-crossing-zero?
                                           proposed-angle
                                         (normalize-angle (+ proposed-angle PI))))
                      (normal-target (if not-crossing-zero?
                                        camera-target-angle
                                      (normalize-angle (+ camera-target-angle PI)))))
                  (when (or (and (> camera-target-speed 0.) (>= normal-proposed normal-target))
                            (and (< camera-target-speed 0.) (<= normal-proposed normal-target)))
                    (circle-uninstall-camera)
                    (set! proposed-angle camera-target-angle)
                    (set! camera-target-angle #f)
                    (set! camera-target-speed #f)))))
            (circle-position-camera count proposed-angle)))))))


(definition (circle-position-camera count new-angle)
  (receive (target radius elevation fov angle) (active-geometry count)
    (position-camera target radius elevation fov new-angle))
  (set! camera-angle (normalize-angle new-angle)))


(definition public (circle-toggle-camera)
  (if camera-tick             
      (circle-uninstall-camera)
    (circle-install-camera)))


(definition public (circle-left-rotation)
  (set! camera-speed (abs camera-speed)))

(definition public (circle-right-rotation)
  (set! camera-speed (* -1 (abs camera-speed))))

(definition public (circle-increase-speed)
  (when (< camera-speed .75)
    (set! camera-speed (* camera-speed 1.5))))

(definition public (circle-decrease-speed)
  (when (> camera-speed .02)
    (set! camera-speed (/ camera-speed 1.5))))


(definition (focused-angle output)
  (let ((ordered-outputs (video-outputs)))
    (let ((count (length ordered-outputs))
          (rank (find-rank output ordered-outputs)))
      (when (> count circle-max-fixed)
        (let ((positions (calculate-positions count)))
          (let ((new-rank (cast <fl> (find-rank rank positions)))
                (circle-size (cast <fl> (length positions))))
            (* PI*2 (/ new-rank circle-size))))))))


(definition public (circle-goto-focus output)
  (let ((count (video-count)))
    (when (> count circle-max-fixed)
      (let ((new-angle (focused-angle output)))
        (circle-position-camera count new-angle)))))


(definition public (circle-switch-focus output (test? #f))
  (if (and speakers-xp? test?)
      (begin
        (change-focused-output (current-video) output)
        (update-interface-matrices (current-video)))
    (when (> (video-count) circle-max-fixed)
      (let ((new-angle (focused-angle output)))
        (let ((not-crossing-zero? (< (abs (- camera-angle new-angle)) PI)))
          (let ((current-angle (if not-crossing-zero?
                                   camera-angle
                                 (normalize-angle (+ camera-angle PI))))
                (target-angle (if not-crossing-zero?
                                  new-angle
                                (normalize-angle (+ new-angle PI)))))
            (if (> target-angle current-angle)
                (set! camera-target-speed 5.)
              (set! camera-target-speed -5.))
            (set! camera-target-angle new-angle)
            (circle-install-camera)))))
    (change-focused-output (current-video) output)))


;;;
;;;; Checkerboard
;;;


(definition protected checkerboard-interface?
  #f)

(definition protected (set-checkerboard-interface? flag)
  (set! checkerboard-interface? flag))


(definition protected (draw-checkerboard-interface surface)
  (set-font surface {Font font-name: tahoma point-size: 18 shadow: thin})
  (loop (for i from 0 below 16)
        (loop (for j from 0 below 9)
              (let ((h (* i 80))
                    (v (* j 80)))
                (let ((color (cycle-debug-color!)))
                  (let ((alpha-color (new Color red: (get-red color) green: (get-green color) blue: (get-blue color) alpha: .5)))
                    (fill-rect surface (new Rect h v (+ h 80) (+ v 80)) alpha-color)))
                (draw-text surface (+ h 22) (+ v 30) (format "{a}, {a}" (+ i 1) (+ j 1)) {Color White})))))


;;;
;;;; Pane
;;;


(class Circle-Pane extends Sheet-Pane
  
  
  (slot output initialize #f accessors generate)
  
  
  @COLLABO ;; all this is buggy
  (method override (mousable? self)
    (and (nextmethod self)
         bound-camera?))
  
  
  @COLLABO ;; all this is buggy
  (method override (mousable-down self x y)
    (if (and bound-camera? (memq? video-layout '(circle focus)))
        (when (memq? video-layout '(circle focus))
          (circle-switch-focus output #t))
      (nextmethod self x y)))
  
  
  @COLLABO ;; all this is buggy
  (method override (mousable-double self x y)
    (if (and bound-camera? (memq? video-layout '(circle focus)))
        (when (memq? video-layout '(circle focus))
          (circle-switch-focus output #t))
      (nextmethod self x y))))


;;;
;;;; View
;;;


(definition protected debug-media?
  #f)

(definition protected (set-debug-media? flag)
  (set! debug-media? flag))


(interface Circleable
  
  
  (method public virtual abstract (update self output)))


(class Circle-View extends View implements Circleable
  
  
  (slot output initialize #f accessors generate)
  
  
  (form
    (<install>
      (<Pause-View>  name: stream-pause position: {Point 10 673} size: {Dimension 40 40} visible?: #f)
      (<Seek-View>   name: stream-seek  position: {Point 70 673} size: {Dimension 250 40} visible?: #f)
      (<Mute-View>   name: stream-mute  position: {Point 350 673} size: {Dimension 50 40} visible?: #f)
      (<Mute-View>   name: mute         position: {Point 1100 673} size: {Dimension 50 40} visible?: #f)
      (<Volume-View> name: volume       position: {Point 1150 673} size: {Dimension 120 40} visible?: #f)))
  
  
  (method override (update self out)
    (set! output out)
    (set-output (get-player self) out)
    (when (streaming-channel? self)
      (set-visible? (child self 'stream-pause) #t)
      (set-visible? (child self 'stream-seek) #t)
      (set-visible? (child self 'stream-mute) #t)
      (set-stream? (child self 'stream-mute) #t))
    (setup-audio self))
  
  
  (method protected (setup-audio self)
    (let ((audio-output (find-audio-output self)))
      (when audio-output
        (setup-knob (child self 'volume) (get-volume audio-output))
        (when (not (audio-off? self))
          (set-visible? (child self 'mute) #t)
          (set-visible? (child self 'volume) #t)))))
  
  
  (method protected (invalidate-audio self)
    (let ((audio-output (find-audio-output self)))
      (when audio-output
        (let ((visible? (not (audio-off? self))))
          (set-visible? (child self 'mute) visible?)
          (set-visible? (child self 'volume) visible?)))))
  
  
  (method (streaming-channel? self)
    (let ((channel (get-channel output)))
      (and (is? channel UDP-Send-Channel)
           (eq? (get-source-kind (get-stream channel)) 'stream))))
  
  
  (method public (find-audio-output self)
    (let ((video-channel (get-channel output)))
      (and video-channel
           (let ((audio-channel (locate-stream-audio-channel (get-stream video-channel))))
             (and audio-channel
                  (find-output (current-audio) (get-no audio-channel)))))))
  
  
  (method protected (audio-off? self)
    (let ((video (current-video))
          (client (current-client)))
      (if (eq? output (get-self-output video))
          (not (mic-playing? client))
        (let ((audio-output (find-audio-output self)))
          (or (not audio-output)
              (eq? (get-stream-state audio-output) 'off))))))
  
  
  (method override (draw self surface context)
    (let ((video (current-video))
          (audio (current-audio))
          (interface (current-interface))
          (client (current-client))
          (udp (current-udp)))
      (define (determine-output-name output)
        (let ((channel (get-channel output)))
          (if (not channel)
              "Me"
            (effective-name (get-stream channel)))))
      
      (when checkerboard-interface?
        (draw-checkerboard-interface surface))
      (let ((name (determine-output-name output)))
        (cond ((eq? (get-stream-state output) 'drawn)
               (set-font surface {Font font-name: tahoma point-size: 36 shadow: thin})
               (let ((extent (get-text-extent surface name))
                     (streaming? (streaming-channel? self)))
                 (let ((pos {Point 0 0})
                       (offset (new Point 6 (- 720 (get-height extent) 5))))
                   (let ((h (+ (get-h pos) (get-h offset) (if streaming? 5 0)))
                         (v (+ (get-v pos) (get-v offset) (if streaming? -60 0))))
                     (draw-text surface h v name (if streaming? {Color World-Ochre} {Color White}))
                     (when (audio-off? self)
                       (set-color surface {Color Dark-Red})
                       (set-line-width surface 3)
                       (line surface h (+ v (get-height extent)) (+ h (get-width extent)) v))))))
              (else
               (let ((pos {Point 0 0})
                     (size {Dimension 1280 720})
                     (rect {Rect 0 0 1280 720}))
                 (fill-rect surface (inflate-rect rect -1 -1) {Color red: 30 green: 30 blue: 30 alpha: .7})
                 (frame-rect surface rect {Color Dim-Gray})
                 (set-font surface {Font font-name: tahoma point-size: 48 hint-style: slight hint-metrics: on})
                 (let ((extent (get-text-extent surface name)))
                   (let ((offset (center extent size)))
                     (let ((h (+ (get-h pos) (get-h offset)))
                           (v (+ (get-v pos) (get-v offset))))
                       (draw-text surface h v name {Color White})
                       (when (audio-off? self)
                         (set-color surface {Color Dark-Red})
                         (set-line-width surface 3)
                         (line surface h (+ v (get-height extent)) (+ h (get-width extent)) v)))))))))
      (when (and debug-media? video-interface?)
        (set-font surface {Font font-name: tahoma point-size: 32 shadow: thin})
        (draw-text surface 10 10 (format "{a} #{a}" (reference-name (get-name (class-of output))) (object->serial output)) {Color World-Ochre})
        (let ((channel (or (get-channel output) (let ((stream (get-live-stream client)))
                                                  (and stream
                                                       (locate-level-channel stream (get-level output)))))))
          (when channel
            (let ((stream (get-stream channel)))
              (define (draw rank text color)
                (let ((h (if (= rank 0) 10 45))
                      (v (+ 55 (* rank 45))))
                  (draw-text surface h v text color)))
              
              (draw 0 (format "{a} #{a}" (reference-name (get-name (class-of channel))) (object->serial channel)) {Color World-Ochre})
              (draw 1 (format "Sender: {a}" (get-sender stream)) {Color World-Red})
              (draw 2 (format "Name: {a}" (get-name stream)) {Color World-Red})
              (draw 3 (format "Kind: {a}" (get-source-kind stream)) {Color World-Red})
              (draw 4 (format "Resolution: {a}x{a}" (get-width (get-resolution channel)) (get-height (get-resolution channel))) {Color World-Red})
              (draw 5 (format "Framerate: {a}" (get-framerate channel)) {Color World-Red})
              (draw 6 (format "Bitrate: {a}" (get-bitrate channel)) {Color World-Red})))))))
  
  
  ;; COLLABO
  (method override (mouse-down self evt)
    (acquire-capture self)
    (when (memq? video-layout '(circle focus))
      (circle-switch-focus output #t)))
  
  
  ;; COLLABO
  (method override (double-click self evt)
    (when (memq? video-layout '(circle focus))
      (circle-switch-focus output #t)))
  
  
  ;; COLLABO
  (method override (drag-up self evt . rest)
    (release-capture self)))


;;;
;;;; Pause
;;;


(class Pause-View extends View
  
  
  (property paused? initialize #f accessors generate)
  
  
  (method override (draw self surface context)
    (cond (paused?
           (set-color surface {Color White})
           (set-line-width surface 1.5)
           (loop (for n from 0 to 18)
                 (let ((half (- 18 n)))
                   (line surface (+ 16 n) (- 18 half) (+ 16 n) (+ 18 half)))))
          (else
           (fill-rect surface (new Rect 5 0 16 36) {Color White})
           (fill-rect surface (new Rect 24 0 35 36) {Color White}))))
  
  
  (method override (mouse-up self evt)
    (let ((client (current-client)))
      (let ((output (get-output parent)))
        (let ((stream (get-stream (get-channel output))))
          (stream-action client (get-no stream) (if paused? 'play 'pause) '()))))
    (set! paused? (not paused?))
    (invalidate-view self)))


;;;
;;;; Seek
;;;


(class Seek-View extends View
  
  
  (property seek initialize 0. accessors generate)
  
  
  (slot tracking? initialize #f)
  
  
  (method override (draw self surface context)
    (fill-rect surface (new Rect 0 15 250 21) {Color White})
    (let ((h (+ 3 (fxround (* seek (- 250. 6.))))))
      (fill-rect surface (new Rect (- h 3) 3 (+ h 3) 33) {Color White})
      (fill-rect surface (new Rect (+ h 3) 15 250 21) {Color red: 160 green: 160 blue: 160})))
  
  
  (method override (mouse-down self evt)
    (set! tracking? #t)
    (acquire-capture self)
    (adjust-seek self (get-h evt)))
  
  
  (method override (drag-move self evt)
    (when tracking?
      (adjust-seek self (get-h evt))))
  
  
  (method override (drag-up self evt . rest)
    (when tracking?
      (release-capture self)
      (set! tracking? #f)))
  
  
  (method (adjust-seek self h)
    (let ((s (/ (cast <fl> (- (max 0 (min 250 h)) 0)) 250.)))
      (set! seek s)
      (let ((client (current-client)))
        (let ((output (get-output parent)))
          (let ((stream (get-stream (get-channel output))))
            (stream-action client (get-no stream) 'seek (list s)))))
      (invalidate-view self))))


;;;
;;;; Mute
;;;


(class Mute-View extends View
  
  
  (property stream? initialize #f accessors generate)
  (property muted?  initialize #f accessors generate)
  
  
  (method override (draw self surface context)
    (fill-rect surface (new Rect 0 10 16 26) {Color White})
    (set-color surface {Color White})
    (set-line-width surface 1.5)
    (loop (for n from 1 to 10)
          (line surface (+ 16 n) (- 10 n) (+ 16 n) (+ 26 n)))
    (stroke surface)
    (set-line-width surface 4)
    (let ((angle 1.2))
    (arc surface 28 18 10 -1.2 1.2)
    (fill surface)
    (set-line-width surface 5)
    (arc surface 28 18 17 -1.375 1.3)
    (stroke surface))
    (when muted?
      (set-color surface {Color Dark-Red})
      (set-line-width surface 4)
      (line surface 0 36 46 0)))
  
  
  (method override (mouse-up self evt)
    (adjust-muted? self (not muted?)))
  
  
  (method protected (adjust-muted? self flag)
    (set! muted? flag)
    (if stream?
        (let ((client (current-client)))
          (let ((output (get-output parent)))
            (let ((stream (get-stream (get-channel output))))
              (stream-action client (get-no stream) (if muted? 'mute 'unmute) '()))))
      (let ((audio-output (find-audio-output parent)))
        (when audio-output
          (if muted?
              (mute audio-output)
            (unmute audio-output)))))
    (invalidate-view self)))


;;;
;;;; Volume
;;;


(class Volume-View extends View
  
  
  (property knob initialize #f accessors generate)
  
  
  (slot tracking? initialize #f)
  
  
  (method protected (setup-knob self vol)
    (set! knob (- 1. (* (- 1. vol) (- 1. vol)))))
  
  
  (method override (draw self surface context)
    (fill-rect surface (new Rect 10 15 110 21) {Color White})
    (when knob
      (let ((h (+ 20 (fxround (* knob 80.)))))
        (fill-rect surface (new Rect (+ h 10) 15 110 21) {Color red: 160 green: 160 blue: 160})
        (ellipse surface (new Rect (- h 10) 8 (+ h 10) 28) {Color White} {Color White}))))
  
  
  (method override (mouse-down self evt)
    (set! tracking? #t)
    (acquire-capture self)
    (adjust-knob self (get-h evt)))
  
  
  (method override (drag-move self evt)
    (when tracking?
      (adjust-knob self (get-h evt))))
  
  
  (method override (drag-up self evt . rest)
    (when tracking?
      (release-capture self)
      (set! tracking? #f)))

  
  (method (adjust-knob self h)
    (let ((mute-view (find-component parent 'mute)))
      (when (and mute-view (get-muted? mute-view))
        (adjust-muted? mute-view #f)))
    (let ((range (cast <fl> (max 0 (min 80 (- h 20))))))
      (set! knob (/ range 80.))
      (let ((audio-output (find-audio-output parent))
            (asymptotic-volume (- 1. (sqrt (- 1. knob)))))
        (when audio-output
          (set-volume audio-output asymptotic-volume)))
      (invalidate-view self))))


;;;
;;;; Text-Panel
;;;


(class Circle-Text-Panel extends Layout-View implements Circleable
  
  
  (form
    (<install>                       layout-type: fill
      (<Circle-Text-View> name: text)))
  
  
  (method override (update self out)
    (set-output (locate self 'text) out)
    (set-output (get-player self) out)))


;;;
;;;; Text-View
;;;


(class Circle-Text-View extends World-Text-View
  
  
  (property output initialize #f accessors generate)
  
  
  (method override (new-model self)
    (new Text-Model wrap?: #t left-padding: 1 top-padding: 1))
    
  
  (method override (install self rest)
    (nextmethod self rest)
    (add-style self 'Entry {Text-Style Text-Base font: {Font font-name: tahoma point-size: 24.5 shadow: thin} color: {Color World-Purple}})
    (set-default-style model {Text-Style Entry}))))
