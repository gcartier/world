;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Circles
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.circle jazz


(import (jazz.action)
        (jazz.application)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.handler)
        (jazz.io)
        (jazz.markup)
        (jazz.math)
        (jazz.opengl.window)
        (jazz.platform)
        (jazz.stream)
        (jazz.stream.syntax (phase syntax))
        (jazz.text)
        (jazz.ui)
        (jazz.view)
        (gaea.geometry)
        (world)
        (world.audio)
        (world.camera)
        (world.client.actions)
        (world.client.tier)
        (world.client.udp)
        (world.colors)
        (world.context)
        (world.devel)
        (world.entity)
        (world.global)
        (world.hook)
        (world.interface)
        (world.interface.sheet)
        (world.interface.text)
        (world.media)
        (world.pane)
        (world.scriptum)
        (world.settings)
        (world.skybox)
        (world.sound)
        (world.support)
        (world.task)
        (world.time)
        (world.udp)
        (world.video)
        (world.window)
        (world.zone))


(definition protected current-circle-shape
  @w 'round
  'hybrid
  @w 'heart
  @w 'theater)

(definition protected (set-current-circle-shape shape)
  (set! current-circle-shape shape)
  (update-layouts (current-video)))

(definition protected (circle-refresh-shape)
  (update-layouts (current-video)))


;;;
;;;; Video
;;;


(definition protected (video-outputs)
  (get-ordered-outputs (current-video)))

(definition protected (video-count)
  (length (video-outputs)))


;;;
;;;; Layout
;;;


(definition (active-camera-position count)
  (case video-layout
    ((focus)
     (focus-camera-position count))
    (else
     (case current-circle-shape
       ((round)
        (round-camera-position count))
       ((hybrid)
        (hybrid-camera-position count))
       ((heart)
        (heart-camera-position count))
       ((theater)
        (theater-camera-position count))))))


(definition public (circle-update-camera count (smooth? #f))
  (let ((info (active-camera-position count)))
    (if (pair? info)
        (bind (position lookat) info
          (if smooth?
              (aim-at (vertex+ circle-center position) (get-sight lookat))
            (position-camera position lookat)))
      (receive (target radius elevation fov angle) info
        (position-camera-around target radius elevation fov angle)
        (set! camera-angle (normalize-angle angle))))))


(definition (calculate-positions count)
  (if (eq? video-layout 'focus)
      (focus-positions count)
    (circle-positions count)))


(definition (circle-positions count)
  (case count
    ((1)  '(#f #f #f 0  #f #f))
    ((2)  '(#f #f #f 0  1  #f))
    ((3)  '(#f 0  1  #f (2 . 0.5) #f))
    ((4)  '(#f 0  1  #f 2  3))
    ((5)  '(#f 0  1  2  #f 3  4))
    ((6)  '(#f 0  1  2  3  #f  4  5))
    ((7)  '(#f 0  1  2  3  #f 4  5  6))
    ((8)  '(#f 0  1  2  3  4  #f 5  6  7))
    (else (naturals 0 count))))


(definition public (circle-placements count)
  (if (eq? video-layout 'focus)
      (round-placements count)
    (case current-circle-shape
      ((round)
       (round-placements count))
      ((hybrid)
       (hybrid-placements count))
      ((heart)
       (heart-placements count))
      ((theater)
       (theater-placements count)))))


;;;
;;;; Round
;;;


(definition (round-camera-position count)
  (let ((target (vertex 0. -2.5 0.)))
    (define (general-circle-formula)
      (let ((c1 (length (circle-positions count))))
        (let ((c2 (* c1 c1))
              (c3 (* c1 c1 c1))
              (c-sq (sqrt c1)))
          (values target
                  (+ (* c-sq 13.) (- (* c1 1.6) (* c2 .004)))
                  (+ (/ 47. c-sq) (* 0.15 c1) (* .001 c2))
                  20.
                  (if (= count c1)
                      5.
                    (if (even? c1)
                        (- 5.2 (* c1 0.013))
                      5.))))))
    
    (define (general-sphere-formula)
      (let ((c1 (length (circle-positions count))))
        (let ((c2 (* c1 c1))
              (c3 (* c1 c1 c1))
              (c-sq (sqrt c1)))
          (values target
                  (+ (* c-sq 7.) (- (* c1 1.6) (* c2 .004)))
                  (+ (/ 35. c-sq) (* 0.15 c1) (* .001 c2))
                  35.
                  (if (= count c1)
                      5.
                    (if (even? c1)
                        (- 5.2 (* c1 0.013))
                      5.))))))
    
    (case count
      ((0) (values (vertex 0. 0.5 0.) 10.  1. 35.  .521))
      ((1) (values (vertex 0. 0.5 0.) 12.  1. 35.  .521))
      ((2) (values (vertex 0. 0.5 0.) 12.  1. 35.  .521))
      ((3) (values (vertex 0. -1.8 0.) 45. 15. 18. 1.58))
      ((4) (values (vertex 0. -1.8 0.) 40. 14. 20. 4.754))
      ((5) (values (vertex 0. -2.3 0.) 38. 15. 25. 4.95))
      ((6) (values (vertex 0. -2.3 0.) 46. 16. 20. 5.14))
      ((7) (values (vertex 0. -2.3 0.) 44. 13. 26. 4.94))
      (else (general-circle-formula)))
    @w
    (general-sphere-formula)))


(definition (round-placements count)
  (let ((positions (calculate-positions count)))
    (collect (lambda (info)
               (and info
                    (let ((pos (if (pair? info) (car info) info)))
                      (round-placement pos positions))))
             positions)))


(definition (round-placement pos positions)
  (let ((circle-size (length positions)))
    (list
      2.8125
      (* 10. (circle-radius circle-size))
      (calculate-angle pos positions)
      1.
      0.)))


(definition protected (circle-radius count)
  (/ (cast <fl> count) PI*2))


(definition protected (calculate-angle pos positions)
  (let ((rank (find-rank pos positions key: (lambda (info) (if (pair? info) (car info) info)))))
    (let ((info (element positions rank))) 
      (let ((adjustment (if (pair? info) (cdr info) 0.))
            (circle-size (length positions)))
        (let ((slice (/ PI*2 (cast <fl> circle-size))))
          (let ((angle (* slice (cast <fl> rank))))
            (+ angle (* slice adjustment))))))))


;;;
;;;; Hybrid
;;;


(definition (hybrid-camera-position count)
  (case count
    ((0) (list (vertex -3.139 2.530 9.840) (lookat (vertex .217 -.007 .976) (vertex .001 1.000 .006) (vertex -.976 -.001 .217))))
    ((1) (list (vertex -3.139 2.530 9.840) (lookat (vertex .217 -.007 .976) (vertex .001 1.000 .006) (vertex -.976 -.001 .217))))
    ((2) (list (vertex -.922 1.968 3.738) (lookat (vertex .045 .018 .999) (vertex -.001 1.000 -.018) (vertex -.999 -.001 .045))))
    ((3) (list (vertex -2.153 4.508 5.002) (lookat (vertex .198 .063 .978) (vertex -.013 .998 -.061) (vertex -.980 -.001 .198))))
    ((4) (list (vertex -3.055 4.674 2.850) (lookat (vertex .158 .018 .987) (vertex -.004 1.000 -.018) (vertex -.987 -.001 .158))))
    ((5) (list (vertex -4.377 4.476 -2.631) (lookat (vertex .203 .018 .979) (vertex -.004 1.000 -.018) (vertex -.979 -.000 .203))))
    ((6) (list (vertex -4.377 4.476 -2.631) (lookat (vertex .203 .018 .979) (vertex -.004 1.000 -.018) (vertex -.979 -.000 .203))))
    ((7) (list (vertex -.145 6.958 -3.135) (lookat (vertex .163 .032 .986) (vertex -.006 .999 -.032) (vertex -.987 -.001 .163))))
    ((8) (list (vertex -2.404 7.756 -3.086) (lookat (vertex .178 .008 .984) (vertex -.002 1.000 -.008) (vertex -.984 -.000 .178))))
    ((9) (list (vertex -2.761 7.740 -5.054) (lookat (vertex .149 -.007 .989) (vertex .001 1.000 .007) (vertex -.989 -.000 .149))))
    (else
     (round-camera-position count))))


(definition (hybrid-focused-position count output)
  (let ((ordered-outputs (video-outputs)))
    (let ((pos (find-rank output ordered-outputs)))
      (case count
        ((2)
         (case pos
           ;; left
           ((1) (list (vertex 8.312 1.850 6.817) (vertex -.412 .043 .910)))
           ;; right
           ((0) (list (vertex -6.880 1.979 5.898) (vertex .333 .008 .943)))))
        (else
         #f)))))


(definition (hybrid-placements count)
  (let ((translation 140.)
        (adjustment 120.))
    (case count
      ((0)
       '())
      ((1)
       (list
         (list 2.8125 translation 0. 1. adjustment)))
      ((2)
       (list
         (list 2.8125 15. -.35 1. -6.)
         (list 2.8125 15.  .35 1. -6.)))
      ((3)
       (list
         (list 2.8125 translation (+ 0. .01) 1. adjustment)
         (list 8.4 (+ translation 1.) (+ -.04 .017) 1. adjustment)
         (list 8.4 (+ translation 1.) (+  .04 .018) 1. adjustment)))
      ((4)
       (list
         (list 2.8125 translation -.04 1. adjustment)
         (list 2.8125 translation  .04 1. adjustment)
         (list 8.4 (+ translation 1.) (+ -.04 .017) 1. adjustment)
         (list 8.4 (+ translation 1.) (+  .04 .018) 1. adjustment)))
      ((5)
       (list
         (list 2.8125 translation -.04 1. adjustment)
         (list 2.8125 translation  .04 1. adjustment)
         (list 8.35 (+ translation 1.) (+ -.08 .015) 1. adjustment)
         (list 8.35 (+ translation 1.) (+  .0  .015) 1. adjustment)
         (list 8.35 (+ translation 1.) (+  .08 .015) 1. adjustment)))
      ((6)
       (list
         (list 2.8125 translation -.08 1. adjustment)
         (list 2.8125 translation  .0  1. adjustment)
         (list 2.8125 translation  .08 1. adjustment)
         (list 8.35 (+ translation 1.) (+ -.08 .015) 1. adjustment)
         (list 8.35 (+ translation 1.) (+  .0  .015) 1. adjustment)
         (list 8.35 (+ translation 1.) (+  .08 .015) 1. adjustment)))
      ((7)
       (list
         (list 2.8125 translation (+ -.04 .015) 1. adjustment)
         (list 2.8125 translation (+  .04 .015) 1. adjustment)
         (list 8.35 (+ translation 1.) (+ -.08 .04) 1. adjustment)
         (list 8.35 (+ translation 1.) (+   0. .04) 1. adjustment)
         (list 8.35 (+ translation 1.) (+  .08 .04)  1. adjustment)
         (list 14. (+ translation 2.) (+  -.04 .04)  1. adjustment)
         (list 14. (+ translation 2.) (+   .04 .04)  1. adjustment)))
      ((8)
       (list
         (list 2.8125 translation (+ -.04 .02) 1. adjustment)
         (list 2.8125 translation (+  .04 .02) 1. adjustment)
         (list 8.35 (+ translation 1.) (+ -.08 .015) 1. adjustment)
         (list 8.35 (+ translation 1.) (+  .0  .015) 1. adjustment)
         (list 8.35 (+ translation 1.) (+  .08 .015) 1. adjustment)
         (list 14. (+ translation 2.) (+ -.08 .03)  1. adjustment)
         (list 14. (+ translation 2.) (+  .0  .03)  1. adjustment)
         (list 14. (+ translation 2.) (+  .08 .03)  1. adjustment)))
      ((9)
       (list
         (list 2.8125 translation -.08 1. adjustment)
         (list 2.8125 translation  .0  1. adjustment)
         (list 2.8125 translation  .08 1. adjustment)
         (list 8.35 (+ translation 1.) (+ -.08 .015) 1. adjustment)
         (list 8.35 (+ translation 1.) (+  .0  .015) 1. adjustment)
         (list 8.35 (+ translation 1.) (+  .08 .015) 1. adjustment)
         (list 14. (+ translation 2.) (+ -.08 .03)  1. adjustment)
         (list 14. (+ translation 2.) (+  .0  .03)  1. adjustment)
         (list 14. (+ translation 2.) (+  .08 .03)  1. adjustment)))
      (else
       (round-placements count)))))


;;;
;;;; Heart
;;;


(definition fire-adjustment
  10.)


(definition (heart-camera-position count)
  (let ((target (vertex 0. -2.5 (- fire-adjustment)))
        (remain (- count 1)))
    (cond ((<= remain 3) (values target 72. 10. 45. 0.))
          ((<= remain 4) (values target 78. 12. 45. 0.))
          ((<= remain 5) (values target 80. 14. 45. 0.))
          ((<= remain 6) (values target 84. 15. 45. 0.))
          (else          (values target 88. 16. 45. 0.)))))


(definition (heart-focused-angle output)
  (let ((ordered-outputs (video-outputs)))
    (let ((count (length ordered-outputs)))
      (let ((remain (- count 1))
            (pos (find-rank output ordered-outputs)))
        ;; quick hack until i have time to figure out bug
        (and pos
             (let ((increment .23))
               (let ((start (if (even? remain)
                                (- (- (/ increment 2.)) (* (- (/ remain 2) 1) increment))
                              (- (* increment (/ (- remain 1) 2))))))
                 (+ start (* (- pos 1) increment)))))))))


(definition (heart-placements count)
  (case count
    ((0)
     '())
    (else
     (let ((size 4.5)
           (translation 50.)
           (adjustment fire-adjustment)
           (increment .23)
           (remain (- count 1)))
       (cons (list (* 2.8125 size)
                   0.
                   0.
                   size
                   adjustment
                   (if (<= remain 4)
                       #f
                     'billboard))
             (let ((start (if (even? remain)
                              (- (- (/ increment 2.)) (* (- (/ remain 2) 1) increment))
                            (- (* increment (/ (- remain 1) 2))))))
               (map (lambda (n)
                      (list
                        2.8125
                        translation
                        (+ start (* n increment))
                        1.
                        adjustment))
                    (naturals 0 remain))))))))


;;;
;;;; Theater
;;;


(definition (theater-camera-position count)
  (let ((target (vertex 0. -2.5 0.)))
    (let ((c1 (length (circle-positions count))))
      (let ((c2 (* c1 c1))
            (c3 (* c1 c1 c1))
            (c-sq (sqrt c1)))
        (values target
                200.
                (+ (/ 47. c-sq) (* 0.15 c1) (* .001 c2))
                45.
                PI)))))


(definition (theater-placements count)
  (case count
    ((0)
     '())
    ((16)
     (cons (list 14.
                 0.
                 0.
                 5.
                 0.)
           (append
             (let ((translation (* 50. (circle-radius count)))
                   (from -.65)
                   (to .65))
               (let ((inc (/ (- to from) (- count 1))))
                 (map (lambda (n)
                        (list
                          2.8125
                          translation
                          (+ from (* (cast <fl> n) inc))
                          1.
                          0.))
                      (naturals 0 7))))
             (let ((translation (* 50. (circle-radius count)))
                   (from -.65)
                   (to .65))
               (let ((inc (/ (- to from) (- count 1))))
                 (map (lambda (n)
                        (list
                          8.5
                          translation
                          (+ from (* (cast <fl> n) inc) -.03)
                          1.
                          0.))
                      (naturals 0 8)))))))
    (else
     (cons (list 14.
                 0.
                 0.
                 5.
                 0.)
           (if (= count 1)
               '()
             (let ((translation 50.)
                   (from -.65)
                   (to .65))
               (let ((inc (/ (- to from) (- count 1))))
                 (map (lambda (n)
                        (list
                          2.8125
                          translation
                          (+ from (* (cast <fl> n) inc))
                          1.
                          0.))
                      (naturals 0 (- count 1))))))))))


;;;
;;;; Focus
;;;


(definition (focus-camera-position count)
  (case count
    ((0)  (values (vertex 0. 19.7 0.) 150.   0.  20. 0.))
    ((1)  (values (vertex 0. 25. 0.)  160.  10.  20. 6.81))
    ((2)  (values (vertex 0. 25. 0.)  160.  10.  20. 6.81))
    ((3)  (values (vertex 0. 64. 0.)  167. -19.8 20  1.58))
    ((4)  (values (vertex 0. 64. 0.)  167. -19.8 20  1.3))
    ((5)  (values (vertex 0. 80. 0.)  164. -27.7 20. 0.))
    ((6)  (values (vertex 0. 75. 0.)  170. -25.  20. 0.2))
    ((7)  (values (vertex 0. 60. 0.)  172. -17.6 20. 0.2))
    ((8)  (values (vertex 0. 60. 0.)  179. -17.2 20. 0.))
    ((9)  (values (vertex 0. 60. 0.)  191. -16.3 20. 0.))
    ((10) (values (vertex 0. 60. 0.)  196. -16.  20. 0.))
    ((11) (values (vertex 0. 60. 0.)  204. -15.5 20. 0.))
    ((12) (values (vertex 0. 53. 0.)  205. -12.  20. 0.))
    ((13) (values (vertex 0. 45. 0.)  206. -8.   20. 0.))
    ((14) (values (vertex 0. 40. 0.)  206. -5.6  20. 0.))
    ((15) (values (vertex 0. 36. 0.)  210. -3.35 20. 0.))
    ((16) (values (vertex 0. 36. 0.)  215. -3.05 20. 0.))
    ((17) (values (vertex 0. 35. 0.)  221. -2.15 20. 0.))
    ((18) (values (vertex 0. 35. 0.)  226. -1.8  20. 0.))
    ((19) (values (vertex 0. 34. 0.)  229. -1.1  20. 0.))
    ((20) (values (vertex 0. 33. 0.)  235. -0.24 20. 0.))
    (else
     (let ((cnt (cast <fl> count)))
       (values (vertex 0. (* cnt (/ 33. 20.)) 0.)
               (* cnt (/ 235. 20.)) 
               (/ cnt 10.)
               20.
               0.)))))


(definition (focus-positions count)
  (case count
    ((1 2 3 4) (circle-positions count))
    (else
     (naturals 0 count))))


;;;
;;;; Looked At
;;;


(definition protected looked-at-output
  #f)


;;;
;;;; Camera
;;;


(definition protected camera-angle
  2.0)

(definition protected camera-speed
  0.1)

(definition protected camera-tick
  #f)


(definition public (circle-install-camera)
  (let ((window (current-window))
        (zone (current-zone)))
    (unless camera-tick
      (set! camera-tick (lambda (elapse)
                          (with-exception-catcher
                            (lambda (exc)
                              (terminal (exception-reason exc)))
                            (lambda ()
                              (circle-path-camera elapse)))))
      (register-tick zone camera-tick)
      ;; removes tearing in the pathing
      (maybe-enable-vsync window)
      (circle-path-camera 0.))))


(definition public (circle-uninstall-camera)
  (let ((window (current-window))
        (zone (current-zone)))
    (when camera-tick
      (unregister-tick zone camera-tick)
      (maybe-disable-vsync window)
      (set! camera-tick #f))))


(definition (aim-camera-around target radius elevation fov angle)
  (let ((world (current-world)))
    ;; quick hack
    (set! target (vertex+ target (vertex 0. 3. 0.)))
    (let ((angle (- PI/2 angle)))
      (let ((x (cos angle))
            (z (sin angle)))
        (let ((flat (vertex+ target (vertex-scalar*& (vertex x 0. z) radius))))
          (let ((pos (vertex+ flat (vertex 0. elevation 0.))))
            (let ((dir (vertex-normalize (vertex-& target pos)))
                  (dir-flat (vertex-normalize (vertex-& target flat))))
              (let ((vert-angle (vector-angle dir dir-flat)))
                (let ((sight dir-flat)
                      (eye (get-eye world))
                      (up (get-world-up world)))
                  (let ((right (cross-product sight up)))
                    (let ((lookat (lookat sight up right)))
                      (list (vertex+& circle-center pos)
                            (rotate-lookat-vertical& lookat (- vert-angle))))))))))))))


(definition (position-camera-around target radius elevation fov angle)
  (let ((world (current-world))
        (zone (current-zone)))
    (let ((eye (get-eye world)))
      (bind (position lookat) (aim-camera-around target radius elevation fov angle)
        (set-perspective-fov eye fov)
        (prepare-projection eye)
        (vista-motion world circle-center)
        (set-lookat eye lookat)
        (set-position eye position)
        (derive-target eye)
        (camera-update eye)))))


(definition protected (position-camera position lookat)
  (let ((world (current-world))
        (zone (current-zone)))
    (let ((eye (get-eye world)))
      (set-perspective-fov eye default-fov)
      (prepare-projection eye)
      (set-lookat eye lookat)
      (set-position eye (vertex+& circle-center position))
      (derive-target eye)
      (camera-update eye))))


(definition protected (restore-fov)
  (let ((world (current-world)))
    (let ((eye (get-eye world)))
      (set-perspective-fov eye 45.)
      (prepare-projection eye))))


(definition camera-target-angle
  #f)

(definition camera-target-speed
  #f)


(definition (circle-path-camera elapse)
  (unless sleeping?
    (let ((count (video-count)))
      (when (> count circle-max-fixed)
        (let ((speed (or camera-target-speed camera-speed)))
          (let ((proposed-angle (+ camera-angle (* elapse speed))))
            (when camera-target-angle
              (let ((not-crossing-zero? (< (abs (- camera-angle camera-target-angle)) PI)))
                (let ((normal-proposed (if not-crossing-zero?
                                           proposed-angle
                                         (normalize-angle (+ proposed-angle PI))))
                      (normal-target (if not-crossing-zero?
                                        camera-target-angle
                                      (normalize-angle (+ camera-target-angle PI)))))
                  (when (or (and (> camera-target-speed 0.) (>= normal-proposed normal-target))
                            (and (< camera-target-speed 0.) (<= normal-proposed normal-target)))
                    (circle-uninstall-camera)
                    (set! proposed-angle camera-target-angle)
                    (set! camera-target-angle #f)
                    (set! camera-target-speed #f)))))
            (circle-position-camera count proposed-angle)))))))


(definition (circle-position-camera count new-angle)
  (let ((info (active-camera-position count)))
    (if (pair? info)
        #f ;; todo
      (receive (target radius elevation fov angle) info
        (position-camera-around target radius elevation fov new-angle))
      (set! camera-angle (normalize-angle new-angle)))))


(definition public (circle-toggle-camera)
  (if camera-tick             
      (circle-uninstall-camera)
    (circle-install-camera)))


(definition public (circle-left-rotation)
  (set! camera-speed (* -1 (abs camera-speed))))

(definition public (circle-right-rotation)
  (set! camera-speed (abs camera-speed)))

(definition public (circle-increase-speed)
  (when (< (abs camera-speed) .75)
    (set! camera-speed (* camera-speed 1.5))))

(definition public (circle-decrease-speed)
  (when (> (abs camera-speed) .02)
    (set! camera-speed (/ camera-speed 1.5))))


(definition (focused-angle output)
  (if (eq? current-circle-shape 'heart)
      (heart-focused-angle output)
    (let ((ordered-outputs (video-outputs)))
      (let ((count (length ordered-outputs)))
        (when (> count circle-max-fixed)
          (let ((positions (calculate-positions count))
                (pos (find-rank output ordered-outputs)))
            ;; quick hack until i have time to figure out bug
            (and pos
                 (calculate-angle pos positions))))))))


(definition public (circle-goto-focus output)
  (let ((count (video-count)))
    (when (> count circle-max-fixed)
      (let ((new-angle (focused-angle output)))
        ;; quick hack until i have time to figure out bug
        (when new-angle
          (circle-position-camera count new-angle))))))


(definition public (circle-switch-focus output (test? #f))
  (let ((video (current-video)))
    (if (and speakers-xp? test?)
        (begin
          (change-focused-output video output)
          (update-interface-matrices video))
      (let ((count (video-count)))
        (define (round-shape?)
          (if (and (eq? current-circle-shape 'hybrid)
                   (neq? video-layout 'focus))
              (> count 9)
            (> count circle-max-fixed)))
        
        (cond ((round-shape?)
               (let ((new-angle (focused-angle output)))
                 ;; quick hack until i have time to figure out bug
                 (when new-angle
                   (let ((not-crossing-zero? (< (abs (- camera-angle new-angle)) PI)))
                     (let ((current-angle (if not-crossing-zero?
                                              camera-angle
                                            (normalize-angle (+ camera-angle PI))))
                           (target-angle (if not-crossing-zero?
                                             new-angle
                                           (normalize-angle (+ new-angle PI)))))
                       (if (> target-angle current-angle)
                           (set! camera-target-speed 5.)
                         (set! camera-target-speed -5.))
                       (set! camera-target-angle new-angle)
                       (circle-install-camera))))))
              @not-used-at-the-moment
              ((and (eq? current-circle-shape 'hybrid)
                    (neq? video-layout 'focus))
               (let ((info (hybrid-focused-position count output)))
                 (when info
                   (bind (target direction) info
                     (aim-at (vertex+ circle-center target) direction)))))))
      (change-focused-output video output))))


(definition public (circle-left)
  (let ((count (video-count)))
    (when (> count circle-max-fixed)
      (circle-left-rotation)
      (circle-install-camera))))


(definition public (circle-right)
  (let ((count (video-count)))
    (when (> count circle-max-fixed)
      (circle-right-rotation)
      (circle-install-camera))))


(definition public (circle-up)
  (let ((count (video-count)))
    (when (> count circle-max-fixed)
      (circle-increase-speed))))


(definition public (circle-down)
  (let ((count (video-count)))
    (when (> count circle-max-fixed)
      (circle-decrease-speed))))


(definition public (circle-return)
  (let ((count (video-count)))
    (when (> count circle-max-fixed)
      (circle-toggle-camera))))


(definition public (circle-backspace)
  (circle-home))


(definition public (circle-home (smooth? #f))
  (let ((count (video-count)))
    (circle-uninstall-camera)
    (circle-update-camera count smooth?)
    (bind-camera)))


;;;
;;;; Push to talk
;;;


(definition protected push-to-talk-tick
  #f)

(definition protected talking?
  #f)


(definition public (push-to-talk?)
  push-to-talk-tick)


(definition public (toggle-push-to-talk)
  (let ((world (current-world)))
    (change-push-to-talk (not push-to-talk-tick))
    (display-on/off world "Push to talk" push-to-talk-tick)))


(definition public (change-push-to-talk flag)
  (if flag
      (install-push-to-talk)
    (uninstall-push-to-talk)))


(definition public (install-push-to-talk)
  (let ((client (current-client))
        (zone (current-zone)))
    (unless push-to-talk-tick
      (set! talking? #f)
      (set! push-to-talk-tick tick-push-to-talk)
      (mute-microphone)
      (register-tick zone push-to-talk-tick)
      (invalidate-self-output client))))


(definition public (uninstall-push-to-talk)
  (let ((client (current-client))
        (zone (current-zone)))
    (when push-to-talk-tick
      (unregister-tick zone push-to-talk-tick)
      (unmute-microphone)
      (set! push-to-talk-tick #f)
      (set! talking? #f)
      (invalidate-self-output client))))


(definition (tick-push-to-talk elapse)
  (when application-active?
    (if (and (null? (modifiers-keys))
             (key-down? #\space))
        (unless talking?
          (play-ambient-sound "warcraft/user/uChatScrollButton" volume: .2)
          (unmute-microphone)
          (set! talking? #t))
      (when talking?
        (play-ambient-sound "warcraft/user/uChatScrollButton" volume: .15)
        (mute-microphone)
        (set! talking? #f)))))


(definition (mute-microphone)
  (let ((client (current-client)))
    (when (microphone-on? client)
      (let ((microphone-channel (get-microphone-channel client)))
        (let ((src (get-src (get-pipeline microphone-channel))))
          (mute src))))))


(definition (unmute-microphone)
  (let ((client (current-client)))
    (when (microphone-on? client)
      (let ((microphone-channel (get-microphone-channel client)))
        (let ((src (get-src (get-pipeline microphone-channel))))
          (unmute src))))))


;;;
;;;; Circle-Stone
;;;


(class Circle-Stone extends Entity
  
  
  (method override (finish self rest)
    (nextmethod self rest)
    (when (client?)
      (set-name-pane self name color: group-color)))
  
  
  (method override (circle-stone? self)
    #t))


;;;
;;;; Checkerboard
;;;


(definition protected checkerboard-interface?
  #f)

(definition protected (set-checkerboard-interface? flag)
  (set! checkerboard-interface? flag))


(definition protected (draw-checkerboard-interface surface (alpha: alpha .5))
  (draw-checkerboard surface 16 9 alpha: alpha))


;;;
;;;; Pane
;;;


(class Circle-Pane extends Sheet-Pane
  
  
  (slot output initialize #f accessors generate)
  
  
  (method override (mousable? self)
    (and (nextmethod self)
         (is-not? (current-space) together.gathering:Avatar-Space)))
  
  
  @COLLABO ;; all this is buggy
  (method override (mousable-down self x y)
    (if (memq? video-layout '(circle focus))
        (when (memq? video-layout '(circle focus))
          (circle-switch-focus output #t))
      (nextmethod self x y)))
  
  
  @COLLABO ;; all this is buggy
  (method override (mousable-double self x y)
    (if (memq? video-layout '(circle focus))
        (when (memq? video-layout '(circle focus))
          (circle-switch-focus output #t))
      (nextmethod self x y)))
  
  
  (method override (mousable-look-at? self)
    #f))


;;;
;;;; View
;;;


(definition protected debug-stream
  #f)

(definition protected (set-debug-stream what)
  (set! debug-stream what))


;; quick solution
(definition protected server-streaming
  (make-table test: equal?))

(definition protected (register-server-streaming location)
  (table-set! server-streaming (filename-name location) #t))

(definition protected (unregister-server-streaming location)
  (table-set! server-streaming (filename-name location)))

(definition protected (server-streaming? name)
  (table-ref server-streaming name #f))


(definition protected (streaming-audio? audio-output)
  (let ((channel (get-channel audio-output)))
    (and channel
         (neq? (get-source-kind channel) 'live))))


(definition protected (unmuted-audios (ignore: ignore #f))
  (let ((audio (current-audio)))
    (collect-if (lambda (audio-output)
                  (and (streaming-audio? audio-output)
                       (not (muted? audio-output))
                       (or (not ignore)
                           (neq? audio-output ignore))))
                (table-values (get-outputs audio)))))


(definition protected (audio->circle-view output)
  (let ((channel (get-channel output)))
    (and channel
         (let ((video-channel (locate-stream-video-channel (get-stream channel))))
           (and video-channel
                (let ((output (get-output video-channel)))
                  (and output
                       (get-root (get-interface-pane output)))))))))


(definition (navigation-bar-color circle-view)
  (if (eq? circle-view (active-focus))
      {Color red: .005 green: .484 blue: .918}
    {Color White}))
      

(interface Circleable
  
  
  (method public virtual abstract (update self output)))


(class Circle-View extends View implements Circleable
  
  
  (slot output initialize #f accessors generate)
  
  
  (form
    (<install>
      (<Pause-View>  name: stream-pause position: {Point 20 663} size: {Dimension 40 40} visible?: #f)
      (<Seek-View>   name: stream-seek  position: {Point 80 663} size: {Dimension 252 40} visible?: #f)
      (<Mute-View>   name: stream-mute  position: {Point 361 663} size: {Dimension 50 40} visible?: #f)
      (<Mute-View>   name: mute         position: {Point 1090 663} size: {Dimension 50 40} visible?: #f)
      (<Volume-View> name: volume       position: {Point 1140 663} size: {Dimension 120 40} visible?: #f)))
  
  
  (method override (update self out)
    (set! output out)
    (set-output (get-player self) out)
    (when (streaming-channel? self)
      (set-visible? (child self 'stream-pause) #t)
      (set-visible? (child self 'stream-seek) #t)
      (setup-seek (child self 'stream-seek) output)
      (set-stream? (child self 'stream-mute) #t))
    (setup-audio self))
  
  
  (method protected (setup-audio self)
    (let ((audio-output (find-audio-output self)))
      (when audio-output
        (when (and (streaming-audio? audio-output)
                   (not-null? (unmuted-audios ignore: audio-output)))
          (mute audio-output)
          (set-muted? (child self 'mute) #t))
        (setup-knob (child self 'volume) (get-volume audio-output))
        (when (not (audio-off? self))
          (when (streaming-channel? self)
            (set-visible? (child self 'stream-mute) #t))
          (set-visible? (child self 'mute) #t)
          (set-visible? (child self 'volume) #t)))))
  
  
  (method protected (invalidate-audio self)
    (let ((audio-output (find-audio-output self)))
      (when audio-output
        (let ((visible? (not (audio-off? self))))
          (when (streaming-channel? self)
            (set-visible? (child self 'stream-mute) visible?))
          (set-visible? (child self 'mute) visible?)
          (set-visible? (child self 'volume) visible?)))))
  
  
  (method (streaming-channel? self)
    (let ((channel (get-channel output)))
      (or (and (is? channel UDP-Receive-Channel)
               (server-streaming? (get-name (get-stream channel))))
          (and (is? channel UDP-Send-Channel)
               (eq? (get-source-kind (get-stream channel)) 'stream)))))
  
  
  (method public (find-audio-channel self)
    (let ((video-channel (get-channel output)))
      (and video-channel
           (locate-stream-audio-channel (get-stream video-channel)))))
  
  
  (method public (find-audio-output self)
    (let ((audio-channel (find-audio-channel self)))
      (and audio-channel
           (get-output audio-channel))))
  
  
  (method protected (audio-off? self)
    (let ((video (current-video))
          (client (current-client)))
      (if (eq? output (get-self-output video))
          (not (microphone-on? client))
        (let ((audio-channel (find-audio-channel self)))
          (or (not audio-channel)
              (eq? (get-send-state audio-channel) 'off))))))
  
  
  (method override (draw self surface context)
    (let ((video (current-video))
          (audio (current-audio))
          (interface (current-interface))
          (client (current-client))
          (udp (current-udp)))
      (let ((channel (get-channel output)))
        (define (determine-output-name output)
          (cond ((not channel)
                 (if (push-to-talk?)
                     "Me (Push to talk)"
                   "Me"))
                ((eq? (get-source-kind channel) 'screen)
                 (if (is? channel UDP-Send-Channel)
                     "You are now sharing your screen"
                   (format "{a}'s screen" (get-sender (get-stream channel)))))
                ((eq? (get-source-kind channel) 'view)
                 (if (is? channel UDP-Send-Channel)
                     "You are now sharing your together"
                   (format "{a}'s together" (get-sender (get-stream channel)))))
                (else
                 (filename-base (effective-name (get-stream channel))))))
        
        (define (effective-audio-off?)
          (and (audio-off? self)
               (not (and channel
                         (memq? (get-source-kind channel) '(screen view))))))
        
        (when checkerboard-interface?
          (draw-checkerboard-interface surface))
        (let ((name (determine-output-name output)))
          (when (get-stream-disconnected? output)
            (set! name (format "{a} (disconnected)" name)))
          (cond ((eq? (get-stream-state output) 'drawn)
                 (set-font surface {Font font-name: tahoma point-size: 36 shadow: thin})
                 (let ((extent (get-text-extent surface name))
                       (streaming? (streaming-channel? self)))
                   (let ((pos {Point 0 0})
                         (offset (new Point 19 (- 720 (get-height extent) 15))))
                     (let ((h (+ (get-h pos) (get-h offset) (if streaming? 5 0)))
                           (v (+ (get-v pos) (get-v offset) (if streaming? -60 0))))
                       (draw-text surface h v name (if streaming? {Color World-Ochre} {Color White}))
                       (when (effective-audio-off?)
                         (set-color surface {Color Dark-Red})
                         (set-line-width surface 3)
                         (line surface h (+ v (get-height extent)) (+ h (get-width extent)) v))))))
                (else
                 (let ((pos {Point 0 0})
                       (size {Dimension 1280 720})
                       (rect {Rect 0 0 1280 720}))
                   (fill-rect surface (inflate-rect rect -1 -1) {Color red: 30 green: 30 blue: 30 alpha: .7})
                   (frame-rect surface rect {Color Dim-Gray})
                   (set-font surface {Font font-name: tahoma point-size: 48 hint-style: slight hint-metrics: on})
                   (let ((extent (get-text-extent surface name)))
                     (let ((offset (center extent size)))
                       (let ((h (+ (get-h pos) (get-h offset)))
                             (v (+ (get-v pos) (get-v offset))))
                         (draw-text surface h v name {Color White})
                         (when (effective-audio-off?)
                           (set-color surface {Color Dark-Red})
                           (set-line-width surface 3)
                           (line surface h (+ v (get-height extent)) (+ h (get-width extent)) v)))))))))
        (when (and debug-stream video-interface?)
          (let ((rect {Rect 0 0 1280 720}))
            (fill-rect surface rect {Color Black alpha: 0.5}))
          (set-font surface {Font font-name: tahoma point-size: 32 shadow: thin})
          (case debug-stream
            ((media)
             (draw-text surface 10 10 (format "{a} #{a}" (reference-name (get-name (class-of output))) (object->serial output)) {Color World-Ochre})
             (let ((channel (or (get-channel output) (let ((stream (get-live-stream client)))
                                                       (and stream
                                                            (locate-level-channel stream (get-level output)))))))
               (when channel
                 (let ((stream (get-stream channel))
                       (rank 0))
                   (define (draw text color)
                     (let ((h (if (= rank 0) 10 45))
                           (v (+ 55 (* rank 45))))
                       (draw-text surface h v text color)
                       (increase! rank)))
                   
                   (define (present-rate rate)
                     (cond ((not rate)
                            "N/A")
                           ((integer? rate)
                            (->string rate))
                           (else
                            (format "{r precision: 1}" rate))))
                   
                   (draw (format "{a} #{a}" (reference-name (get-name (class-of channel))) (object->serial channel)) {Color World-Ochre})
                   (draw (format "Sender: {a}" (get-sender stream)) {Color World-Red})
                   (draw (format "Name: {a}" (get-name stream)) {Color World-Red})
                   (draw (format "Kind: {a}" (get-source-kind stream)) {Color World-Red})
                   (draw (format "Resolution: {a}x{a}" (get-width (get-resolution channel)) (get-height (get-resolution channel))) {Color World-Red})
                   (draw (format "Framerate: {a}{? ({r precision: 1})~}" (present-rate (get-framerate channel)) (get-frequency (get-rate output))) {Color World-Red})
                   (draw (format "Bitrate: {a}" (present-rate (get-bitrate channel))) {Color World-Red})
                   (when (is? channel UDP-Receive-Channel)
                     (draw (format "Insert: {?{r precision: 1}~}" (get-frequency (get-insert-rate channel))) {Color World-Red})
                     (draw (format "Process: {?{r precision: 1}~}" (get-frequency (get-process-rate channel))) {Color World-Red})
                     (let ((output (get-output channel)))
                       (when output
                         (draw (format "Hardware: {a}" (if (get-hardware? output) "Yes" "No")) {Color World-Red}))))
                   (when (is? channel UDP-Send-Channel)
                     (let ((pipeline (get-pipeline channel)))
                       (when pipeline
                         (let ((src (get-src pipeline)))
                           (when (is? src Camera-Video-Src)
                             (let ((port (open-output-string)))
                               (for-each (lambda (consumer)
                                           (when (is? consumer Camera-Video-Consumer)
                                             (let ((rate (get-frequency (get-rate consumer))))
                                               (when rate
                                                 (format port " {r precision: 1}" rate)))))
                                         (get-sinks src))
                               (let ((rates (get-output-string port)))
                                 (draw (format "Send: {a}" rates) {Color World-Red})))
                             (let ((port (open-output-string)))
                               (for-each (lambda (consumer)
                                           (when (is? consumer Camera-Video-Consumer)
                                             (format port " {a}" (if (get-hardware? consumer) "Yes" "No"))))
                                         (get-sinks src))
                               (let ((hardware (get-output-string port)))
                                 (draw (format "Hardware: {a}" hardware) {Color World-Red})))))))
                     (let ((output (get-output channel)))
                       (when output
                         (draw (format "Hardware: {a}" (if (get-hardware? output) "Yes" "No")) {Color World-Red}))))))))
            ((flow)
             (set-font surface {Font font-name: tahoma point-size: 32 shadow: thin})
             (draw-text surface 10 10 (format "{a} #{a}" (reference-name (get-name (class-of output))) (object->serial output)) {Color World-Ochre})
             (let ((audio-output (find-audio-output self)))
               (when audio-output
                 (let ((monitor (get-monitor audio-output))
                       (rank 0))
                   (define (draw text color)
                     (let ((h (if (= rank 0) 10 45))
                           (v (+ 55 (* rank 45))))
                       (draw-text surface h v text color)
                       (increase! rank)))
                   
                   (draw (format "{a} #{a}" (reference-name (get-name (class-of audio-output))) (object->serial audio-output)) {Color World-Ochre})
                   (draw (format "System clock: {a}" (get-systemclock-name monitor)) {Color World-Orange})
                   (draw (format "Audio clock: {a}" (get-audioclock-name monitor)) {Color World-Orange})
                   (draw (format "Origin rate: {r precision: 4}" (get-originclock-rate monitor)) {Color World-Red})
                   (draw (format "Real rate: {r precision: 4}" (get-realclock-rate monitor)) {Color World-Red})
                   (draw (format "Monotonic rate: {r precision: 4}" (get-monotonicclock-rate monitor)) {Color World-Red})
                   (draw (format "System rate: {r precision: 4}" (get-systemclock-rate monitor)) {Color World-Red})
                   (draw (format "Audio rate: {r precision: 4}" (get-audioclock-rate monitor)) {Color World-Red})))))
            ((live)
             (draw-text surface 10 10 (format "{a} #{a}" (reference-name (get-name (class-of output))) (object->serial output)) {Color World-Ochre})
             (let ((channel (get-channel output)))
               (when channel
                 (let ((stream (get-stream channel))
                       (rank 0))
                   (define (draw text color)
                     (let ((h 45)
                           (v (+ 55 (* rank 45))))
                       (draw-text surface h v text color)
                       (increase! rank)))
                   
                   (define (present-voice audio-output)
                     (let ((channel (get-channel audio-output)))
                       (let ((ring (get-process-ring channel)))
                         (format "{r precision: 1}%" (voice-percentage ring)))))
                   
                   (define (present-send audio-output)
                     (let ((channel (get-channel audio-output)))
                       (format "{a}" (get-count (get-retain-ring channel)))))
                   
                   (define (present-receive audio-output)
                     (let ((channel (get-channel audio-output)))
                       (format "{a}" (get-count (get-process-ring channel)))))
                   
                   (define (present-latency latency)
                     (if (not latency)
                         "N/A"
                       (present-timestamp latency)))
                   
                   (typecase stream
                     ((UDP-Send-Stream)
                      (let ((audio-output (find-audio-output self)))
                        (when audio-output
                          (draw (format "Send: {a}" (present-send audio-output)) {Color World-Red}))))
                     ((UDP-Receive-Stream)
                      (let ((audio-output (find-audio-output self)))
                        (when audio-output
                          (draw (format "Voice: {a}" (present-voice audio-output)) {Color World-Red})
                          (draw (format "Receive: {a}" (present-receive audio-output)) {Color World-Red}))
                        (draw (format "Audio latency: {a} ({a} raw)" (present-latency (get-audio-latency stream)) (present-latency (get-audio-raw stream))) {Color World-Red})
                        (draw (format "Video latency: {a} ({a} raw)" (present-latency (get-video-latency stream)) (present-latency (get-video-raw stream))) {Color World-Red})
                        (when audio-output
                          (let ((channel (get-channel audio-output)))
                            (draw (format "Audio rate: {?{r precision: 1}~}" (get-frequency (get-insert-rate channel))) {Color World-Red})))))))))))))))
  
  
  ;; COLLABO
  ;; quicky
  (hub avatar-mode?)
  (method override (mouse-down self evt)
    (let ((together (together:current-together)))
      (unless (avatar-mode? together)
        (acquire-capture self)
        (acquire-focus self)
        (case video-layout
          ((circle)
           (let ((focused-output (get-focused-output (current-video)))
                 (count (video-count)))
             (if (and (eq? current-circle-shape 'hybrid)
                      (<= count 9))
                 (cond ((eq? output looked-at-output)
                        (circle-home #t)
                        (set! looked-at-output #f))
                       (else
                        (look-at (get-media-pane output))
                        (set! looked-at-output output)))
               (if (eq? output focused-output)
                   (cond ((eq? output looked-at-output)
                          (let ((info (active-camera-position count))
                                (new-angle (focused-angle output)))
                            (receive (target radius elevation fov angle) info
                              (bind (position lookat) (aim-camera-around target radius elevation fov new-angle)
                                (aim-at position (get-sight lookat)))))
                          (set! looked-at-output #f))
                         (else
                          (look-at (get-media-pane output))
                          (set! looked-at-output output)))
                 (circle-switch-focus output #t)))))
          ((focus)
           (circle-switch-focus output #t))))))
  
  
  ;; COLLABO
  @wait
  (method override (double-click self evt)
    (when (eq? video-layout 'circle)
      (circle-switch-focus output #t)))
  
  
  ;; COLLABO
  (method override (drag-up self evt . rest)
    (release-capture self))
  
  
  (method override (focus-gained self)
    (nextmethod self)
    (invalidate-view self)
    (invalidate-texture (get-interface-pane output)))
  
  
  (method override (focus-lost self)
    (nextmethod self)
    (invalidate-view self)
    (invalidate-texture (get-interface-pane output)))
  
  
  (method protected (toggle-paused self)
    (let ((pause-view (child self 'stream-pause)))
      (when (get-visible? pause-view)
        (toggle-paused pause-view))))
  
  
  (method protected (seek-backward self)
    (let ((seek-view (child self 'stream-seek)))
      (if (not (get-visible? seek-view))
          (circle-left)
        (let ((pause-view (child self 'stream-pause)))
          (unless (get-paused? pause-view)
            (toggle-paused pause-view)))
        (seek-backward seek-view))))
  
  
  (method protected (seek-forward self)
    (let ((seek-view (child self 'stream-seek)))
      (if (not (get-visible? seek-view))
          (circle-right)
        (let ((pause-view (child self 'stream-pause)))
          (unless (get-paused? pause-view)
            (toggle-paused pause-view)))
        (seek-forward seek-view)))))


(class Together-View-Actions extends World-Actions

  
  (form
    (<install>                                 title: "View"
      (<World-Action-Item> name: toggle-paused title: "Toggle paused" shortcut: {Shortcut Space})
      (<World-Action-Item> name: seek-backward title: "Seek backward" shortcut: {Shortcut Left})
      (<World-Action-Item> name: seek-forward  title: "Seek forward" shortcut: {Shortcut Right}))))


;;;
;;;; Pause
;;;


(class Pause-View extends View
  
  
  (property paused? initialize #f accessors generate)
  
  
  (method override (draw self surface context)
    (cond (paused?
           (set-color surface {Color White})
           (set-line-width surface 1.5)
           (loop (for n from 0 to 18)
                 (let ((half (- 18 n)))
                   (line surface (+ 16 n) (- 18 half) (+ 16 n) (+ 18 half)))))
          (else
           (fill-rect surface (new Rect 5 0 16 36) {Color White})
           (fill-rect surface (new Rect 24 0 35 36) {Color White}))))
  
  
  (method override (mouse-up self evt)
    (toggle-paused self))
  
  
  (method protected (toggle-paused self)
    (set! paused? (not paused?))
    (set-paused? (brother self 'stream-seek) paused?)
    (let ((output (get-output parent)))
      (let ((stream (get-stream (get-channel output)))
            (action (if paused? 'pause 'play)))
        (if (is? stream UDP-Send-Stream)
            (let ((action-proc (get-action-proc stream)))
              (action-proc stream action '()))
          (let ((client (current-client)))
            (let ((stream (get-stream (get-channel output))))
              (stream-action client (get-no stream) action '()))))))
    (invalidate-view self)))


;;;
;;;; Seek
;;;


;; play -> pause     : pause on, seek on
;; pause -> play     : pause off, seek off
;; seek in play      : seek on -> seek -> seek off
;; seek in pause     : pause off -> seek -> pause on
;; navigate in pause : pause off -> navigate -> pause on


(class Seek-View extends View
  
  
  (property seek initialize 0. accessors generate)
  
  
  (slot paused?   initialize #f getter generate)
  (slot tracking? initialize #f getter generate)
  (slot start     initialize #f getter generate)
  (slot end       initialize #f getter generate)
  (slot duration  initialize #f getter generate)
  (slot elapsed   initialize #f getter generate)
  (slot preserved-threshold)
  (slot preserved-sync)
  
  
  (method protected (setup-seek self output)
    (let ((channel (get-channel output)))
      (let ((metadata (get-metadata channel)))
        (let ((start (getf metadata start:))
              (end (getf metadata end:)))
          (when (and start end)
            (let ((duration (- end start)))
              (set! self.start (timestamp->flonum start))
              (set! self.end (timestamp->flonum end))
              (set! self.duration (timestamp->flonum duration))
              (set-seek-callback output
                (lambda (dts)
                  (seek-update self dts)))))))))
  
  
  (method override (draw self surface context)
    (set-line-width surface 3)
    (fill-rect surface (new Rect 1 15 251 21) (navigation-bar-color parent))
    (let ((h (seek->h self seek)))
      (fill-rect surface (new Rect (+ h 10) 15 251 21) {Color red: 160 green: 160 blue: 160})
      (ellipse surface (new Rect (- h 10) 8 (+ h 10) 28) {Color White} {Color White}))
    @wait
    (when elapsed
      (set-font surface {Font font-name: tahoma point-size: 18 shadow: thin})
      (draw-text surface 0 -5 (present-duration elapsed compact?: #t) {Color White})))
  
  
  (method protected (seek->h self s)
    (+ 12 (fxround (* s (- 250. 22.)))))
  
  
  (method protected (seek-update self dts)
    (let ((current-h (seek->h self seek)))
      (set! elapsed (- (timestamp->flonum dts) start))
      (set! seek (/ elapsed duration))
      (when (and video-interface? (/= (seek->h self seek) current-h))
        (invalidate-view self))))
  
  
  (method override (mouse-down self evt)
    (set! tracking? #t)
    (acquire-capture self)
    (acquire-focus parent)
    (if paused?
        (paused-off self)
      (seeking-on self))
    (adjust-seek self (get-h evt)))
  
  
  (method override (drag-move self evt)
    (when tracking?
      (adjust-seek self (get-h evt))))
  
  
  (method override (drag-up self evt . rest)
    (when tracking?
      (invoke-action self 'seek (list #f))
      (if paused?
          (paused-on self)
        (seeking-off self))
      (release-capture self)
      (set! tracking? #f)))
  
  
  (method (adjust-seek self h)
    (let ((range (cast <fl> (max 0 (min 228 (- h 12))))))
      (let ((s (/ range 228.)))
        (when (/= s seek)
          (set! seek s)
          (invoke-action self 'seek (list s))
          (invalidate-view self)))))
  
  
  (method (invoke-action self action arguments)
    (let ((output (get-output parent)))
      (let ((stream (get-stream (get-channel output))))
        (if (is? stream UDP-Send-Stream)
            (let ((action-proc (get-action-proc stream)))
              (action-proc stream action arguments))
          (let ((client (current-client)))
            (stream-action client (get-no stream) action arguments))))))
  
  
  (method protected (set-paused? self flag)
    (set! paused? flag)
    (cond (paused?
           (paused-on self)
           (seeking-on self))
          (else
           (seeking-off self)
           (paused-off self))))
  
  
  (method protected (seek-backward self)
    (when paused?
      (with-playing self
        (lambda ()
          (invoke-action self 'backward '())))))
  
  
  (method protected (seek-forward self)
    (when paused?
      (with-playing self
        (lambda ()
          (invoke-action self 'forward '())))))
  
  
  (method protected (seeking-on self)
    (let ((output (get-output parent)))
      (let ((stream (get-stream (get-channel output))))
        (when (is? stream UDP-Send-Stream)
          (let ((pipeline (get-color-pipeline output)))
            ;; audio only test
            (when pipeline
              ;; no min-threshold-time and no sync during seek
              (with-unref ((queue (gst_bin_get_by_name pipeline "queue"))
                           (appsink (gst_bin_get_by_name pipeline "sink")))
                (set! preserved-threshold (g_object_get_uint64 queue "min-threshold-time"))
                (g_object_set_uint64 queue "min-threshold-time" 0)
                (set! preserved-sync (g_object_get_boolean appsink "sync"))
                (g_object_set_boolean appsink "sync" #f))))))))
  
  
  (method protected (seeking-off self)
    (let ((output (get-output parent)))
      (let ((stream (get-stream (get-channel output))))
        (when (is? stream UDP-Send-Stream)
          (let ((pipeline (get-color-pipeline output)))
            ;; audio only test
            (when pipeline
              (with-unref ((queue (gst_bin_get_by_name pipeline "queue"))
                           (appsink (gst_bin_get_by_name pipeline "sink")))
                (g_object_set_uint64 queue "min-threshold-time" preserved-threshold)
                (g_object_set_boolean appsink "sync" preserved-sync))))))))
  
  
  (method (with-playing self thunk)
    (paused-off self)
    (thunk)
    ;; quick hack give a bit of time for frame to be processed
    (sleep .025)
    (paused-on self))
  
  
  (method (paused-on self)
    (let ((output (get-output parent)))
      (let ((stream (get-stream (get-channel output))))
        (when (is? stream UDP-Send-Stream)
          (let ((pipeline (get-color-pipeline output)))
            ;; audio only test
            (when pipeline
              (gst_element_set_state_blocking pipeline GST_STATE_PAUSED)))))))
  
  
  (method (paused-off self)
    (let ((output (get-output parent)))
      (let ((stream (get-stream (get-channel output))))
        (when (is? stream UDP-Send-Stream)
          (let ((pipeline (get-color-pipeline output)))
            ;; audio only test
            (when pipeline
              (gst_element_set_state_blocking pipeline GST_STATE_PLAYING))))))))


;;;
;;;; Mute
;;;


(class Mute-View extends View
  
  
  (property stream? initialize #f accessors generate)
  (property muted?  initialize #f accessors generate)
  
  
  (method override (draw self surface context)
    (fill-rect surface (new Rect 0 10 16 26) {Color White})
    (set-color surface {Color White})
    (set-line-width surface 1.5)
    (loop (for n from 1 to 10)
          (line surface (+ 16 n) (- 10 n) (+ 16 n) (+ 26 n)))
    (stroke surface)
    (set-line-width surface 4)
    (let ((angle 1.2))
    (arc surface 28 18 10 -1.2 1.2)
    (fill surface)
    (set-line-width surface 5)
    (arc surface 28 18 17 -1.375 1.3)
    (stroke surface))
    (when muted?
      (set-color surface {Color Dark-Red})
      (set-line-width surface 4)
      (line surface 0 36 46 0)))
  
  
  (method override (mouse-up self evt)
    (adjust-muted? self (not muted?)))
  
  
  (method protected (adjust-muted? self flag)
    (set! muted? flag)
    (if stream?
        (let ((client (current-client)))
          (let ((output (get-output parent)))
            (let ((stream (get-stream (get-channel output))))
              (stream-action client (get-no stream) (if muted? 'mute 'unmute) '()))))
      (let ((audio-output (find-audio-output parent)))
        (when audio-output
          (if muted?
              (mute audio-output)
            (unless (shift-down?)
              (when (streaming-audio? audio-output)
                (for-each (lambda (output)
                            (mute output)
                            (let ((circle-view (audio->circle-view output)))
                              (when circle-view
                                (let ((mute-view (child circle-view 'mute)))
                                  (set-muted? mute-view #t)
                                  (invalidate-view mute-view)))))
                          (unmuted-audios ignore: audio-output))))
            (unmute audio-output)))))
    (invalidate-view self)))


;;;
;;;; Volume
;;;


(class Volume-View extends View
  
  
  (property knob initialize #f accessors generate)
  
  
  (slot tracking? initialize #f)
  
  
  (method protected (setup-knob self vol)
    (set! knob (- 1. (* (- 1. vol) (- 1. vol)))))
  
  
  (method override (draw self surface context)
    (set-line-width surface 3)
    (fill-rect surface (new Rect 10 15 110 21) (navigation-bar-color parent))
    (when knob
      (let ((h (+ 20 (fxround (* knob 80.)))))
        (fill-rect surface (new Rect (+ h 10) 15 110 21) {Color red: 160 green: 160 blue: 160})
        (ellipse surface (new Rect (- h 10) 8 (+ h 10) 28) {Color White} {Color White}))))
  
  
  (method override (mouse-down self evt)
    (set! tracking? #t)
    (acquire-capture self)
    (acquire-focus parent)
    (adjust-knob self (get-h evt)))
  
  
  (method override (drag-move self evt)
    (when tracking?
      (adjust-knob self (get-h evt))))
  
  
  (method override (drag-up self evt . rest)
    (when tracking?
      (release-capture self)
      (set! tracking? #f)))

  
  (method (adjust-knob self h)
    (let ((mute-view (find-component parent 'mute)))
      (when (and mute-view (get-muted? mute-view))
        (adjust-muted? mute-view #f)))
    (let ((range (cast <fl> (max 0 (min 80 (- h 20))))))
      (set! knob (/ range 80.))
      (let ((audio-output (find-audio-output parent))
            (asymptotic-volume (- 1. (nthroot (- 1. knob) 3.))))
        (when audio-output
          (set-volume audio-output asymptotic-volume)))
      (invalidate-view self))))


;;;
;;;; Setting-View
;;;


(class Setting-View extends Border-View
  
  
  (form
    (<install>                       size: {Dimension 250 24} border-type: edge style: entry @border-type: solid @border-color: {Color Medium-Gray}
      (<Scroller-View>               hscroll?: #f vscroll?: #f
        (<content~>                  layout-type: fill
          (<Setting-Text> name: text accepts-returns?: #f left-padding: 1 top-padding: 1 background: #f show-unfocused-selection?: #f focus-selects-all?: #t return-press-handler: {Event-Handler :form on-return})))))
  
  
  (method (on-return self evt)
    ))


;;;
;;;; Setting-Text
;;;


(class Setting-Text extends World-Text-View
  
  
  (method override (new-model self)
    (new Text-Model default-style: {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin}} left-padding: 12)))


;;;
;;;; Text-Panel
;;;


(class Circle-Text-Panel extends Layout-View implements Circleable
  
  
  (form
    (<install>                       layout-type: fill
      (<Circle-Text-View> name: text)))
  
  
  (method override (update self out)
    (set-output (locate self 'text) out)
    (set-output (get-player self) out)))


;;;
;;;; Text-View
;;;


(class Circle-Text-View extends World-Text-View
  
  
  (property output initialize #f accessors generate)
  
  
  (method override (new-model self)
    (new Text-Model wrap?: #t left-padding: 1 top-padding: 1))
    
  
  (method override (install self rest)
    (nextmethod self rest)
    (add-style self 'Entry {Text-Style Text-Base font: {Font font-name: tahoma point-size: 24.5 shadow: thin} color: {Color World-Purple}})
    (set-default-style model {Text-Style Entry}))))
