;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Circles
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.circle jazz


(import (jazz.geometry)
        (jazz.opengl.window)
        (jazz.action)
        (world)
        (world.camera)
        (world.context)
        (world.devel)
        (world.interface)
        (world.geometry)
        (world.global)
        (world.hook)
        (world.scriptum)
        (world.skybox)
        (world.task)
        (world.video)
        (world.window)
        (world.zone))


;;;
;;;; Video
;;;


(definition protected (video-outputs)
  (get-ordered-outputs (current-video)))

(definition protected (video-count)
  (length (video-outputs)))

(definition protected (is-output-self? n)
  (ordered-output-self? (current-video) n))

(definition protected (find-output-rank h v)
  (let ((found (find-pane h v)))
    (and found
         (receive (pane pos) found
           (pane->output-rank (current-video) pane)))))


;;;
;;;; Layout
;;;


(definition (circle-geometry count)
  (let ((target (vertex 0. -2.5 0.)))
    (define (general-formula)
      (let ((cg-count (length (circle-matrix-list count))))
        (values target
                (- (* 7.2 cg-count) (* .13 (* cg-count cg-count))) 
                (- 21. (* cg-count 0.4))
                20.
                (if (= count cg-count)
                    5.
                  (if (even? cg-count)
                      (- 5.2 (* cg-count 0.013))
                    5.)))))
    
    (case count
      ((1) (values (vertex 0. 0.5 0.) 12.  1. 35.  .521))
      ((2) (values (vertex 0. 0.5 0.) 12.  1. 35.  .521))
      ((3) (values (vertex 0. 1.5 0.) 19.  4. 35. 6.283))
      ((4) (values (vertex 0. -1.8 0.) 40. 14. 20. 4.754))
      ((5) (values (vertex 0. -2.3 0.) 38. 15. 25. 4.95))
      ((6) (values (vertex 0. -2.3 0.) 46. 16. 20. 5.23))
      @w((6) (values (vertex 0. -2.3 0.) 46. 13. 20. 4.76))
      ((7) (values (vertex 0. -2.3 0.) 44. 13. 26. 4.94))
      (else
       (general-formula)))))


(definition (focus-geometry count)
  (let ((target (vertex 0. (- 26. (/ count 3.2)) 0.)))
    (case count
      ((1) (values (vertex 0. 19.7 0.) 150.  0. 20.  0.))
      ((2) (values (vertex 0. 19. 0.) 150.  0. 20.  6.81))
      ((3) (values (vertex 0. 19. 0.) 150.  0. 20.  6.28))
      ((4) (values (vertex 0. 17.5 0.) 160. 45. 20.  1.3))
      ((5) (values (vertex 0. 18.5 0.) 160. 45. 20.  0.))
      ((6) (values (vertex 0. 19. 0.) 168.  45. 20.  0.2))
      ((7) (values (vertex 0. 19. 0.) 175.  35. 20.  0.2))
      ((8) (values (vertex 0. 20. 0.) 185.  35. 20. 0.2))
      ((9) (values (vertex 0. 20.3 0.) 190.  30. 20. 0.))
      ((10) (values (vertex 0. 20.6 0.) 195. 25. 20. 0.))
      ((11) (values (vertex 0. 21. 0.) 200.  25. 20. 0.))
      (else
       (values target
               (- (* 27. count) (* .8 (* count count))) 
               (- 20. (* count 0.5))
               20.
               0.)))))


(definition public (circle-update-camera count)
  (receive (target radius elevation fov angle) (circle-geometry count)
    (position-camera target radius elevation fov angle)
    (set! camera-angle (normalize-angle angle))))


(definition (calculate-positions count (focus? #f))
  (define (matrix-list circle-size front-group back-group spacing)
    (assert (= count (+ front-group back-group))
      (let ((pos1 1)
            (pos2 front-group)
            (pos3 (+ front-group 2))
            (pos4 (+ front-group 2 back-group))
            (accumulator 0))
        (map (lambda (n)
               (if (or (and (>= n pos1) (<= n pos2))
                       (and (>= n pos3) (<= n pos4)))
                   (+ n accumulator)
                 (set! accumulator (- accumulator 1))
                 #f))
             (naturals 0 circle-size)))))
  (if focus?
      (focus-matrix-list count)
    (circle-matrix-list count)))


(definition (circle-matrix-list count)
  (case count
    ((1)  (list #f #f #f 0  #f #f))
    ((2)  (list #f #f #f 0  1  #f))
    ((3)  (list #f #f #f 0  1  2  #f #f))
    ((4)  (list #f 0  1  #f 2  3))
    ((5)  (list #f 0  1  2  #f 3  4))
    @w((6)  (list #f 0  1  2  #f 3  4  5))
    ((6)  (list #f 0  1  2  3  #f  4  5))
    ((7)  (list #f 0  1  2  3  #f 4  5  6))
    ((8)  (list #f 0  1  2  3  4  #f 5  6  7))
    @w(
    ((9)  (list #f 0  1  2  3  4  #f 5  6  7  8))
    ((10) (list #f 0  1  2  3  4  5  #f 6  7  8  9))
    ((11) (list #f 0  1  2  3  4  5  6  #f 7  8  9  10))
    ((12) (list #f 0  1  2  3  4  5  6  #f 7  8  9  10  11)))
    (else
     (naturals 0 count))))


(definition (focus-matrix-list count)
  (case count
    ((1 2 3 4) (circle-matrix-list count))
    (else
     (naturals 0 count))))


(definition public (circle-matrices count)
  (let ((positions (calculate-positions count)))
    (let ((circle-size (length positions)))
      (collect (lambda (pos)
                 (and pos
                      (let ((rank (find-rank pos positions)))
                        (circle-matrix circle-size rank))))
               positions))))


(definition (circle-matrix count n)
  (copy-matrix
    (matrix-multiply&
      (make-rotation-matrix (vertex 0. 1. 0.) (* (/ PI*2 (cast <fl> count)) (cast <fl> n)))
      (make-translation-matrix (vertex 0. 0. (* 10. (circle-radius count)))))))


(definition (display-info)
  (let ((world (current-world)))
    (let ((count (video-count)))
      (receive (target radius elevation fov angle) (circle-geometry count)
        (display-message world (format "count: {a} radius: {a} fov: {a}" count radius fov))))))


;;;
;;;; Camera
;;;


(definition camera-angle
  2.0)

(definition camera-speed
  0.1)

(definition camera-tick
  #f)


(definition public (circle-install-camera)
  (let ((window (current-window))
        (zone (current-zone)))
    (unless camera-tick
      (set! camera-tick (lambda (elapse)
                          (with-exception-catcher
                            (lambda (exc)
                              (terminal (exception-reason exc)))
                            (lambda ()
                              (circle-path-camera elapse)))))
      (register-tick zone camera-tick)
      ;; removes tearing in the pathing
      (enable-vsync window)
      (circle-path-camera 0.))))


(definition public (circle-uninstall-camera)
  (let ((window (current-window))
        (zone (current-zone)))
    (when camera-tick
      (unregister-tick zone camera-tick)
      (disable-vsync window)
      (set! camera-tick #f))))


(definition (position-camera target radius elevation fov angle)
  (let ((world (current-world)))
    (let ((angle (- PI/2 angle)))
      (let ((x (cos angle))
            (z (sin angle)))
        (let ((flat (vertex+ target (vertex-scalar*& (vertex x 0. z) radius))))
          (let ((pos (vertex+ flat (vertex 0. elevation 0.))))
            (let ((dir (vertex-normalize (vertex-& target pos)))
                  (dir-flat (vertex-normalize (vertex-& target flat))))
              (let ((vert-angle (vector-angle dir dir-flat)))
                (let ((sight dir-flat)
                      (eye (get-eye world))
                      (up (get-world-up world)))
                  (let ((right (cross-product sight up)))
                    (let ((lookat (lookat sight up right)))
                      (set-perspective-fov eye fov)
                      (prepare-projection eye)
                      (free-motion world feedback?: #f)
                      (set-lookat eye (rotate-lookat-vertical& lookat (- vert-angle)))
                      (set-position eye pos)
                      (derive-target eye)
                      (camera-update eye))))))))))))


(definition protected (circle-restore-fov)
  (let ((world (current-world)))
    (let ((eye (get-eye world)))
      (set-perspective-fov eye 45.)
      (prepare-projection eye))))


(definition camera-target-angle
  #f)

(definition camera-target-speed
  #f)


(definition (circle-path-camera elapse)
  (unless sleeping?
    (let ((count (video-count)))
      (when (> count 3)
        (let ((speed (or camera-target-speed camera-speed)))
          (let ((proposed-angle (+ camera-angle (* elapse speed))))
            (when camera-target-angle
              (let ((not-crossing-zero? (< (abs (- camera-angle camera-target-angle)) PI)))
                (let ((current-angle (if not-crossing-zero?
                                         camera-angle
                                       (normalize-angle (+ camera-angle PI))))
                      (target-angle (if not-crossing-zero?
                                        camera-target-angle
                                      (normalize-angle (+ camera-target-angle PI)))))
                  (when (or (and (> camera-target-speed 0) (>= current-angle target-angle))
                            (and (< camera-target-speed 0) (<= current-angle target-angle)))
                    (circle-uninstall-camera)
                    (set! proposed-angle camera-target-angle)
                    (set! camera-target-angle #f)
                    (set! camera-target-speed #f)))))
            (set! camera-angle (normalize-angle proposed-angle))
            (receive (target radius elevation fov angle) (circle-geometry count)
              (position-camera target radius elevation fov camera-angle))))))))


(definition public (circle-toggle-camera)
  (if camera-tick             
      (circle-uninstall-camera)
    (circle-install-camera)))


(definition public (circle-left-rotation)
  (set! camera-speed (abs camera-speed)))

(definition public (circle-right-rotation)
  (set! camera-speed (* -1 (abs camera-speed))))

(definition public (circle-increase-speed)
  (when (< camera-speed .75)
    (set! camera-speed (* camera-speed 1.5))))

(definition public (circle-decrease-speed)
  (when (> camera-speed .02)
    (set! camera-speed (/ camera-speed 1.5))))


(definition public (circle-switch-focus rank)
  (let ((ordered-outputs (video-outputs)))
    (let ((count (length ordered-outputs)))
      (let ((positions (calculate-positions count)))
        (let ((new-rank (cast <fl> (find-rank rank positions)))
              (circle-size (cast <fl> (length positions))))
          (let ((new-angle (* PI*2 (/ new-rank circle-size))))
            (let ((not-crossing-zero? (< (abs (- camera-angle new-angle)) PI)))
              (let ((current-angle (if not-crossing-zero?
                                       camera-angle
                                     (normalize-angle (+ camera-angle PI))))
                    (target-angle (if not-crossing-zero?
                                      new-angle
                                    (normalize-angle (+ new-angle PI)))))
                (if (> target-angle current-angle)
                    (set! camera-target-speed 5.)
                  (set! camera-target-speed -5.))
                (set! camera-target-angle new-angle)
                (circle-install-camera)))))))))

)
