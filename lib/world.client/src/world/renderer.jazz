;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Renderer
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.renderer jazz


(import (jazz.component)
        (jazz.opengl.glew)
        (world)
        (world.animation)
        (world.autoload)
        (world.context)
        (world.entity)
        (world.geometry)
        (world.homogeneous)
        (world.lighting)
        (world.mesh)
        (world.model)
        (world.overlay)
        (world.renderers)
        (world.shader)
        (world.support)
        (world.task))


(proclaim (not check bounds)
          (warn optimizations))


(hub get-point-lights)
(hub element-expanse)


(class Base-Renderer extends Object
  
  
  (slot program <Shader-Program> accessors generate)
  
  
  (method package virtual (reset self)
    )
  
  
  (method package virtual (add-mesh self mesh <Mesh> sector <Sector>)
    )
  
  
  (method package virtual (empty? self)
    )
  
  
  (method package virtual (render self)
    ))


;;;
;;;; Block
;;;


(class Block-Renderer extends Base-Renderer
  
  
  (slot meshes <Axis> getter generate)
  
  
  (method override (initialize self program)
    (let ((world (current-world)))
      (set! self.program (find-mesh-program world program))
      (set! self.meshes (new Axis 0))))
  
  
  (method override (reset self)
    (assert-task-mutex)
    (set-size meshes 0))
  
  
  (method override (add-mesh self mesh <Mesh> sector <Sector>)
    (assert-task-mutex)
    (axis-add meshes mesh)
    (axis-add meshes sector))
  
  
  (method override (empty? self)
    (assert-task-mutex)
    (= 0 (get-size meshes)))
  
  
  (method (draw-meshes self material alpha-cut)
    (assert-task-mutex)
    (let ((world (current-world)))
      (let ((size (get-size meshes))
            (content (get-content meshes)))
        (when (> size 0)
          (bind-material program material)
          (bind-uniforms program #f no-overlay alpha-cut (current-lighting))
          (loop (for i from 0 below size by 2)
                (let ((mesh <Mesh> (vector-ref content i))
                      (sector <Sector> (vector-ref content (+ i 1))))
                  (vector-set! content i #f)
                  (vector-set! content (+ i 1) #f)
                  (bind-mesh-matrix program (get-position& sector))
                  (draw-mesh program mesh)))
          (unbind-uniforms program)))))
  
  
  (method package virtual (bind-uniforms self entity <Entity> model <Model> overlay alpha-cut lighting animate?)
    (bind-uniforms program #f overlay alpha-cut lighting))
  
  
  (method package virtual (unbind-uniforms self)
    (unbind-uniforms program)))


;;;
;;;; Model
;;;


(class Model-Renderer extends Base-Renderer
  
  
  (slot meshes   <Axis> getter generate)
  (slot entities <Axis> getter generate)
  (slot ghosts   <Axis> getter generate)
  
  
  (method override (initialize self program)
    (let ((world (current-world)))
      (set! self.program (find-mesh-program world program))
      (set! self.meshes (new Axis 0))
      (set! self.entities (new Axis 0))
      (set! self.ghosts (new Axis 0))))
  
  
  (method override (reset self)
    (assert-task-mutex)
    (set-size meshes 0)
    (set-size entities 0)
    (set-size ghosts 0))
  
  
  (method override (add-mesh self mesh <Mesh> sector <Sector>)
    (assert-task-mutex)
    (axis-add meshes mesh)
    (axis-add meshes sector))
  
  
  (method package (add-entity self entity model mesh <Mesh> lighting)
    (assert-task-mutex)
    (axis-add entities entity)
    (axis-add entities model)
    (axis-add entities mesh)
    (axis-add entities lighting))
  
  
  (method package (add-ghost self entity model mesh <Mesh> matrix <matrix> moment <fx>)
    (assert-task-mutex)
    (axis-add ghosts entity)
    (axis-add ghosts model)
    (axis-add ghosts mesh)
    (axis-add ghosts matrix)
    (axis-add ghosts moment))
  
  
  (method override (empty? self)
    (assert-task-mutex)
    (and (= 0 (get-size meshes))
         (= 0 (get-size entities))
         (= 0 (get-size ghosts))))
  
  
  (method package (draw self alpha-cut)
    (assert-task-mutex)
    (draw-meshes self alpha-cut)
    (draw-entities self alpha-cut)
    (draw-ghosts self alpha-cut))
  
  
  (method (draw-meshes self alpha-cut)
    (assert-task-mutex)
    (let ((world (current-world)))
      (let ((size (get-size meshes))
            (content (get-content meshes))
            (material? (bind-material? program)))
        (when (> size 0)
          (bind-uniforms program #f no-overlay alpha-cut (current-lighting))
          (loop (for i from 0 below size by 2)
                (let ((mesh <Mesh> (vector-ref content i))
                      (sector <Sector> (vector-ref content (+ i 1))))
                  (vector-set! content i #f)
                  (vector-set! content (+ i 1) #f)
                  (when material?
                    (bind-material program (get-material mesh)))
                  (bind-mesh-matrix program (get-position& sector))
                  (draw-mesh program mesh)))
          (unbind-uniforms program)))))
  
  
  (method (draw-entities self alpha-cut)
    (assert-task-mutex)
    (let ((size (get-size entities))
          (content (get-content entities))
          (material? (bind-material? program)))
      (when (> size 0)
        (loop (for i from 0 below size by 4)
              (let ((entity <Entity> (vector-ref content i))
                    (model <Model> (vector-ref content (+ i 1)))
                    (mesh <Mesh> (vector-ref content (+ i 2)))
                    (lighting <Lighting+> (vector-ref content (+ i 3))))
                (vector-set! content i #f)
                (vector-set! content (+ i 1) #f)
                (vector-set! content (+ i 2) #f)
                (vector-set! content (+ i 3) #f)
                (let ((matrix (matrix-multiply& (get-matrix entity) (get-global-matrix model))))
                  (when material?
                    (bind-material program (get-material mesh)))
                  (setup-sector-lights (current-lighting) (get-point-lights (element-expanse (current-zone) entity)))
                  (bind-uniforms self entity model (get-overlay entity) alpha-cut (or lighting (current-lighting)) #t)
                  (bind-entity-matrix program matrix)
                  (draw-mesh program mesh)
                  (unbind-uniforms self))
                (set-rendering? entity #f))))))
  
  
  ;; temp copy/paste of draw-entities
  (method (draw-ghosts self alpha-cut)
    (assert-task-mutex)
    (let ((size (get-size ghosts))
          (content (get-content ghosts))
          (material? (bind-material? program)))
      (when (> size 0)
        (loop (for i from 0 below size by 5)
              (let ((entity <Entity> (vector-ref content i))
                    (model <Model> (vector-ref content (+ i 1)))
                    (mesh <Mesh> (vector-ref content (+ i 2)))
                    (matrix <matrix> (vector-ref content (+ i 3)))
                    (moment <fx> (vector-ref content (+ i 4))))
                (vector-set! content i #f)
                (vector-set! content (+ i 1) #f)
                (vector-set! content (+ i 2) #f)
                (vector-set! content (+ i 3) #f)
                (vector-set! content (+ i 4) #f)
                (let ((matrix (matrix-multiply& matrix (get-global-matrix model))))
                  (when material?
                    (bind-material program (get-material mesh)))
                  (let ((overlay (if (= moment 0)
                                     #f32(1. 1. 1. 1.)
                                   #f32(1. 1. 1. .3))))
                    (bind-uniforms self entity model overlay alpha-cut (current-lighting) #f))
                  (bind-entity-matrix program matrix)
                  (draw-mesh program mesh)
                  (unbind-uniforms self)))))))
  
  
  (method package virtual (bind-uniforms self entity <Entity> model <Model> overlay alpha-cut lighting animate?)
    (bind-uniforms program (and animate? (entity-animate? entity) (get-bone-matrices (cast <Morphing> (get-morphing entity)))) overlay alpha-cut lighting))
  
  
  (method package virtual (unbind-uniforms self)
    (unbind-uniforms program)))


;;;
;;;; Renderers
;;;


(definition public (prepare-renderes)
  ;; block
  (set-opaque-block-renderer (register-renderer 'opaque-block (new Opaque-Block-Renderer 'block)))
  (set-transparent-block-renderer (register-renderer 'transparent-block (new Transparent-Block-Renderer 'block)))
  (set-coverage-block-renderer (register-renderer 'coverage-block (new Coverage-Block-Renderer 'block)))
  (set-water-block-renderer (register-renderer 'water-block (new (if arb-multisample? Water-Block-Renderer Transparent-Block-Renderer) 'water-block)))
  (set-wet-block-renderer (register-renderer 'wet-block (new Opaque-Block-Renderer 'wet-block)))
  (set-multitexture-block-renderer (register-renderer 'multitexture-block (new Multitexture-Block-Renderer 'multitexture-block)))
  ;; model
  (set-opaque-renderer (register-renderer 'opaque (new Opaque-Renderer 'model)))
  (set-transparent-renderer (register-renderer 'transparent (new Transparent-Renderer 'model)))
  (set-culled-transparent-renderer (register-renderer 'culled-transparent (new Culled-Transparent-Renderer 'model)))
  (set-coverage-renderer (register-renderer 'coverage (new Coverage-Renderer 'model)))
  (set-occlusion-renderer (register-renderer 'occlusion (new Transparent-Renderer 'occlusion)))
  (set-wireframe-renderer (register-renderer 'wireframe (new Transparent-Renderer 'wireframe)))
  (set-squareframe-renderer (register-renderer 'squareframe (new Transparent-Renderer 'squareframe)))
  (set-white-renderer (register-renderer 'white (new Transparent-Renderer 'white)))
  (set-radial-blur-renderer (register-renderer 'radial-blur (new Transparent-Renderer 'radial-blur)))
  (set-motion-blur-renderer (register-renderer 'motion-blur (new Transparent-Renderer 'motion-blur)))
  (set-water-renderer (register-renderer 'water (new (if arb-multisample? Water-Renderer Transparent-Renderer) 'water)))
  (set-julia-renderer (register-renderer 'julia (new Transparent-Renderer 'julia)))
  (set-sierpinski-renderer (register-renderer 'sierpinski (new Transparent-Renderer 'sierpinski)))
  (set-multitexture-renderer (register-renderer 'multitexture (new Transparent-Renderer 'multitexture)))
  (set-kaleidoscope-renderer (register-renderer 'kaleidoscope (new Transparent-Renderer 'kaleidoscope)))
  (set-tunnel-renderer (register-renderer 'tunnel (new Transparent-Renderer 'tunnel)))
  (set-square-tunnel-renderer (register-renderer 'square-tunnel (new Transparent-Renderer 'square-tunnel)))
  (set-fly-renderer (register-renderer 'fly (new Transparent-Renderer 'fly)))
  (set-color-renderer (register-renderer 'color (new Color-Renderer 'color)))
  (set-orb-renderer (register-renderer 'orb (new Orb-Renderer 'playerframe)))
  (set-eye-renderer (register-renderer 'eye (new Eye-Renderer 'color)))
  (set-enemy-renderer (register-renderer 'enemy (new Enemy-Renderer 'color)))
  (set-missile-renderer (register-renderer 'missile (new Missile-Renderer 'playerframe)))
  (set-texture-renderer (register-renderer 'texture (new Texture-Renderer)))
  (set-console-renderer (register-renderer 'console (new Console-Renderer)))
  (set-drawable-renderer (register-renderer 'drawable (new Drawable-Renderer 'color))))


;;;
;;;; Opaque-Block-Renderer
;;;


(class Opaque-Block-Renderer extends Block-Renderer
  
  
  (method override (render self)
    (assert-task-mutex)
    (unless (empty? self)
      (use program)
      (draw-meshes self (get-block-opaque (current-world)) 0.)
      (unuse program))))


;;;
;;;; Transparent-Block-Renderer
;;;


(class Transparent-Block-Renderer extends Block-Renderer
  
  
  (method override (render self)
    (assert-task-mutex)
    (unless (empty? self)
      (use program)
      (draw-meshes self (get-block-transparent (current-world)) .7)
      (unuse program))))


;;;
;;;; Coverage-Block-Renderer
;;;


(class Coverage-Block-Renderer extends Block-Renderer
  
  
  (method override (render self)
    (assert-task-mutex)
    (unless (empty? self)
      (use program)
      (glEnable GL_SAMPLE_ALPHA_TO_COVERAGE_ARB)
      (draw-meshes self (get-block-coverage (current-world)) 0.)
      (glDisable GL_SAMPLE_ALPHA_TO_COVERAGE_ARB)
      (unuse program))))


;;;
;;;; Water-Block-Renderer
;;;


(class Water-Block-Renderer extends Block-Renderer
  
  
  (method override (render self)
    (assert-task-mutex)
    (unless (empty? self)
      (use program)
      (glEnable GL_SAMPLE_ALPHA_TO_COVERAGE_ARB)
      (draw-meshes self (get-block-water (current-world)) 0.)
      (glDisable GL_SAMPLE_ALPHA_TO_COVERAGE_ARB)
      (unuse program))))


;;;
;;;; Multitexture-Block-Renderer
;;;


(class Multitexture-Block-Renderer extends Block-Renderer
  
  
  (method override (render self)
    (assert-task-mutex)
    (unless (empty? self)
      (use program)
      (draw-meshes self (get-block-multitexture (current-world)) .7)
      (unuse program))))


;;;
;;;; Opaque-Renderer
;;;


(class Opaque-Renderer extends Model-Renderer
  
  
  (method override (render self)
    (assert-task-mutex)
    (unless (empty? self)
      (use program)
      (draw self 0.)
      (unuse program))))


;;;
;;;; Transparent-Renderer
;;;


(class Transparent-Renderer extends Model-Renderer
  
  
  (method override (render self)
    (assert-task-mutex)
    (unless (empty? self)
      (use program)
      ;; meshes / entities
      (draw-meshes self .7)
      (draw-entities self .7)
      ;; ghosts
      (glEnable GL_CULL_FACE)
      (glCullFace GL_FRONT)
      (glEnable GL_BLEND)
      (draw-ghosts self .2)
      (glDisable GL_BLEND)
      (glCullFace GL_BACK)
      (glDisable GL_CULL_FACE)
      (unuse program))))


;;;
;;;; Culled-Transparent-Renderer
;;;


(class Culled-Transparent-Renderer extends Model-Renderer
  
  
  (method override (render self)
    (assert-task-mutex)
    (unless (empty? self)
      (use program)
      (glEnable GL_BLEND)
      (glEnable GL_CULL_FACE)
      (glCullFace GL_FRONT)
      (draw self .7)
      (glDisable GL_BLEND)
      (glCullFace GL_BACK)
      (glDisable GL_CULL_FACE)
      (unuse program))))


;;;
;;;; Coverage-Renderer
;;;


(class Coverage-Renderer extends Model-Renderer
  
  
  (method override (render self)
    (assert-task-mutex)
    (unless (empty? self)
      (use program)
      (glEnable GL_SAMPLE_ALPHA_TO_COVERAGE_ARB)
      (draw self 0.)
      (glDisable GL_SAMPLE_ALPHA_TO_COVERAGE_ARB)
      (unuse program))))


;;;
;;;; Water-Renderer
;;;


(class Water-Renderer extends Model-Renderer
  
  
  (method override (render self)
    (assert-task-mutex)
    (unless (empty? self)
      (use program)
      (glEnable GL_SAMPLE_ALPHA_TO_COVERAGE_ARB)
      (draw self 0.)
      (glDisable GL_SAMPLE_ALPHA_TO_COVERAGE_ARB)
      (unuse program))))


;;;
;;;; Color-Renderer
;;;


(class Color-Renderer extends Model-Renderer
  
  
  (method override (render self)
    (assert-task-mutex)
    (unless (empty? self)
      (use program)
      (draw self .1)
      (unuse program)))
  
  
  (method override (bind-uniforms self entity <Entity> model <Model> overlay alpha-cut lighting animate?)
    (model-bind-uniforms model entity program overlay alpha-cut lighting)))


;;;
;;;; Orb-Renderer
;;;


(class Orb-Renderer extends Model-Renderer
  
  
  (method override (render self)
    (assert-task-mutex)
    (unless (empty? self)
      (use program)
      (glEnable GL_CULL_FACE)
      (glCullFace GL_FRONT)
      (glEnable GL_BLEND)
      (draw self .1)
      (glDisable GL_BLEND)
      (glCullFace GL_BACK)
      (glDisable GL_CULL_FACE)
      (unuse program)))
  
  
  (method override (bind-uniforms self entity <Entity> model <Model> overlay alpha-cut lighting animate?)
    (model-bind-uniforms model entity program overlay alpha-cut lighting)))


;;;
;;;; Eye-Renderer
;;;


(class Eye-Renderer extends Model-Renderer
  
  
  (method override (render self)
    (assert-task-mutex)
    (unless (empty? self)
      (use program)
      (glEnable GL_CULL_FACE)
      (glCullFace GL_FRONT)
      (glEnable GL_BLEND)
      (draw self 0.)
      (glDisable GL_BLEND)
      (glCullFace GL_BACK)
      (glDisable GL_CULL_FACE)
      (unuse program)))
  
  
  (method override (bind-uniforms self entity <Entity> model <Model> overlay alpha-cut lighting animate?)
    (model-bind-uniforms model entity program overlay alpha-cut lighting)))


;;;
;;;; Enemy-Renderer
;;;


(class Enemy-Renderer extends Model-Renderer
  
  
  (method override (render self)
    (assert-task-mutex)
    (unless (empty? self)
      (use program)
      (glEnable GL_CULL_FACE)
      (glCullFace GL_FRONT)
      (glEnable GL_SAMPLE_ALPHA_TO_COVERAGE_ARB)
      (draw self 0.)
      (glDisable GL_SAMPLE_ALPHA_TO_COVERAGE_ARB)
      (glCullFace GL_BACK)
      (glDisable GL_CULL_FACE)
      (unuse program)))
  
  
  (method override (bind-uniforms self entity <Entity> model <Model> overlay alpha-cut lighting animate?)
    (model-bind-uniforms model entity program overlay alpha-cut lighting)))


;;;
;;;; Missile-Renderer
;;;


(class Missile-Renderer extends Model-Renderer
  
  
  (method override (render self)
    (assert-task-mutex)
    (unless (empty? self)
      (use program)
      (glEnable GL_CULL_FACE)
      (glCullFace GL_FRONT)
      (glEnable GL_BLEND)
      (draw self .1)
      (glDisable GL_BLEND)
      (glCullFace GL_BACK)
      (glDisable GL_CULL_FACE)
      (unuse program)))
  
  
  (method override (bind-uniforms self entity <Entity> model <Model> overlay alpha-cut lighting animate?)
    (unless (get-rendered? entity)
      (set-rendered? entity #t))
    (model-bind-uniforms model entity program overlay alpha-cut lighting)))


;;;
;;;; Texture-Renderer
;;;


(class Texture-Renderer extends Base-Renderer
  
  
  (slot elements <Axis> getter generate)
  
  
  (method override (initialize self)
    (let ((world (current-world)))
      (set! self.program (get-texture-program world))
      (set! self.elements (new Axis 0))))
  
  
  (method override (reset self)
    (assert-task-mutex)
    (set-size elements 0))
  
  
  (method override (empty? self)
    (assert-task-mutex)
    (= 0 (get-size elements)))
  
  
  (method override (render self)
    (assert-task-mutex)
    (let ((camera (current-camera)))
      (glEnable GL_SAMPLE_ALPHA_TO_COVERAGE_ARB)
      (use program)
      (let ((size (get-size elements))
            (content (get-content elements)))
        (loop (for i from 0 below size)
              (let ((element <Element> (vector-ref content i)))
                (vector-set! content i #f)
                (bind-uniforms program (get-projection-matrix camera) (get-view-matrix camera) (get-matrix element))
                (bind-entity-matrix program (get-matrix element))
                (render element))))
      (unuse program)
      (glDisable GL_SAMPLE_ALPHA_TO_COVERAGE_ARB))))


;;;
;;;; Console-Renderer
;;;


(class Console-Renderer extends Base-Renderer
  
  
  (slot elements <Axis> getter generate)
  
  
  (method override (initialize self)
    (let ((world (current-world)))
      (set! self.program (get-texture-program world))
      (set! self.elements (new Axis 0))))
  
  
  (method override (reset self)
    (assert-task-mutex)
    (set-size elements 0))
  
  
  (method override (empty? self)
    (assert-task-mutex)
    (= 0 (get-size elements)))
  
  
  (method override (render self)
    (proclaim (not check types))
    (assert-task-mutex)
    (let ((camera (current-camera)))
      (glEnable GL_BLEND)
      (use program)
      (let ((size (get-size elements))
            (content (get-content elements))
            (camera-pos (get-position camera)))
        (when (> size 0)
          ;; compute distances
          (loop (for i from 0 below size by 2)
                (let ((pane (vector-ref content i)))
                  (let ((dist (or (vector-ref content (+ i 1))
                                  (let ((d (make-f64)))
                                    (vector-set! content (+ i 1) d)
                                    d))))
                    (vertex-distance! dist camera-pos (get-position (get-entity pane))))))
          ;; insertion sort
          (let (outer (i 2))
            (when (< i size)
              (let (inner (j i))
                (when (> j 0)
                  (let ((p <fv> (vector-ref content (- j 1)))
                        (n <fv> (vector-ref content (+ j 1))))
                    (unless (> p n)
                      (let ((p (vector-ref content (- j 2)))
                            (n (vector-ref content j)))
                        (vector-set! content (- j 2) n)
                        (vector-set! content j p))
                      (vector-set! content (- j 1) n)
                      (vector-set! content (+ j 1) p)
                      (inner (- j 2))))))
              (outer (+ i 2))))
          ;; render panes
          (loop (for i from 0 below size by 2)
                (let ((pane (vector-ref content i)))
                  (bind-uniforms program (get-projection-matrix camera) (get-view-matrix camera) (get-matrix pane))
                  (bind-entity-matrix program (get-matrix pane))
                  (render pane)
                  (vector-set! content i #f)))))
      (unuse program)
      (glDisable GL_BLEND))))


;;;
;;;; Drawable-Renderer
;;;


(class Drawable-Renderer extends Model-Renderer
  
  
  (method override (render self)
    (assert-task-mutex)
    (let ((size (get-size entities))
          (content (get-content entities)))
      (loop (for i from 0 below size)
            (let ((element <Element> (vector-ref content i)))
              (vector-set! content i #f)
              (render element))))))


;;;
;;;; Occlusion
;;;


(definition occlusion?
  #f)

(definition public (get-occlusion?)
  occlusion?)

(definition public (set-occlusion? flag)
  (set! occlusion? flag))


;;;
;;;; Wireframe
;;;


(definition wireframe?
  #f)

(definition public (get-wireframe?)
  wireframe?)

(definition public (set-wireframe? flag)
  (set! wireframe? flag))


;;;
;;;; Register
;;;


(definition override-renderer
  #f)

(definition public (get-override-renderer)
  override-renderer)

(definition public (set-override-renderer renderer)
  (set! override-renderer renderer))


;; aec quicky
(definition public (register-entity entity <Entity> (include-invisibles? #f) (renderer #f) (lighting #f))
  (define (add-model model <Model> meshes)
    (loop (for mesh <Mesh> in-vector meshes)
          (let ((renderer <Model-Renderer> (or renderer (get-renderer entity) (effective-renderer model mesh))))
            (add-entity renderer entity model mesh lighting)))
    (for-each (lambda (child <Model>)
                (add-model child (get-meshes child)))
              (get-children model)))
  
  (define (effective-renderer model <Model> mesh <Mesh>)
    (let ((material (get-material mesh)))
      (or (and material (get-renderer material))
          (model-renderer model))))
  
  (assert-task-mutex)
  (when (or (get-visible? entity) include-invisibles?)
    (unless (virtual? entity)
      (if (renderable? entity)
          (axis-add (get-entities (get-drawable-renderer)) entity)
        (add-model (cache-model entity)
                   (entity-meshes entity))))
    (register-parts entity)))


(definition public (register-texture-elements elements)
  (assert-task-mutex)
  (let ((axis (get-elements (get-texture-renderer))))
    (for-each (lambda (element)
                (axis-add axis element))
              elements)))


(definition public (register-texture-element element)
  (assert-task-mutex)
  (let ((axis (get-elements (get-texture-renderer))))
    (axis-add axis element)))


(definition public (register-console-element element)
  (assert-task-mutex)
  (let ((axis (get-elements (get-console-renderer))))
    (axis-add axis element)
    (axis-add axis #f)))


;; temp copy/paste of register-entity
(definition public (register-ghost entity <Entity> model <Model> meshes <object> matrix <matrix> moment <fx>)
  (define (add-model model <Model> meshes)
    (loop (for mesh <Mesh> in-vector meshes)
          (let ((renderer <Model-Renderer> (or (get-renderer entity) (effective-renderer model mesh))))
            (add-ghost renderer entity model mesh matrix moment)))
    (for-each (lambda (child <Model>)
                (add-model child (get-meshes child)))
              (get-children model)))
  
  (define (effective-renderer model <Model> mesh <Mesh>)
    (let ((material (get-material mesh)))
      (or (and material (get-renderer material))
          (model-renderer model))))
  
  (assert-task-mutex)
  (add-model model meshes))


;;;
;;;; Render
;;;


(definition public (render-opaque)
  (render (get-opaque-block-renderer))
  (render (get-opaque-renderer))
  (render (get-wet-block-renderer)))


(definition public (render-transparent)
  (render (get-occlusion-renderer))
  (render (get-wireframe-renderer))
  (render (get-squareframe-renderer))
  (render (get-white-renderer))
  (render (get-radial-blur-renderer))
  (render (get-motion-blur-renderer))
  (render (get-water-block-renderer))
  (render (get-water-renderer))
  (render (get-julia-renderer))
  (render (get-sierpinski-renderer))
  (render (get-multitexture-block-renderer))
  (render (get-multitexture-renderer))
  (render (get-kaleidoscope-renderer))
  (render (get-tunnel-renderer))
  (render (get-square-tunnel-renderer))
  (render (get-fly-renderer))
  (render (get-color-renderer))
  (render (get-transparent-block-renderer))
  (render (get-transparent-renderer))
  (render (get-culled-transparent-renderer))
  (render (get-coverage-block-renderer))
  (render (get-coverage-renderer))
  (render (get-texture-renderer))
  (render (get-console-renderer))
  (render (get-drawable-renderer)))


(definition public (render-orb)
  (render (get-eye-renderer))
  (render (get-orb-renderer))
  (render (get-enemy-renderer))
  (render (get-missile-renderer))))
