;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Audio
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.audio jazz


(import (jazz.graphic)
        (jazz.gstreamer)
        (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.billboard)
        (world.configure)
        (world.foreign.gstreamer)
        (world.geometry)
        (world.id)
        (world.quad-texture)
        (world.settings)
        (world.stream)
        (world.syntax (phase syntax))
        (world.task))


(definition audio-codec
  (world-setting 'world.audio-codec 'vorbis))


(definition audio-debug?
  (world-setting 'world.audio-debug? #f))


;;;
;;;; Start
;;;


(definition protected (start-audio)
  (when (and (client?) (world-setting 'world.audio-input? #f))
    (start-input~ (current-audio))))


;;;
;;;; Task
;;;


(definition public (audio-task task <Task>)
  (declare (proper-tail-calls))
  (let ((audio (current-audio)))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-seconds)))
          (let ((time (current-seconds)))
            (let ((elapse (- time previous)))
              (unless (stopping?~ task)
                (site (audio on?: #t)
                  (process-audio)))
              (let ((duration (- (current-seconds) time)))
                (task-sleep task audio-period duration exit))
              (iter time))))))))


(definition (process-audio)
  (when (client?)
    (process-input~ (current-audio))))


;;;
;;;; Audio
;;;


(class World-Audio extends Object
  
  
  (slot input?   <bool>      initialize #f accessors generate)
  (slot pipeline             initialize #f accessors generate)
  (slot sink                 initialize #f accessors generate)
  (slot buffer   <u8vector>  initialize #f accessors generate)
  (slot info     <u64vector> initialize #f accessors generate)
  
  
  (method (on-toggle-audio evt)
    (toggle-input))
  
  
  (method (toggle-input)
    (when (client?)
      (let ((world (current-world)))
        (if (not input?)
            (start-input)
          (stop-input))
        (update-parameter~ world 'audio)
        (display-on/off~ world "Audio" input?))))
  
  
  (method (start-input)
    (unless input?
      (init-gstreamer)
      (let ((codec audio-codec))
        (let ((pipeline (gst-launch "autoaudiosrc format=F32LE layout=interleaved rate=8000 channels=2 name=src"
                                    (and (eq? codec 'opus) (tie "avenc_opus name=enc"))
                                    (and (eq? codec 'vorbis) (tie "vorbisenc name=enc"))
                                    "appsink name=sink")))
          (gst_object_set_name pipeline "input")
          (let ((sink (gst_bin_get_by_name pipeline "sink"))
                (buffer (make-u8vector 4096))
                (info (make-u64vector 2)))
            (gst_element_set_state pipeline GST_STATE_PLAYING)
            (set! buffer~self buffer)
            (set! info~self info)
            (set! pipeline~self pipeline)
            (set! sink~self sink)
            (set! input? #t))))))
  
  
  (method (stop-input)
    (when input?
      (gst_element_set_state pipeline GST_STATE_NULL)
      (gst_object_unref pipeline)
      (set! info #f)
      (set! buffer #f)
      (set! pipeline #f)
      (set! sink #f)
      (set! input? #f)))
  
  
  (method (process-input)
    (when input?
      (let ((size (gst_app_sink_read sink buffer info)))
        (when (/= size -1)
          (let ((timestamp (u64vector-ref info 0))
                (duration (u64vector-ref info 1)))
            (when audio-debug?
              (terminal 'audio 'input 'send size))
            (send-client-audio~ (client-tier) (subu8vector buffer 0 size) timestamp duration)))))))


;;;
;;;; Output
;;;


(class World-Audio-Output extends Object
  
  
  (slot id              initialize #f accessors generate)
  (slot output?  <bool> initialize #f accessors generate)
  (slot pipeline        initialize #f accessors generate)
  (slot src             initialize #f accessors generate)
  
  
  (method override (initialize id)
    (nextmethod)
    (set! id~self id))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" id))))
  
  
  (method (start-output)
    (unless output?
      (init-gstreamer)
      (let ((codec audio-codec))
        (let ((pipeline (gst-launch (tie "appsrc name=src")
                                    (and (eq? codec 'opus) "avdec_opus name=dec")
                                    (and (eq? codec 'vorbis) "vorbisdec name=dec")
                                    (tie "autoaudiosink name=sink"))))
          (gst_object_set_name pipeline "output")
          (let ((src (gst_bin_get_by_name pipeline "src")))
            (case codec
              ((vorbis)
               (gst_app_src_set_caps src
                 (gst_caps "audio/x-vorbis")))
              (else
               (gst_app_src_set_caps src
                 (gst_caps "audio/x-raw"
                   "format"   (g_value_string "F32LE")
                   "layout"   (g_value_string "interleaved")
                   "rate"     (g_value_int 8000)
                   "channels" (g_value_int 2)))))
            (g_object_set src
              "is-live"     (g_value_boolean #t)
              "stream-type" (g_value_int GST_APP_STREAM_TYPE_STREAM)
              "format"      (g_value_int GST_FORMAT_TIME))
            (gst_element_set_state pipeline GST_STATE_PLAYING)
            (set! pipeline~self pipeline)
            (set! src~self src)
            (set! output? #t))))))
  
  
  (method (stop-output)
    (when output?
      (gst_element_set_state pipeline GST_STATE_NULL)
      (gst_object_unref pipeline)
      (set! pipeline #f)
      (set! src #f)
      (set! output? #f)))
  
  
  (method (receive-output bytes timestamp duration)
    (when audio-debug?
      (terminal 'audio 'output 'receive (u8vector-length bytes)))
    (gst_app_src_write3 src bytes (u8vector-length bytes) timestamp duration)))


;;;
;;;; Outputs
;;;


(definition audio-outputs
  (make-table test: equal?))


(definition (cache-audio-output id)
  (or (table-ref audio-outputs id #f)
      (let ((output (new World-Audio-Output id)))
        (table-set! audio-outputs id output)
        output)))


(definition public (receive-server-audio id bytes timestamp duration)
  (let ((output (cache-audio-output id)))
    (start-output~ output)
    (receive-output~ output bytes timestamp duration))))
