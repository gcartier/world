;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Audio
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.audio jazz


(import (jazz.stream)
        (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.configure)
        (world.context)
        (world.settings)
        (world.task))


(definition protected audio-codec
  (world-setting 'world.audio-codec 'vorbis))


(definition audio-show
  (world-setting 'world.audio-show #f))


(definition audio-debug?
  (world-setting 'world.audio-debug? #f))


;;;
;;;; Audio
;;;


(definition protected (new-world-audio)
  (let ((mic-src (new Mic-Audio-Src))
        (server-sink (new Stream-Sink
                       consumer: (lambda (buffer timestamp duration)
                                   (send-client-audio (current-client) buffer timestamp duration)))))
    (new World-Audio input: (pipeline mic-src server-sink))))


(class World-Audio extends Object
  
  
  (slot input        getter generate)
  (slot outputs      getter generate)
  (slot receive-hook accessors generate)
  
  
  (method override (initialize self (input: input #f))
    (nextmethod self)
    (set! self.input input)
    (set! self.outputs (make-table test: equal?))
    (set! receive-hook #f))
  
  
  (method package (autostart self)
    (when (world-setting 'world.audio-autostart? #f)
      (start self)))
  
  
  (method package (start self)
    (start input))
  
  
  (method package (stop self)
    (release input))
  
  
  (method package (reset self)
    (let ((mic (car (get-elements input))))
      (let ((pipeline (get-pipeline mic)))
        (when pipeline
          (gst_element_set_state pipeline GST_STATE_READY)
          (gst_element_set_state pipeline GST_STATE_PLAYING)))))
  
  
  ;;;
  ;;;; Input
  ;;;
  
  
  (method (on-toggle-audio self evt)
    (toggle-audio self))
  
  
  (method package (toggle-audio self)
    (when (client?)
      (if (audio-playing? self)
          (stop-audio self)
        (start-audio self))))
  
  
  (method package (start-audio self (feedback?: feedback? #t))
    (when (client?)
      (let ((world (current-world)))
        (start self)
        (update-parameter world 'audio)
        (when feedback?
          (display-on/off world "Audio" (playing? input))))))
  
  
  (method package (stop-audio self (feedback?: feedback? #t))
    (when (client?)
      (let ((world (current-world)))
        (stop self)
        (update-parameter world 'audio)
        (when feedback?
          (display-on/off world "Audio" (playing? input))))))
  
  
  (method package (audio-playing? self)
    (playing? input))
  
  
  ;;;
  ;;;; Output
  ;;;
  
  
  (method package (find-output self id)
    (table-ref outputs id #f))
  
  (method package (register-output self id output)
    (table-set! outputs id output))
  
  
  (method package (player-output self id)
    (or (table-ref outputs id #f)
        (let ((output (new-output self)))
          (table-set! outputs id output)
          output)))
  
  
  (method (new-output self)
    (new Audio-Sink
      codec: audio-codec))
  
  
  (method package (receive-server-audio self id buffer timestamp duration)
    (unless (and receive-hook
                 (receive-hook self id buffer timestamp duration))
      (if (not buffer)
          (let ((output (find-output self id)))
            (when output
              (table-clear outputs id)
              (release output)))
        (let ((output (player-output self id)))
          (setup output)
          (start output)
          (consume output buffer timestamp duration))))))


;;;
;;;; Audio-Src
;;;


(class Audio-Src extends Stream-Src)


;;;
;;;; Mic-Audio-Src
;;;


(class Mic-Audio-Src extends Audio-Src
  
  
  (slot pipeline              initialize #f accessors generate)
  (slot appsink               initialize #f accessors generate)
  (slot data     <u8vector+>  initialize #f accessors generate)
  (slot info     <u64vector+> initialize #f accessors generate)
  (slot task                  initialize #f accessors generate)
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((codec audio-codec))
      (let ((pipeline (gst-launch (cond-expand
                                    (windows "autoaudiosrc format=S16LE layout=interleaved rate=80000 channels=2 name=src")
                                    (else "autoaudiosrc format=F32LE layout=interleaved rate=80000 channels=2 name=src"))
                                  (and (eq? codec 'opus) (tie "avenc_opus name=enc"))
                                  (and (eq? codec 'vorbis) (tie "vorbisenc name=enc"))
                                  "appsink name=sink")))
        (gst_object_set_name pipeline "mic")
        (let ((appsink (gst_bin_get_by_name pipeline "sink"))
              (data (make-u8vector 4096))
              (info (make-u64vector 2)))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.data data)
          (set! self.info info)
          (set! self.pipeline pipeline)
          (set! self.appsink appsink)))))
  
  
  (method override (start-element self)
    (define (task-start)
      (let ((procedure
              (lambda (task)
                (mic-task self task))))
        (let ((task (new Task 'mic procedure priority: audio-priority)))
          (start-task task)
          (set! self.task task))))
    
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING)
    (task-start))
  
  
  (method override (stop-element self)
    (define (task-stop)
      (halt-task task)
      (set! task #f))
    
    (nextmethod self)
    (task-stop)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! info #f)
    (set! data #f)
    (set! pipeline #f)
    (set! appsink #f)
    (consume sink #f #f #f))
  
  
  (method (mic-task self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-seconds)))
          ;; not 100% correct if preempted before task-mutex
          (let ((time (current-seconds)))
            (unless (stopping? task)
              (site (audio on?: #t)
                (let ((elapse (- time previous))
                      (max-elapse 10.))
                  ;; ignore ridiculous elapses like
                  ;; coming back from computer sleep
                  (unless (> elapse max-elapse)
                    (let ((history (current-history)))
                      (unless (get-paused? history)
                        (process self)))))))
            (let ((duration (- (current-seconds) time)))
              (task-sleep task audio-period duration exit))
            (iter time))))))
  
  
  (definition ccc 0)
  (definition stt #f)
  (method override (process self)
    (let ((size (gst_app_sink_read appsink data info)))
      (when (/= size -1)
        (let ((buffer (subu8vector data 0 size))
              (timestamp (u64vector-ref info 0))
              (duration (u64vector-ref info 1)))
          (when audio-show
            (when (not stt)
              (set! stt (current-seconds)))
            (increase! ccc)
            (let ((elapse (- (current-seconds) stt)))
              (let ((frequency (and (/= elapse 0.) (/ ccc elapse))))
                ;; vorbis specific
                (let ((type (if (and (>= size 7) (equal? (subu8vector buffer 1 7) #u8(118 111 114 98 105 115)))
                                '***header***
                              'audio)))
                  (terminal frequency size type)))))
          (consume sink buffer timestamp duration))))))


;;;
;;;; Audio-Sink
;;;


(class Audio-Sink extends Stream-Sink
  
  
  (slot codec    initialize #f accessors generate)
  (slot volume   initialize #f accessors explicit)
  (slot pipeline initialize #f accessors generate)
  (slot appsrc   initialize #f accessors generate)
  
  
  (method override (initialize self (codec: codec #f) (volume: volume #f))
    (nextmethod self)
    (set! self.codec codec)
    (set! self.volume volume))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((pipeline (gst-launch (tie "appsrc name=src")
                                (and (eq? codec 'opus) "avdec_opus name=dec")
                                (and (eq? codec 'vorbis) "vorbisdec name=dec")
                                (let ((volume (or volume 1))
                                      (mute (if (mute-audio? (current-zone)) "true" "false")))
                                  (tie "volume name=volume volume={volume} mute={mute}"))
                                "audiopanorama name=panorama"
                                (cond-expand
                                  (windows "directsoundsink name=sink buffer-time=200000 latency-time=100000")
                                  (else "autoaudiosink name=sink")))))
      (gst_object_set_name pipeline "output")
      (let ((appsrc (gst_bin_get_by_name pipeline "src")))
        (case codec
          ((vorbis)
           (gst_app_src_set_caps appsrc
             (gst_caps "audio/x-vorbis")))
          (else
           (gst_app_src_set_caps appsrc
             (gst_caps "audio/x-raw"
               "format"   (g_value_string (cond-expand
                                            (windows "S16LE")
                                            (else "F32LE")))
               "layout"   (g_value_string "interleaved")
               "rate"     (g_value_int 80000)
               "channels" (g_value_int 2)))))
        (g_object_set appsrc
          "is-live"     (g_value_boolean #t)
          "stream-type" (g_value_int GST_APP_STREAM_TYPE_STREAM)
          "format"      (g_value_int GST_FORMAT_TIME))
        (gst_element_set_state pipeline GST_STATE_READY)
        (set! self.pipeline pipeline)
        (set! self.appsrc appsrc))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! pipeline #f)
    (set! appsrc #f))
  
  
  (method override (consume self buffer timestamp duration)
    (gst_app_src_write3 appsrc buffer (u8vector-length buffer) timestamp duration))
  
  
  (method public (mute self)
    (let ((volume (gst_bin_get_by_name pipeline "volume")))
      (g_object_set_boolean volume "mute" #t)))
  
  
  (method public (unmute self)
    (let ((volume (gst_bin_get_by_name pipeline "volume")))
      (g_object_set_boolean volume "mute" #f)))
  
  
  (method public (get-volume self)
    (let ((volume (gst_bin_get_by_name pipeline "volume")))
      (g_object_get_double volume "volume")))
  
  
  (method public (set-volume self vol)
    (let ((volume (gst_bin_get_by_name pipeline "volume")))
      (g_object_set_double volume "volume" vol)))
  
  
  (method public (set-panorama self pan)
    (let ((panorama (gst_bin_get_by_name pipeline "panorama")))
      (g_object_set_double panorama "panorama" pan)))))
