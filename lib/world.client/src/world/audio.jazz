;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Audio
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.audio jazz


(import (jazz.stream)
        (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.configure)
        (world.context)
        (world.event)
        (world.interface)
        (world.settings)
        (world.stream)
        (world.support)
        (world.task))


(definition protected audio-rate
  (world-setting 'world.audio-rate 48000))

(definition protected audio-codec
  (world-setting 'world.audio-codec 'vorbis))


(definition audio-show
  (world-setting 'world.audio-show #f))


(definition protected audio-denoise?
  (world-setting 'world.audio-denoise? #t))

(definition protected (get-audio-denoise?)
  (get-denoising?))

(definition protected (set-audio-denoise? flag)
  (set-denoising? flag))

(set-audio-denoise? audio-denoise?)


(definition protected audio-properties
  (world-setting 'world.audio-properties #f))

(definition protected (set-audio-properties properties)
  (set! audio-properties properties))


;;;
;;;; Audio
;;;


(definition protected (new-world-audio)
  (let ((mic-src (and (not audio-stream)
                      (new Mic-Audio-Src)))
        (file-src (and audio-stream
                       (new File-Stream-Audio-Src
                         audio-stream)))
        (server-sink (new Stream-Sink
                       consumer: (lambda (buffer timestamp duration)
                                   (case audio-codec
                                     ((opus)
                                      (let ((header? (and buffer (audio-buffer-header? buffer))))
                                        (send-client-audio (current-client) buffer header? timestamp duration)))
                                     ((vorbis)
                                      (if (pair? buffer)
                                          (send-client-audio (current-client) (car buffer) #t -1 GST_CLOCK_TIME_NONE)
                                        (send-client-audio (current-client) buffer #f timestamp duration))))))))
    (new World-Audio input: (pipeline (if audio-stream
                                          file-src
                                        mic-src)
                                      server-sink))))


(definition protected (audio-buffer-header? buffer)
  (if (eq? audio-codec 'vorbis)
      (let ((size (u8vector-length buffer)))
        (and (>= size 7)
             (equal? (subu8vector buffer 1 7)
                     #u8(118 111 114 98 105 115))))
    #f))


(class World-Audio extends Object
  
  
  (slot input   getter generate)
  (slot outputs getter generate)
  
  
  (method override (initialize self (input: input #f))
    (nextmethod self)
    (set! self.input input)
    (set! self.outputs (make-table test: equal?)))
  
  
  (method package (autostart self)
    (when (world-setting 'world.audio-autostart? #f)
      (start self)))
  
  
  (method package (start self)
    (start input))
  
  
  (method package (stop self)
    (release input))
   
   
  (method package (resend-mic-header self)
    (let ((tier (current-client)))
      (let ((mic (car (get-elements input))))
        (let ((header (get-mic-header mic)))
          (when header
            (send-client-audio tier (car header) #t -1 GST_CLOCK_TIME_NONE))))))
  
  
  (method package (microphone-header self)
    (let ((mic (car (get-elements input))))
      (get-mic-header mic)))
  
  
  ;;;
  ;;;; Input
  ;;;
  
  
  (method (on-toggle-audio self evt)
    (toggle-audio self))
  
  
  (method package (toggle-audio self)
    (when (client?)
      (if (audio-playing? self)
          (stop-audio self)
        (start-audio self))))
  
  
  (method package (start-audio self (feedback?: feedback? #t))
    (when (client?)
      (let ((world (current-world)))
        (start self)
        (invalidate-interface)
        (update-parameter world 'audio)
        (when feedback?
          (display-on/off world "Audio" (playing? input))))))
  
  
  (method package (stop-audio self (feedback?: feedback? #t))
    (when (client?)
      (let ((world (current-world)))
        (stop self)
        (invalidate-interface)
        (update-parameter world 'audio)
        (when feedback?
          (display-on/off world "Audio" (playing? input))))))
  
  
  (method package (audio-playing? self)
    (playing? input))
  
  
  ;;;
  ;;;; Output
  ;;;
  
  
  (method package (find-output self id)
    (table-ref outputs id #f))
  
  (method package (register-output self id output)
    (table-set! outputs id output))
  
  
  (method package (player-output self id)
    (or (table-ref outputs id #f)
        (let ((output (new-output self)))
          (table-set! outputs id output)
          (setup output)
          (start output)
          output)))
  
  
  (method package (visualizer-output self)
    (let ((output (new-output self)))
      (setup output)
      (start output)
      output))
  
  
  (method (new-output self)
    (new Audio-Sink
      codec: audio-codec))
  
  
  (method package (close-output self id output)
    (table-clear outputs id)
    (release output))
  
  
  (method package (close-outputs self)
    (iterate-table-safe outputs
      (lambda (id output)
        (close-output self id output))))
  
  
  (method package (receive-server-audio self id buffer timestamp duration)
    (let ((output (find-output self id)))
      (when output
        (if (not buffer)
            (set-stream-state output 'off)
          (when (eq? (get-stream-state output) 'off)
            (set-stream-state output 'on))
          (consume output buffer timestamp duration)
          (record-event udp-id-sink-media
                        (fixnum->flonum client-no)
                        (fixnum->flonum world.udp:udp-audio)
                        -1.
                        -1.
                        -1.
                        (timestamp->flonum timestamp))))))
  
  
  (method package (receive-visualizer-audio self output buffer timestamp duration)
    (if (not buffer)
        (set-stream-state output 'off)
      (when (eq? (get-stream-state output) 'off)
        (set-stream-state output 'on))
      (consume output buffer timestamp duration))))


;;;
;;;; Audio-Src
;;;


(class Audio-Src extends Stream-Src)


;;;
;;;; Mic-Audio-Src
;;;


(class Mic-Audio-Src extends Audio-Src
  
  
  (slot mic-headers                 initialize '() accessors generate)
  (slot mic-header                  initialize #f  accessors generate)
  (slot mic-pipeline                initialize #f  accessors generate)
  (slot mic-sink                    initialize #f  accessors generate)
  (slot codec-pipeline              initialize #f  accessors generate)
  (slot codec-src                   initialize #f  accessors generate)
  (slot codec-sink                  initialize #f  accessors generate)
  (slot codec-data     <u8vector+>  initialize #f  accessors generate)
  (slot codec-info     <u64vector+> initialize #f  accessors generate)
  (slot codec-task                  initialize #f  accessors generate)
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((properties (or audio-properties "")))
      ;; mic
      (let ((pipeline (gst-launch (cond-expand
                                    (windows (tie "directsoundsrc format=S16LE layout=interleaved rate={audio-rate} channels=1 name=src"))
                                    (else (tie "autoaudiosrc format=S16LE layout=interleaved rate={audio-rate} channels=1 name=src")))
                                  ;; no idea why these next two lines are necessary
                                  "audioresample"
                                  (tie "audio/x-raw, format=S16LE, layout=interleaved, rate={audio-rate}, channels=1")
                                  "appsink name=sink")))
        (gst_object_set_name pipeline "mic")
        (let ((appsink (gst_bin_get_by_name pipeline "sink"))
              (data (make-u8vector 4096))
              (info (make-u64vector 2)))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.mic-pipeline pipeline)
          (set! self.mic-sink appsink)))
      ;; codec
      (let ((pipeline (gst-launch "appsrc name=src"
                                  (and (eq? audio-codec 'opus) (tie "opusenc {properties} name=enc"))
                                  (and (eq? audio-codec 'vorbis) "audioconvert")
                                  (and (eq? audio-codec 'vorbis) (tie "audio/x-raw, format=F32LE, layout=interleaved, rate={audio-rate}, channels=1"))
                                  (and (eq? audio-codec 'vorbis) (tie "vorbisenc {properties} name=enc"))
                                  "appsink name=sink")))
        (gst_object_set_name pipeline "codec")
        (let ((appsrc (gst_bin_get_by_name pipeline "src"))
              (appsink (gst_bin_get_by_name pipeline "sink"))
              (data (make-u8vector 4096))
              (info (make-u64vector 2)))
          (gst_app_src_set_caps appsrc
                                (gst_caps "audio/x-raw"
                                          "format"   (g_value_string "S16LE")
                                          "layout"   (g_value_string "interleaved")
                                          "rate"     (g_value_int audio-rate)
                                          "channels" (g_value_int 1)))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.codec-data data)
          (set! self.codec-info info)
          (set! self.codec-pipeline pipeline)
          (set! self.codec-src appsrc)
          (set! self.codec-sink appsink)))
      ;; denoiser
      (create-denoiser-thread mic-sink codec-src)))
  
  
  (method override (start-element self)
    (define (codec-start)
      (let ((procedure
              (lambda (task)
                (codec-loop self task))))
        (let ((task (new Task 'codec procedure priority: audio-priority)))
          (start-task task)
          (set! self.codec-task task))))
    
    (nextmethod self)
    (gst_element_set_state mic-pipeline GST_STATE_PLAYING)
    (gst_element_set_state codec-pipeline GST_STATE_PLAYING)
    (codec-start))
  
  
  (method override (stop-element self)
    (define (codec-stop)
      (halt-task codec-task)
      (set! codec-task #f))
    
    (nextmethod self)
    (gst_element_set_state mic-pipeline GST_STATE_READY)
    (codec-stop)
    (gst_element_set_state codec-pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release mic-pipeline)
    (set! mic-headers '())
    (set! mic-header #f)
    (set! mic-pipeline #f)
    (set! mic-sink #f)
    (consume sink #f #f #f)
    (gst_element_release codec-pipeline)
    (set! codec-info #f)
    (set! codec-data #f)
    (set! codec-pipeline #f)
    (set! codec-src #f)
    (set! codec-sink #f))
  
  
  (method (codec-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-seconds)))
          ;; not 100% correct if preempted before task-mutex
          (let ((time (current-seconds)))
            (when (running? task)
              (site (audio on?: #t)
                (let ((elapse (- time previous))
                      (max-elapse 10.))
                  ;; ignore ridiculous elapses like
                  ;; coming back from computer sleep
                  (unless (> elapse max-elapse)
                    (let ((history (current-history)))
                      (unless (get-paused? history)
                        (process self)))))))
            (let ((duration (- (current-seconds) time)))
              (task-sleep task audio-period duration exit))
            (iter time))))))
  
  
  (method override (process self)
    (let ((size (gst_app_sink_read codec-sink codec-data codec-info)))
      (when (/= size -1)
        (let ((buffer (subu8vector codec-data 0 size))
              (timestamp (u64vector-ref codec-info 0))
              (duration (u64vector-ref codec-info 1)))
          (let ((header? (audio-buffer-header? buffer)))
            (when audio-show
              (if (eq? audio-codec 'vorbis)
                  (let ((type (if header?
                                  '***header***
                                'data)))
                    (terminal 'audio size type))
                (terminal 'audio size)))
            (case audio-codec
              ;; opus has no headers
              ((opus)
               (consume sink buffer timestamp duration))
              ((vorbis)
               (if header?
                   (begin
                     (set! mic-headers (append! mic-headers (list (list buffer timestamp duration))))
                     (when (= (length mic-headers) 3)
                       (set! mic-header (list (object->u8vector mic-headers)))
                       (consume sink mic-header #f #f)))
                 (consume sink buffer timestamp duration))))
            (record-event udp-id-src-media
                          (fixnum->flonum client-no)
                          (fixnum->flonum world.udp:udp-audio)
                          -1.
                          (if header? 1. -1.)
                          (fixnum->flonum size)
                          (timestamp->flonum timestamp))))))))


;;;
;;;; File-Stream-Audio-Src
;;;


;; quicky for tests
(class File-Stream-Audio-Src extends Mic-Audio-Src
  
  
  (slot location initialize #f accessors generate)
  
  
  (method override (initialize self location . rest)
    (apply nextmethod self rest)
    (set! self.location location))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((properties (or audio-properties "")))
      (let ((pipeline (gst-launch (tie "filesrc name=filesrc")
                                  "decodebin name=decoder"
                                  (list "decoder."
                                        "queue"
                                        "audioconvert"
                                        "audioresample"
                                        (and (eq? audio-codec 'opus) (tie "opusenc {properties} name=enc"))
                                        (and (eq? audio-codec 'vorbis) "audioconvert")
                                        (and (eq? audio-codec 'vorbis) (tie "audio/x-raw, format=F32LE, layout=interleaved, rate={audio-rate}, channels=1"))
                                        (and (eq? audio-codec 'vorbis) (tie "vorbisenc {properties} name=enc"))
                                        "appsink name=sink"))))
        (gst_object_set_name pipeline "codec")
        (let ((filesrc (gst_bin_get_by_name pipeline "filesrc"))
              (appsink (gst_bin_get_by_name pipeline "sink"))
              (data (make-u8vector 4096))
              (info (make-u64vector 2)))
          (g_object_set_string filesrc "location" (path-normalize location))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.codec-data data)
          (set! self.codec-info info)
          (set! self.codec-pipeline pipeline)
          (set! self.codec-sink appsink))))))


;;;
;;;; Audio-Sink
;;;


(class Audio-Sink extends Stream-Sink
  
  
  (slot codec        initialize #f accessors generate)
  (slot volume       initialize #f accessors explicit)
  (slot pipeline     initialize #f accessors generate)
  (slot appsrc       initialize #f accessors generate)
  (slot stream-state initialize 'off getter generate setter explicit)
  
  
  (method override (initialize self (codec: codec #f) (volume: volume #f))
    (nextmethod self)
    (set! self.codec codec)
    (set! self.volume volume))
  
  
  (method package (set-stream-state self state)
    (when (neq? state stream-state)
      (set! stream-state state)
      (invalidate-interface)))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((pipeline (gst-launch (tie "appsrc name=src")
                                (and (eq? codec 'opus) "opusdec name=dec")
                                (and (eq? codec 'vorbis) "vorbisdec name=dec")
                                (let ((volume (or volume 1)))
                                  (tie "volume name=volume volume={volume}"))
                                "audiopanorama name=panorama"
                                (cond-expand
                                  (windows (and (eq? codec 'vorbis) "audioconvert"))
                                  (else #f))
                                (cond-expand
                                  (windows (and (eq? codec 'vorbis) "audioresample"))
                                  (else #f))
                                (cond-expand
                                  (windows (and (eq? codec 'vorbis) (tie "audio/x-raw, format=S16LE, layout=interleaved, rate={audio-rate}, channels=1")))
                                  (else #f))
                                (cond-expand
                                  (windows "directsoundsink name=sink buffer-time=200000 latency-time=100000")
                                  (else "autoaudiosink name=sink")))))
      (gst_object_set_name pipeline "output")
      (let ((appsrc (gst_bin_get_by_name pipeline "src")))
        (case codec
          ((opus)
           (gst_app_src_set_caps appsrc
                                 (gst_caps "audio/x-opus"
                                           "channel-mapping-family" (g_value_int 0))))
          ((vorbis)
           (gst_app_src_set_caps appsrc
                                 (gst_caps "audio/x-vorbis"))))
        (g_object_set appsrc
          "is-live"     (g_value_boolean #t)
          "stream-type" (g_value_int GST_APP_STREAM_TYPE_STREAM)
          "format"      (g_value_int GST_FORMAT_TIME))
        (gst_element_set_state pipeline GST_STATE_READY)
        (set! self.pipeline pipeline)
        (set! self.appsrc appsrc))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! pipeline #f)
    (set! appsrc #f)
    (set-stream-state self 'off))
  
  
  (method override (consume self buffer timestamp duration)
    (gst_app_src_write3 appsrc buffer (u8vector-length buffer) timestamp duration))
  
  
  (method public (mute self)
    (let ((volume (gst_bin_get_by_name pipeline "volume")))
      (g_object_set_boolean volume "mute" #t)))
  
  
  (method public (unmute self)
    (let ((volume (gst_bin_get_by_name pipeline "volume")))
      (g_object_set_boolean volume "mute" #f)))
  
  
  (method public (get-volume self)
    (let ((volume (gst_bin_get_by_name pipeline "volume")))
      (g_object_get_double volume "volume")))
  
  
  (method public (set-volume self vol)
    (let ((volume (gst_bin_get_by_name pipeline "volume")))
      (g_object_set_double volume "volume" vol)))
  
  
  (method public (set-panorama self pan)
    (let ((panorama (gst_bin_get_by_name pipeline "panorama")))
      (g_object_set_double panorama "panorama" pan)))))
