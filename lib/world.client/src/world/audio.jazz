;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Audio
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.audio jazz


(import (jazz.sound)
        (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.configure)
        (world.settings)
        (world.syntax (phase syntax))
        (world.task))


(definition default-rate
  44100)

(definition default-format
  SoundIoFormatFloat32NE)

(definition default-channels
  2)

(definition default-latency
  .2)


;;;
;;;; Task
;;;


(definition public (audio-task task <Task>)
  (declare (proper-tail-calls))
  (let ((audio (current-audio)))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-seconds)))
          (let ((time (current-seconds)))
            (let ((elapse (- time previous)))
              (unless (stopping?~ task)
                (site (audio on?: #t)
                  (process-audio~ audio)))
              (let ((duration (- (current-seconds) time)))
                (task-sleep task audio-period duration exit))
              (iter time))))))))


;;;
;;;; Input
;;;


(class World-Audio extends Object
  
  
  (slot audio? <bool>     initialize #f accessors generate)
  (slot buffer <u8vector> initialize #f accessors generate)
  
  
  (method override (initialize)
    (set! audio? (world-setting 'world.audio? #f))
    (when (and audio? (client?))
      (start-audio)))
  
  
  ;;;
  ;;;; Events
  ;;;
  
  
  (method (on-toggle-audio evt)
    (toggle-audio))
  
  
  ;;;
  ;;;; Process
  ;;;
  
  
  (method (toggle-audio)
    (when (client?)
      (let ((world (current-world)))
        (if (not audio?)
            (start-audio)
          (stop-audio))
        (update-parameter~ world 'audio)
        (display-on/off~ world "Audio" audio?))))
  
  
  (method (start-audio)
    (unless audio?
      (startup-sound)
      (let ((in-device (sound-default-input-device))
            (rate default-rate)
            (format default-format)
            (layout (sound-get-default-layout default-channels))
            (latency default-latency))
        (start-sound-input in-device rate format layout latency)
        (set! buffer (make-u8vector (sound-input-ring-capacity)))
        (set! audio? #t))))
  
  
  (method (stop-audio)
    (when audio?
      (stop-sound-input)
      (set! buffer #f)
      (set! audio? #f)))
  
  
  (method (process-audio)
    (when (and audio? (client?))
      (let ((read (sound-read-input-ring buffer)))
        (when (> read 0)
          (if (local?)
              (write-server-audio (get-id~ (current-me)) (subu8vector buffer 0 read))
            (send-client-audio~ (client-tier) (subu8vector buffer 0 read))))))))


;;;
;;;; Output
;;;


(definition speaker?
  #f)


(definition public (start-speaker)
  (unless speaker?
    (startup-sound)
    (let ((out-device (sound-default-output-device))
          (rate default-rate)
          (format default-format)
          (layout (sound-get-default-layout default-channels))
          (latency default-latency))
      (start-sound-output out-device rate format layout latency)
      (set! speaker? #t))))


(definition public (stop-speaker)
  (when speaker?
    (stop-sound-output)
    ;(shutdown-sound)
    (set! speaker? #f)))


(definition public (write-server-audio id bytes)
  (start-speaker)
  (sound-write-output-ring bytes (u8vector-length bytes))))
