;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Audio
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.audio jazz


(import (jazz.event)
        (jazz.io)
        (jazz.listener)
        (jazz.presence)
        (jazz.stream)
        (jazz.stream.syntax (phase syntax))
        (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.configure)
        (world.context)
        (world.event)
        (world.interface)
        (world.media)
        (world.settings)
        (world.stream)
        (world.support)
        (world.task)
        (world.time)
        (world.udp))


(definition protected audio-rate
  (world-setting 'world.audio-rate 48000))

(definition protected audio-codec
  (world-setting 'world.audio-codec 'vorbis))

(definition protected audio-provider
  (world-setting 'world.audio-provider (cond-expand
                                         (windows 'directsound)
                                         (else #f))))


;; denoiser only works for 48000 rate
(definition protected audio-denoise?
  (cond-expand
    (linux #f)
    (else (world-setting 'world.audio-denoise? (= audio-rate 48000)))))

(definition protected (set-audio-denoise? flag)
  (set! audio-denoise? flag))


(definition protected (graph-audio)
  (let ((pipeline (get-pipeline (cache-audio))))
    (gst_debug_bin_to_dot_file pipeline GST_DEBUG_GRAPH_SHOW_ALL "audio")))


(definition protected (clock-audio)
  (let ((pipeline (get-pipeline (cache-audio))))
    (define (report elem)
      (format :terminal "{a} {a} {a}{%}"
        (gst_element_path elem)
        (g_object_class_name elem)
        (gst_object_get_name (gst_element_get_clock elem))))
    
    (format :terminal "pipeline {a}{%}" (gst_object_get_name (gst_pipeline_get_clock pipeline)))
    (report pipeline)
    (for-each report (gst_bin_elements_recurse pipeline))))


(definition protected monitor-mix
  (let ((monitored #f))
    (lambda ()
      (cond (monitored
             (gst_unmonitor monitored)
             (set! monitored #f))
            (else
             (let ((pipeline (get-pipeline (cache-audio))))
               (set! monitored (gst_monitor pipeline 'data "mix")))))
      monitored)))


(definition protected monitor-mic
  (let ((monitored #f))
    (lambda ()
      (cond (monitored
             (gst_unmonitor monitored)
             (set! monitored #f))
            (else
             (let ((pipeline (get-mic-pipeline (get-src (get-pipeline (get-mic-channel (current-client)))))))
               (set! monitored (gst_monitor pipeline 'data "src")))))
      monitored)))


;;;
;;;; Codec
;;;


(class AAC-Codec extends Codec)
(class Vorbis-Codec extends Codec)
(class Opus-Codec extends Codec)


(register-codec (new AAC-Codec 'aac 'audio))
(register-codec (new Vorbis-Codec 'vorbis 'audio))
(register-codec (new Opus-Codec 'opus 'audio))


;;;
;;;; Profile
;;;


(definition public (audio-profile-extension)
  "streamaudio")


(definition public (streaming-audio-extensions)
  (list (audio-profile-extension)))


;;;
;;;; Stream
;;;


(definition protected (locate-stream-audio-channel stream)
  (table-search (lambda (no channel)
                  (and (= (get-media-kind channel) udp-audio)
                       channel))
                (get-channels stream)))


;;;
;;;; Microphone
;;;


(definition public (has-microphone?)
  (not-null? (microphone-devices)))


(definition protected (microphone-devices)
  (with-unref ((monitor (gst_device_monitor_new)))
    (let ((caps (gst_caps_new_empty_simple "audio/x-raw")))
      (gst_device_monitor_add_filter monitor "Audio/Source" caps)
      (gst_caps_unref caps))
    (let ((queue (new-queue)))
      (let (loop (devices (gst_device_monitor_get_devices monitor)))
        (if (not devices)
            (begin
              (g_list_free devices)
              (queue-list queue))
          (enqueue queue (gst_device_monitor_device_list_data devices))
          (loop (gst_device_monitor_device_list_next devices)))))))


(definition protected (microphone-device-properties device)
  (with-unref ((element (gst_device_create_element device)))
    (cond-expand
      (mac (list "device" (g_object_get_int element "device")))
      (else '()))))


;;;
;;;; Audio
;;;


(class World-Audio extends Object
  
  
  (slot outputs         getter generate)
  (slot ordered-outputs getter generate)
  
  
  (method override (initialize self)
    (nextmethod self)
    (set! self.outputs (make-table test: equal?))
    (set! self.ordered-outputs '()))
  
  
  ;;;
  ;;;; Output
  ;;;
  
  
  (method package (find-output self id)
    (table-ref outputs id #f))
  
  
  (method package (player-output self id (codec: codec #f) (caps: caps #f) (volume: volume #f))
    (or (table-ref outputs id #f)
        (let ((output (new-output self codec: codec caps: caps volume: volume)))
          (setup output)
          (table-set! outputs id output)
          (set! ordered-outputs (append! ordered-outputs (list output)))
          (start output)
          output)))
  
  
  (method package (channel-output self channel (volume: volume #f))
    (let ((codec (get-codec channel))
          (caps (get-caps channel)))
      (let ((output (player-output self (get-no channel) codec: codec caps: caps volume: volume)))
        (set-channel output channel)
        output)))
  
  
  (method package (visualizer-output self (caps: caps #f))
    (let ((sink (new Audio-Sink codec: audio-codec caps: caps))
          (audio (cache-audio)))
      (add-sink audio sink)
      (start sink)
      sink))
  
  
  (method (new-output self (codec: codec #f) (caps: caps #f) (volume: volume #f))
    (let ((sink (new Audio-Sink
                  codec: (or codec audio-codec)
                  caps: caps
                  volume: volume))
          (audio (cache-audio)))
      (add-sink audio sink)
      (play sink)
      sink))
  
  
  (method package (close-output self id output)
    (table-clear outputs id)
    (set! ordered-outputs (remove! output ordered-outputs))
    (remove-sink (cache-audio) output)
    (release output)
    (close output))
  
  
  (method package (receive-server-audio self id buffer dts pts duration)
    (let ((output (find-output self id)))
      (when (and output (not (get-stream-disconnected? output)))
        (if (not buffer)
            (set-stream-state output 'off)
          (when (eq? (get-stream-state output) 'off)
            (set-stream-state output 'on))
          (consume-audio output buffer dts pts duration)
          (when udp-record-src/sink?
            (let ((origin (get-origin (get-stream (get-channel output)))))
              (record-event udp-id-sink-media
                            (fixnum->flonum id)
                            (fixnum->flonum origin)
                            (fixnum->flonum udp-audio)
                            -1.
                            -1.
                            -1.
                            (timestamp->flonum dts))))))))
  
  
  (method package (receive-visualizer-audio self output buffer dts pts duration)
    (if (not buffer)
        (set-stream-state output 'off)
      (when (eq? (get-stream-state output) 'off)
        (set-stream-state output 'on))
      (consume-audio output buffer dts pts duration)))
  
  
  (method package (receive-audio self id/output buffer dts pts duration)
    (if (is? id/output Audio-Sink)
        (receive-visualizer-audio self id/output buffer dts pts duration)
      (receive-server-audio self id/output buffer dts pts duration))))


;;;
;;;; Audio
;;;


(definition protected audioprobe-delay
  0)


(definition protected audio
  #f)

(definition public (cache-audio)
  (or audio
      (let ((aud (new Audio)))
        (setup aud)
        (play aud)
        (set! audio aud)
        aud)))


(class Audio extends Object
  
  
  (slot provider initialize #f accessors generate)
  (slot pipeline initialize #f accessors generate)
  
  
  (method override (initialize self (provider: provider #f))
    (nextmethod self)
    (set! self.provider (or provider audio-provider)))
  
  
  (method protected (add-sink self sink)
    (setup sink)
    (let ((bin (get-bin sink)))
      (set-pipeline sink pipeline)
      (with-unref ((mix (gst_bin_get_by_name pipeline "mix")))
        (gst_bin_add pipeline bin)
        (with-unref ((pan (gst_bin_get_by_name bin "panorama")))
          (gst_element_link pan mix))))
    (redistribute-latency self))
  
  
  (method protected (remove-sink self sink)
    (let ((bin (get-bin sink)))
      (let ((pads (gst_element_src_pads bin)))
        (let ((ghost-pad (car pads)))
          (with-unref ((pan (gst_bin_get_by_name bin "panorama"))
                       (mix (gst_bin_get_by_name pipeline "mix")))
            (gst_element_unlink pan mix)
            (gst_element_release_request_pad mix (gst_pad_get_peer ghost-pad)))))
      (gst_element_set_state bin GST_STATE_NULL)
      (gst_bin_remove pipeline bin)
      (redistribute-latency self)))
  
  
  (method (redistribute-latency self)
    (let ((info (make-u64vector 3)))
      (gst_element_query_latency pipeline info)
      (let ((live (u64vector-ref info 0))
            (min (u64vector-ref info 1))
            (max (u64vector-ref info 2)))
        (gst_element_send_event pipeline (gst_event_new_latency min)))))
  
  
  (method (wait-playing self pipeline)
    (let (loop (n 0))
      (when (< n 100)
        (when (/= (gst_element_get_state pipeline) 4)
          (sleep .01)
          (loop (+ n 1))))))
  
  
  (method (check-audioclock self pipeline)
    (with-unref ((clock (gst_pipeline_get_clock pipeline)))
      (let ((clock-name (gst_object_get_name clock)))
        (unless (equal? clock-name (cond-expand
                                     (linux "GstPulseSinkClock")
                                     (else "GstAudioSinkClock")))
          (delay-event
            (lambda ()
              (with-task-mutex
                (lambda ()
                  (chat-problem (current-world) (format "Failed to install an audio clock: {a}" clock-name))))))))))
  
  
  (method public (setup self)
    (let ((pipeline (gst-pipeline "audiotestsrc samplesperbuffer=4800 wave=silence name=silence"
                                  "audiomixer name=mix"
                                  "queue name=queue"
                                  (tie "webrtcaudioprobe delay={audioprobe-delay}")
                                  "audio/x-raw, format=S16LE, layout=interleaved, rate=48000, channels=2"
                                  (gst-element (cond-expand (windows (if (eq? provider 'directsound)
                                                                         "directsoundsink"
                                                                       "wasapisink"))
                                                            (mac "osxaudiosink")
                                                            (else "pulsesink"))
                                               buffer-time: 200000
                                               ; discont-wait: 0
                                               name: "sink"))))
      (gst_object_set_name pipeline "audio")
      (set! self.pipeline pipeline)
      (gst_element_set_state pipeline GST_STATE_PLAYING)
      (wait-playing self pipeline)
      (check-audioclock self pipeline)))
  
  
  (method public (play self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method public (pause self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method public (stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method public (release self)
    (gst_element_release pipeline)
    (set! pipeline #f)))


;;;
;;;; Audio-Src
;;;


(class Audio-Src extends Stream-Src
  
  
  (slot pipeline initialize #f accessors generate)
  (slot appsrc   initialize #f accessors generate)
  (slot task     initialize #f accessors generate)
  (slot consumer initialize #f getter generate)
  
  
  (method package virtual (start-listeners self)
    (when consumer
      (start-listener consumer)))
  
  
  (method package virtual (stop-listeners self)
    (when consumer
      (stop-listener consumer)))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (set! consumer (car sinks)))
  
  
  (method (task-start self name)
    (let ((procedure
            (lambda (task)
              (audio-loop self task))))
      (let ((task (new Task name procedure priority: audio-priority)))
        (start-listeners self)
        (start-task task)
        (set! self.task task))))
  
  
  (method (task-stop self)
    (stop-listeners self)
    (stop-task task)
    (set! task #f))
  
  
  (method protected virtual (audio-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (process self task exit)
          (iter)))))
  
  
  (method override (process self task exit)
    (gst_app_sink_process task exit consumer)))


;;;
;;;; Mic-Audio-Src
;;;


(definition protected echo-debug?
  (world-setting 'world.echo-debug? #f))


;; denoiser only works in S16LE format, 48000 rate and 1 channel
(definition protected denoiser-caps
  "audio/x-raw, format=S16LE, layout=interleaved, rate=48000, channels=1")

;; prevents sharp spikes that sound really harsh when denoised
(definition protected denoiser-filter
  "audiodynamic threshold=0.5 ratio=0.5 characteristics=soft-knee")


(class Mic-Audio-Src extends Audio-Src
  
  
  (slot mic-pipeline initialize #f accessors generate)
  (slot mic-sink     initialize #f accessors generate)
  (slot cached-caps  initialize #f getter generate)
  
  
  ;; we need to go in playing before the caps are available
  (method protected (require-caps self)
    (or cached-caps
        (begin
          (setup self)
          (gst_element_set_state mic-pipeline GST_STATE_PLAYING)
          (with-unref ((sink (gst_bin_get_by_name mic-pipeline "sink")))
            (with-unref ((pad (gst_element_get_static_pad sink "sink")))
              ;; wait for data to flow
              (let (loop (n 0))
                (if (> n 100)
                    (begin
                      (terminal 'COULD 'NOT 'GET 'MICROPHONE 'CAPS)
                      (exit))
                  (if (not (gst_pad_has_current_caps pad))
                      (begin
                        (sleep .01)
                        (loop (+ n 1)))
                    (let ((caps (gst_pad_get_current_caps pad)))
                      (let ((caps-string (gst_caps_to_string caps)))
                        (gst_caps_unref caps)
                        caps-string))))))))))
  
  
  (method override (setup-element self)
    (nextmethod self)
    ;; mic
    (let ((pipeline (gst-pipeline
                      ;; provide-clock=false to use the audio sink clock
                      ;; this makes sure audio and video stay synced
                      ;; latency-time=30000 is the minimum to get good
                      ;; audio on windows and also improves the mac audio
                      (cond-expand
                        (windows "directsoundsrc latency-time=30000 provide-clock=false name=src")
                        (mac "osxaudiosrc latency-time=30000 provide-clock=false name=src")
                        (else "pulsesrc latency-time=30000 provide-clock=false name=src"))
                      ;; needed on some computers
                      "audioresample"
                      (gst-element "webrtcaudioprocessor"
                                   echo-cancel: "true"
                                   noise-suppression: "true")
                      "audioresample"
                      ; denoiser-caps
                      ; denoiser-filter
                      (and (eq? audio-codec 'opus) "opusenc name=enc")
                      (and (eq? audio-codec 'vorbis) "audioconvert")
                      (and (eq? audio-codec 'vorbis) (tie "audio/x-raw, format=F32LE, layout=interleaved, rate={audio-rate}, channels=1"))
                      (and (eq? audio-codec 'vorbis) "vorbisenc name=enc")
                      "appsink sync=false name=sink")))
      (let ((listener (open-stream-listener "mic")))
        (with-unref ((appsink (gst_bin_get_by_name pipeline "sink")))
          (gst_app_sink_connect_signals appsink listener)
          (setup-consumer consumer listener appsink 4096)
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.mic-pipeline pipeline)
          (set! self.mic-sink appsink)))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (gst_element_set_state mic-pipeline GST_STATE_PAUSED)
    (task-start self 'mic))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state mic-pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state mic-pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state mic-pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (consume consumer #f #f #f #f #f)
    (release-consumer consumer)
    (gst_element_release mic-pipeline)
    (set! mic-pipeline #f)
    (set! mic-sink #f)))


;;;
;;;; Mic-Audio-Consumer
;;;


(class Mic-Audio-Consumer extends Stream-Consumer
  
  
  (method override (consume self buffer dts pts duration keyframe?)
    ;; ignore stream headers
    (unless (and duration (= duration GST_CLOCK_TIME_NONE))
      (nextmethod self buffer dts pts duration keyframe?)
      (when buffer
        (let ((size (u8vector-length buffer)))
          (when udp-record-src/sink?
            (record-event udp-id-src-media
                          -1. ;; todo channel no
                          (fixnum->flonum client-no)
                          (fixnum->flonum udp-audio)
                          -1.
                          -1.
                          (fixnum->flonum size)
                          (timestamp->flonum dts))))))))


;;;
;;;; File-Preprocess-Audio-Src
;;;


(class File-Preprocess-Audio-Src extends Audio-Src
  
  
  (slot location initialize #f accessors generate)
  (slot prime?   initialize #f accessors generate)
  
  
  (method override (initialize self location (prime?: prime? #f))
    (nextmethod self)
    (set! self.location location)
    (set! self.prime? prime?))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((listener (open-stream-listener "preprocessaudio")))
      (let ((pipeline (if prime?
                          (gst-pipeline (tie "filesrc name=filesrc")
                                        "qtdemux"
                                        "audio/mpeg"
                                        "appsink name=appsink sync=false")
                        (gst-pipeline (tie "filesrc name=filesrc")
                                      "decodebin"
                                      (and (eq? audio-codec 'opus) "opusenc name=enc")
                                      (and (eq? audio-codec 'vorbis) "audioconvert")
                                      (and (eq? audio-codec 'vorbis) "audioresample")
                                      (and (eq? audio-codec 'vorbis) (tie "audio/x-raw, format=F32LE, layout=interleaved, rate={audio-rate}, channels=2"))
                                      (and (eq? audio-codec 'vorbis) "vorbisenc name=enc")
                                      "appsink name=appsink sync=false"))))
        (gst_object_set_name pipeline "file")
        (with-unref ((filesrc (gst_bin_get_by_name pipeline "filesrc"))
                     (appsink (gst_bin_get_by_name pipeline "appsink")))
          (gst_app_sink_connect_signals appsink listener)
          (setup-consumer consumer listener appsink 4096)
          (g_object_set_string filesrc "location" (path-normalize location))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.pipeline pipeline)))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'file)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! pipeline #f)
    (release-consumer consumer))
  
  
  (method override (audio-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (site preprocess
            (process self task exit))
          (iter))))))


;;;
;;;; File-Stream-Audio-Src
;;;


(class File-Stream-Audio-Src extends Audio-Src implements Media-Stream
  
  
  (slot location     getter generate)
  (slot stream?      accessors explicit)
  (slot sound?       getter generate) ;; gambit30 revisit
  (slot file         getter generate)
  (slot reader       getter generate)
  (slot time-base    getter generate)
  (slot muted?       getter generate)
  (slot pause?       getter generate)
  (slot flush?       getter generate)
  (slot delayed-seek getter generate)
  
  
  (method override (initialize self location (file: file #f) (stream?: stream? #t) (sound?: sound? #f))
    (nextmethod self)
    (set! self.location location)
    (set! self.stream? stream?)
    (set! self.sound? sound?)
    (set! self.file file)
    (set! self.reader #f)
    (set! self.time-base (new Time-Base))
    (set! self.muted? #f)
    (set! self.pause? #f)
    (set! self.flush? #f)
    (set! self.delayed-seek #f))
  
  
  (method override (start-element self)
    (nextmethod self)
    (set! file (or file (new-file {Directory Documents} (add-extension location (audio-profile-extension)))))
    (set! reader (new Stream-Reader file))
    (task-start self (if sound?
                         'sound
                       'audio-stream)))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (close reader)
    (set! file #f)
    (set! reader #f))
  
  
  (method override (get-stream? self)
    stream?)
  
  
  (method override (set-stream? self flag)
    (set! stream? flag))
  
  
  (method override (play-stream self)
    (task-wakeup (get-thread task)
      (lambda (exit)
        (set! pause? #f)
        (reset time-base))))
  
  
  (method override (pause-stream self)
    (task-wakeup (get-thread task)
      (lambda (exit)
        (set! pause? #t)
        (task-sleep task +inf.0 exit))))
  
  
  (method override (rewind-stream self)
    (task-wakeup (get-thread task)
      (lambda (exit)
        (goto-frame reader 0)
        (reset time-base)
        (set! flush? #t))))
  
  
  (method override (goto-delayed self pos normalized-dts)
    (when (not delayed-seek)
      (task-wakeup (get-thread task)
        (lambda (exit)
          (task-sleep task +inf.0 exit))))
    (set! delayed-seek (cons pos normalized-dts)))
  
  
  (method override (goto-stream self pos normalized-dts)
    (task-wakeup (get-thread task)
      (lambda (exit)
        (if (not pos)
            (begin
              (when delayed-seek
                (bind (pos . normalized-dts) delayed-seek
                  (goto-position reader pos normalized-dts))
                (set! delayed-seek #f))
              (if pause?
                  (task-sleep task +inf.0 exit)
                (reset time-base)
                (set! flush? #t)))
          (goto-position reader pos normalized-dts)
          (task-sleep task +inf.0 exit)))))
  
  
  (method override (backward-stream self pos normalized-dts)
    (when pause?
      (task-wakeup (get-thread task)
        (lambda (exit)
          (goto-position reader pos normalized-dts)
          (task-sleep task +inf.0 exit)))))
  
  
  (method override (forward-stream self pos normalized-dts)
    (when pause?
      (task-wakeup (get-thread task)
        (lambda (exit)
          (goto-position reader pos normalized-dts)
          (task-sleep task +inf.0 exit)))))
  
  
  (method protected (mute-stream self)
    (set! muted? #t))
  
  
  (method protected (unmute-stream self)
    (set! muted? #f))
  
  
  (method override (audio-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (if (stopping? task)
              (task-done task exit)
            ;; protect against stream? threaded change
            (let ((stream? stream?))
              (receive (buffer dts pts duration keyframe?) (read-frame reader stream?)
                (if (not buffer)
                    (if stream-loop?
                        (begin
                          (close reader)
                          (set! reader (new Stream-Reader file))
                          (set! time-base (new Time-Base))
                          (iter))
                      (task-done task exit))
                  (let ((time (current-seconds))
                        (nanodts (timestamp->flonum dts)))
                    (update-start time-base time nanodts)
                    (let ((sendtime (remote->local time-base nanodts)))
                      (if (not sound?)
                          (task-sleep task (- sendtime time) exit)
                        (sleep (- sendtime time))
                        (task-sleep task 0 exit))
                      (when stream?
                        (if flush?
                            (set! flush? #f)
                          (site audio-stream
                            (unless muted?
                              (consume consumer buffer dts pts duration keyframe?))))))))))
            (iter)))))))


;;;
;;;; Audio-Sink
;;;


(class Audio-Sink extends Stream-Sink
  
  
  (slot channel                initialize #f accessors generate)
  (slot codec                  initialize #f accessors generate)
  (slot caps                   initialize #f accessors generate)
  (slot provider               initialize #f accessors generate)
  (slot volume                 initialize #f accessors explicit)
  (slot sound?                 initialize #f accessors explicit) ;; gambit30 revisit
  (slot pipeline               initialize #f accessors generate)
  (slot bin                    initialize #f accessors generate)
  (slot appsrc                 initialize #f accessors generate)
  (slot volelem                initialize #f accessors generate)
  (slot panelem                initialize #f accessors generate)
  (slot stream-state           initialize 'off getter generate setter explicit)
  (slot stream-playing?        initialize #f getter generate)
  (slot stream-disconnected?   initialize #f getter generate)
  (slot stream-prerolled?      initialize #f getter generate)
  (slot time-adapter           initialize #f getter generate)
  (slot monitor                getter generate)
  
  
  (method override (initialize self (codec: codec #f) (caps: caps #f) (provider: provider #f) (volume: volume #f) (sound?: sound? #f))
    (nextmethod self)
    (set! self.codec codec)
    (set! self.caps caps)
    (set! self.provider (or provider audio-provider))
    (set! self.volume volume)
    (set! self.sound? sound?)
    (set! self.time-adapter (new Time-Adapter))
    (set! self.monitor (new Audio-Monitor)))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (let ((effective-name (if (not channel) "Me" (get-name (get-stream channel)))))
          (format output "{a}" effective-name)))))
  
  
  (method package (set-stream-state self state)
    (when (neq? state stream-state)
      (set! stream-state state)
      (when (client?)
        (invalidate-audio-state (current-client) self))))
  
  
  (method package (set-stream-disconnected self)
    (set! stream-state 'off)
    (set! stream-disconnected? #t)
    (invalidate-audio-state (current-client) self))
  
  
  (method package (setup-bin self)
    (let ((bin (gst-bin (format "appsrc{? caps=\"{a}\"~} min-latency=30000000 name=src" caps)
                        (and (not sound?) "queue")
                        (and (eq? codec 'aac) "avdec_aac name=dec")
                        (and (eq? codec 'opus) "opusdec name=dec")
                        (and (eq? codec 'vorbis) "vorbisdec name=dec")
                        "audioconvert"
                        "audioresample"
                        ;; hardcoded caps for now that must match
                        ;; the event caps pushed on the decoder pad
                        "audio/x-raw, format=S16LE, layout=interleaved, rate=48000, channels=2"
                        (let ((volume (or volume 1)))
                          (tie "volume name=volume volume={volume}"))
                        "audiopanorama method=1 name=panorama")))
      (with-unref ((appsrc (gst_bin_get_by_name bin "src"))
                   (volelem (gst_bin_get_by_name bin "volume"))
                   (panelem (gst_bin_get_by_name bin "panorama")))
        (when (not caps)
          (case codec
            ((opus)
             (gst-app-src-set-caps appsrc "audio/x-opus"
               "channel-mapping-family" 'int 0))
            ((vorbis)
             (gst-app-src-set-caps appsrc "audio/x-vorbis"))))
        (g-object-set appsrc
          "is-live"     'boolean #t
          "stream-type" 'int     GST_APP_STREAM_TYPE_STREAM
          "format"      'int     GST_FORMAT_TIME)
        (gst_element_set_state bin GST_STATE_READY)
        (set! self.bin bin)
        (set! self.appsrc appsrc)
        (set! self.volelem volelem)
        (set! self.panelem panelem))))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (setup-bin self))
  
  
  (method override (start-element self)
    (nextmethod self)
    (gst_element_set_state bin GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state bin GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state bin GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (gst_element_set_state bin GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release bin)
    (set! bin #f)
    (set! appsrc #f)
    (set-stream-state self 'off))
  
  
  (method protected virtual (consume-audio self buffer dts pts duration)
    (when (not stream-playing?)
      (if (not stream-prerolled?)
          (set! stream-prerolled? #t)
        (play self)
        (set! stream-playing? #t)))
    ;; this experimental number seems to give the best results
    (let ((extra-offset 30000000)
          (timestamp-offset (rebase-time time-adapter 'audio appsrc dts)))
      (gst_app_src_write appsrc buffer (u8vector-length buffer) dts pts duration (+ timestamp-offset extra-offset))))
  
  
  (method public (muted? self)
    (g_object_get_boolean volelem "mute"))
  
  
  (method public (mute self)
    (g_object_set_boolean volelem "mute" #t))
  
  
  (method public (unmute self)
    (g_object_set_boolean volelem "mute" #f))
  
  
  (method public (get-volume self)
    (g_object_get_double volelem "volume"))
  
  
  (method public (set-volume self vol)
    (g_object_set_double volelem "volume" vol))
  
  
  (method public (set-panorama self pan)
    (g_object_set_double panelem "panorama" pan)))


;;;
;;;; Monitor
;;;


(class Audio-Monitor extends Object
  
  
  (slot systemclock-name      initialize #f accessors generate)
  (slot audioclock-name       initialize #f accessors generate)
  (slot first-originclock     initialize #f getter generate)
  (slot first-realclock       initialize #f getter generate)
  (slot first-monotonicclock  initialize #f getter generate)
  (slot first-systemclock     initialize #f getter generate)
  (slot first-audioclock      initialize #f getter generate)
  (slot originclock-elapse    initialize 0. getter generate)
  (slot realclock-elapse      initialize 0. getter generate)
  (slot monotonicclock-elapse initialize 0. getter generate)
  (slot systemclock-elapse    initialize 0. getter generate)
  (slot audioclock-elapse     initialize 0. getter generate)
  (slot originclock-rate      initialize 1. getter generate)
  (slot realclock-rate        initialize 1. getter generate)
  (slot monotonicclock-rate   initialize 1. getter generate)
  (slot systemclock-rate      initialize 1. getter generate)
  (slot audioclock-rate       initialize 1. getter generate)
  
  
  (method (update self origintime realclock monotonicclock systemtime audiotime)
    (let ((originclock (timestamp->flonum origintime))
          (systemclock (timestamp->flonum systemtime))
          (audioclock (timestamp->flonum audiotime)))
      (when (not first-originclock)
        (set! first-originclock originclock)
        (set! first-realclock realclock)
        (set! first-monotonicclock monotonicclock)
        (set! first-systemclock systemclock)
        (set! first-audioclock audioclock))
      (set! originclock-elapse (- originclock first-originclock))
      (set! realclock-elapse (- realclock first-realclock))
      (set! monotonicclock-elapse (- monotonicclock first-monotonicclock))
      (set! systemclock-elapse (- systemclock first-systemclock))
      (set! audioclock-elapse (- audioclock first-audioclock))
      (record-event udp-id-debug-audio
                    -1.
                    -1.
                    -1.
                    originclock-elapse
                    realclock-elapse
                    monotonicclock-elapse
                    systemclock-elapse
                    audioclock-elapse)
      (when (> originclock-elapse 0.)
        (set! originclock-rate (/ originclock-elapse originclock-elapse))
        (set! realclock-rate (/ realclock-elapse originclock-elapse))
        (set! monotonicclock-rate (/ monotonicclock-elapse originclock-elapse))
        (set! systemclock-rate (/ systemclock-elapse originclock-elapse))
        (set! audioclock-rate (/ audioclock-elapse originclock-elapse)))))))
