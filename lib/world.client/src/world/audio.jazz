;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Audio
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.audio jazz


(import (jazz.graphic)
        (jazz.gstreamer)
        (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.billboard)
        (world.configure)
        (world.geometry)
        (world.id)
        (world.quad-texture)
        (world.settings)
        (world.stream)
        (world.stream.foreign)
        (world.syntax (phase syntax))
        (world.task))


(definition audio-codec
  (world-setting 'world.audio-codec 'vorbis))


(definition audio-debug?
  (world-setting 'world.audio-debug? #f))


;;;
;;;; Audio
;;;


(definition protected (new-world-audio)
  (let ((mic-src (new Mic-Src))
        (server-sink (new Stream-Sink
                       consumer: (lambda (buffer timestamp duration)
                                   (send-client-audio~ (client-tier) buffer timestamp duration)))))
    (new World-Audio input: (pipeline mic-src server-sink))))


(class World-Audio extends Object
  
  
  (slot input   getter generate)
  (slot outputs getter generate)
  
  
  (method override (initialize (input: input #f))
    (nextmethod)
    (set! input~self input)
    (set! outputs~self (make-table test: equal?)))
  
  
  (method (autostart)
    (when (world-setting 'world.audio-autostart? #f)
      (start)))
  
  
  (method (start)
    (start~ input))
  
  
  (method (stop)
    (stop~ input)
    (iterate-table outputs
      (lambda (id output)
        (stop~ output))))
  
  
  ;;;
  ;;;; Input
  ;;;
  
  
  (method (on-toggle-audio evt)
    (toggle))
  
  
  (method (toggle)
    (when (client?)
      (let ((world (current-world)))
        (if (stopped?~ input)
            (start)
          (stop))
        (update-parameter~ world 'audio)
        (display-on/off~ world "Audio" (playing?~ input)))))
  
  
  ;;;
  ;;;; Output
  ;;;
  
  
  (method (cache-output id)
    (or (table-ref outputs id #f)
        (let ((output (new-output)))
          (table-set! outputs id output)
          output)))
  
  (method (find-output id)
    (table-ref outputs id #f))
  
  
  (method (new-output)
    (new Audio-Sink
      codec: audio-codec))
  
  
  (method (receive-server-audio id buffer timestamp duration)
    (if (not buffer)
        (let ((output (find-output id)))
          (when output
            (table-clear outputs id)
            (stop~ output)))
      (let ((output (cache-output id)))
        (start~ output)
        (consume~ output buffer timestamp duration)))))


;;;
;;;; Mic-Src
;;;


(class Mic-Src extends Stream-Src
  
  
  (slot pipeline             initialize #f accessors generate)
  (slot appsink              initialize #f accessors generate)
  (slot data     <u8vector>  initialize #f accessors generate)
  (slot info     <u64vector> initialize #f accessors generate)
  (slot task                 initialize #f accessors generate)
  
  
  (method override (start)
    (define (task-start)
      (let ((procedure
              (lambda (task)
                (mic-task task))))
        (let ((task (new Task 'mic procedure)))
          (start-task task)
          (thread-base-priority-set! (get-thread~ task) audio-priority)
          task)))
    
    (unless (eq? state 'playing)
      (init-gstreamer)
      (let ((codec audio-codec))
        (let ((pipeline (gst-launch "autoaudiosrc format=F32LE layout=interleaved rate=8000 channels=2 name=src"
                                    (and (eq? codec 'opus) (tie "avenc_opus name=enc"))
                                    (and (eq? codec 'vorbis) (tie "vorbisenc name=enc"))
                                    "appsink name=sink")))
          (gst_object_set_name pipeline "input")
          (let ((appsink (gst_bin_get_by_name pipeline "sink"))
                (data (make-u8vector 4096))
                (info (make-u64vector 2)))
            (gst_element_set_state pipeline GST_STATE_PLAYING)
            (set! data~self data)
            (set! info~self info)
            (set! pipeline~self pipeline)
            (set! appsink~self appsink)
            (set! task~self (task-start))
            (set! state 'playing))))))
  
  
  (method override (stop)
    (define (task-stop)
      (cease-task task))
    
    (when (eq? state 'playing)
      (gst_element_set_state pipeline GST_STATE_NULL)
      (gst_object_unref pipeline)
      (set! info #f)
      (set! data #f)
      (set! pipeline #f)
      (set! appsink #f)
      (set! task #f)
      (set! state #f)
      (consume~ sink #f #f #f)))
  
  
  (method (mic-task task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-seconds)))
          ;; not 100% correct if preempted before task-mutex
          (let ((time (current-seconds)))
            (with-task-mutex
              (lambda ()
                (unless (stopping?~ task)
                  (let ((elapse (- time previous))
                        (max-elapse 10.))
                    ;; ignore ridiculous elapses like
                    ;; coming back from computer sleep
                    (unless (> elapse max-elapse)
                      (let ((history (current-history)))
                        (unless (get-paused?~ history)
                          (process))))))))
            (let ((duration (- (current-seconds) time)))
              (task-sleep task audio-period duration exit))
            (iter time))))))
  
  
  (method override (process)
    (when (eq? state 'playing)
      (let ((size (gst_app_sink_read appsink data info)))
        (when (/= size -1)
          (let ((buffer (subu8vector data 0 size))
                (timestamp (u64vector-ref info 0))
                (duration (u64vector-ref info 1)))
            (consume~ sink buffer timestamp duration)))))))


;;;
;;;; Output
;;;


(class Audio-Sink extends Stream-Sink
  
  
  (slot codec    initialize #f accessors generate)
  (slot pipeline initialize #f accessors generate)
  (slot appsrc   initialize #f accessors generate)
  
  
  (method override (initialize (codec: codec #f))
    (nextmethod)
    (set! codec~self codec))
  
  
  (method override (start)
    (unless (eq? state 'playing)
      (init-gstreamer)
      (let ((pipeline (gst-launch (tie "appsrc name=src")
                                  (and (eq? codec 'opus) "avdec_opus name=dec")
                                  (and (eq? codec 'vorbis) "vorbisdec name=dec")
                                  (tie "autoaudiosink name=sink"))))
        (gst_object_set_name pipeline "output")
        (let ((appsrc (gst_bin_get_by_name pipeline "src")))
          (case codec
            ((vorbis)
             (gst_app_src_set_caps appsrc
               (gst_caps "audio/x-vorbis")))
            (else
             (gst_app_src_set_caps appsrc
               (gst_caps "audio/x-raw"
                 "format"   (g_value_string "F32LE")
                 "layout"   (g_value_string "interleaved")
                 "rate"     (g_value_int 8000)
                 "channels" (g_value_int 2)))))
          (g_object_set appsrc
            "is-live"     (g_value_boolean #t)
            "stream-type" (g_value_int GST_APP_STREAM_TYPE_STREAM)
            "format"      (g_value_int GST_FORMAT_TIME))
          (gst_element_set_state pipeline GST_STATE_PLAYING)
          (set! pipeline~self pipeline)
          (set! appsrc~self appsrc)
          (set! state 'playing)))))
  
  
  (method override (stop)
    (when (eq? state 'playing)
      (gst_element_set_state pipeline GST_STATE_NULL)
      (gst_object_unref pipeline)
      (set! pipeline #f)
      (set! appsrc #f)
      (set! state #f)))
  
  
  (method override (consume buffer timestamp duration)
    (gst_app_src_write3 appsrc buffer (u8vector-length buffer) timestamp duration))))
