;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Audio
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.audio jazz


(import (jazz.io)
        (jazz.listener)
        (jazz.presence)
        (jazz.stream)
        (jazz.stream.syntax (phase syntax))
        (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.configure)
        (world.context)
        (world.event)
        (world.interface)
        (world.media)
        (world.settings)
        (world.stream)
        (world.support)
        (world.task)
        (world.time)
        (world.udp))


(definition protected audio-rate
  (world-setting 'world.audio-rate 48000))

(definition protected audio-codec
  (world-setting 'world.audio-codec 'vorbis))

(definition protected audio-provider
  (world-setting 'world.audio-provider 'directsound))


(definition audio-show
  (world-setting 'world.audio-show #f))


;; denoiser only works for 48000 rate
(definition protected audio-denoise?
  (world-setting 'world.audio-denoise? (= audio-rate 48000)))

(definition protected (set-audio-denoise? flag)
  (set! audio-denoise? flag))


(definition protected audio-properties
  (world-setting 'world.audio-properties #f))

(definition protected (set-audio-properties properties)
  (set! audio-properties properties))


(definition protected start-muted?
  (world-setting 'world.start-muted? #f))


;;;
;;;; Codec
;;;


(class Vorbis-Codec extends Codec
  
  
  (method override (buffer-header? self buffer)
    (let ((size (u8vector-length buffer)))
      (and (>= size 7)
           (equal? (subu8vector buffer 1 7)
                   #u8(118 111 114 98 105 115))))))


(class Opus-Codec extends Codec
  
  
  (method override (buffer-header? self buffer)
    #f))


(register-codec (new Vorbis-Codec 'vorbis 'audio))
(register-codec (new Opus-Codec 'opus 'audio))


;;;
;;;; Header
;;;


(definition protected (audio-buffer-header? buffer)
  (if (eq? audio-codec 'vorbis)
      (let ((size (u8vector-length buffer)))
        (and (>= size 7)
             (equal? (subu8vector buffer 1 7)
                     #u8(118 111 114 98 105 115))))
    #f))


;;;
;;;; Profile
;;;


(definition public (audio-profile-extension)
  "streamaudio")


(definition public (streaming-audio-extensions)
  (list (audio-profile-extension)))


;;;
;;;; Stream
;;;


(definition protected (locate-stream-audio-channel stream)
  (table-search (lambda (no channel)
                  (and (= (get-media-kind channel) udp-audio)
                       channel))
                (get-channels stream)))


;;;
;;;; Audio
;;;


(class World-Audio extends Object
  
  
  (slot outputs         getter generate)
  (slot ordered-outputs getter generate)
  
  
  (method override (initialize self)
    (nextmethod self)
    (set! self.outputs (make-table test: equal?))
    (set! self.ordered-outputs '()))
  
  
  ;;;
  ;;;; Output
  ;;;
  
  
  (method package (find-output self id)
    (table-ref outputs id #f))
  
  
  (method package (player-output self id (volume: volume #f))
    (or (table-ref outputs id #f)
        (let ((output (new-output self volume: volume)))
          (setup output)
          (table-set! outputs id output)
          (set! ordered-outputs (append! ordered-outputs (list output)))
          (start output)
          output)))
  
  
  (method package (channel-output self channel (volume: volume #f))
    (let ((output (player-output self (get-no channel) volume: volume)))
      (set-channel output channel)
      (when start-muted?
        (mute output))
      output))
  
  
  (method package (visualizer-output self)
    (let ((output (new Audio-Sink codec: audio-codec provider: audio-provider)))
      (start output)
      output))
  
  
  (method (new-output self (volume: volume #f))
    (new Audio-Sink
      codec: audio-codec
      provider: audio-provider
      volume: volume))
  
  
  (method package (close-output self id output)
    (table-clear outputs id)
    (set! ordered-outputs (remove! output ordered-outputs))
    (release output)
    (close output))
  
  
  (method package (receive-server-audio self id buffer dts pts duration)
    (let ((output (find-output self id)))
      (when output
        (if (not buffer)
            (set-stream-state output 'off)
          (when (eq? (get-stream-state output) 'off)
            (set-stream-state output 'on))
          (consume-audio output buffer dts pts duration)
          (when udp-record-src/sink?
            (let ((origin (get-origin (get-channel output))))
              (record-event udp-id-sink-media
                            (fixnum->flonum id)
                            (fixnum->flonum origin)
                            (fixnum->flonum udp-audio)
                            -1.
                            -1.
                            -1.
                            (timestamp->flonum pts))))))))
  
  
  (method package (receive-visualizer-audio self output buffer dts pts duration)
    (if (not buffer)
        (set-stream-state output 'off)
      (when (eq? (get-stream-state output) 'off)
        (set-stream-state output 'on))
      (consume-audio output buffer dts pts duration)))
  
  
  (method package (receive-audio self id/output buffer dts pts duration)
    (if (is? id/output Audio-Sink)
        (receive-visualizer-audio self id/output buffer dts pts duration)
      (receive-server-audio self id/output buffer dts pts duration))))


;;;
;;;; Audio-Src
;;;


(class Audio-Src extends Stream-Src
  
  
  (slot pipeline initialize #f accessors generate)
  (slot appsrc   initialize #f accessors generate)
  (slot task     initialize #f accessors generate)
  (slot consumer initialize #f getter generate)
  
  
  (method package virtual (start-listeners self)
    (when consumer
      (start-listener consumer)))
  
  
  (method package virtual (stop-listeners self)
    (when consumer
      (stop-listener consumer)))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (set! consumer (car sinks)))
  
  
  (method (task-start self name)
    (let ((procedure
            (lambda (task)
              (audio-loop self task))))
      (let ((task (new Task name procedure priority: audio-priority)))
        (start-listeners self)
        (start-task task)
        (set! self.task task))))
  
  
  (method (task-stop self)
    (stop-listeners self)
    (stop-task task)
    (set! task #f))
  
  
  (method protected virtual (audio-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (process self task exit)
          (iter)))))
  
  
  (method override (process self task exit)
    (gst_app_sink_process task exit consumer)))


;;;
;;;; Mic-Audio-Src
;;;


;; denoiser only works in S16LE format and 48000 rate
(definition protected denoiser-caps
  "audio/x-raw, format=S16LE, layout=interleaved, rate=48000, channels=1")

;; prevents sharp spikes that sound really harsh when denoised
(definition protected denoiser-filter
  "audiodynamic threshold=0.5 ratio=0.5 characteristics=soft-knee")


(class Mic-Audio-Src extends Audio-Src
  
  
  (slot mic-pipeline initialize #f accessors generate)
  (slot mic-sink     initialize #f accessors generate)
  (slot denoiser     initialize #f accessors generate)
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((properties (or audio-properties "")))
      ;; mic
      (let ((pipeline (gst-pipeline ;; provide-clock=false to use the system clock
                                    ;; this makes sure audio and video stay synced
                                    ;; latency-time=30000 is the minimum to get good
                                    ;; audio on windows and also improves the mac audio
                                    (cond-expand
                                      (windows "directsoundsrc latency-time=30000 provide-clock=false name=src")
                                      (else "osxaudiosrc latency-time=30000 provide-clock=false name=src"))
                                    "audioresample"
                                    denoiser-caps
                                    denoiser-filter
                                    "appsink sync=false name=sink")))
        (gst_object_set_name pipeline "mic")
        (with-unref ((appsink (gst_bin_get_by_name pipeline "sink")))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.mic-pipeline pipeline)
          (set! self.mic-sink appsink)))
      ;; audio
      (let ((listener (open-stream-listener "mic"))
            (pipeline (gst-pipeline "appsrc name=src"
                                    (and (eq? audio-codec 'opus) (tie "opusenc {properties} name=enc"))
                                    (and (eq? audio-codec 'vorbis) "audioconvert")
                                    (and (eq? audio-codec 'vorbis) (tie "audio/x-raw, format=F32LE, layout=interleaved, rate={audio-rate}, channels=1"))
                                    (and (eq? audio-codec 'vorbis) (tie "vorbisenc {properties} name=enc"))
                                    "appsink sync=false name=sink")))
        (gst_object_set_name pipeline "audio")
        (with-unref ((appsrc (gst_bin_get_by_name pipeline "src"))
                     (appsink (gst_bin_get_by_name pipeline "sink")))
          (gst-app-src-set-caps appsrc "audio/x-raw"
            "format"   'string "S16LE"
            "layout"   'string "interleaved"
            "rate"     'int    audio-rate
            "channels" 'int    1)
          (g-object-set appsrc
            "is-live"     'boolean #t
            "stream-type" 'int     GST_APP_STREAM_TYPE_STREAM
            "format"      'int     GST_FORMAT_TIME)
          (gst_app_sink_connect_signals appsink listener)
          (setup-consumer consumer listener appsink 4096)
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.pipeline pipeline)
          (set! self.appsrc appsrc)))
      ;; denoiser
      (set! denoiser (create-denoiser mic-sink appsrc #f #f audio-denoise?))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED)
    (gst_element_set_state mic-pipeline GST_STATE_PAUSED)
    (task-start self 'mic))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING)
    (gst_element_set_state mic-pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED)
    (gst_element_set_state mic-pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY)
    (gst_element_set_state mic-pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (consume consumer #f #f #f #f)
    (gst_element_release pipeline)
    (set! pipeline #f)
    (set! appsrc #f)
    (release-consumer consumer)
    (gst_element_release mic-pipeline)
    (set! mic-pipeline #f)
    (set! mic-sink #f)
    (free-denoiser denoiser)
    (set! denoiser #f))
  
  
  (method override (resettable? self)
    #t)
  
  
  (method override (reset-media self channel)
    (when (eq? audio-codec 'vorbis)
      (resend-header consumer (get-no channel)))))


;;;
;;;; Audio-Consumer
;;;


(class Audio-Consumer extends Stream-Consumer
  
  
  (slot headers initialize '() accessors generate)
  (slot header  initialize #f  accessors generate)
  
  
  (method override (release-element self)
    (nextmethod self)
    (set! headers '())
    (set! header #f))
  
  
  (method override (consume self buffer dts pts duration)
    (case audio-codec
      ;; opus has no headers
      ((opus)
       (nextmethod self buffer dts pts duration))
      ((vorbis)
       (if (and buffer (audio-buffer-header? buffer))
           (begin
             (set! headers (append! headers (list (list buffer dts pts duration))))
             (when (= (length headers) 3)
               (set! header (object->u8vector headers))
               (nextmethod self (list header) #f #f #f)))
         (nextmethod self buffer dts pts duration)))))
   
   
  (method protected (resend-header self channel-no)
    (when header
      (if (client?)
          (let ((tier (current-client)))
            (send-client-media tier channel-no header #t GST_CLOCK_TIME_NONE GST_CLOCK_TIME_NONE GST_CLOCK_TIME_NONE))
        (let ((tier (current-server)))
          (send-server-media tier channel-no header #t GST_CLOCK_TIME_NONE GST_CLOCK_TIME_NONE GST_CLOCK_TIME_NONE))))))


;;;
;;;; Mic-Audio-Consumer
;;;


(class Mic-Audio-Consumer extends Audio-Consumer
  
  
  (method override (consume self buffer dts pts duration)
    (nextmethod self buffer dts pts duration)
    (when buffer
      (let ((header? (audio-buffer-header? buffer))
            (size (u8vector-length buffer)))
        (when audio-show
          (if (eq? audio-codec 'vorbis)
              (let ((type (if header?
                              '***header***
                            'data)))
                (terminal 'audio size type))
            (terminal 'audio size)))
        (when udp-record-src/sink?
          (record-event udp-id-src-media
                        -1. ;; todo channel no
                        (fixnum->flonum client-no)
                        (fixnum->flonum udp-audio)
                        -1.
                        (if header? 1. -1.)
                        (fixnum->flonum size)
                        (timestamp->flonum pts)))))))


;;;
;;;; File-Preprocess-Audio-Src
;;;


(class File-Preprocess-Audio-Src extends Audio-Src
  
  
  (slot location      initialize #f accessors generate)
  (slot file-pipeline initialize #f accessors generate)
  (slot file-sink     initialize #f accessors generate)
  (slot volume        initialize #f accessors generate)
  (slot denoiser      initialize #f accessors generate)
  
  
  (method override (initialize self location)
    (nextmethod self)
    (set! self.location location))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((properties (or audio-properties ""))
          (listener (open-stream-listener "preprocessaudio")))
      ;; file
      (let ((pipeline (gst-pipeline (tie "filesrc name=filesrc")
                                    "decodebin"
                                    "audioconvert"
                                    "audioresample"
                                    denoiser-caps
                                    denoiser-filter
                                    "appsink sync=false name=sink")))
        (gst_object_set_name pipeline "file")
        (with-unref ((filesrc (gst_bin_get_by_name pipeline "filesrc"))
                     (appsink (gst_bin_get_by_name pipeline "sink")))
          (g_object_set_string filesrc "location" (path-normalize location))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.file-pipeline pipeline)
          (set! self.file-sink appsink)))
      ;; audio
      (let ((listener (open-stream-listener "file"))
            (pipeline (gst-pipeline "appsrc name=src"
                                    "volume name=volume"
                                    (and (eq? audio-codec 'opus) (tie "opusenc {properties} name=enc"))
                                    (and (eq? audio-codec 'vorbis) "audioconvert")
                                    (and (eq? audio-codec 'vorbis) "audioresample")
                                    (and (eq? audio-codec 'vorbis) (tie "audio/x-raw, format=F32LE, layout=interleaved, rate={audio-rate}, channels=1"))
                                    (and (eq? audio-codec 'vorbis) (tie "vorbisenc {properties} name=enc"))
                                    "appsink name=appsink sync=false")))
        (with-unref ((appsrc (gst_bin_get_by_name pipeline "src"))
                     (appsink (gst_bin_get_by_name pipeline "appsink"))
                     (volume (gst_bin_get_by_name pipeline "volume")))
          (gst-app-src-set-caps appsrc "audio/x-raw"
            "format"   'string "S16LE"
            "layout"   'string "interleaved"
            "rate"     'int    audio-rate
            "channels" 'int    1)
          (g-object-set appsrc
            "is-live"     'boolean #t
            "stream-type" 'int     GST_APP_STREAM_TYPE_STREAM
            "format"      'int     GST_FORMAT_TIME)
          (gst_app_sink_connect_signals appsink listener)
          (setup-consumer consumer listener appsink 4096)
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.pipeline pipeline)
          (set! self.appsrc appsrc)
          (set! self.volume volume)))
      ;; denoiser
      (set! denoiser (create-denoiser file-sink appsrc volume #t #t))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'file)
    (gst_element_set_state pipeline GST_STATE_PAUSED)
    (gst_element_set_state file-pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING)
    (gst_element_set_state file-pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED)
    (gst_element_set_state file-pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY)
    (gst_element_set_state file-pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! pipeline #f)
    (set! appsrc #f)
    (release-consumer consumer)
    (gst_element_release file-pipeline)
    (set! file-pipeline #f)
    (set! file-sink #f)
    (free-denoiser denoiser)
    (set! denoiser #f))
  
  
  (method override (audio-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (site (preprocess)
            (process self task exit))
          (sleep .001)
          (iter))))))


;;;
;;;; File-Stream-Audio-Src
;;;


(class File-Stream-Audio-Src extends Audio-Src implements Media-Stream
  
  
  (slot location  getter generate)
  (slot stream?   accessors explicit)
  (slot file      getter generate)
  (slot reader    getter generate)
  (slot time-base getter generate)
  (slot muted?    getter generate)
  (slot pause?    getter generate)
  (slot flush?    getter generate)
  
  
  (method override (initialize self location (stream?: stream? #t))
    (nextmethod self)
    (set! self.location location)
    (set! self.stream? stream?)
    (set! self.file #f)
    (set! self.reader #f)
    (set! self.time-base (new Time-Base))
    (set! self.muted? #f)
    (set! self.pause? #f)
    (set! self.flush? #f))
  
  
  (method override (start-element self)
    (nextmethod self)
    (set! file (new-file {Directory Documents} (add-extension location (audio-profile-extension))))
    (set! reader (new Stream-Reader file))
    (task-start self 'audio-stream))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (close reader)
    (set! file #f)
    (set! reader #f))
  
  
  (method override (get-stream? self)
    stream?)
  
  
  (method override (set-stream? self flag)
    (set! stream? flag))
  
  
  (method override (play-stream self)
    (task-wakeup (get-thread task)
      (lambda (exit)
        (set! pause? #f)
        (reset time-base))))
  
  
  (method override (pause-stream self)
    (task-wakeup (get-thread task)
      (lambda (exit)
        (set! pause? #t)
        (task-sleep task +inf.0 exit))))
  
  
  (method override (goto-stream self pos pts)
    (task-wakeup (get-thread task)
      (lambda (exit)
        (if (not pos)
            (if pause?
                (task-sleep task +inf.0 exit)
              (reset time-base)
              (set! flush? #t))
          (goto reader pos pts)
          (task-sleep task +inf.0 exit)))))
  
  
  (method override (backward-stream self)
    )
  
  
  (method override (forward-stream self)
    )
  
  
  (method protected (mute-stream self)
    (set! muted? #t))
  
  
  (method protected (unmute-stream self)
    (set! muted? #f))
  
  
  (method override (audio-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (if (stopping? task)
              (task-done task exit)
            ;; protect against stream? threaded change
            (let ((stream? stream?))
              (receive (buffer dts pts duration) (read-frame reader stream?)
                (if (not buffer)
                    (if stream-loop?
                        (begin
                          (close reader)
                          (set! reader (new Stream-Reader file))
                          (set! time-base (new Time-Base))
                          (iter))
                      (task-done task exit))
                  (let ((time (current-seconds))
                        (nanopts (timestamp->flonum pts)))
                    (update-start time-base time nanopts)
                    (let ((sendtime (remote->local time-base nanopts)))
                      (task-sleep task (- sendtime time) exit)
                      (when stream?
                        (if flush?
                            (set! flush? #f)
                          (site (stream)
                            (unless muted?
                              (consume consumer buffer dts pts duration))))))))))
            (iter))))))
  
  
  (method override (resettable? self)
    #t)
  
  
  (method override (reset-media self channel)
    (when (eq? audio-codec 'vorbis)
      (resend-header consumer (get-no channel)))))


;;;
;;;; Audio-Sink
;;;


(class Audio-Sink extends Stream-Sink
  
  
  (slot channel             initialize #f accessors generate)
  (slot codec               initialize #f accessors generate)
  (slot provider            initialize #f accessors generate)
  (slot volume              initialize #f accessors explicit)
  (slot pipeline            initialize #f accessors generate)
  (slot appsrc              initialize #f accessors generate)
  (slot volelem             initialize #f accessors generate)
  (slot panelem             initialize #f accessors generate)
  (slot stream-state        initialize 'off getter generate setter explicit)
  (slot stream-playing?     initialize #f getter generate)
  (slot moving-deviation    initialize 0. getter generate)
  (slot timestamp-offset    initialize 0  getter generate)
  (slot extra-offset        initialize 30000000 accessors generate)
  (slot buffer-count        initialize 0  getter generate)
  (slot monitor             getter generate)
  
  
  (method override (initialize self (codec: codec #f) (provider: provider #f) (volume: volume #f))
    (nextmethod self)
    (set! self.codec codec)
    (set! self.provider provider)
    (set! self.volume volume)
    (set! self.monitor (new Audio-Monitor)))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (let ((effective-name (if (not channel) "Me" (get-name (get-stream channel)))))
          (format output "{a}" effective-name)))))
  
  
  (method package (set-stream-state self state)
    (when (neq? state stream-state)
      (set! stream-state state)
      (invalidate-audio-state (current-client) self)))
  
  
  (method package virtual (setup-pipeline self)
    (let ((pipeline (gst-pipeline (tie "appsrc name=src")
                                  "queue"
                                  (and (eq? codec 'opus) "opusdec name=dec")
                                  (and (eq? codec 'vorbis) "vorbisdec name=dec")
                                  (let ((volume (or volume 1)))
                                    (tie "volume name=volume volume={volume}"))
                                  "audiopanorama method=1 name=panorama"
                                  ;; hardcoded caps for now that must match
                                  ;; the event caps pushed on the decoder pad
                                  "audioconvert"
                                  "audioresample"
                                  "audio/x-raw, format=S16LE, layout=interleaved, rate=48000, channels=1"
                                  (cond-expand
                                    (windows (if (eq? provider 'directsound)
                                                 "directsoundsink buffer-time=200000 discont-wait=0 name=sink"
                                               "wasapisink buffer-time=200000 discont-wait=0 name=sink"))
                                    (mac "osxaudiosink buffer-time=200000 discont-wait=0 name=sink")
                                    (else "autoaudiosink name=sink")))))
      (gst_object_set_name pipeline "output")
      (with-unref ((appsrc (gst_bin_get_by_name pipeline "src"))
                   (volelem (gst_bin_get_by_name pipeline "volume"))
                   (panelem (gst_bin_get_by_name pipeline "panorama")))
        (case codec
          ((opus)
           (gst-app-src-set-caps appsrc "audio/x-opus"
             "channel-mapping-family" 'int 0))
          ((vorbis)
           (gst-app-src-set-caps appsrc "audio/x-vorbis")))
        (g-object-set appsrc
          "is-live"     'boolean #t
          "stream-type" 'int     GST_APP_STREAM_TYPE_STREAM
          "format"      'int     GST_FORMAT_TIME)
        (gst_element_set_state pipeline GST_STATE_READY)
        (set! self.pipeline pipeline)
        (set! self.appsrc appsrc)
        (set! self.volelem volelem)
        (set! self.panelem panelem))))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (setup-pipeline self))
  
  
  (method override (start-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED)
    ;; it seems that appsrc will not generate events
    ;; and so we need to generate them ourselves as it
    ;; is critical that the audio sink receives the caps
    ;; event before going to play else when the pipeline
    ;; asks the audio sink for a provided clock the sink
    ;; will return null because its ring buffer won't have
    ;; been created in response to the caps event yet
    (with-unref ((dec (gst_bin_get_by_name pipeline "dec")))
      (with-unref ((pad (gst_element_get_static_pad dec "src")))
        (let ((caps (gst-new-caps "audio/x-raw"
                                  "format" 'string "S16LE"
                                  "layout" 'string "interleaved"
                                  "rate" 'int 48000
                                  "channels" 'int 1)))
          (gst_pad_push_event pad (gst_event_new_stream_start "stream"))
          (gst_pad_push_event pad (gst_event_new_caps caps))))))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! pipeline #f)
    (set! appsrc #f)
    (set-stream-state self 'off))
  
  
  (method protected virtual (consume-audio self buffer dts pts duration)
    (when (and (not stream-playing?)
               (> buffer-count 0))
      (play-element self)
      (set! stream-playing? #t))
    (if (audio-buffer-header? buffer)
        (gst_app_src_write appsrc buffer (u8vector-length buffer) dts pts duration 0)
      (let ((perfect-offset (- (gst_element_get_running_time appsrc) pts)))
        (let ((deviation (timestamp->flonum (abs (- perfect-offset timestamp-offset))))
              (tolerance .05))
          (set! moving-deviation (/ (+ (* moving-deviation 31.) deviation) 32.))
          (when (> moving-deviation tolerance)
            (set! timestamp-offset perfect-offset)
            (set! moving-deviation 0.)
            (when show-sync?
              (format :terminal "audio timestamp-offset {r precision: 3} extra-offset {r precision: 3}{%}" (timestamp->flonum timestamp-offset) (timestamp->flonum extra-offset))))))
      (gst_app_src_write appsrc buffer (u8vector-length buffer) dts pts duration (+ timestamp-offset extra-offset))
      (increase! buffer-count)))
  
  
  (method public (muted? self)
    (g_object_get_boolean volelem "mute"))
  
  
  (method public (mute self)
    (g_object_set_boolean volelem "mute" #t))
  
  
  (method public (unmute self)
    (g_object_set_boolean volelem "mute" #f))
  
  
  (method public (get-volume self)
    (g_object_get_double volelem "volume"))
  
  
  (method public (set-volume self vol)
    (g_object_set_double volelem "volume" vol))
  
  
  (method public (set-panorama self pan)
    (g_object_set_double panelem "panorama" pan)))


;;;
;;;; Monitor
;;;


(class Audio-Monitor extends Object
  
  
  (slot systemclock-name      initialize #f accessors generate)
  (slot audioclock-name       initialize #f accessors generate)
  (slot first-originclock     initialize #f getter generate)
  (slot first-realclock       initialize #f getter generate)
  (slot first-monotonicclock  initialize #f getter generate)
  (slot first-systemclock     initialize #f getter generate)
  (slot first-audioclock      initialize #f getter generate)
  (slot originclock-elapse    initialize 0. getter generate)
  (slot realclock-elapse      initialize 0. getter generate)
  (slot monotonicclock-elapse initialize 0. getter generate)
  (slot systemclock-elapse    initialize 0. getter generate)
  (slot audioclock-elapse     initialize 0. getter generate)
  (slot originclock-rate      initialize 1. getter generate)
  (slot realclock-rate        initialize 1. getter generate)
  (slot monotonicclock-rate   initialize 1. getter generate)
  (slot systemclock-rate      initialize 1. getter generate)
  (slot audioclock-rate       initialize 1. getter generate)
  
  
  (method (update self origintime realclock monotonicclock systemtime audiotime)
    (let ((originclock (timestamp->flonum origintime))
          (systemclock (timestamp->flonum systemtime))
          (audioclock (timestamp->flonum audiotime)))
      (when (not first-originclock)
        (set! first-originclock originclock)
        (set! first-realclock realclock)
        (set! first-monotonicclock monotonicclock)
        (set! first-systemclock systemclock)
        (set! first-audioclock audioclock))
      (set! originclock-elapse (- originclock first-originclock))
      (set! realclock-elapse (- realclock first-realclock))
      (set! monotonicclock-elapse (- monotonicclock first-monotonicclock))
      (set! systemclock-elapse (- systemclock first-systemclock))
      (set! audioclock-elapse (- audioclock first-audioclock))
      (record-event udp-id-debug-audio
                    -1.
                    -1.
                    -1.
                    originclock-elapse
                    realclock-elapse
                    monotonicclock-elapse
                    systemclock-elapse
                    audioclock-elapse)
      (when (> originclock-elapse 0.)
        (set! originclock-rate (/ originclock-elapse originclock-elapse))
        (set! realclock-rate (/ realclock-elapse originclock-elapse))
        (set! monotonicclock-rate (/ monotonicclock-elapse originclock-elapse))
        (set! systemclock-rate (/ systemclock-elapse originclock-elapse))
        (set! audioclock-rate (/ audioclock-elapse originclock-elapse)))))))
