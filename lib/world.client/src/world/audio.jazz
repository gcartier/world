;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Audio
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.audio jazz


(import (jazz.event)
        (jazz.flow)
        (jazz.io)
        (jazz.listener)
        (jazz.platform)
        (jazz.presence)
        (jazz.settings)
        (jazz.stream)
        (jazz.stream.syntax (phase syntax))
        (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.capture)
        (world.configure)
        (world.context)
        (world.customize)
        (world.event)
        (world.interface)
        (world.media)
        (world.settings)
        (world.stream)
        (world.support)
        (world.task)
        (world.time)
        (world.udp))


(definition protected audio-rate
  48000)

(definition protected audio-codec
  'opus)


(definition protected audio-echo-cancel?
  (world-setting 'world.audio-echo-cancel? #t))

(definition protected (set-audio-echo-cancel? flag)
  (set! audio-echo-cancel? flag))


(definition protected audio-noise-suppress?
  (world-setting 'world.audio-noise-suppress? #t))

(definition protected (set-audio-noise-suppress? flag)
  (set! audio-noise-suppress? flag))


(definition protected audio-rndenoise?
  (world-setting 'world.audio-rndenoise? #f))

(definition protected (set-audio-rndenoise? flag)
  (set! audio-rndenoise? flag))


;; to debug mixer gritches
(definition protected visualizer-mixer?
  (world-setting 'world.visualizer-mixer? #t))


;;;
;;;; Codec
;;;


(class AAC-Codec extends Codec)
(class Vorbis-Codec extends Codec)
(class Opus-Codec extends Codec)


(register-codec (new AAC-Codec 'aac 'audio))
(register-codec (new Vorbis-Codec 'vorbis 'audio))
(register-codec (new Opus-Codec 'opus 'audio))


;;;
;;;; Profile
;;;


(definition public (audio-profile-extension)
  "streamaudio")


(definition public (streaming-audio-extensions)
  (list (audio-profile-extension)))


;;;
;;;; Stream
;;;


(definition protected (locate-stream-audio-channel stream)
  (table-search (lambda (no channel)
                  (and (= (get-media-kind channel) udp-audio)
                       channel))
                (get-channels stream)))


;;;
;;;; Capture
;;;


(definition (capture-audio name bin pad)
  (capture-point name
    (lambda ()
      (gst_monitor bin pad 'queue 20.))
    (lambda (monitored)
      (bind (pad . id) monitored
        (cons (rawaudio-pad-info pad)
              (gst_monitor_queue_copy id))))
    gst_unmonitor))


(definition (uncapture-audio name)
  (uncapture-point name))


;;;
;;;; Microphone
;;;


(class Microphone-Provider extends Object
  
  
  (slot name       getter generate)
  (slot identifier getter generate)
  
  
  (method override (initialize self name identifier)
    (nextmethod self)
    (set! self.name name)
    (set! self.identifier identifier))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name)))))


(definition public (has-microphone?)
  (not-null? (concrete-microphone-providers)))


(definition protected (concrete-microphone-providers)
  (cdr (microphone-providers)))


(definition protected (microphone-providers)
  (define (microphone-device-identifier device)
    (with-unref ((element (gst_device_create_element device)))
      (cond-expand
        (mac (g_object_get_int element "device"))
        (windows (g_object_get_string element "device"))
        (else #f))))
  
  (with-microphone-devices
    (lambda (devices)
      (cons (new Microphone-Provider "System Default" #f)
            (map (lambda (device)
                   (let ((name (gst_device_get_display_name device))
                         (identifier (microphone-device-identifier device)))
                     (new Microphone-Provider name identifier)))
                 devices)))))


(definition protected (with-microphone-devices proc)
  (define (microphone-devices)
    (with-unref ((monitor (gst_device_monitor_new)))
      ;; gstreamer filter leak workaround
      (gst_device_monitor_add_filter monitor #f #f)
      @using-this-filter-leaks-in-gstreamer-hence-the-workaround
      (let ((caps (gst_caps_new_empty_simple "audio/x-raw")))
        (gst_device_monitor_add_filter monitor "Audio/Source" caps)
        (gst_caps_unref caps))
      (let ((queue (new-queue)))
        (let (loop (devices (gst_device_monitor_get_devices monitor)))
          (if (not devices)
              (begin
                (g_list_free devices)
                (queue-list queue))
            (let ((device (gst_device_monitor_device_list_data devices)))
              ;; gstreamer filter leak workaround
              (if (and (equal? (gst_device_get_device_class device) "Audio/Source")
                       (equal? (gst_device_get_type_name device) microphonesrc))
                  (enqueue queue device)
                (gst_device_unref_hack device))
              (loop (gst_device_monitor_device_list_next devices))))))))
  
  (let ((devices (microphone-devices)))
    (prog1 (proc devices)
      (gst_devices_unref devices))))


;;;
;;;; Speaker
;;;


(class Speaker-Provider extends Object
  
  
  (slot name       getter generate)
  (slot identifier getter generate)
  
  
  (method override (initialize self name identifier)
    (nextmethod self)
    (set! self.name name)
    (set! self.identifier identifier))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name)))))


(definition public (has-speaker?)
  (not-null? (concrete-speaker-providers)))


(definition protected (concrete-speaker-providers)
  (cdr (speaker-providers)))


(definition protected (speaker-providers)
  (define (speaker-device-identifier device)
    (with-unref ((element (gst_device_create_element device)))
      (cond-expand
        (mac (g_object_get_int element "device"))
        (windows (g_object_get_string element "device"))
        (else #f))))
  
  (with-speaker-devices
    (lambda (devices)
      (cons (new Speaker-Provider "System Default" #f)
            (map (lambda (device)
                   (let ((name (gst_device_get_display_name device))
                         (identifier (speaker-device-identifier device)))
                     (new Speaker-Provider name identifier)))
                 devices)))))


(definition protected (with-speaker-devices proc)
  (define (speaker-devices)
    (with-unref ((monitor (gst_device_monitor_new)))
      ;; gstreamer filter leak workaround
      (gst_device_monitor_add_filter monitor #f #f)
      @using-this-filter-leaks-in-gstreamer-hence-the-workaround
      (let ((caps (gst_caps_new_empty_simple "audio/x-raw")))
        (gst_device_monitor_add_filter monitor "Audio/Sink" caps)
        (gst_caps_unref caps))
      (let ((queue (new-queue)))
        (let (loop (devices (gst_device_monitor_get_devices monitor)))
          (if (not devices)
              (begin
                (g_list_free devices)
                (queue-list queue))
            (let ((device (gst_device_monitor_device_list_data devices)))
              ;; gstreamer filter leak workaround
              (if (and (equal? (gst_device_get_device_class device) "Audio/Sink")
                       (equal? (gst_device_get_type_name device) speakersink))
                  (enqueue queue device)
                (gst_device_unref_hack device))
              (loop (gst_device_monitor_device_list_next devices))))))))
  
  (let ((devices (speaker-devices)))
    (prog1 (proc devices)
      (gst_devices_unref devices))))


;;;
;;;; Audio
;;;


(class World-Audio extends Object
  
  
  (slot outputs         getter generate)
  (slot ordered-outputs getter generate)
  
  
  (method override (initialize self)
    (nextmethod self)
    (set! self.outputs (make-table test: equal?))
    (set! self.ordered-outputs '()))
  
  
  ;;;
  ;;;; Output
  ;;;
  
  
  (method package (find-output self id)
    (table-ref outputs id #f))
  
  
  (method package (player-output self id (channel: channel #f) (codec: codec #f) (caps: caps #f) (volume: volume #f))
    (or (table-ref outputs id #f)
        (let ((output (new-output self channel: channel codec: codec caps: caps volume: volume)))
          (setup output)
          (table-set! outputs id output)
          (set! ordered-outputs (append! ordered-outputs (list output)))
          (start output)
          output)))
  
  
  (method package (channel-output self channel (volume: volume #f))
    (let ((codec (get-codec channel))
          (caps (get-caps channel)))
      (player-output self (get-no channel) channel: channel codec: codec caps: caps volume: volume)))
  
  
  (method package (visualizer-output self (codec: codec #f) (caps: caps #f))
    (cond (visualizer-mixer?
           (let ((sink (new Audio-Sink codec: codec caps: caps mix?: #t))
                 (audio (cache-audio)))
             (add-sink audio sink)
             (play sink)
             (recalculate-latency audio)
             sink))
          (else
           (let ((sink (new Audio-Sink codec: codec caps: caps))
                 (audio (cache-audio)))
             (play sink)
             sink))))
  
  
  (method (new-output self (channel: channel #f) (codec: codec #f) (caps: caps #f) (volume: volume #f))
    (let ((sink (new Audio-Sink
                  channel: channel
                  codec: (or codec audio-codec)
                  caps: caps
                  volume: volume
                  mix?: #t))
          (audio (cache-audio)))
      (add-sink audio sink)
      (play sink)
      (recalculate-latency audio)
      sink))
  
  
  (method package (close-output self id output)
    (table-clear outputs id)
    (set! ordered-outputs (remove! output ordered-outputs))
    (remove-sink (cache-audio) output)
    (recalculate-latency (cache-audio)))
  
  
  (method package (close-empty-audio self)
    ;; need to do this as it is done in the commented out call to close-audio
    (unmonitor-default-output)
    @comment-out-until-debugged-as-this-sometimes-hangs-in-the-set-state-to-null
    (when (null? ordered-outputs)
      (close-audio)))
  
  
  (method package (receive-audio self output buffer dts pts duration timestamp-offset)
    (unless (get-stream-disconnected? output)
      (when (eq? (get-stream-state output) 'off)
        (set-stream-state output 'on))
      (write-audio output buffer dts pts duration timestamp-offset)))
  
  
  (method package (receive-visualizer-audio self output buffer dts pts duration)
    (when (eq? (get-stream-state output) 'off)
      (set-stream-state output 'on))
    (write-audio output buffer dts pts duration #f)))


;;;
;;;; Audio
;;;


(definition protected speakersink
  (cond-expand
    (windows "wasapisink")
    (mac "osxaudiosink")
    (else "pulsesink")))


(definition protected audioprobe-delay
  0)


(definition protected cached-audio
  #f)

(definition public (cache-audio)
  (if cached-audio
      ;; needed because the close-empty-audio call to close-audio is commented out
      (begin
        (monitor-default-output)
        cached-audio)
    (let ((audio (new Audio)))
      (setup audio)
      (play audio)
      (set! cached-audio audio)
      (monitor-default-output)
      audio)))

(definition public (close-audio)
  (when cached-audio
    (unmonitor-default-output)
    (release cached-audio)
    (set! cached-audio #f)))


(definition audiosink-tail
  "panorama")

(definition audiosink-tail-src
  "panorama.src")


(definition protected (effective-speaker-provider providers)
  (let ((name (world-setting 'world.speaker-name #f)))
    (if (not name)
        (car providers)
      (or (find providers name key: get-name test: equal? return: 'item)
          (car providers)))))


(definition protected (effective-speaker-information)
  (let ((providers (speaker-providers)))
    (let ((provider (effective-speaker-provider providers)))
      (values (get-name provider)
              (get-identifier provider)))))


(definition protected (speaker-identifier-update sink identifier)
  (cond-expand
    (mac (g_object_set_int sink "device" (or identifier 0)))
    (windows (g_object_set_string sink "device" (or identifier #f)))
    (else)))


(definition package (write-speaker-name name)
  (set-setting options-settings 'world.speaker-name name)
  (save-content options-settings))


(definition monitor-thread
  #f)

(definition monitor-listener
  #f)


(definition (monitor-default-output)
  (cond-expand
    (mac
     (unless monitor-listener
       (let ((client (current-client))
             (listener (open-stream-listener "speaker")))
         (define (process-listener)
           (declare (proper-tail-calls))
           (let (loop)
             (let ((c (wait listener)))
               (case c
                 ((#\.)
                  (delay-event
                    (lambda ()
                      (with-task-mutex
                        (lambda ()
                          (with-update-audio client
                            (lambda ()
                              (write-speaker-name #f)))))))
                  (loop))
                 ((#\@))))))
         
         (platformAudioMonitorDefaultOutput (get-write-file listener))
         (set! monitor-thread (thread-start! (new-thread process-listener 'audio-monitor)))
         (set! monitor-listener listener))))
    (else)))


(definition (unmonitor-default-output)
  (cond-expand
    (mac
     (when monitor-listener
       (platformAudioUnmonitorDefaultOutput (get-write-file monitor-listener))
       (thread-join! monitor-thread)
       (set! monitor-listener #f)
       (set! monitor-thread #f)))
    (else)))


(definition audio-mutex
  (make-mutex 'audio))


(class Audio extends Object
  
  
  (slot pipeline initialize #f accessors generate)
  
  
  (method package (add-sink self sink)
    (setup sink)
    (let ((bin (get-bin sink)))
      (set-pipeline sink pipeline)
      (with-unref ((mixer (gst_bin_get_by_name pipeline "mixer")))
        (gst_bin_add pipeline bin)
        (with-unref ((tail (gst_bin_get_by_name bin audiosink-tail)))
          (gst_element_link tail mixer)))))
  
  
  (method package (remove-sink self sink)
    (capture-release sink)
    (let ((bin (get-bin sink)))
      (with-unref ((pads (gst_element_src_pads bin)))
        (let ((ghost-pad (car pads)))
          (with-unref ((tail (gst_bin_get_by_name bin audiosink-tail))
                       (mixer (gst_bin_get_by_name pipeline "mixer")))
            (with-unref ((mixer-pad (gst_pad_get_peer ghost-pad)))
              (gst_element_unlink tail mixer)
              (gst_element_release_request_pad mixer mixer-pad)))))
      (with-bins-mutex
        (lambda ()
          (gst_element_set_state bin GST_STATE_NULL)
          (gst_bin_remove pipeline bin)
          (unregister-bin bin)))))

  
  (method package (recalculate-latency self)
    (gst_bin_recalculate_latency pipeline))
  
  
  (method (wait-audioclock self pipeline)
    (declare (proper-tail-calls))
    (with-unref ((sink (gst_bin_get_by_name pipeline "sink")))
      (let (loop (n 0))
        (when (< n 100)
          (when (not (gst_audio_ring_buffer_acquired sink))
            (sleep .01)
            (loop (+ n 1))))))
    (with-unref ((clock (gst_pipeline_get_clock pipeline)))
      (let ((clock-name (gst_object_get_name clock)))
        (unless (equal? clock-name (cond-expand
                                     (linux "GstPulseSinkClock")
                                     (else "GstAudioSinkClock")))
          (error "Failed to install an audio clock: {a}" clock-name)))))
  
  
  (method (remove-bootstrap self pipeline)
    (with-unref ((bootstrap (gst_bin_get_by_name pipeline "bootstrap"))
                 (tee (gst_bin_get_by_name pipeline "tee")))
      (gst_element_unlink bootstrap tee)
      (gst_element_set_state bootstrap GST_STATE_NULL)
      (gst_bin_remove pipeline bootstrap)))
  
  
  (method (start-clocksync self)
    (with-unref ((clocksync (gst_bin_get_by_name pipeline "clocksync")))
      (g_object_set_boolean clocksync "sync" #t)))
  
  
  (method package (update-identifier self identifier)
    (mutex-lock! audio-mutex)
    (gst_element_set_state pipeline GST_STATE_NULL)
    (with-unref ((sink (gst_bin_get_by_name pipeline "sink")))
      (speaker-identifier-update sink identifier))
    (gst_element_set_state pipeline GST_STATE_PLAYING)
    (wait-playing pipeline)
    (mutex-unlock! audio-mutex))
  
  
  (method public (setup self)
    (receive (speaker-name speaker-identifier) (effective-speaker-information)
      (let ((pipeline (gst-pipeline "audiotestsrc samplesperbuffer=480 wave=silence name=bootstrap"
                                    "audiomixer force-live=true min-upstream-latency=40000000 latency=100000000 name=mixer"
                                    "tee name=tee"
                                    "queue max-size-time=200000000 name=queue"
                                    (cond-expand
                                      (windows "audioconvert")
                                      (else #f))
                                    (gst-element speakersink
                                                 buffer-time: 100000
                                                 name: "sink")
                                    (cond-expand
                                      (silicon
                                       (list
                                         "tee."
                                         "queue"
                                         "proxysink name=audioproxy"))
                                      (else
                                       #f))
                                    (cond-expand
                                      (linux #f)
                                      (else (and (custom-webrtc-processing?)
                                                 (list
                                                   "tee."
                                                   "queue max-size-time=200000000 name=probequeue"
                                                   "clocksync ts-offset=270000000 sync=false name=clocksync"
                                                   (tie "webrtcaudioprobe delay={audioprobe-delay} name=probe")
                                                   "fakesink name=fakesink")))))))
        (with-unref ((sink (gst_bin_get_by_name pipeline "sink")))
          (write-speaker-name speaker-name)
          (speaker-identifier-update sink speaker-identifier))
        (gst_object_set_name pipeline "audio.speaker")
        (set! self.pipeline pipeline)
        (gst_element_set_state pipeline GST_STATE_PAUSED)
        (wait-audioclock self pipeline)
        (gst_element_set_state pipeline GST_STATE_PLAYING)
        (wait-playing pipeline)
        (remove-bootstrap self pipeline)
        (when (custom-webrtc-processing?)
          (start-clocksync self)))))
  
  
  (method public (play self)
    (gst_element_set_state pipeline GST_STATE_PLAYING)
    @audio-probe
    (when (custom-webrtc-processing?)
      (capture-audio "audio.probe" pipeline "probe.sink"))
    (capture-audio "audio.sink" pipeline "sink.sink"))
  
  
  (method public (pause self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method public (stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method public (release self)
    @audio-probe
    (when (custom-webrtc-processing?)
      (uncapture-audio "audio.probe"))
    (uncapture-audio "audio.sink")
    (gst_bin_release pipeline)
    (set! pipeline #f)))


;;;
;;;; Audio-Src
;;;


(class Audio-Src extends Stream-Src
  
  
  (slot pipeline initialize #f accessors generate)
  (slot appsrc   initialize #f accessors generate)
  (slot task     initialize #f accessors generate)
  (slot consumer initialize #f getter generate)
  
  
  (method package virtual (start-listeners self)
    (when consumer
      (start-listener consumer)))
  
  
  (method package virtual (stop-listeners self)
    (when consumer
      (stop-listener consumer)))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (set! consumer (car sinks)))
  
  
  (method public virtual abstract (task-priority self)
    )
  
  
  (method (task-start self name)
    (let ((task (new Task name (~ run-audio self) priority: (task-priority self) stack: stack-size)))
      (start-listeners self)
      (start-task task)
      (set! self.task task)))
  
  
  (method (task-stop self)
    (stop-listeners self)
    (stop-task task)
    (set! task #f))
  
  
  (method protected virtual (run-audio self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (process self task exit)
          (iter)))))
  
  
  (method override (process self task exit)
    (gst_app_sink_process task exit consumer)))


;;;
;;;; Microphone-Audio-Src
;;;


(definition protected microphone-directsound?
  (world-setting 'world.microphone-directsound? #f))

(definition protected (set-microphone-directsound? directsound?)
  (set! microphone-directsound? directsound?)
  (set! microphonesrc (determine-microphonesrc)))


(definition protected (determine-microphonesrc)
  (cond-expand
    (windows (if microphone-directsound? "directsoundsrc" "wasapisrc"))
    (mac "osxaudiosrc")
    (else "pulsesrc")))

(definition protected microphonesrc
  (determine-microphonesrc))


(definition protected microphone-pipeline
  #f)

(definition protected microphone-listener
  #f)

(definition protected microphone-power-probe?
  #f)

(definition protected microphone-power-probe
  #f)

(definition protected microphone-voice-probe
  #f)

(definition protected microphone-caps
  #f)

(definition protected microphone-drained?
  #f)


(definition (require-microphone-pipeline)
  (assert microphone-pipeline
    microphone-pipeline))

(definition (require-microphone-listener)
  (assert microphone-listener
    microphone-listener))

(definition (require-microphone-caps)
  (assert microphone-caps
    microphone-caps))


(definition public (acquire-microphone-pipeline)
  (if microphone-pipeline
      #t
    (receive (microphone-name microphone-identifier) (effective-microphone-information)
      (let ((pipeline (gst-pipeline
                        (gst-element microphonesrc
                                     ;; hardcode latency-time for now as the
                                     ;; webrtcaudioprocessor downstream will
                                     ;; create incorrect timestamps when given
                                     ;; any other buffer size than the size it
                                     ;; wants of .01s note that the hardcoded
                                     ;; value is also the default value
                                     latency-time: "10000"
                                     name: "src")
                        "volume name=volume"
                        "queue name=queue"
                        (cond-expand
                          (windows "audioconvert name=convert")
                          (else #f))
                        ;; needed on some computers
                        "audioresample name=resample1"
                        (cond-expand
                          (linux #f)
                          (else (and (custom-webrtc-processing?)
                                     (gst-element "webrtcaudioprocessor"
                                                  echo-cancel: (gst-boolean audio-echo-cancel?)
                                                  noise-suppression: (gst-boolean audio-noise-suppress?)
                                                  ;; not using gain controller as it tends to garble
                                                  ;; emotional voices and is clearly business targeted
                                                  ;; the default value in the gstreamer element is true
                                                  ;; at the moment so this needs to be specified
                                                  gain-controller: "false"
                                                  logging-severity: (custom-logging-severity)
                                                  name: "processor"))))
                        (cond-expand
                          (linux "identity name=rndenoiser")
                          (else (gst-element "rndenoiser name=rndenoiser"
                                             denoise: (gst-boolean audio-rndenoise?)
                                             voice: (gst-boolean #t))))
                        (cond-expand
                          (silicon "tee name=tee")
                          (else #f))
                        (cond-expand
                          (silicon "queue")
                          (else #f))
                        "audioresample name=resample2"
                        "opusenc audio-type=voice bandwidth=wideband bitrate-type=vbr inband-fec=true packet-loss-percentage=3 name=enc"
                        "appsink name=sink"
                        (cond-expand
                          (silicon
                           (list
                             "tee."
                             "queue max-size-time=200000000"
                             "proxysink name=micproxy"))
                          (else
                           #f)))))
        (with-unref ((src (gst_bin_get_by_name pipeline "src")))
          (write-microphone-name microphone-name)
          (microphone-identifier-update src microphone-identifier))
        (let ((listener (open-stream-listener "microphone")))
          (with-unref ((appsink (gst_bin_get_by_name pipeline "sink")))
            (with-unref ((pad (gst_element_get_static_pad appsink "sink")))
              (let ((voice-probe (gst_pad_add_voice_probe pad (get-write-file listener))))
                (gst_app_sink_connect_signals appsink listener)
                (gst_element_set_state pipeline GST_STATE_PLAYING)
                (let ((caps (wait-caps-string appsink)))
                  (if (not caps)
                      (begin
                        (gst_element_set_state pipeline GST_STATE_NULL)
                        (gst_object_unref pipeline)
                        #f)
                    (set! microphone-pipeline pipeline)
                    (set! microphone-listener listener)
                    (set! microphone-voice-probe voice-probe)
                    (set! microphone-caps caps)
                    (set! microphone-drained? #f)
                    (when microphone-power-probe?
                      (add-microphone-power-probe))
                    #t))))))))))


(definition public (release-microphone-pipeline)
  (when microphone-power-probe?
    (remove-microphone-power-probe))
  (gst_pad_probe_free microphone-voice-probe)
  (gst_bin_release microphone-pipeline)
  (set! microphone-pipeline #f)
  (set! microphone-listener #f)
  (set! microphone-voice-probe #f)
  (set! microphone-caps #f)
  (set! microphone-drained? #f))


(definition (add-microphone-power-probe)
  (unless microphone-power-probe
    (when microphone-pipeline
      (with-unref ((denoiser (gst_bin_get_by_name microphone-pipeline "rndenoiser")))
        (with-unref ((denoiser-pad (gst_element_get_static_pad denoiser "src")))
          (let ((probe (gst_pad_add_power_probe denoiser-pad)))
            (set! microphone-power-probe probe)))))))


(definition (remove-microphone-power-probe)
  (when microphone-power-probe
    (when microphone-pipeline
      (with-unref ((denoiser (gst_bin_get_by_name microphone-pipeline "rndenoiser")))
        (with-unref ((denoiser-pad (gst_element_get_static_pad denoiser "src")))
          (gst_pad_remove_probe denoiser-pad microphone-power-probe))))
    (set! microphone-power-probe #f)))


(definition protected (install-microphone-power-probe)
  (unless microphone-power-probe?
    (add-microphone-power-probe)
    (set! microphone-power-probe? #t)))


(definition protected (uninstall-microphone-power-probe)
  (when microphone-power-probe?
    (remove-microphone-power-probe)
    (set! microphone-power-probe? #f)))


(definition protected (microphone-power-level)
  (if (not microphone-power-probe)
      0.
    (gst_power_probe_get_average_level microphone-power-probe)))


(definition protected (name->microphone-provider name)
  (let ((providers (microphone-providers)))
    (find providers name key: get-name test: equal? return: 'item)))


(definition protected (effective-microphone-provider providers)
  (let ((name (world-setting 'world.microphone-name #f)))
    (if (not name)
        (car providers)
      (or (find providers name key: get-name test: equal? return: 'item)
          (car providers)))))


(definition protected (effective-microphone-information)
  (let ((providers (microphone-providers)))
    (let ((provider (effective-microphone-provider providers)))
      (values (get-name provider)
              (get-identifier provider)))))


(definition protected (microphone-identifier-update src identifier)
  (cond-expand
    (mac (g_object_set_int src "device" (or identifier 0)))
    (windows (g_object_set_string src "device" (or identifier #f)))
    (else)))


(definition package (write-microphone-name name)
  (set-setting options-settings 'world.microphone-name name)
  (save-content options-settings))


(class Microphone-Audio-Src extends Audio-Src
  
  
  (slot sink initialize #f accessors generate)
  
  
  (method override (require-caps self)
    (require-microphone-caps))
  
  
  (method package (update-identifier self identifier)
    (gst_element_set_state pipeline GST_STATE_NULL)
    (with-unref ((src (gst_bin_get_by_name pipeline "src")))
      (microphone-identifier-update src identifier))
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((pipeline (require-microphone-pipeline)))
      (gst_object_set_name pipeline "audio.mic")
      (let ((listener (require-microphone-listener)))
        (with-unref ((appsink (gst_bin_get_by_name pipeline "sink")))
          (setup-consumer consumer listener appsink)
          @already-done-in-acquire-microphone
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.pipeline pipeline)))))
  
  
  (method override (task-priority self)
    microphone-priority)
  
  
  (method override (start-element self)
    (nextmethod self)
    @already-done-in-acquire-microphone
    (gst_element_set_state pipeline GST_STATE_PAUSED)
    (task-start self 'microphone))
  
  
  (method override (play-element self)
    (nextmethod self)
    @already-done-in-acquire-microphone
    (gst_element_set_state pipeline GST_STATE_PLAYING)
    (capture-audio "microphone.src" pipeline "src.src")
    (cond-expand
      (linux)
      (else
       (when (custom-webrtc-processing?)
         (capture-audio "microphone.processor" pipeline "processor.src")))))
  
  
  @live-sources-should-not-go-to-pause
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (uncapture-audio "microphone.src")
    (cond-expand
      (linux)
      (else
       (when (custom-webrtc-processing?)
         (uncapture-audio "microphone.processor"))))
    (release-consumer consumer)
    (release-microphone-pipeline)
    (set! pipeline #f))
  
  
  (method package (update-rndenoise self rndenoise?)
    (with-unref ((rndenoiser (gst_bin_get_by_name pipeline "rndenoiser")))
      (g_object_set_boolean rndenoiser "denoise" rndenoise?)))
  
  
  (method override (process self task exit)
    (if (not microphone-drained?)
        (begin
          (gst_app_sink_process_buffers task exit consumer drain?: #t)
          (set! microphone-drained? #t))
      (gst_app_sink_process_buffers task exit consumer)))
  
  
  (method public (mute self)
    (with-unref ((volume (gst_bin_get_by_name pipeline "volume")))
      (g_object_set_boolean volume "mute" #t)))
  
  
  (method public (unmute self)
    (with-unref ((volume (gst_bin_get_by_name pipeline "volume")))
      (g_object_set_boolean volume "mute" #f)))
  
  
  (method public (get-volume self)
    (with-unref ((volume (gst_bin_get_by_name pipeline "volume")))
      (g_object_get_double volume "volume")))
  
  
  (method public (set-volume self vol)
    (with-unref ((volume (gst_bin_get_by_name pipeline "volume")))
      (g_object_set_double volume "volume" vol))))


;;;
;;;; Microphone-Audio-Consumer
;;;


(class Microphone-Audio-Consumer extends Stream-Buffer-Consumer
  
  
  (method override (consume-buffer self buffer)
    (site microphone
      (let ((dts (gst_buffer_get_dts buffer))
            (pts (gst_buffer_get_pts buffer))
            (duration (gst_buffer_get_duration buffer))
            (keyframe? (gst_buffer_is_keyframe buffer)))
        (let ((flags (frame-flags keyframe? voice?)))
          ;; ignore stream headers
          (unless (and duration (= duration GST_CLOCK_TIME_NONE))
            (when consumer
              (consumer buffer dts pts duration flags))))))))


;;;
;;;; File-Preprocess-Audio-Src
;;;


(class File-Preprocess-Audio-Src extends Audio-Src implements File-Preprocessor
  
  
  (slot location    initialize #f accessors generate)
  (slot container   initialize #f accessors generate)
  (slot prime?      initialize #f accessors generate)
  (slot denoise?    initialize #f accessors generate)
  (slot voice?      initialize #f accessors generate)
  (slot voice-probe initialize #f accessors generate)
  (slot stat-probe  initialize #f)
  
  
  (method override (initialize self location (container: container #f) (prime?: prime? #f) (denoise?: denoise? #f) (voice?: voice? #f))
    (nextmethod self)
    (set! self.location location)
    (set! self.container container)
    (set! self.prime? prime?)
    (set! self.denoise? denoise?)
    (set! self.voice? voice?))
  
  
  (method override (get-stat-probe self)
    stat-probe)
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((listener (open-stream-listener "preprocessaudio")))
      (let ((pipeline (if (and prime? (not denoise?) (not voice?))
                          (case container
                            ((qt)
                             (gst-pipeline (tie "filesrc name=filesrc")
                                           "qtdemux"
                                           "audio/mpeg"
                                           "appsink name=appsink sync=false"))
                            ((mp3)
                             (gst-pipeline (tie "filesrc name=filesrc")
                                           "id3demux"
                                           "mpegaudioparse"
                                           "appsink name=appsink sync=false"))
                            ((mpegts)
                             (gst-pipeline (tie "filesrc name=filesrc")
                                           "tsdemux"
                                           "audio/mpeg"
                                           "appsink name=appsink sync=false"))
                            ((ogg)
                             (gst-pipeline (tie "filesrc name=filesrc")
                                           "oggdemux"
                                           "appsink name=appsink sync=false"))
                            (else
                             (error "Unsupported preprocess prime audio container: {a}" container)))
                        (gst-pipeline (tie "filesrc name=filesrc")
                                      "decodebin"
                                      "audioconvert"
                                      "audioresample"
                                      "opusenc audio-type=generic bandwidth=fullband bitrate=128000 bitrate-type=vbr name=enc"
                                      (and (or denoise? voice?)
                                           (gst-element "rndenoiser name=rndenoiser"
                                                        denoise: (gst-boolean denoise?)
                                                        voice: (gst-boolean voice?)))
                                      "appsink name=appsink sync=false"))))
        (gst_object_set_name pipeline "audio.file")
        (with-unref ((filesrc (gst_bin_get_by_name pipeline "filesrc"))
                     (appsink (gst_bin_get_by_name pipeline "appsink")))
          (with-unref ((pad (gst_element_get_static_pad filesrc "src")))
            (set! stat-probe (gst_pad_add_stat_probe pad)))
          (with-unref ((pad (gst_element_get_static_pad appsink "sink")))
            (set! voice-probe (gst_pad_add_voice_probe pad (get-write-file listener))))
          (gst_app_sink_connect_signals appsink listener)
          (setup-consumer consumer listener appsink 8192)
          (g_object_set_utf-8-string filesrc "location" (path-normalize location))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.pipeline pipeline)))))
  
  
  (method override (task-priority self)
    preprocess-audio-priority)
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'audio-preprocess)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when voice-probe
      (gst_pad_probe_free voice-probe)
      (set! voice-probe #f))
    (gst_bin_release pipeline)
    (set! pipeline #f)
    (release-consumer consumer))
  
  
  (method override (run-audio self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (site audio-preprocess
            (process self task exit))
          (iter))))))


;;;
;;;; File-Stream-Audio-Src
;;;


(class File-Stream-Audio-Src extends Audio-Src implements Media-Stream
  
  
  (slot location     getter generate)
  (slot stream?      accessors explicit)
  (slot loop?        getter generate)
  (slot sound?       getter generate)
  (slot file         getter generate)
  (slot reader       getter generate)
  (slot time-base    getter generate)
  (slot muted?       getter generate)
  (slot pause?       getter generate)
  (slot flush?       getter generate)
  (slot delayed-seek getter generate)
  
  
  (method override (initialize self location (file: file #f) (stream?: stream? #t) (loop?: loop? #f) (sound?: sound? #f))
    (nextmethod self)
    (set! self.location location)
    (set! self.stream? stream?)
    (set! self.loop? loop?)
    (set! self.sound? sound?)
    (set! self.file file)
    (set! self.reader #f)
    (set! self.time-base (new Time-Base))
    (set! self.muted? #f)
    (set! self.pause? #f)
    (set! self.flush? #f)
    (set! self.delayed-seek #f))
  
  
  (method override (task-priority self)
    stream-audio-priority)
  
  
  (method override (start-element self)
    (nextmethod self)
    (set! file (or file (new-file {Directory Documents} (add-extension location (audio-profile-extension)))))
    (set! reader (new Stream-Reader file))
    (task-start self (if sound?
                         'sound
                       (list 'audio-stream (get-base file)))))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (close reader)
    (set! file #f)
    (set! reader #f))
  
  
  (method override (get-stream? self)
    stream?)
  
  
  (method override (set-stream? self flag)
    (set! stream? flag))
  
  
  (method override (play-stream self)
    (task-wakeup task
      (lambda (exit)
        (set! pause? #f)
        (reset time-base))))
  
  
  (method override (pause-stream self)
    (task-wakeup task
      (lambda (exit)
        (set! pause? #t)
        (task-sleep task #f exit))))
  
  
  (method override (rewind-stream self)
    (task-wakeup task
      (lambda (exit)
        (goto-frame reader 0)
        (reset time-base)
        (set! flush? #t))))
  
  
  (method override (goto-delayed self pos normalized-dts)
    (when (not delayed-seek)
      (task-wakeup task
        (lambda (exit)
          (task-sleep task #f exit))))
    (set! delayed-seek (cons pos normalized-dts)))
  
  
  (method override (goto-stream self pos normalized-dts)
    (task-wakeup task
      (lambda (exit)
        (if (not pos)
            (begin
              (when delayed-seek
                (bind (pos . normalized-dts) delayed-seek
                  (goto-position reader pos normalized-dts))
                (set! delayed-seek #f))
              (if pause?
                  (task-sleep task #f exit)
                (reset time-base)
                (set! flush? #t)))
          (goto-position reader pos normalized-dts)
          (task-sleep task #f exit)))))
  
  
  (method override (backward-stream self pos normalized-dts)
    (when pause?
      (task-wakeup task
        (lambda (exit)
          (goto-position reader pos normalized-dts)
          (task-sleep task #f exit)))))
  
  
  (method override (forward-stream self pos normalized-dts)
    (when pause?
      (task-wakeup task
        (lambda (exit)
          (goto-position reader pos normalized-dts)
          (task-sleep task #f exit)))))
  
  
  (method package (mute-stream self)
    (set! muted? #t))
  
  
  (method package (unmute-stream self)
    (set! muted? #f))
  
  
  (method override (run-audio self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (if (stopping? task)
              (task-done task exit)
            ;; protect against stream? threaded change
            (let ((stream? stream?))
              (let ((frame (read-frame reader stream?)))
                (if (not frame)
                    (if loop?
                        (begin
                          (close reader)
                          (set! reader (new Stream-Reader file))
                          (set! time-base (new Time-Base))
                          (iter))
                      (task-done task exit))
                  (bind-values (buffer dts pts duration flags) frame
                    (let ((time (current-seconds))
                          (nanodts (timestamp->flonum dts)))
                      (update-start time-base time nanodts)
                      (let ((sendtime (remote->local time-base nanodts)))
                        (if (not sound?)
                            (task-sleep task (- sendtime time) exit)
                          (sleep (- sendtime time))
                          (task-sleep task 0 exit))
                        (when stream?
                          (if flush?
                              (set! flush? #f)
                            (site audio-stream
                              (unless muted?
                                (consume-frame consumer buffer dts pts duration flags)))))))))))
            (iter)))))))


;;;
;;;; Audio-Sink
;;;


(class Audio-Sink extends Stream-Sink
  
  
  (slot channel                initialize #f accessors generate)
  (slot codec                  initialize #f accessors generate)
  (slot caps                   initialize #f accessors generate)
  (slot volume                 initialize #f accessors explicit)
  (slot mix?                   initialize #f getter generate)
  (slot sound?                 initialize #f accessors explicit)
  (slot pipeline               initialize #f accessors generate)
  (slot bin                    initialize #f accessors generate)
  (slot flow                   initialize #f getter generate)
  (slot appsrc                 initialize #f accessors generate)
  (slot volelem                initialize #f accessors generate)
  (slot panelem                initialize #f accessors generate)
  (slot stream-state           initialize 'off getter generate setter explicit)
  (slot stream-playing?        initialize #f getter generate)
  (slot stream-disconnected?   initialize #f getter generate)
  (slot source-adapter         initialize #f getter generate)
  (slot monitor                getter generate)
  
  
  (method override (initialize self (channel: channel #f) (codec: codec #f) (caps: caps #f) (volume: volume #f) (mix?: mix? #f) (sound?: sound? #f))
    (nextmethod self)
    (set! self.name (determine-name self channel))
    (set! self.channel channel)
    (set! self.codec codec)
    (set! self.caps caps)
    (set! self.volume volume)
    (set! self.mix? mix?)
    (set! self.sound? sound?)
    (set! self.source-adapter (if (and channel (sender? channel)) (new Source-Rebaser) (new Source-Coupler)))
    (set! self.monitor (new Audio-Monitor)))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name))))
  
  
  (method override (reset self)
    (reset source-adapter))
  
  
  (method (determine-name self channel)
    (determine-channel-name channel))
  
  
  (method package (set-stream-state self state)
    (when (neq? state stream-state)
      (set! stream-state state)
      (when (client?)
        (invalidate-audio-state (current-client) self))))
  
  
  (method package (set-stream-disconnected self)
    (set! stream-state 'off)
    (set! stream-disconnected? #t)
    (invalidate-audio-state (current-client) self))
  
  
  @assert-mutex
  (method package (assert-channel-mutex self tag)
    (when (and channel (receiver? channel))
      (assert-mutex channel tag)))
  
  
  (method package (setup-bin self)
    ;; min-latency should be at least .01s greater than adapter-tolerance
    ;; else a rising rebase will generate audible gritches in the audio mixer
    (assert caps)
    (let ((bin ((if mix? gst-bin gst-pipeline)
                (format "appsrc caps=\"{a}\"{?: min-latency=40000000~} name=src" caps (not sound?))
                (and (not sound?) "queue name=queue")
                (and (eq? codec 'mp3) "avdec_mp3 name=dec")
                (and (eq? codec 'aac) "avdec_aac name=dec")
                (and (eq? codec 'opus) "opusdec plc=true name=dec")
                (and (eq? codec 'vorbis) "vorbisdec name=dec")
                "audioconvert name=convert"
                "audioresample name=resample"
                "audio/x-raw, format=S16LE, layout=interleaved, rate=48000, channels=2"
                (let ((volume (or volume 1)))
                  (tie "volume volume={volume} name=volume"))
                "audiopanorama method=1 name=panorama"
                (and (not mix?)
                     (if (not sound?)
                         (gst-element speakersink name: "sink")
                       (gst-element speakersink buffer-time: "100000" name: "sink"))))))
      (let ((unique-suffix (if (not channel) "" (format "_{a}" (get-no channel)))))
        (gst_object_set_name bin (string-append "audio." name unique-suffix)))
      (let ((appsrc (gst_bin_get_by_name bin "src"))
            (volelem (gst_bin_get_by_name bin "volume"))
            (panelem (gst_bin_get_by_name bin "panorama")))
        (g-object-set appsrc
          "is-live"     'boolean #t
          "stream-type" 'int     GST_APP_STREAM_TYPE_STREAM
          "format"      'int     GST_FORMAT_TIME)
        (gst_element_set_state bin GST_STATE_READY)
        (set! self.bin bin)
        @assert-mutex
        (assert-channel-mutex self 'audio-setup)
        (set! self.flow (new GStreamer-Flow #f appsrc #f udp-audio-process))
        (set! self.appsrc appsrc)
        (set! self.volelem volelem)
        (set! self.panelem panelem))))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (setup-bin self))
  
  
  (method override (start-element self)
    (nextmethod self)
    (gst_element_set_state bin GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state bin GST_STATE_PLAYING)
    ;; set after startup so opusdec doesn't add 120ms of latency
    ;; as our pipeline at the moment has enough latency already
    (when (eq? codec 'opus)
      (with-unref ((dec (gst_bin_get_by_name bin "dec")))
        (g_object_set_boolean dec "use-inband-fec" #t)))
    (when channel
      (capture-audio (capture-name self) bin audiosink-tail-src)))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state bin GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (gst_element_set_state bin GST_STATE_READY))
  
  
  ;; not called when part of audio
  (method override (release-element self)
    (nextmethod self)
    @assert-mutex
    (assert-channel-mutex self 'release-audio)
    (gst_object_unref appsrc)
    (gst_object_unref volelem)
    (when panelem
      (gst_object_unref panelem))
    (gst_bin_release bin)
    (set! bin #f)
    (set! appsrc #f)
    (set! volelem #f)
    (set! panelem #f)
    (set! flow #f)
    (set-stream-state self 'off))
  
  
  (method protected (capture-release self)
    (when channel
      (uncapture-audio (capture-name self))))
  
  
  (method (capture-name self)
    (string-append "audio." name))
  
  
  (method package (play-audio self)
    (when (not stream-playing?)
      (play self)
      (set! stream-playing? #t)))
  
  
  (method package virtual (write-audio self buffer dts pts duration timestamp-offset)
    (mutex-lock! audio-mutex)
    (play-audio self)
    (let ((timestamp-offset (or timestamp-offset (adapt-time source-adapter appsrc dts))))
      (let ((dts (max 0 (+ dts timestamp-offset)))
            (pts (max 0 (+ pts timestamp-offset))))
        (when record-events?
          (let ((running-time (gst_element_get_running_time appsrc)))
            (let ((distance (- running-time dts)))
              (cond ((< distance udp-audio-early)
                     (record-event udp-id-media-early
                                   -1.
                                   -1.
                                   (fixnum->flonum udp-audio)
                                   -1.
                                   -1.
                                   -1.
                                   -1.))
                    ((> distance udp-audio-late)
                     (record-event udp-id-media-late
                                   -1.
                                   -1.
                                   (fixnum->flonum udp-audio)
                                   -1.
                                   -1.
                                   -1.
                                   -1.))))))
        (cond ((not buffer)
               (gst_app_src_write_event appsrc (gst_event_new_gap dts duration)))
              ((u8vector? buffer)
               (gst_app_src_write appsrc buffer (u8vector-length buffer) dts pts duration))
              (else
               (gst_app_src_write_buffer appsrc buffer dts pts duration)))))
    (mutex-unlock! audio-mutex))
  
  
  (method public (muted? self)
    (g_object_get_boolean volelem "mute"))
  
  
  (method public (mute self)
    (g_object_set_boolean volelem "mute" #t))
  
  
  (method public (unmute self)
    (g_object_set_boolean volelem "mute" #f))
  
  
  (method public (get-volume self)
    (g_object_get_double volelem "volume"))
  
  
  (method public (set-volume self vol)
    (g_object_set_double volelem "volume" vol))
  
  
  (method public (set-panorama self pan)
    (g_object_set_double panelem "panorama" pan)))


;;;
;;;; Monitor
;;;


(class Audio-Monitor extends Object
  
  
  (slot systemclock-name      initialize #f accessors generate)
  (slot audioclock-name       initialize #f accessors generate)
  (slot first-originclock     initialize #f getter generate)
  (slot first-realclock       initialize #f getter generate)
  (slot first-monotonicclock  initialize #f getter generate)
  (slot first-systemclock     initialize #f getter generate)
  (slot first-audioclock      initialize #f getter generate)
  (slot originclock-elapse    initialize 0. getter generate)
  (slot realclock-elapse      initialize 0. getter generate)
  (slot monotonicclock-elapse initialize 0. getter generate)
  (slot systemclock-elapse    initialize 0. getter generate)
  (slot audioclock-elapse     initialize 0. getter generate)
  (slot originclock-rate      initialize 1. getter generate)
  (slot realclock-rate        initialize 1. getter generate)
  (slot monotonicclock-rate   initialize 1. getter generate)
  (slot systemclock-rate      initialize 1. getter generate)
  (slot audioclock-rate       initialize 1. getter generate)
  
  
  (method (update self origintime realclock monotonicclock systemtime audiotime)
    (let ((originclock (timestamp->flonum origintime))
          (systemclock (timestamp->flonum systemtime))
          (audioclock (timestamp->flonum audiotime)))
      (when (not first-originclock)
        (set! first-originclock originclock)
        (set! first-realclock realclock)
        (set! first-monotonicclock monotonicclock)
        (set! first-systemclock systemclock)
        (set! first-audioclock audioclock))
      (set! originclock-elapse (- originclock first-originclock))
      (set! realclock-elapse (- realclock first-realclock))
      (set! monotonicclock-elapse (- monotonicclock first-monotonicclock))
      (set! systemclock-elapse (- systemclock first-systemclock))
      (set! audioclock-elapse (- audioclock first-audioclock))
      (when record-events?
        (record-event udp-id-debug-audio
                      -1.
                      -1.
                      originclock-elapse
                      realclock-elapse
                      monotonicclock-elapse
                      systemclock-elapse
                      audioclock-elapse))
      (when (> originclock-elapse 0.)
        (set! originclock-rate (/ originclock-elapse originclock-elapse))
        (set! realclock-rate (/ realclock-elapse originclock-elapse))
        (set! monotonicclock-rate (/ monotonicclock-elapse originclock-elapse))
        (set! systemclock-rate (/ systemclock-elapse originclock-elapse))
        (set! audioclock-rate (/ audioclock-elapse originclock-elapse)))))))
