;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Audio
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.audio jazz


(import (jazz.event)
        (jazz.io)
        (jazz.listener)
        (jazz.platform)
        (jazz.presence)
        (jazz.settings)
        (jazz.stream)
        (jazz.stream.syntax (phase syntax))
        (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.capture)
        (world.configure)
        (world.context)
        (world.customize)
        (world.event)
        (world.interface)
        (world.media)
        (world.settings)
        (world.stream)
        (world.support)
        (world.task)
        (world.time)
        (world.udp))


(definition protected audio-rate
  (world-setting 'world.audio-rate 48000))

(definition protected audio-codec
  (world-setting 'world.audio-codec 'vorbis))


(definition protected audio-echo-cancel?
  (world-setting 'world.audio-echo-cancel? #t))

(definition protected (set-audio-echo-cancel? flag)
  (set! audio-echo-cancel? flag))


(definition protected audio-gain-control?
  (world-setting 'world.audio-gain-control? #t))

(definition protected (set-audio-gain-control? flag)
  (set! audio-gain-control? flag))


(definition protected audio-noise-suppress?
  (world-setting 'world.audio-noise-suppress? #t))

(definition protected (set-audio-noise-suppress? flag)
  (set! audio-noise-suppress? flag))


(definition protected audio-rndenoise?
  (world-setting 'world.audio-rndenoise? #f))

(definition protected (set-audio-rndenoise? flag)
  (set! audio-rndenoise? flag))


;; to debug mixer gritches
(definition protected visualizer-mixer?
  (world-setting 'world.visualizer-mixer? #t))


;;;
;;;; Codec
;;;


(class AAC-Codec extends Codec)
(class Vorbis-Codec extends Codec)
(class Opus-Codec extends Codec)


(register-codec (new AAC-Codec 'aac 'audio))
(register-codec (new Vorbis-Codec 'vorbis 'audio))
(register-codec (new Opus-Codec 'opus 'audio))


;;;
;;;; Profile
;;;


(definition public (audio-profile-extension)
  "streamaudio")


(definition public (streaming-audio-extensions)
  (list (audio-profile-extension)))


;;;
;;;; Stream
;;;


(definition protected (locate-stream-audio-channel stream)
  (table-search (lambda (no channel)
                  (and (= (get-media-kind channel) udp-audio)
                       channel))
                (get-channels stream)))


;;;
;;;; Capture
;;;


(definition (capture-audio name bin pad)
  (capture-point name
    (lambda ()
      (gst_monitor bin pad 'queue 20.))
    (lambda (monitored)
      (bind (pad . id) monitored
        (cons (rawaudio-pad-info pad)
              (gst_monitor_queue_copy id))))
    gst_unmonitor))


(definition (uncapture-audio name)
  (uncapture-point name))


;;;
;;;; Microphone
;;;


(definition public (has-microphone?)
  (not-null? (cache-microphone-device-names)))


(definition microphone-device-names
  #f)

(definition protected (cache-microphone-device-names)
  (or microphone-device-names
      (with-microphone-devices
        (lambda (devices)
          (let ((names (map gst_device_get_display_name devices)))
            (set! microphone-device-names names)
            names)))))


(definition protected (with-microphone-devices proc)
  (let ((devices (microphone-devices)))
    (prog1 (proc devices)
      (gst_devices_unref devices))))


(definition protected (microphone-devices)
  (with-unref ((monitor (gst_device_monitor_new)))
    ;; gstreamer filter leak workaround
    (gst_device_monitor_add_filter monitor #f #f)
    @using-this-filter-leaks-in-gstreamer-hence-the-workaround
    (let ((caps (gst_caps_new_empty_simple "audio/x-raw")))
      (gst_device_monitor_add_filter monitor "Audio/Source" caps)
      (gst_caps_unref caps))
    (let ((queue (new-queue)))
      (let (loop (devices (gst_device_monitor_get_devices monitor)))
        (if (not devices)
            (begin
              (g_list_free devices)
              (queue-list queue))
          (let ((device (gst_device_monitor_device_list_data devices)))
            ;; gstreamer filter leak workaround
            (if (and (equal? (gst_device_get_device_class device) "Audio/Source")
                     (equal? (gst_device_get_type_name device) microphonesrc))
                (enqueue queue device)
              (gst_device_unref_hack device))
            (loop (gst_device_monitor_device_list_next devices))))))))


(definition protected (microphone-device-identifier device)
  (with-unref ((element (gst_device_create_element device)))
    (cond-expand
      (mac (g_object_get_int element "device"))
      (windows (g_object_get_string element "device"))
      (else #f))))


;;;
;;;; Speaker
;;;


(definition protected (with-speaker-devices proc)
  (let ((devices (speaker-devices)))
    (prog1 (proc devices)
      (gst_devices_unref devices))))


(definition protected (speaker-devices)
  (with-unref ((monitor (gst_device_monitor_new)))
    ;; gstreamer filter leak workaround
    (gst_device_monitor_add_filter monitor #f #f)
    @using-this-filter-leaks-in-gstreamer-hence-the-workaround
    (let ((caps (gst_caps_new_empty_simple "audio/x-raw")))
      (gst_device_monitor_add_filter monitor "Audio/Sink" caps)
      (gst_caps_unref caps))
    (let ((queue (new-queue)))
      (let (loop (devices (gst_device_monitor_get_devices monitor)))
        (if (not devices)
            (begin
              (g_list_free devices)
              (queue-list queue))
          (let ((device (gst_device_monitor_device_list_data devices)))
            ;; gstreamer filter leak workaround
            (if (and (equal? (gst_device_get_device_class device) "Audio/Sink")
                     (equal? (gst_device_get_type_name device) speakersink))
                (enqueue queue device)
              (gst_device_unref_hack device))
            (loop (gst_device_monitor_device_list_next devices))))))))


(definition protected (speaker-device-identifier device)
  (with-unref ((element (gst_device_create_element device)))
    (cond-expand
      (mac (g_object_get_int element "device"))
      (windows (g_object_get_string element "device"))
      (else #f))))


;;;
;;;; Audio
;;;


(class World-Audio extends Object
  
  
  (slot outputs         getter generate)
  (slot ordered-outputs getter generate)
  
  
  (method override (initialize self)
    (nextmethod self)
    (set! self.outputs (make-table test: equal?))
    (set! self.ordered-outputs '()))
  
  
  ;;;
  ;;;; Output
  ;;;
  
  
  (method package (find-output self id)
    (table-ref outputs id #f))
  
  
  (method package (player-output self id (channel: channel #f) (codec: codec #f) (caps: caps #f) (volume: volume #f))
    (or (table-ref outputs id #f)
        (let ((output (new-output self channel: channel codec: codec caps: caps volume: volume)))
          (setup output)
          (table-set! outputs id output)
          (set! ordered-outputs (append! ordered-outputs (list output)))
          (start output)
          output)))
  
  
  (method package (channel-output self channel (volume: volume #f))
    (let ((codec (get-codec channel))
          (caps (get-caps channel)))
      (player-output self (get-no channel) channel: channel codec: codec caps: caps volume: volume)))
  
  
  (method package (visualizer-output self (codec: codec #f) (caps: caps #f))
    (cond (visualizer-mixer?
           (let ((sink (new Audio-Sink codec: codec caps: caps mix?: #t))
                 (audio (cache-audio)))
             (add-sink audio sink)
             (play sink)
             (recalculate-latency audio)
             sink))
          (else
           (let ((sink (new Audio-Sink codec: codec caps: caps))
                 (audio (cache-audio)))
             (play sink)
             sink))))
  
  
  (method (new-output self (channel: channel #f) (codec: codec #f) (caps: caps #f) (volume: volume #f))
    (let ((sink (new Audio-Sink
                  channel: channel
                  codec: (or codec audio-codec)
                  caps: caps
                  volume: volume
                  mix?: #t))
          (audio (cache-audio)))
      (add-sink audio sink)
      (play sink)
      (recalculate-latency audio)
      sink))
  
  
  (method package (close-output self id output)
    (table-clear outputs id)
    (set! ordered-outputs (remove! output ordered-outputs))
    (remove-sink (cache-audio) output)
    (recalculate-latency (cache-audio)))
  
  
  (method package (close-empty-audio self)
    @not-sure-about-automatic-closing-audio
    (when (null? ordered-outputs)
      (close-audio)))
  
  
  (method package (receive-server-audio self id buffer dts pts duration)
    (let ((output (find-output self id)))
      (when (and output (not (get-stream-disconnected? output)))
        (when (eq? (get-stream-state output) 'off)
          (set-stream-state output 'on))
        (write-audio output buffer dts pts duration)
        (when (and record-events? udp-record-src/sink?)
          (let ((origin (get-origin (get-stream (get-channel output)))))
            (record-event udp-id-sink-media
                          (fixnum->flonum id)
                          (fixnum->flonum origin)
                          (fixnum->flonum udp-audio)
                          -1.
                          -1.
                          -1.
                          (timestamp->flonum dts)))))))
  
  
  (method package (receive-visualizer-audio self output buffer dts pts duration)
    (when (eq? (get-stream-state output) 'off)
      (set-stream-state output 'on))
    (write-audio output buffer dts pts duration))
  
  
  (method package (receive-audio self id/output buffer dts pts duration)
    (if (is? id/output Audio-Sink)
        (receive-visualizer-audio self id/output buffer dts pts duration)
      (receive-server-audio self id/output buffer dts pts duration))))


;;;
;;;; Audio
;;;


(definition protected speakersink
  (cond-expand
    (windows "wasapisink")
    (mac "osxaudiosink")
    (else "pulsesink")))


(definition protected audioprobe-delay
  0)


(definition protected cached-audio
  #f)

(definition public (cache-audio)
  (or cached-audio
      (let ((audio (new Audio)))
        (setup audio)
        (play audio)
        (set! cached-audio audio)
        (monitor-default-output)
        audio)))

(definition public (close-audio)
  (when cached-audio
    (unmonitor-default-output)
    (release cached-audio)
    (set! cached-audio #f)))


(definition audiosink-tail
  ;; wasapi regression
  (cond-expand
    (windows "volume")
    (else "panorama")))

(definition audiosink-tail-src
  ;; wasapi regression
  (cond-expand
    (windows "volume.src")
    (else "panorama.src")))


(definition protected (effective-speaker-identifier)
  (with-speaker-devices
    (lambda (devices)
      (read-speaker-identifier devices))))


(definition package (read-speaker-identifier devices)
  (let ((name (world-setting 'world.speaker-name #f)))
    (if (not name)
        #f
      (let ((device (find devices name key: gst_device_get_display_name test: equal? return: 'item)))
        (and device
             (speaker-device-identifier device))))))


(definition protected (speaker-identifier-keyword)
  device:)


(definition protected (speaker-identifier-update sink identifier)
  (cond-expand
    (mac (g_object_set_int sink "device" (or identifier 0)))
    (windows (g_object_set_string sink "device" (or identifier #f)))
    (else)))


(definition package (write-speaker-name name)
  (set-setting options-settings 'world.speaker-name name)
  (save-content options-settings))


(definition monitor-thread
  #f)

(definition monitor-listener
  #f)


(definition (monitor-default-output)
  (cond-expand
    (mac
     (let ((listener (open-stream-listener "speaker")))
       (define (process-listener)
         (declare (proper-tail-calls))
         (let (loop)
           (let ((c (wait listener)))
             (case c
               ((#\.)
                (when cached-audio
                  (let ((identifier (effective-speaker-identifier)))
                    ;; using default device
                    (when (not identifier)
                      (update-identifier cached-audio #f))))
                (loop))
               ((#\@))))))
       
       (platformAudioMonitorDefaultOutput (get-write-file listener))
       (set! monitor-thread (thread-start! (new-thread process-listener 'audio-monitor)))
       (set! monitor-listener listener)))
    (else)))


(definition (unmonitor-default-output)
  (cond-expand
    (mac
     (platformAudioUnmonitorDefaultOutput (get-write-file monitor-listener))
     (set! monitor-listener #f)
     (set! monitor-thread #f))
    (else)))


(definition audio-mutex
  (make-mutex 'audio))


(class Audio extends Object
  
  
  (slot pipeline initialize #f accessors generate)
  
  
  (method protected (add-sink self sink)
    (setup sink)
    (let ((bin (get-bin sink)))
      (set-pipeline sink pipeline)
      (with-unref ((mixer (gst_bin_get_by_name pipeline "mixer")))
        (gst_bin_add pipeline bin)
        (with-unref ((tail (gst_bin_get_by_name bin audiosink-tail)))
          (gst_element_link tail mixer)))))
  
  
  (method protected (remove-sink self sink)
    (capture-release sink)
    (let ((bin (get-bin sink)))
      (with-unref ((pads (gst_element_src_pads bin)))
        (let ((ghost-pad (car pads)))
          (with-unref ((tail (gst_bin_get_by_name bin audiosink-tail))
                       (mixer (gst_bin_get_by_name pipeline "mixer")))
            (with-unref ((mixer-pad (gst_pad_get_peer ghost-pad)))
              (gst_element_unlink tail mixer)
              (gst_element_release_request_pad mixer mixer-pad)))))
      (with-bin-mutex
        (lambda ()
          (gst_element_set_state bin GST_STATE_NULL)
          (gst_bin_remove pipeline bin)
          (unregister-bin bin)))))

  
  (method protected (recalculate-latency self)
    (gst_bin_recalculate_latency pipeline))
  
  
  (method (wait-audioclock self pipeline)
    (declare (proper-tail-calls))
    (with-unref ((sink (gst_bin_get_by_name pipeline "sink")))
      (let (loop (n 0))
        (when (< n 100)
          (when (not (gst_audio_ring_buffer_acquired sink))
            (sleep .01)
            (loop (+ n 1))))))
    (with-unref ((clock (gst_pipeline_get_clock pipeline)))
      (let ((clock-name (gst_object_get_name clock)))
        (unless (equal? clock-name (cond-expand
                                     (linux "GstPulseSinkClock")
                                     (else "GstAudioSinkClock")))
          (error "Failed to install an audio clock: {a}" clock-name)))))
  
  
  (method (remove-bootstrap self pipeline)
    (with-unref ((bootstrap (gst_bin_get_by_name pipeline "bootstrap"))
                 (queue (gst_bin_get_by_name pipeline "queue")))
      (gst_element_unlink bootstrap queue)
      (gst_element_set_state bootstrap GST_STATE_NULL)
      (gst_bin_remove pipeline bootstrap)))
  
  
  (method protected (add-mixer self)
    (let ((mixer (gst_element_factory_make "audiomixer" (gst-element-bin-name pipeline "mixer"))))
      (g_object_set_uint64 mixer "latency" 100000000)
      (with-unref ((queue (gst_bin_get_by_name pipeline "queue")))
        (gst_bin_add pipeline mixer)
        (gst_element_link mixer queue)
        (gst_element_sync_state_with_parent mixer))))
  
  
  (method package (update-identifier self identifier)
    (mutex-lock! audio-mutex)
    (gst_element_set_state pipeline GST_STATE_NULL)
    (with-unref ((sink (gst_bin_get_by_name pipeline "sink")))
      (speaker-identifier-update sink identifier))
    (gst_element_set_state pipeline GST_STATE_PLAYING)
    (wait-playing pipeline)
    (mutex-unlock! audio-mutex))
  
  
  (method public (setup self)
    (let ((identifier-keyword (speaker-identifier-keyword))
          (identifier (effective-speaker-identifier)))
      (let ((pipeline (gst-pipeline "audiotestsrc samplesperbuffer=480 wave=silence is-live=true name=bootstrap"
                                    "queue max-size-time=200000000 name=queue"
                                    (cond-expand
                                      (linux #f)
                                      (else (and (custom-webrtc-processing)
                                                 (tie "webrtcaudioprobe delay={audioprobe-delay} name=probe"))))
                                    (cond-expand
                                      (windows "audioconvert")
                                      (else #f))
                                    (gst-element speakersink
                                                 identifier-keyword identifier
                                                 buffer-time: 100000
                                                 name: "sink"))))
        (gst_object_set_name pipeline "audio.speaker")
        (set! self.pipeline pipeline)
        (gst_element_set_state pipeline GST_STATE_PAUSED)
        (wait-audioclock self pipeline)
        (gst_element_set_state pipeline GST_STATE_PLAYING)
        (wait-playing pipeline)
        (remove-bootstrap self pipeline)
        (add-mixer self))))
  
  
  (method public (play self)
    (gst_element_set_state pipeline GST_STATE_PLAYING)
    @audio-probe
    (when (custom-webrtc-processing)
      (capture-audio "audio.probe" pipeline "probe.sink"))
    (capture-audio "audio.sink" pipeline "sink.sink"))
  
  
  (method public (pause self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method public (stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method public (release self)
    @audio-probe
    (when (custom-webrtc-processing)
      (uncapture-audio "audio.probe"))
    (uncapture-audio "audio.sink")
    (gst_bin_release pipeline)
    (set! pipeline #f)))


;;;
;;;; Audio-Src
;;;


(class Audio-Src extends Stream-Src
  
  
  (slot pipeline initialize #f accessors generate)
  (slot appsrc   initialize #f accessors generate)
  (slot task     initialize #f accessors generate)
  (slot consumer initialize #f getter generate)
  
  
  (method package virtual (start-listeners self)
    (when consumer
      (start-listener consumer)))
  
  
  (method package virtual (stop-listeners self)
    (when consumer
      (stop-listener consumer)))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (set! consumer (car sinks)))
  
  
  (method (task-start self name)
    (let ((task (new Task name (~ run-audio self) priority: audio-priority)))
      (start-listeners self)
      (start-task task)
      (set! self.task task)))
  
  
  (method (task-stop self)
    (stop-listeners self)
    (stop-task task)
    (set! task #f))
  
  
  (method protected virtual (run-audio self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (process self task exit)
          (iter)))))
  
  
  (method override (process self task exit)
    (gst_app_sink_process_frames task exit consumer)))


;;;
;;;; Microphone-Audio-Src
;;;


(definition protected microphonesrc
  (cond-expand
    (windows "wasapisrc")
    (mac "osxaudiosrc")
    (else "pulsesrc")))


(definition protected microphone-pipeline
  #f)

(definition protected microphone-listener
  #f)

(definition protected microphone-voice-probe
  #f)

(definition protected microphone-caps
  #f)

(definition protected microphone-drained?
  #f)


(definition (require-microphone-pipeline)
  (assert microphone-pipeline
    microphone-pipeline))

(definition (require-microphone-listener)
  (assert microphone-listener
    microphone-listener))

(definition (require-microphone-caps)
  (assert microphone-caps
    microphone-caps))


(definition public (acquire-microphone-pipeline)
  (if microphone-pipeline
      #t
    (let ((identifier-keyword (microphone-identifier-keyword))
          (identifier (effective-microphone-identifier)))
      (let ((pipeline (gst-pipeline
                        ;; provide-clock=false to use the audio sink clock
                        ;; this makes sure audio and video stay synced
                        (gst-element microphonesrc
                                     identifier-keyword identifier
                                     ;; hardcode latency-time for now as the
                                     ;; webrtcaudioprocessor downstream will
                                     ;; create incorrect timestamps when given
                                     ;; any other buffer size than the size it
                                     ;; wants of .01s note that the hardcoded
                                     ;; value is also the default value
                                     latency-time: "10000"
                                     provide-clock: "false"
                                     name: "src")
                        "volume name=volume"
                        "queue name=queue"
                        (cond-expand
                          (windows "audioconvert")
                          (else #f))
                        ;; needed on some computers
                        "audioresample"
                        (cond-expand
                          (linux #f)
                          (else (and (custom-webrtc-processing)
                                     (gst-element "webrtcaudioprocessor"
                                                  echo-cancel: (gst-boolean audio-echo-cancel?)
                                                  noise-suppression: (gst-boolean audio-noise-suppress?)
                                                  gain-controller: (gst-boolean audio-gain-control?)
                                                  logging-severity: (custom-logging-severity)
                                                  name: "processor"))))
                        (cond-expand
                          (linux #f)
                          (windows (gst-element "rndenoiser name=rndenoiser"
                                                denoise: (gst-boolean audio-rndenoise?)))
                          (else (gst-element "rndenoiser name=rndenoiser"
                                             denoise: (gst-boolean audio-rndenoise?)
                                             voice: (gst-boolean #t))))
                        "audioresample"
                        (and (eq? audio-codec 'opus) "opusenc name=enc")
                        (and (eq? audio-codec 'vorbis) "audioconvert")
                        (and (eq? audio-codec 'vorbis) (tie "audio/x-raw, format=F32LE, layout=interleaved, rate={audio-rate}, channels=1"))
                        (and (eq? audio-codec 'vorbis) "vorbisenc name=enc")
                        "appsink name=sink")))
        (let ((listener (open-stream-listener "microphone")))
          (with-unref ((appsink (gst_bin_get_by_name pipeline "sink")))
            (with-unref ((pad (gst_element_get_static_pad appsink "sink")))
              (let ((voice-probe (gst_pad_add_voice_probe pad (get-write-file listener))))
                (gst_app_sink_connect_signals appsink listener)
                (gst_element_set_state pipeline GST_STATE_PLAYING)
                (let ((caps (wait-caps-string appsink)))
                  (if (not caps)
                      (begin
                        (gst_element_set_state pipeline GST_STATE_NULL)
                        (gst_object_unref pipeline)
                        #f)
                    (set! microphone-pipeline pipeline)
                    (set! microphone-listener listener)
                    (set! microphone-voice-probe voice-probe)
                    (set! microphone-caps caps)
                    (set! microphone-drained? #f)
                    #t))))))))))


(definition public (release-microphone-pipeline)
  (gst_pad_probe_free microphone-voice-probe)
  (gst_bin_release microphone-pipeline)
  (set! microphone-pipeline #f)
  (set! microphone-listener #f)
  (set! microphone-voice-probe #f)
  (set! microphone-caps #f)
  (set! microphone-drained? #f))


(definition protected (effective-microphone-identifier)
  (with-microphone-devices
    (lambda (devices)
      (read-microphone-identifier devices))))


(definition package (read-microphone-identifier devices)
  (let ((name (world-setting 'world.microphone-name #f)))
    (if (not name)
        #f
      (let ((device (find devices name key: gst_device_get_display_name test: equal? return: 'item)))
        (and device
             (microphone-device-identifier device))))))


(definition protected (microphone-identifier-keyword)
  device:)


(definition protected (microphone-identifier-update src identifier)
  (cond-expand
    (mac (g_object_set_int src "device" (or identifier 0)))
    (windows (g_object_set_string src "device" (or identifier #f)))
    (else)))


(definition package (write-microphone-identifier name)
  (set-setting options-settings 'world.microphone-name name)
  (save-content options-settings))


(class Microphone-Audio-Src extends Audio-Src
  
  
  (slot sink initialize #f accessors generate)
  
  
  (method override (require-caps self)
    (require-microphone-caps))
  
  
  (method package (update-identifier self identifier)
    (gst_element_set_state pipeline GST_STATE_NULL)
    (with-unref ((src (gst_bin_get_by_name pipeline "src")))
      (microphone-identifier-update src identifier))
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((pipeline (require-microphone-pipeline)))
      (gst_object_set_name pipeline "audio.mic")
      (let ((listener (require-microphone-listener)))
        (with-unref ((appsink (gst_bin_get_by_name pipeline "sink")))
          (setup-consumer consumer listener appsink 4096)
          @already-done-in-acquire-microphone
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.pipeline pipeline)))))
  
  
  (method override (start-element self)
    (nextmethod self)
    @already-done-in-acquire-microphone
    (gst_element_set_state pipeline GST_STATE_PAUSED)
    (task-start self 'microphone))
  
  
  (method override (play-element self)
    (nextmethod self)
    @already-done-in-acquire-microphone
    (gst_element_set_state pipeline GST_STATE_PLAYING)
    (capture-audio "microphone.src" pipeline "src.src")
    (cond-expand
      (linux)
      (else
       (when (custom-webrtc-processing)
         (capture-audio "microphone.processor" pipeline "processor.src")))))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (uncapture-audio "microphone.src")
    (cond-expand
      (linux)
      (else
       (when (custom-webrtc-processing)
         (uncapture-audio "microphone.processor"))))
    (release-consumer consumer)
    (release-microphone-pipeline)
    (set! pipeline #f))
  
  
  @wait-live-change
  (method protected (update-echo-cancel self echo-cancel?)
    (with-unref ((processor (gst_bin_get_by_name pipeline "processor")))
      (g_object_set_boolean processor "echo-cancel" echo-cancel?)))
  
  
  @wait-live-change
  (method protected (update-gain-control self gain-control?)
    (with-unref ((processor (gst_bin_get_by_name pipeline "processor")))
      (g_object_set_boolean processor "gain-controller" gain-control?)))
  
  
  @wait-live-change
  (method protected (update-noise-suppress self noise-suppress?)
    (with-unref ((processor (gst_bin_get_by_name pipeline "processor")))
      (g_object_set_boolean processor "noise-suppression" noise-suppress?)))
  
  
  (method protected (update-rndenoise self rndenoise?)
    (with-unref ((rndenoiser (gst_bin_get_by_name pipeline "rndenoiser")))
      (g_object_set_boolean rndenoiser "denoise" rndenoise?)))
  
  
  (method override (process self task exit)
    (if (not microphone-drained?)
        (begin
          (gst_app_sink_process_frames task exit consumer drain?: #t)
          (set! microphone-drained? #t))
      (gst_app_sink_process_frames task exit consumer)))
  
  
  (method public (mute self)
    (with-unref ((volume (gst_bin_get_by_name pipeline "volume")))
      (g_object_set_boolean volume "mute" #t)))
  
  
  (method public (unmute self)
    (with-unref ((volume (gst_bin_get_by_name pipeline "volume")))
      (g_object_set_boolean volume "mute" #f)))
  
  
  (method public (get-volume self)
    (with-unref ((volume (gst_bin_get_by_name pipeline "volume")))
      (g_object_get_double volume "volume")))
  
  
  (method public (set-volume self vol)
    (with-unref ((volume (gst_bin_get_by_name pipeline "volume")))
      (g_object_set_double volume "volume" vol))))


;;;
;;;; Microphone-Audio-Consumer
;;;


(class Microphone-Audio-Consumer extends Stream-Frame-Consumer
  
  
  (method override (consume-frame self buffer dts pts duration flags)
    (site microphone
      ;; ignore stream headers
      (unless (and duration (= duration GST_CLOCK_TIME_NONE))
        (nextmethod self buffer dts pts duration flags)
        (when buffer
          (let ((size (u8vector-length buffer)))
            (when (and record-events? udp-record-src/sink?)
              (record-event udp-id-src-media
                            -1. ;; todo channel no
                            (fixnum->flonum client-no)
                            (fixnum->flonum udp-audio)
                            -1.
                            -1.
                            (fixnum->flonum size)
                            (timestamp->flonum dts)))))))))


;;;
;;;; File-Preprocess-Audio-Src
;;;


(class File-Preprocess-Audio-Src extends Audio-Src
  
  
  (slot location    initialize #f accessors generate)
  (slot container   initialize #f accessors generate)
  (slot prime?      initialize #f accessors generate)
  (slot denoise?    initialize #f accessors generate)
  (slot voice?      initialize #f accessors generate)
  (slot voice-probe initialize #f accessors generate)
  
  
  (method override (initialize self location (container: container #f) (prime?: prime? #f) (denoise?: denoise? #f) (voice?: voice? #f))
    (nextmethod self)
    (set! self.location location)
    (set! self.container container)
    (set! self.prime? prime?)
    (set! self.denoise? denoise?)
    (set! self.voice? voice?))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((listener (open-stream-listener "preprocessaudio")))
      (let ((pipeline (if (and prime? (not denoise?) (not voice?))
                          (case container
                            ((qt)
                             (gst-pipeline (tie "filesrc name=filesrc")
                                           "qtdemux"
                                           "audio/mpeg"
                                           "appsink name=appsink sync=false"))
                            ((mp3)
                             (gst-pipeline (tie "filesrc name=filesrc")
                                           "id3demux"
                                           "mpegaudioparse"
                                           "appsink name=appsink sync=false"))
                            ((mpegts)
                             (gst-pipeline (tie "filesrc name=filesrc")
                                           "tsdemux"
                                           "audio/mpeg"
                                           "appsink name=appsink sync=false"))
                            ((ogg)
                             (gst-pipeline (tie "filesrc name=filesrc")
                                           "oggdemux"
                                           "appsink name=appsink sync=false"))
                            (else
                             (error "Unsupported preprocess prime audio container: {a}" container)))
                        (gst-pipeline (tie "filesrc name=filesrc")
                                      "decodebin"
                                      (and (eq? audio-codec 'opus) "audioconvert")
                                      (and (eq? audio-codec 'opus) "audioresample")
                                      (and (eq? audio-codec 'opus) "opusenc name=enc")
                                      (and (or denoise? voice?) (eq? audio-codec 'vorbis) "audioconvert")
                                      (and (or denoise? voice?) (eq? audio-codec 'vorbis) "audioresample")
                                      (and (or denoise? voice?)
                                           (gst-element "rndenoiser name=rndenoiser"
                                                        denoise: (gst-boolean denoise?)
                                                        voice: (gst-boolean voice?)))
                                      (and (eq? audio-codec 'vorbis) "audioconvert")
                                      (and (eq? audio-codec 'vorbis) "audioresample")
                                      (and (eq? audio-codec 'vorbis) (tie "audio/x-raw, format=F32LE, layout=interleaved, rate={audio-rate}, channels=2"))
                                      (and (eq? audio-codec 'vorbis) "vorbisenc name=enc")
                                      "appsink name=appsink sync=false"))))
        (gst_object_set_name pipeline "audio.file")
        (with-unref ((filesrc (gst_bin_get_by_name pipeline "filesrc"))
                     (appsink (gst_bin_get_by_name pipeline "appsink")))
          (with-unref ((pad (gst_element_get_static_pad appsink "sink")))
            (set! voice-probe (gst_pad_add_voice_probe pad (get-write-file listener))))
          (gst_app_sink_connect_signals appsink listener)
          (setup-consumer consumer listener appsink 8192)
          (g_object_set_string filesrc "location" (path-normalize location))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.pipeline pipeline)))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'file)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when voice-probe
      (gst_pad_probe_free voice-probe)
      (set! voice-probe #f))
    (gst_bin_release pipeline)
    (set! pipeline #f)
    (release-consumer consumer))
  
  
  (method override (run-audio self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (site audio-preprocess
            (process self task exit))
          (iter))))))


;;;
;;;; File-Stream-Audio-Src
;;;


(class File-Stream-Audio-Src extends Audio-Src implements Media-Stream
  
  
  (slot location     getter generate)
  (slot stream?      accessors explicit)
  (slot sound?       getter generate) ;; gambit30 revisit
  (slot file         getter generate)
  (slot reader       getter generate)
  (slot time-base    getter generate)
  (slot muted?       getter generate)
  (slot pause?       getter generate)
  (slot flush?       getter generate)
  (slot delayed-seek getter generate)
  
  
  (method override (initialize self location (file: file #f) (stream?: stream? #t) (sound?: sound? #f))
    (nextmethod self)
    (set! self.location location)
    (set! self.stream? stream?)
    (set! self.sound? sound?)
    (set! self.file file)
    (set! self.reader #f)
    (set! self.time-base (new Time-Base))
    (set! self.muted? #f)
    (set! self.pause? #f)
    (set! self.flush? #f)
    (set! self.delayed-seek #f))
  
  
  (method override (start-element self)
    (nextmethod self)
    (set! file (or file (new-file {Directory Documents} (add-extension location (audio-profile-extension)))))
    (set! reader (new Stream-Reader file))
    (task-start self (if sound?
                         'sound
                       'audio-stream)))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (close reader)
    (set! file #f)
    (set! reader #f))
  
  
  (method override (get-stream? self)
    stream?)
  
  
  (method override (set-stream? self flag)
    (set! stream? flag))
  
  
  (method override (play-stream self)
    (task-wakeup task
      (lambda (exit)
        (set! pause? #f)
        (reset time-base))))
  
  
  (method override (pause-stream self)
    (task-wakeup task
      (lambda (exit)
        (set! pause? #t)
        (task-sleep task +inf.0 exit))))
  
  
  (method override (rewind-stream self)
    (task-wakeup task
      (lambda (exit)
        (goto-frame reader 0)
        (reset time-base)
        (set! flush? #t))))
  
  
  (method override (goto-delayed self pos normalized-dts)
    (when (not delayed-seek)
      (task-wakeup task
        (lambda (exit)
          (task-sleep task +inf.0 exit))))
    (set! delayed-seek (cons pos normalized-dts)))
  
  
  (method override (goto-stream self pos normalized-dts)
    (task-wakeup task
      (lambda (exit)
        (if (not pos)
            (begin
              (when delayed-seek
                (bind (pos . normalized-dts) delayed-seek
                  (goto-position reader pos normalized-dts))
                (set! delayed-seek #f))
              (if pause?
                  (task-sleep task +inf.0 exit)
                (reset time-base)
                (set! flush? #t)))
          (goto-position reader pos normalized-dts)
          (task-sleep task +inf.0 exit)))))
  
  
  (method override (backward-stream self pos normalized-dts)
    (when pause?
      (task-wakeup task
        (lambda (exit)
          (goto-position reader pos normalized-dts)
          (task-sleep task +inf.0 exit)))))
  
  
  (method override (forward-stream self pos normalized-dts)
    (when pause?
      (task-wakeup task
        (lambda (exit)
          (goto-position reader pos normalized-dts)
          (task-sleep task +inf.0 exit)))))
  
  
  (method protected (mute-stream self)
    (set! muted? #t))
  
  
  (method protected (unmute-stream self)
    (set! muted? #f))
  
  
  (method override (run-audio self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (if (stopping? task)
              (task-done task exit)
            ;; protect against stream? threaded change
            (let ((stream? stream?))
              (let ((frame (read-frame reader stream?)))
                (if (not frame)
                    (if stream-loop?
                        (begin
                          (close reader)
                          (set! reader (new Stream-Reader file))
                          (set! time-base (new Time-Base))
                          (iter))
                      (task-done task exit))
                  (receive (buffer dts pts duration flags) frame
                    (let ((time (current-seconds))
                          (nanodts (timestamp->flonum dts)))
                      (update-start time-base time nanodts)
                      (let ((sendtime (remote->local time-base nanodts)))
                        (if (not sound?)
                            (task-sleep task (- sendtime time) exit)
                          (sleep (- sendtime time))
                          (task-sleep task 0 exit))
                        (when stream?
                          (if flush?
                              (set! flush? #f)
                            (site audio-stream
                              (unless muted?
                                (consume-frame consumer buffer dts pts duration flags)))))))))))
            (iter)))))))


;;;
;;;; Audio-Sink
;;;


(class Audio-Sink extends Stream-Sink
  
  
  (slot channel                initialize #f accessors generate)
  (slot codec                  initialize #f accessors generate)
  (slot caps                   initialize #f accessors generate)
  (slot volume                 initialize #f accessors explicit)
  (slot mix?                   initialize #f getter generate)
  (slot sound?                 initialize #f accessors explicit) ;; gambit30 revisit
  (slot pipeline               initialize #f accessors generate)
  (slot bin                    initialize #f accessors generate)
  (slot appsrc                 initialize #f accessors generate)
  (slot volelem                initialize #f accessors generate)
  (slot panelem                initialize #f accessors generate)
  (slot stream-state           initialize 'off getter generate setter explicit)
  (slot stream-playing?        initialize #f getter generate)
  (slot stream-disconnected?   initialize #f getter generate)
  (slot source-adapter         initialize #f getter generate)
  (slot last-timestamp         initialize #f getter generate)
  (slot last-duration          initialize #f getter generate)
  (slot monitor                getter generate)
  
  
  (method override (initialize self (channel: channel #f) (codec: codec #f) (caps: caps #f) (volume: volume #f) (mix?: mix? #f) (sound?: sound? #f))
    (nextmethod self)
    (set! self.name (determine-name self channel))
    (set! self.channel channel)
    (set! self.codec codec)
    (set! self.caps caps)
    (set! self.volume volume)
    (set! self.mix? mix?)
    (set! self.sound? sound?)
    (set! self.source-adapter (if (and channel (sender? channel)) (new Source-Rebaser) (new Source-Coupler)))
    (set! self.monitor (new Audio-Monitor)))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name))))
  
  
  (method (ensure-unique self base)
    (define (try rank)
      (let ((audio (current-audio)))
        (let ((name (if (= rank 1)
                        base
                      (string-append base (number->string rank)))))
          (if (find (get-ordered-outputs audio) name key: get-name test: equal?)
              (try (+ rank 1))
            name))))
    
    (try 1))
  
  
  (method (determine-name self channel)
    (ensure-unique self (determine-channel-name channel)))
  
  
  (method package (set-stream-state self state)
    (when (neq? state stream-state)
      (set! stream-state state)
      (when (client?)
        (invalidate-audio-state (current-client) self))))
  
  
  (method package (set-stream-disconnected self)
    (set! stream-state 'off)
    (set! stream-disconnected? #t)
    (invalidate-audio-state (current-client) self))
  
  
  (method package (setup-bin self)
    ;; min-latency should be at least .01s greater than adapter-tolerance
    ;; else a rising rebase will generate audible gritches in the audio mixer
    (let ((bin ((if mix? gst-bin gst-pipeline)
                (format "appsrc{? caps=\"{a}\"~}{?: min-latency=40000000~} name=src" caps (not sound?))
                (and (not sound?) "queue name=queue")
                (and (eq? codec 'mp3) "avdec_mp3 name=dec")
                (and (eq? codec 'aac) "avdec_aac name=dec")
                (and (eq? codec 'opus) "opusdec name=dec")
                (and (eq? codec 'vorbis) "vorbisdec name=dec")
                "audioconvert name=convert"
                "audioresample name=resample"
                ;; wasapi regression
                (cond-expand
                  (windows #f)
                  (else "audio/x-raw, format=S16LE, layout=interleaved, rate=48000, channels=2"))
                (let ((volume (or volume 1)))
                  (tie "volume volume={volume} name=volume"))
                ;; wasapi regression
                (cond-expand
                  (windows #f)
                  (else "audiopanorama method=1 name=panorama"))
                (and (not mix?)
                     (if (not sound?)
                         (gst-element speakersink name: "sink")
                       (gst-element speakersink buffer-time: "100000" name: "sink"))))))
      (gst_object_set_name bin (string-append "audio." name))
      (with-unref ((appsrc (gst_bin_get_by_name bin "src"))
                   (volelem (gst_bin_get_by_name bin "volume"))
                   (panelem ;; wasapi regression
                            (cond-expand
                              (windows #f)
                              (else (gst_bin_get_by_name bin "panorama")))))
        (when (not caps)
          (case codec
            ((opus)
             (gst-app-src-set-caps appsrc "audio/x-opus"
               "channel-mapping-family" 'int 0))
            ((vorbis)
             (gst-app-src-set-caps appsrc "audio/x-vorbis"))))
        (g-object-set appsrc
          "is-live"     'boolean #t
          "stream-type" 'int     GST_APP_STREAM_TYPE_STREAM
          "format"      'int     GST_FORMAT_TIME)
        (gst_element_set_state bin GST_STATE_READY)
        (set! self.bin bin)
        (set! self.appsrc appsrc)
        (set! self.volelem volelem)
        (set! self.panelem panelem))))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (setup-bin self))
  
  
  (method override (start-element self)
    (nextmethod self)
    (gst_element_set_state bin GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state bin GST_STATE_PLAYING)
    (when channel
      (capture-audio (capture-name self) bin audiosink-tail-src)))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state bin GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (gst_element_set_state bin GST_STATE_READY))
  
  
  ;; not called when part of audio
  (method override (release-element self)
    (nextmethod self)
    (gst_bin_release bin)
    (set! bin #f)
    (set! appsrc #f)
    (set-stream-state self 'off))
  
  
  (method protected (capture-release self)
    (when channel
      (uncapture-audio (capture-name self))))
  
  
  (method (capture-name self)
    (string-append "audio." name))
  
  
  (method protected (play-audio self)
    (when (not stream-playing?)
      (play self)
      (set! stream-playing? #t)))
  
  
  (method protected virtual (write-audio self buffer dts pts duration)
    (mutex-lock! audio-mutex)
    (play-audio self)
    (let ((timestamp-offset (adapt-time source-adapter appsrc pts)))
      (let ((dts (max 0 (+ dts timestamp-offset)))
            (pts (max 0 (+ pts timestamp-offset))))
        (when record-events?
          (let ((running-time (gst_element_get_running_time appsrc))
                (presentation-time (+ pts udp-audio-late)))
            (when (> running-time presentation-time)
              (record-event udp-id-media-late
                            -1.
                            -1.
                            (fixnum->flonum udp-audio)
                            -1.
                            -1.
                            -1.
                            -1.))))
        (when (or (not last-timestamp) (>= pts (+ last-timestamp last-duration)))
          (gst_app_src_write appsrc buffer (u8vector-length buffer) dts pts duration)
          (set! last-timestamp pts)
          (set! last-duration duration))))
    (mutex-unlock! audio-mutex))
  
  
  (method public (muted? self)
    (g_object_get_boolean volelem "mute"))
  
  
  (method public (mute self)
    (g_object_set_boolean volelem "mute" #t))
  
  
  (method public (unmute self)
    (g_object_set_boolean volelem "mute" #f))
  
  
  (method public (get-volume self)
    (g_object_get_double volelem "volume"))
  
  
  (method public (set-volume self vol)
    (g_object_set_double volelem "volume" vol))
  
  
  (method public (set-panorama self pan)
    ;; wasapi regression
    (cond-expand
      (windows)
      (else
       (g_object_set_double panelem "panorama" pan)))))


;;;
;;;; Monitor
;;;


(class Audio-Monitor extends Object
  
  
  (slot systemclock-name      initialize #f accessors generate)
  (slot audioclock-name       initialize #f accessors generate)
  (slot first-originclock     initialize #f getter generate)
  (slot first-realclock       initialize #f getter generate)
  (slot first-monotonicclock  initialize #f getter generate)
  (slot first-systemclock     initialize #f getter generate)
  (slot first-audioclock      initialize #f getter generate)
  (slot originclock-elapse    initialize 0. getter generate)
  (slot realclock-elapse      initialize 0. getter generate)
  (slot monotonicclock-elapse initialize 0. getter generate)
  (slot systemclock-elapse    initialize 0. getter generate)
  (slot audioclock-elapse     initialize 0. getter generate)
  (slot originclock-rate      initialize 1. getter generate)
  (slot realclock-rate        initialize 1. getter generate)
  (slot monotonicclock-rate   initialize 1. getter generate)
  (slot systemclock-rate      initialize 1. getter generate)
  (slot audioclock-rate       initialize 1. getter generate)
  
  
  (method (update self origintime realclock monotonicclock systemtime audiotime)
    (let ((originclock (timestamp->flonum origintime))
          (systemclock (timestamp->flonum systemtime))
          (audioclock (timestamp->flonum audiotime)))
      (when (not first-originclock)
        (set! first-originclock originclock)
        (set! first-realclock realclock)
        (set! first-monotonicclock monotonicclock)
        (set! first-systemclock systemclock)
        (set! first-audioclock audioclock))
      (set! originclock-elapse (- originclock first-originclock))
      (set! realclock-elapse (- realclock first-realclock))
      (set! monotonicclock-elapse (- monotonicclock first-monotonicclock))
      (set! systemclock-elapse (- systemclock first-systemclock))
      (set! audioclock-elapse (- audioclock first-audioclock))
      (when record-events?
        (record-event udp-id-debug-audio
                      -1.
                      -1.
                      -1.
                      originclock-elapse
                      realclock-elapse
                      monotonicclock-elapse
                      systemclock-elapse
                      audioclock-elapse))
      (when (> originclock-elapse 0.)
        (set! originclock-rate (/ originclock-elapse originclock-elapse))
        (set! realclock-rate (/ realclock-elapse originclock-elapse))
        (set! monotonicclock-rate (/ monotonicclock-elapse originclock-elapse))
        (set! systemclock-rate (/ systemclock-elapse originclock-elapse))
        (set! audioclock-rate (/ audioclock-elapse originclock-elapse)))))))
