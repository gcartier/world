;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Audio
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.audio jazz


(import (jazz.stream)
        (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.configure)
        (world.context)
        (world.interface)
        (world.settings)
        (world.support)
        (world.task))


(definition protected audio-codec
  (world-setting 'world.audio-codec 'opus))


(definition audio-show
  (world-setting 'world.audio-show #f))


(definition protected audio-denoise?
  (world-setting 'world.audio-denoise? #t))

(definition protected (set-audio-denoise? flag)
  (set! audio-denoise? flag))


(definition protected audio-properties
  (world-setting 'world.audio-properties "audio-type=2048"))

(definition protected (set-audio-properties properties)
  (set! audio-properties properties))


;;;
;;;; Audio
;;;


(definition protected (new-world-audio)
  (let ((mic-src (new Mic-Audio-Src))
        (server-sink (new Stream-Sink
                       consumer: (lambda (buffer timestamp duration)
                                   (send-client-audio (current-client) buffer timestamp duration)))))
    (new World-Audio input: (pipeline mic-src server-sink))))


(class World-Audio extends Object
  
  
  (slot input   getter generate)
  (slot outputs getter generate)
  
  
  (method override (initialize self (input: input #f))
    (nextmethod self)
    (set! self.input input)
    (set! self.outputs (make-table test: equal?)))
  
  
  (method package (autostart self)
    (when (world-setting 'world.audio-autostart? #f)
      (start self)))
  
  
  (method package (start self)
    (start input))
  
  
  (method package (stop self)
    (release input))
  
  
  ;;;
  ;;;; Input
  ;;;
  
  
  (method (on-toggle-audio self evt)
    (toggle-audio self))
  
  
  (method package (toggle-audio self)
    (when (client?)
      (if (audio-playing? self)
          (stop-audio self)
        (start-audio self))))
  
  
  (method package (start-audio self (feedback?: feedback? #t))
    (when (client?)
      (let ((world (current-world)))
        (when audio-self?
          (let ((id (get-id (current-me))))
            (player-output self id)))
        (start self)
        (update-parameter world 'audio)
        (when feedback?
          (display-on/off world "Audio" (playing? input))))))
  
  
  (method package (stop-audio self (feedback?: feedback? #t))
    (when (client?)
      (let ((world (current-world)))
        (stop self)
        (when audio-self?
          (let ((id (get-id (current-me))))
            (let ((output (find-output self id)))
              (when output
                (close-output self id output)))))
        (update-parameter world 'audio)
        (when feedback?
          (display-on/off world "Audio" (playing? input))))))
  
  
  (method package (audio-playing? self)
    (playing? input))
  
  
  ;;;
  ;;;; Output
  ;;;
  
  
  (method package (find-output self id)
    (table-ref outputs id #f))
  
  (method package (register-output self id output)
    (table-set! outputs id output))
  
  
  (method package (player-output self id)
    (or (table-ref outputs id #f)
        (let ((output (new-output self)))
          (table-set! outputs id output)
          (setup output)
          (start output)
          output)))
  
  
  (method (new-output self)
    (new Audio-Sink
      codec: audio-codec))
  
  
  (method package (close-output self id output)
    (table-clear outputs id)
    (release output))
  
  
  (method package (receive-server-audio self id buffer timestamp duration)
    (let ((output (find-output self id)))
      (when output
        (if (not buffer)
            (set-stream-state output 'off)
          (when (eq? (get-stream-state output) 'off)
            (set-stream-state output 'on))
          (consume output buffer timestamp duration))))))


;;;
;;;; Audio-Src
;;;


(class Audio-Src extends Stream-Src)


;;;
;;;; Mic-Audio-Src
;;;


(class Mic-Audio-Src extends Audio-Src
  
  
  (slot mic-pipeline                initialize #f  accessors generate)
  (slot mic-sink                    initialize #f  accessors generate)
  (slot mic-data       <u8vector+>  initialize #f  accessors generate)
  (slot mic-info       <u64vector+> initialize #f  accessors generate)
  (slot mic-task                    initialize #f  accessors generate)
  (slot codec-pipeline              initialize #f  accessors generate)
  (slot codec-src                   initialize #f  accessors generate)
  (slot codec-sink                  initialize #f  accessors generate)
  (slot codec-data     <u8vector+>  initialize #f  accessors generate)
  (slot codec-info     <u64vector+> initialize #f  accessors generate)
  (slot codec-task                  initialize #f  accessors generate)
  
  
  (method override (setup-element self)
    (nextmethod self)
    ;; mic
    (let ((pipeline (gst-launch "autoaudiosrc format=S16LE layout=interleaved rate=48000 channels=1 name=src"
                                "audioresample"
                                "audio/x-raw, format=S16LE, layout=interleaved, rate=48000, channels=1"
                                "appsink name=sink")))
      (gst_object_set_name pipeline "mic")
      (let ((appsink (gst_bin_get_by_name pipeline "sink"))
            (data (make-u8vector 4096))
            (info (make-u64vector 2)))
        (gst_element_set_state pipeline GST_STATE_READY)
        (set! self.mic-data data)
        (set! self.mic-info info)
        (set! self.mic-pipeline pipeline)
        (set! self.mic-sink appsink)))
    ;; codec
    (let ((pipeline (gst-launch "appsrc name=src"
                                (tie "opusenc {audio-properties} name=enc")
                                "appsink name=sink")))
      (gst_object_set_name pipeline "codec")
      (let ((appsrc (gst_bin_get_by_name pipeline "src"))
            (appsink (gst_bin_get_by_name pipeline "sink"))
            (data (make-u8vector 4096))
            (info (make-u64vector 2)))
        (gst_app_src_set_caps appsrc
                              (gst_caps "audio/x-raw"
                                        "format"   (g_value_string "S16LE")
                                        "layout"   (g_value_string "interleaved")
                                        "rate"     (g_value_int 48000)
                                        "channels" (g_value_int 1)))
        (gst_element_set_state pipeline GST_STATE_READY)
        (set! self.codec-data data)
        (set! self.codec-info info)
        (set! self.codec-pipeline pipeline)
        (set! self.codec-src appsrc)
        (set! self.codec-sink appsink))))
  
  
  (method override (start-element self)
    (define (mic-start)
      (let ((procedure
              (lambda (task)
                (mic-loop self task))))
        (let ((task (new Task 'mic procedure priority: audio-priority)))
          (start-task task)
          (set! self.mic-task task))))
    
    (define (codec-start)
      (let ((procedure
              (lambda (task)
                (codec-loop self task))))
        (let ((task (new Task 'codec procedure priority: audio-priority)))
          (start-task task)
          (set! self.codec-task task))))
    
    (nextmethod self)
    (gst_element_set_state mic-pipeline GST_STATE_PLAYING)
    (mic-start)
    (gst_element_set_state codec-pipeline GST_STATE_PLAYING)
    (codec-start))
  
  
  (method override (stop-element self)
    (define (mic-stop)
      (halt-task mic-task)
      (set! mic-task #f))
    
    (define (codec-stop)
      (halt-task codec-task)
      (set! codec-task #f))
    
    (nextmethod self)
    (mic-stop)
    (gst_element_set_state mic-pipeline GST_STATE_READY)
    (codec-stop)
    (gst_element_set_state codec-pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release mic-pipeline)
    (set! mic-info #f)
    (set! mic-data #f)
    (set! mic-pipeline #f)
    (set! mic-sink #f)
    (consume sink #f #f #f)
    (gst_element_release codec-pipeline)
    (set! codec-info #f)
    (set! codec-data #f)
    (set! codec-pipeline #f)
    (set! codec-src #f)
    (set! codec-sink #f)
    (cond-expand
      (mac
       (gst_denoise_off))
      (else)))
  
  
  (method (mic-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-seconds)))
          ;; not 100% correct if preempted before task-mutex
          (let ((time (current-seconds)))
            (unless (stopping? task)
              (site (audio-codec on?: #t)
                (let ((elapse (- time previous))
                      (max-elapse 10.))
                  ;; ignore ridiculous elapses like
                  ;; coming back from computer sleep
                  (unless (> elapse max-elapse)
                    (let ((history (current-history)))
                      (unless (get-paused? history)
                        (mic-process self)))))))
            (let ((duration (- (current-seconds) time)))
              (task-sleep task audio-period duration exit))
            (iter time))))))
  
  
  (method (mic-process self)
    (let ((size (gst_app_sink_read mic-sink mic-data mic-info)))
      (when (/= size -1)
        (let ((buffer (subu8vector mic-data 0 size))
              (timestamp (u64vector-ref mic-info 0))
              (duration (u64vector-ref mic-info 1)))
          (cond-expand
            (mac
             (when audio-denoise?
               (gst_denoise buffer size)))
            (else))
          (gst_app_src_write codec-src buffer size timestamp duration)))))
  
  
  (method (codec-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-seconds)))
          ;; not 100% correct if preempted before task-mutex
          (let ((time (current-seconds)))
            (unless (stopping? task)
              (site (audio on?: #t)
                (let ((elapse (- time previous))
                      (max-elapse 10.))
                  ;; ignore ridiculous elapses like
                  ;; coming back from computer sleep
                  (unless (> elapse max-elapse)
                    (let ((history (current-history)))
                      (unless (get-paused? history)
                        (process self)))))))
            (let ((duration (- (current-seconds) time)))
              (task-sleep task audio-period duration exit))
            (iter time))))))
  
  
  (method override (process self)
    (let ((size (gst_app_sink_read codec-sink codec-data codec-info)))
      (when (/= size -1)
        (let ((buffer (subu8vector codec-data 0 size))
              (timestamp (u64vector-ref codec-info 0))
              (duration (u64vector-ref codec-info 1)))
          (when audio-show
            (terminal 'audio size))
          (consume sink buffer timestamp duration))))))


;;;
;;;; Audio-Sink
;;;


(class Audio-Sink extends Stream-Sink
  
  
  (slot codec        initialize #f accessors generate)
  (slot volume       initialize #f accessors explicit)
  (slot pipeline     initialize #f accessors generate)
  (slot appsrc       initialize #f accessors generate)
  (slot stream-state initialize 'off getter generate setter explicit)
  
  
  (method override (initialize self (codec: codec #f) (volume: volume #f))
    (nextmethod self)
    (set! self.codec codec)
    (set! self.volume volume))
  
  
  (method package (set-stream-state self state)
    (when (neq? state stream-state)
      (set! stream-state state)
      (invalidate-interface)))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((pipeline (gst-launch (tie "appsrc name=src")
                                "opusdec name=dec"
                                (let ((volume (or volume 1)))
                                  (tie "volume name=volume volume={volume}"))
                                "audiopanorama name=panorama"
                                (cond-expand
                                  (windows "directsoundsink name=sink buffer-time=200000 latency-time=100000")
                                  (else "autoaudiosink name=sink")))))
      (gst_object_set_name pipeline "output")
      (let ((appsrc (gst_bin_get_by_name pipeline "src")))
        (gst_app_src_set_caps appsrc
                              (gst_caps "audio/x-opus"
                                        "channel-mapping-family" (g_value_int 0)))
        (g_object_set appsrc
          "is-live"     (g_value_boolean #t)
          "stream-type" (g_value_int GST_APP_STREAM_TYPE_STREAM)
          "format"      (g_value_int GST_FORMAT_TIME))
        (gst_element_set_state pipeline GST_STATE_READY)
        (set! self.pipeline pipeline)
        (set! self.appsrc appsrc))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! pipeline #f)
    (set! appsrc #f)
    (set-stream-state self 'off))
  
  
  (method override (consume self buffer timestamp duration)
    (gst_app_src_write3 appsrc buffer (u8vector-length buffer) timestamp duration))
  
  
  (method public (mute self)
    (let ((volume (gst_bin_get_by_name pipeline "volume")))
      (g_object_set_boolean volume "mute" #t)))
  
  
  (method public (unmute self)
    (let ((volume (gst_bin_get_by_name pipeline "volume")))
      (g_object_set_boolean volume "mute" #f)))
  
  
  (method public (get-volume self)
    (let ((volume (gst_bin_get_by_name pipeline "volume")))
      (g_object_get_double volume "volume")))
  
  
  (method public (set-volume self vol)
    (let ((volume (gst_bin_get_by_name pipeline "volume")))
      (g_object_set_double volume "volume" vol)))
  
  
  (method public (set-panorama self pan)
    (let ((panorama (gst_bin_get_by_name pipeline "panorama")))
      (g_object_set_double panorama "panorama" pan)))))
