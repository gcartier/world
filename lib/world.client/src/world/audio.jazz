;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Audio
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.audio jazz


(import (jazz.graphic)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.billboard)
        (world.configure)
        (world.context)
        (world.geometry)
        (world.id)
        (world.quad-texture)
        (world.settings)
        (world.syntax (phase syntax))
        (world.task))


(definition protected audio-codec
  (world-setting 'world.audio-codec 'vorbis))

(definition protected audio-protocol
  (world-setting 'world.audio-protocol 'udp))


(definition audio-debug?
  (world-setting 'world.audio-debug? #f))


;;;
;;;; Audio
;;;


(definition protected (new-world-audio)
  (let ((mic-src (new Mic-Audio-Src))
        (server-sink (new Stream-Sink
                       consumer: (lambda (buffer timestamp duration)
                                   (send-client-audio (client-tier) buffer timestamp duration)))))
    (new World-Audio input: (pipeline mic-src server-sink))))


(class World-Audio extends Object
  
  
  (slot input   getter generate)
  (slot outputs getter generate)
  
  
  (method override (initialize self (input: input #f))
    (nextmethod self)
    (set! self.input input)
    (set! self.outputs (make-table test: equal?)))
  
  
  (method package (autostart self)
    (when (world-setting 'world.audio-autostart? #f)
      (start self)))
  
  
  (method package (start self)
    (start input))
  
  
  (method package (stop self)
    (release input)
    (iterate-table outputs
      (lambda (id output)
        (release output))))
  
  
  ;;;
  ;;;; Input
  ;;;
  
  
  (method (on-toggle-audio self evt)
    (toggle self))
  
  
  (method (on-toggle-audio-protocol self evt)
    (let ((world (current-world)))
      (set! audio-protocol (case audio-protocol
                             ((udp) 'tcp)
                             ((tcp) 'udp)))
      (display-message world (upcase (->string audio-protocol)))))
  
  
  (method (toggle self)
    (when (client?)
      (let ((world (current-world)))
        (if (playing? input)
            (stop self)
          (start self))
        (update-parameter world 'audio)
        (display-on/off world "Audio" (playing? input)))))
  
  
  ;;;
  ;;;; Output
  ;;;
  
  
  (method package (find-output self id)
    (table-ref outputs id #f))
  
  (method package (register-output self id output)
    (table-set! outputs id output))
  
  
  (method package (player-output self id)
    (or (table-ref outputs id #f)
        (let ((output (new-output self)))
          (table-set! outputs id output)
          output)))
  
  
  (method (new-output self)
    (new Audio-Sink
      codec: audio-codec))
  
  
  (method package (receive-server-audio self id buffer timestamp duration)
    (if (not buffer)
        (let ((output (find-output self id)))
          (when output
            (table-clear outputs id)
            (release output)))
      (let ((output (player-output self id)))
        (setup output)
        (start output)
        (consume output buffer timestamp duration)))))


;;;
;;;; Audio-Src
;;;


(class Audio-Src extends Stream-Src)


;;;
;;;; Mic-Audio-Src
;;;


(class Mic-Audio-Src extends Audio-Src
  
  
  (slot pipeline             initialize #f accessors generate)
  (slot appsink              initialize #f accessors generate)
  (slot data     <u8vector>  initialize #f accessors generate)
  (slot info     <u64vector> initialize #f accessors generate)
  (slot task                 initialize #f accessors generate)
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((codec audio-codec))
      (let ((pipeline (gst-launch "autoaudiosrc format=F32LE layout=interleaved rate=80000 channels=2 name=src"
                                  (and (eq? codec 'opus) (tie "avenc_opus name=enc"))
                                  (and (eq? codec 'vorbis) (tie "vorbisenc name=enc"))
                                  "appsink name=sink")))
        (gst_object_set_name pipeline "mic")
        (let ((appsink (gst_bin_get_by_name pipeline "sink"))
              (data (make-u8vector 4096))
              (info (make-u64vector 2)))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.data data)
          (set! self.info info)
          (set! self.pipeline pipeline)
          (set! self.appsink appsink)))))
  
  
  (method override (start-element self)
    (define (task-start)
      (let ((procedure
              (lambda (task)
                (mic-task self task))))
        (let ((task (new Task 'mic procedure priority: audio-priority)))
          (start-task task)
          (set! self.task task))))
    
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING)
    (task-start))
  
  
  (method override (stop-element self)
    (define (task-stop)
      (cease-task task)
      (set! task #f))
    
    (nextmethod self)
    (task-stop)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_NULL)
    (gst_object_unref pipeline)
    (set! info #f)
    (set! data #f)
    (set! pipeline #f)
    (set! appsink #f)
    (consume sink #f #f #f))
  
  
  (method (mic-task self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-seconds)))
          ;; not 100% correct if preempted before task-mutex
          (let ((time (current-seconds)))
            (unless (stopping? task)
              (site (audio on?: #t)
                (let ((elapse (- time previous))
                      (max-elapse 10.))
                  ;; ignore ridiculous elapses like
                  ;; coming back from computer sleep
                  (unless (> elapse max-elapse)
                    (let ((history (current-history)))
                      (unless (get-paused? history)
                        (process self)))))))
            (let ((duration (- (current-seconds) time)))
              (task-sleep task audio-period duration exit))
            (iter time))))))
  
  
  (method override (process self)
    (let ((size (gst_app_sink_read appsink data info)))
      (when (/= size -1)
        (let ((buffer (subu8vector data 0 size))
              (timestamp (u64vector-ref info 0))
              (duration (u64vector-ref info 1)))
          (consume sink buffer timestamp duration))))))


;;;
;;;; Audio-Sink
;;;


(class Audio-Sink extends Stream-Sink
  
  
  (slot codec    initialize #f accessors generate)
  (slot pipeline initialize #f accessors generate)
  (slot appsrc   initialize #f accessors generate)
  
  
  (method override (initialize self (codec: codec #f))
    (nextmethod self)
    (set! self.codec codec))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((pipeline (gst-launch (tie "appsrc name=src")
                                (and (eq? codec 'opus) "avdec_opus name=dec")
                                (and (eq? codec 'vorbis) "vorbisdec name=dec")
                                "volume name=volume"
                                "audiopanorama name=panorama"
                                (tie "autoaudiosink name=sink"))))
      (gst_object_set_name pipeline "output")
      (let ((appsrc (gst_bin_get_by_name pipeline "src")))
        (case codec
          ((vorbis)
           (gst_app_src_set_caps appsrc
             (gst_caps "audio/x-vorbis")))
          (else
           (gst_app_src_set_caps appsrc
             (gst_caps "audio/x-raw"
               "format"   (g_value_string "F32LE")
               "layout"   (g_value_string "interleaved")
               "rate"     (g_value_int 80000)
               "channels" (g_value_int 2)))))
        (g_object_set appsrc
          "is-live"     (g_value_boolean #t)
          "stream-type" (g_value_int GST_APP_STREAM_TYPE_STREAM)
          "format"      (g_value_int GST_FORMAT_TIME))
        (gst_element_set_state pipeline GST_STATE_READY)
        (set! self.pipeline pipeline)
        (set! self.appsrc appsrc))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_NULL)
    (gst_object_unref pipeline)
    (set! pipeline #f)
    (set! appsrc #f))
  
  
  (method override (consume self buffer timestamp duration)
    (gst_app_src_write3 appsrc buffer (u8vector-length buffer) timestamp duration))
  
  
  (method public (mute self)
    (let ((volume (gst_bin_get_by_name pipeline "volume")))
      (g_object_set_boolean volume "mute" #t)))
  
  
  (method public (unmute self)
    (let ((volume (gst_bin_get_by_name pipeline "volume")))
      (g_object_set_boolean volume "mute" #f)))
  
  
  (method public (get-volume self)
    (let ((volume (gst_bin_get_by_name pipeline "volume")))
      (g_object_get_double volume "volume")))
  
  
  (method public (set-volume self vol)
    (let ((volume (gst_bin_get_by_name pipeline "volume")))
      (g_object_set_double volume "volume" vol)))
  
  
  (method public (set-panorama self pan)
    (let ((panorama (gst_bin_get_by_name pipeline "panorama")))
      (g_object_set_double panorama "panorama" pan)))))
