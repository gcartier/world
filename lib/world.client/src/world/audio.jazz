;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Audio
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.audio jazz


(import (jazz.io)
        (jazz.presence)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.configure)
        (world.context)
        (world.event)
        (world.interface)
        (world.settings)
        (world.stream)
        (world.support)
        (world.task)
        (world.time)
        (world.udp))


(definition protected audio-rate
  (world-setting 'world.audio-rate 48000))

(definition protected audio-codec
  (world-setting 'world.audio-codec 'vorbis))


(definition audio-show
  (world-setting 'world.audio-show #f))


;; denoiser only works for 48000 rate
(definition protected audio-denoise?
  (world-setting 'world.audio-denoise? (= audio-rate 48000)))

(definition protected (get-audio-denoise?)
  (get-denoising?))

(definition protected (set-audio-denoise? flag)
  (set-denoising? flag))

(set-audio-denoise? audio-denoise?)


(definition protected audio-properties
  (world-setting 'world.audio-properties #f))

(definition protected (set-audio-properties properties)
  (set! audio-properties properties))


;;;
;;;; Header
;;;


(definition protected (audio-buffer-header? buffer)
  (if (eq? audio-codec 'vorbis)
      (let ((size (u8vector-length buffer)))
        (and (>= size 7)
             (equal? (subu8vector buffer 1 7)
                     #u8(118 111 114 98 105 115))))
    #f))


;;;
;;;; Profile
;;;


(definition public (audio-profile-extension)
  "streamaudio")


;;;
;;;; Audio
;;;


(class World-Audio extends Object
  
  
  (slot outputs getter generate)
  
  
  (method override (initialize self)
    (nextmethod self)
    (set! self.outputs (make-table test: equal?)))
  
  
  ;;;
  ;;;; Output
  ;;;
  
  
  (method package (find-output self id)
    (table-ref outputs id #f))
  
  (method package (register-output self id output)
    (table-set! outputs id output))
  
  
  (method package (player-output self id)
    (or (table-ref outputs id #f)
        (let ((output (new-output self)))
          (table-set! outputs id output)
          (play output)
          output)))
  
  
  (method package (channel-output self channel)
    (let ((output (player-output self (get-no channel))))
      (set-channel output channel)
      output))
  
  
  (method package (visualizer-output self)
    (let ((output (new Audio-Sink codec: audio-codec)))
      (play output)
      output))
  
  
  (method package (simulation-output self)
    (let ((output (new Simulation-Audio-Sink codec: audio-codec)))
      (play output)
      output))
  
  
  (method (new-output self)
    (new Audio-Sink
      codec: audio-codec))
  
  
  (method package (close-output self id output)
    (table-clear outputs id)
    (release output)
    (close output))
  
  
  (method package (receive-server-audio self id buffer timestamp duration)
    (let ((output (find-output self id)))
      (when output
        (if (not buffer)
            (set-stream-state output 'off)
          (when (eq? (get-stream-state output) 'off)
            (set-stream-state output 'on))
          (consume output buffer timestamp duration)
          (record-event udp-id-sink-media
                        (fixnum->flonum id)
                        (fixnum->flonum client-no)
                        (fixnum->flonum udp-audio)
                        -1.
                        -1.
                        -1.
                        (timestamp->flonum timestamp))))))
  
  
  (method package (receive-visualizer-audio self output buffer timestamp duration)
    (if (not buffer)
        (set-stream-state output 'off)
      (when (eq? (get-stream-state output) 'off)
        (set-stream-state output 'on))
      (consume output buffer timestamp duration)))
  
  
  (method package (receive-audio self id/output buffer timestamp duration)
    (if (is? id/output Audio-Sink)
        (receive-visualizer-audio self id/output buffer timestamp duration)
      (receive-server-audio self id/output buffer timestamp duration))))


;;;
;;;; Audio-Src
;;;


(class Audio-Src extends Stream-Src
  
  
  (slot audio-headers               initialize '() accessors generate)
  (slot audio-header                initialize #f  accessors generate)
  (slot audio-pipeline              initialize #f  accessors generate)
  (slot audio-src                   initialize #f  accessors generate)
  (slot audio-sink                  initialize #f  accessors generate)
  (slot audio-data     <u8vector+>  initialize #f  accessors generate)
  (slot audio-info     <u64vector+> initialize #f  accessors generate)
  (slot audio-task                  initialize #f  accessors generate)
  (slot audio-listener              initialize #f  accessors generate)
  (slot audio-consumer              initialize #f  getter generate)
  
  
  (method package virtual (start-listeners self)
    (when audio-listener
      (start-stream-listener audio-listener)))
  
  
  (method package virtual (stop-listeners self)
    (when audio-listener
      (stop-stream-listener audio-listener)))
  
  
  (method override (start-element self)
    (nextmethod self)
    (set! audio-consumer (car sinks)))
  
  
  (method (task-start self name)
    (let ((procedure
            (lambda (task)
              (audio-loop self task))))
      (let ((task (new Task name procedure priority: audio-priority)))
        (start-listeners self)
        (start-task task)
        (set! self.audio-task task))))
  
  
  (method (task-stop self)
    (stop-listeners self)
    (stop-task audio-task)
    (set! audio-task #f))
  
  
  (method protected virtual (audio-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (if (stopping? task)
              (task-done task exit)
            (process self task exit)
            (task-halt task exit)
            (iter))))))
  
  
  (method override (process self task exit)
    (let ((size (gst_app_sink_wait task exit audio-listener audio-sink audio-data audio-info #f #f)))
      (site (audio on?: #t)
        (let ((buffer (subu8vector audio-data 0 size))
              (timestamp (u64vector-ref audio-info 0))
              (duration (u64vector-ref audio-info 1)))
          (let ((header? (audio-buffer-header? buffer)))
            (when audio-show
              (if (eq? audio-codec 'vorbis)
                  (let ((type (if header?
                                  '***header***
                                'data)))
                    (terminal 'audio size type))
                (terminal 'audio size)))
            (consume-audio self buffer header? timestamp duration)
            (record-event udp-id-src-media
                          -1.
                          (fixnum->flonum client-no)
                          (fixnum->flonum udp-audio)
                          -1.
                          (if header? 1. -1.)
                          (fixnum->flonum size)
                          (timestamp->flonum timestamp)))))))
  
  
  (method protected virtual (consume-audio self buffer header? timestamp duration)
    (consume audio-consumer buffer timestamp duration))
  
  
  (method protected (consume-audio/headers self buffer header? timestamp duration)
    (case audio-codec
      ;; opus has no headers
      ((opus)
       (consume audio-consumer buffer timestamp duration))
      ((vorbis)
       (if header?
           (begin
             (set! audio-headers (append! audio-headers (list (list buffer timestamp duration))))
             (when (= (length audio-headers) 3)
               (set! audio-header (object->u8vector audio-headers))
               (consume audio-consumer (list audio-header) #f #f)))
         (consume audio-consumer buffer timestamp duration)))))
   
   
  (method protected (resend-audio-header self channel-no)
    (let ((tier (current-client)))
      (when audio-header
        (send-client-audio tier channel-no audio-header #t -1 GST_CLOCK_TIME_NONE)))))


;;;
;;;; Mic-Audio-Src
;;;


(class Mic-Audio-Src extends Audio-Src
  
  
  (slot mic-listener initialize #f  accessors generate)
  (slot mic-pipeline initialize #f  accessors generate)
  (slot mic-sink     initialize #f  accessors generate)
  
  
  (method override (start-listeners self)
    (nextmethod self)
    (when mic-listener
      (start-stream-listener mic-listener)))
  
  
  (method override (stop-listeners self)
    (nextmethod self)
    (when mic-listener
      (stop-stream-listener mic-listener)))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((properties (or audio-properties "")))
      ;; mic
      (let ((listener (open-stream-listener "mic"))
            (pipeline (gst-launch (cond-expand
                                    (windows "directsoundsrc name=src")
                                    (else (tie "autoaudiosrc format=S16LE layout=interleaved rate={audio-rate} channels=1 name=src")))
                                  ;; no idea why these next two lines are necessary
                                  "audioresample"
                                  (tie "audio/x-raw, format=S16LE, layout=interleaved, rate={audio-rate}, channels=1")
                                  "appsink name=sink")))
        (gst_object_set_name pipeline "mic")
        (let ((appsink (gst_bin_get_by_name pipeline "sink"))
              (data (make-u8vector 4096))
              (info (make-u64vector 2)))
          (gst_app_sink_connect_signals appsink listener)
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.mic-listener listener)
          (set! self.mic-pipeline pipeline)
          (set! self.mic-sink appsink)))
      ;; audio
      (let ((listener (open-stream-listener "micaudio"))
            (pipeline (gst-launch "appsrc name=src"
                                  (and (eq? audio-codec 'opus) (tie "opusenc {properties} name=enc"))
                                  (and (eq? audio-codec 'vorbis) "audioconvert")
                                  (and (eq? audio-codec 'vorbis) (tie "audio/x-raw, format=F32LE, layout=interleaved, rate={audio-rate}, channels=1"))
                                  (and (eq? audio-codec 'vorbis) (tie "vorbisenc {properties} name=enc"))
                                  "appsink name=sink")))
        (gst_object_set_name pipeline "audio")
        (let ((appsrc (gst_bin_get_by_name pipeline "src"))
              (appsink (gst_bin_get_by_name pipeline "sink"))
              (data (make-u8vector 4096))
              (info (make-u64vector 2)))
          (gst_app_src_set_caps appsrc
                                (gst_caps "audio/x-raw"
                                          "format"   (g_value_string "S16LE")
                                          "layout"   (g_value_string "interleaved")
                                          "rate"     (g_value_int audio-rate)
                                          "channels" (g_value_int 1)))
          (g_object_set appsrc
                        "is-live"     (g_value_boolean #t)
                        "stream-type" (g_value_int GST_APP_STREAM_TYPE_STREAM)
                        "format"      (g_value_int GST_FORMAT_TIME))
          (gst_app_sink_connect_signals appsink listener)
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.audio-data data)
          (set! self.audio-info info)
          (set! self.audio-pipeline pipeline)
          (set! self.audio-src appsrc)
          (set! self.audio-sink appsink)
          (set! self.audio-listener listener)))
      ;; denoiser
      (create-denoiser-thread mic-sink audio-src)))
  
  
  (method override (start-element self)
    (nextmethod self)
    (gst_element_set_state audio-pipeline GST_STATE_PAUSED)
    (gst_element_set_state mic-pipeline GST_STATE_PAUSED)
    (task-start self 'mic))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state audio-pipeline GST_STATE_PLAYING)
    (gst_element_set_state mic-pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state audio-pipeline GST_STATE_PAUSED)
    (gst_element_set_state mic-pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state audio-pipeline GST_STATE_READY)
    (gst_element_set_state mic-pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (consume audio-consumer #f #f #f)
    (gst_element_release audio-pipeline)
    (set! audio-info #f)
    (set! audio-data #f)
    (set! audio-pipeline #f)
    (set! audio-src #f)
    (set! audio-sink #f)
    (set! audio-headers '())
    (set! audio-header #f)
    (close-stream-listener audio-listener)
    (set! audio-listener #f)
    (gst_element_release mic-pipeline)
    (set! mic-pipeline #f)
    (set! mic-sink #f)
    (close-stream-listener mic-listener)
    (set! mic-listener #f))
  
  
  (method override (consume-audio self buffer header? timestamp duration)
    (consume-audio/headers self buffer header? timestamp duration))
  
  
  (method override (reset-media self channel)
    (when (eq? audio-codec 'vorbis)
      (resend-audio-header self (get-no channel)))))


;;;
;;;; File-Preprocess-Audio-Src
;;;


(class File-Preprocess-Audio-Src extends Audio-Src
  
  
  (slot location initialize #f accessors generate)
  
  
  (method override (initialize self location)
    (nextmethod self)
    (set! self.location location))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((properties (or audio-properties ""))
          (listener (open-stream-listener "preprocessaudio")))
      (let ((pipeline (gst-launch (tie "filesrc name=filesrc")
                                  "decodebin"
                                  (and (eq? audio-codec 'opus) (tie "opusenc {properties} name=enc"))
                                  (and (eq? audio-codec 'vorbis) "audioconvert")
                                  (and (eq? audio-codec 'vorbis) "audioresample")
                                  (and (eq? audio-codec 'vorbis) (tie "audio/x-raw, format=F32LE, layout=interleaved, rate={audio-rate}, channels=1"))
                                  (and (eq? audio-codec 'vorbis) (tie "vorbisenc {properties} name=enc"))
                                  "appsink name=appsink sync=false")))
        (gst_object_set_name pipeline "file")
        (let ((filesrc (gst_bin_get_by_name pipeline "filesrc"))
              (appsink (gst_bin_get_by_name pipeline "appsink"))
              (data (make-u8vector 4096))
              (info (make-u64vector 2)))
          (gst_app_sink_connect_signals appsink listener)
          (g_object_set_string filesrc "location" (path-normalize location))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.audio-data data)
          (set! self.audio-info info)
          (set! self.audio-listener listener)
          (set! self.audio-pipeline pipeline)
          (set! self.audio-sink appsink)))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'file)
    (gst_element_set_state audio-pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state audio-pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state audio-pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state audio-pipeline GST_STATE_READY))
  
  
  (method override (audio-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (if (stopping? task)
              (task-done task exit)
            (site (preprocess on?: #t)
              (process self task exit))
            (task-sleep task .0001 exit)
            (iter)))))))


;;;
;;;; File-Stream-Audio-Src
;;;


(class File-Stream-Audio-Src extends Audio-Src
  
  
  (slot location  getter generate)
  (slot file      getter generate)
  (slot port      getter generate)
  (slot time-base getter generate)
  
  
  (method override (initialize self location)
    (nextmethod self)
    (set! self.location location)
    (set! self.file #f)
    (set! self.port #f)
    (set! self.time-base (new Time-Base)))
  
  
  (method override (start-element self)
    (nextmethod self)
    (set! file (new-file {Directory Settings} (list "streams" (add-extension location (audio-profile-extension)))))
    (set! port (open-input-file (path-settings file)))
    (task-start self 'audio-stream))
  
  
  (method override (play-element self)
    (nextmethod self)
    (task-wakeup (get-thread audio-task)
      (lambda (exit)
        )))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (task-wakeup (get-thread audio-task)
      (lambda (exit)
        (task-sleep audio-task +inf.0 exit))))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (close port)
    (set! file #f)
    (set! port #f))
  
  
  (method override (audio-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (if (stopping? task)
              (task-done task exit)
            (receive (buffer timestamp duration) (read-frame port)
              (if (not buffer)
                  (if stream-loop?
                      (begin
                        (close port)
                        (set! port (open-input-file (path-settings file)))
                        (set! time-base (new Time-Base))
                        (iter))
                    (task-done task exit))
                (let ((header? (audio-buffer-header? buffer))
                      (time (current-seconds))
                      (nanostamp (timestamp->flonum timestamp)))
                  (update-start time-base time nanostamp)
                  (let ((sendtime (remote->local time-base nanostamp)))
                    (task-sleep task (- sendtime time) exit)
                    (site (stream on?: #t)
                      (consume-audio/headers self buffer header? timestamp duration))))))
            (iter)))))))


;;;
;;;; Audio-Sink
;;;


(class Audio-Sink extends Stream-Sink
  
  
  (slot channel      initialize #f accessors generate)
  (slot codec        initialize #f accessors generate)
  (slot volume       initialize #f accessors explicit)
  (slot pipeline     initialize #f accessors generate)
  (slot appsrc       initialize #f accessors generate)
  (slot volelem      initialize #f accessors generate)
  (slot panelem      initialize #f accessors generate)
  (slot stream-state initialize 'off getter generate setter explicit)
  
  
  (method override (initialize self (codec: codec #f) (volume: volume #f))
    (nextmethod self)
    (set! self.codec codec)
    (set! self.volume volume))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (let ((effective-name (if (not channel) "Me" (get-name (get-stream channel)))))
          (format output "{a}" effective-name)))))
  
  
  (method package (set-stream-state self state)
    (when (neq? state stream-state)
      (set! stream-state state)
      (invalidate-audio-state (current-client) self)))
  
  
  (method package virtual (setup-pipeline self)
    (let ((pipeline (gst-launch (tie "appsrc name=src")
                                (and (eq? codec 'opus) "opusdec name=dec")
                                (and (eq? codec 'vorbis) "vorbisdec name=dec")
                                (let ((volume (or volume 1)))
                                  (tie "volume name=volume volume={volume}"))
                                "audiopanorama method=1 name=panorama"
                                (cond-expand
                                  (windows (and (eq? codec 'vorbis) "audioconvert"))
                                  (else #f))
                                (cond-expand
                                  (windows (and (eq? codec 'vorbis) "audioresample"))
                                  (else #f))
                                (cond-expand
                                  (windows (and (eq? codec 'vorbis) (tie "audio/x-raw, format=S16LE, layout=interleaved, rate={audio-rate}, channels=1")))
                                  (else #f))
                                (cond-expand
                                  (windows "directsoundsink name=sink buffer-time=200000 latency-time=100000")
                                  (else "autoaudiosink name=sink")))))
      (gst_object_set_name pipeline "output")
      (let ((appsrc (gst_bin_get_by_name pipeline "src"))
            (volelem (gst_bin_get_by_name pipeline "volume"))
            (panelem (gst_bin_get_by_name pipeline "panorama")))
        (case codec
          ((opus)
           (gst_app_src_set_caps appsrc
                                 (gst_caps "audio/x-opus"
                                           "channel-mapping-family" (g_value_int 0))))
          ((vorbis)
           (gst_app_src_set_caps appsrc
                                 (gst_caps "audio/x-vorbis"))))
        (g_object_set appsrc
          "is-live"     (g_value_boolean #t)
          "stream-type" (g_value_int GST_APP_STREAM_TYPE_STREAM)
          "format"      (g_value_int GST_FORMAT_TIME))
        (gst_element_set_state pipeline GST_STATE_READY)
        (set! self.pipeline pipeline)
        (set! self.appsrc appsrc)
        (set! self.volelem volelem)
        (set! self.panelem panelem))))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (setup-pipeline self))
  
  
  (method override (start-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! pipeline #f)
    (set! appsrc #f)
    (set-stream-state self 'off))
  
  
  (method override (consume self buffer timestamp duration)
    (gst_app_src_write appsrc buffer (u8vector-length buffer) timestamp duration))
  
  
  (method public (muted? self)
    (g_object_get_boolean volelem "mute"))
  
  
  (method public (mute self)
    (g_object_set_boolean volelem "mute" #t))
  
  
  (method public (unmute self)
    (g_object_set_boolean volelem "mute" #f))
  
  
  (method public (get-volume self)
    (g_object_get_double volelem "volume"))
  
  
  (method public (set-volume self vol)
    (g_object_set_double volelem "volume" vol))
  
  
  (method public (set-panorama self pan)
    (g_object_set_double panelem "panorama" pan)))


;;;
;;;; Simulation-Audio-Sink
;;;


(class Simulation-Audio-Sink extends Audio-Sink
  
  
  (method override (setup-pipeline self)
    (let ((pipeline @w
                    (gst-launch "appsrc name=src"
                                "vorbisdec name=dec"
                                "audiorate"
                                "autoaudiosink name=sink")
                    (gst-launch "appsrc name=src"
                                "vorbisdec name=dec"
                                "audiorate"
                                "tee name=tee"
                                (list
                                  "tee."
                                  "queue"
                                  "autoaudiosink name=sink")
                                (list
                                  "tee."
                                  "queue"
                                  "wavenc"
                                  (format "filesink location={a}" (parse {File Settings "work" "test.wav"})))
                                @ogg
                                (list
                                  "tee."
                                  "queue"
                                  "vorbisenc"
                                  "oggmux"
                                  (format "filesink location={a}" (parse {File Settings "work" "test.ogg"}))))))
      (gst_object_set_name pipeline "output")
      (let ((appsrc (gst_bin_get_by_name pipeline "src")))
        (gst_app_src_set_caps appsrc
                              (gst_caps "audio/x-vorbis"))
        (g_object_set appsrc
          "is-live"     (g_value_boolean #t)
          "stream-type" (g_value_int GST_APP_STREAM_TYPE_STREAM)
          "format"      (g_value_int GST_FORMAT_TIME))
        (gst_element_set_state pipeline GST_STATE_READY)
        (set! self.pipeline pipeline)
        (set! self.appsrc appsrc))))))
