;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Audio
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.audio jazz


(import (jazz.io)
        (jazz.listener)
        (jazz.presence)
        (jazz.stream)
        (jazz.stream.syntax (phase syntax))
        (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.configure)
        (world.context)
        (world.event)
        (world.interface)
        (world.media)
        (world.settings)
        (world.stream)
        (world.support)
        (world.task)
        (world.time)
        (world.udp))


(definition protected audio-rate
  (world-setting 'world.audio-rate 48000))

(definition protected audio-codec
  (world-setting 'world.audio-codec 'vorbis))

(definition protected audio-provider
  (world-setting 'world.audio-provider (cond-expand
                                         (windows 'directsound)
                                         (else #f))))


(definition audio-show
  (world-setting 'world.audio-show #f))


;; denoiser only works for 48000 rate
(definition protected audio-denoise?
  (world-setting 'world.audio-denoise? (= audio-rate 48000)))

(definition protected (set-audio-denoise? flag)
  (set! audio-denoise? flag))


(definition protected start-muted?
  (world-setting 'world.start-muted? #f))


;;;
;;;; Codec
;;;


(class Vorbis-Codec extends Codec)
(class Opus-Codec extends Codec)


(register-codec (new Vorbis-Codec 'vorbis 'audio))
(register-codec (new Opus-Codec 'opus 'audio))


;;;
;;;; Profile
;;;


(definition public (audio-profile-extension)
  "streamaudio")


(definition public (streaming-audio-extensions)
  (list (audio-profile-extension)))


;;;
;;;; Stream
;;;


(definition protected (locate-stream-audio-channel stream)
  (table-search (lambda (no channel)
                  (and (= (get-media-kind channel) udp-audio)
                       channel))
                (get-channels stream)))


;;;
;;;; Audio
;;;


(class World-Audio extends Object
  
  
  (slot outputs         getter generate)
  (slot ordered-outputs getter generate)
  
  
  (method override (initialize self)
    (nextmethod self)
    (set! self.outputs (make-table test: equal?))
    (set! self.ordered-outputs '()))
  
  
  ;;;
  ;;;; Output
  ;;;
  
  
  (method package (find-output self id)
    (table-ref outputs id #f))
  
  
  (method package (player-output self id (caps: caps #f) (volume: volume #f))
    (or (table-ref outputs id #f)
        (let ((output (new-output self caps: caps volume: volume)))
          (setup output)
          (table-set! outputs id output)
          (set! ordered-outputs (append! ordered-outputs (list output)))
          (start output)
          output)))
  
  
  (method package (channel-output self channel (volume: volume #f))
    (let ((caps (get-caps channel)))
      (let ((output (player-output self (get-no channel) caps: caps volume: volume)))
        (set-channel output channel)
        (when start-muted?
          (mute output))
        output)))
  
  
  (method package (visualizer-output self (caps: caps #f))
    (let ((output (new Audio-Sink codec: audio-codec caps: caps provider: audio-provider)))
      (start output)
      output))
  
  
  (method (new-output self (caps: caps #f) (volume: volume #f))
    (new Audio-Sink
      codec: audio-codec
      caps: caps
      provider: audio-provider
      volume: volume))
  
  
  (method package (close-output self id output)
    (table-clear outputs id)
    (set! ordered-outputs (remove! output ordered-outputs))
    (release output)
    (close output))
  
  
  (method package (receive-server-audio self id buffer dts pts duration)
    (let ((output (find-output self id)))
      (when output
        (if (not buffer)
            (set-stream-state output 'off)
          (when (eq? (get-stream-state output) 'off)
            (set-stream-state output 'on))
          (consume-audio output buffer dts pts duration)
          (when udp-record-src/sink?
            (let ((origin (get-origin (get-channel output))))
              (record-event udp-id-sink-media
                            (fixnum->flonum id)
                            (fixnum->flonum origin)
                            (fixnum->flonum udp-audio)
                            -1.
                            -1.
                            -1.
                            (timestamp->flonum pts))))))))
  
  
  (method package (receive-visualizer-audio self output buffer dts pts duration)
    (if (not buffer)
        (set-stream-state output 'off)
      (when (eq? (get-stream-state output) 'off)
        (set-stream-state output 'on))
      (consume-audio output buffer dts pts duration)))
  
  
  (method package (receive-audio self id/output buffer dts pts duration)
    (if (is? id/output Audio-Sink)
        (receive-visualizer-audio self id/output buffer dts pts duration)
      (receive-server-audio self id/output buffer dts pts duration))))


;;;
;;;; Audio-Src
;;;


(class Audio-Src extends Stream-Src
  
  
  (slot pipeline initialize #f accessors generate)
  (slot appsrc   initialize #f accessors generate)
  (slot task     initialize #f accessors generate)
  (slot consumer initialize #f getter generate)
  
  
  (method package virtual (start-listeners self)
    (when consumer
      (start-listener consumer)))
  
  
  (method package virtual (stop-listeners self)
    (when consumer
      (stop-listener consumer)))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (set! consumer (car sinks)))
  
  
  (method (task-start self name)
    (let ((procedure
            (lambda (task)
              (audio-loop self task))))
      (let ((task (new Task name procedure priority: audio-priority)))
        (start-listeners self)
        (start-task task)
        (set! self.task task))))
  
  
  (method (task-stop self)
    (stop-listeners self)
    (stop-task task)
    (set! task #f))
  
  
  (method protected virtual (audio-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (process self task exit)
          (iter)))))
  
  
  (method override (process self task exit)
    (gst_app_sink_process task exit consumer)))


;;;
;;;; Mic-Audio-Src
;;;


;; denoiser only works in S16LE format, 48000 rate and 1 channel
(definition protected denoiser-caps
  "audio/x-raw, format=S16LE, layout=interleaved, rate=48000, channels=1")

;; prevents sharp spikes that sound really harsh when denoised
(definition protected denoiser-filter
  "audiodynamic threshold=0.5 ratio=0.5 characteristics=soft-knee")


(class Mic-Audio-Src extends Audio-Src
  
  
  (slot mic-pipeline initialize #f accessors generate)
  (slot mic-sink     initialize #f accessors generate)
  (slot denoiser     initialize #f getter generate)
  (slot cached-caps  initialize #f getter generate)
  
  
  ;; we need to go in playing before the caps are available
  (method protected (require-caps self)
    (or cached-caps
        (begin
          (setup self)
          (gst_element_set_state pipeline GST_STATE_PLAYING)
          (gst_element_set_state mic-pipeline GST_STATE_PLAYING)
          (let ((listener (get-listener consumer))
                (element (get-element consumer))
                (data (get-data consumer))
                (info (get-info consumer)))
            (gst_app_sink_read listener element data info)
            (gst_app_sink_read listener element data info)
            (gst_app_sink_read listener element data info))
          (prog1 (with-unref ((sink (gst_bin_get_by_name pipeline "sink")))
                   (with-unref ((pad (gst_element_get_static_pad sink "sink")))
                     (let ((caps (gst_pad_get_current_caps pad)))
                       (let ((caps-string (gst_caps_to_string caps)))
                         (gst_caps_unref caps)
                         (set! cached-caps caps-string)
                         caps-string))))
            (gst_element_set_state pipeline GST_STATE_READY)
            (gst_element_set_state mic-pipeline GST_STATE_READY)))))
  
  
  (method override (setup-element self)
    (nextmethod self)
    ;; mic
    (let ((pipeline (gst-pipeline ;; provide-clock=false to use the system clock
                      ;; this makes sure audio and video stay synced
                      ;; latency-time=30000 is the minimum to get good
                      ;; audio on windows and also improves the mac audio
                      (cond-expand
                        (windows "directsoundsrc latency-time=30000 provide-clock=false name=src")
                        (else "osxaudiosrc latency-time=30000 provide-clock=false name=src"))
                      "audioresample"
                      denoiser-caps
                      denoiser-filter
                      "appsink sync=false name=sink")))
      (gst_object_set_name pipeline "mic")
      (with-unref ((appsink (gst_bin_get_by_name pipeline "sink")))
        (gst_element_set_state pipeline GST_STATE_READY)
        (set! self.mic-pipeline pipeline)
        (set! self.mic-sink appsink)))
    ;; audio
    (let ((listener (open-stream-listener "mic"))
          (pipeline (gst-pipeline "appsrc name=src"
                                  (and (eq? audio-codec 'opus) "opusenc name=enc")
                                  (and (eq? audio-codec 'vorbis) "audioconvert")
                                  (and (eq? audio-codec 'vorbis) (tie "audio/x-raw, format=F32LE, layout=interleaved, rate={audio-rate}, channels=1"))
                                  (and (eq? audio-codec 'vorbis) "vorbisenc name=enc")
                                  "appsink sync=false name=sink")))
      (gst_object_set_name pipeline "audio")
      (with-unref ((appsrc (gst_bin_get_by_name pipeline "src"))
                   (appsink (gst_bin_get_by_name pipeline "sink")))
        (gst-app-src-set-caps appsrc "audio/x-raw"
          "format"   'string "S16LE"
          "layout"   'string "interleaved"
          "rate"     'int    audio-rate
          "channels" 'int    1)
        (g-object-set appsrc
                      "is-live"     'boolean #t
                      "stream-type" 'int     GST_APP_STREAM_TYPE_STREAM
                      "format"      'int     GST_FORMAT_TIME)
        (gst_app_sink_connect_signals appsink listener)
        (setup-consumer consumer listener appsink 4096)
        (gst_element_set_state pipeline GST_STATE_READY)
        (set! self.pipeline pipeline)
        (set! self.appsrc appsrc)))
    ;; denoiser
    (set! denoiser (create-denoiser mic-sink appsrc #f #f audio-denoise?)))
  
  
  (method override (start-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED)
    (gst_element_set_state mic-pipeline GST_STATE_PAUSED)
    (task-start self 'mic))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING)
    (gst_element_set_state mic-pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED)
    (gst_element_set_state mic-pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY)
    (gst_element_set_state mic-pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (consume consumer #f #f #f #f)
    (gst_element_release pipeline)
    (set! pipeline #f)
    (set! appsrc #f)
    (release-consumer consumer)
    (gst_element_release mic-pipeline)
    (set! mic-pipeline #f)
    (set! mic-sink #f)
    (free-denoiser denoiser)
    (set! denoiser #f)))


;;;
;;;; Mic-Audio-Consumer
;;;


(class Mic-Audio-Consumer extends Stream-Consumer
  
  
  (method override (consume self buffer dts pts duration)
    ;; ignore stream headers
    (unless (and duration (= duration GST_CLOCK_TIME_NONE))
      (nextmethod self buffer dts pts duration)
      (when buffer
        (let ((size (u8vector-length buffer)))
          (when audio-show
            (terminal 'audio size))
          (when udp-record-src/sink?
            (record-event udp-id-src-media
                          -1. ;; todo channel no
                          (fixnum->flonum client-no)
                          (fixnum->flonum udp-audio)
                          -1.
                          -1.
                          (fixnum->flonum size)
                          (timestamp->flonum pts))))))))


;;;
;;;; File-Preprocess-Audio-Src
;;;


(class File-Preprocess-Audio-Src extends Audio-Src
  
  
  (slot location initialize #f accessors generate)
  
  
  (method override (initialize self location)
    (nextmethod self)
    (set! self.location location))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((listener (open-stream-listener "preprocessaudio")))
      (let ((pipeline (gst-pipeline (tie "filesrc name=filesrc")
                                    "decodebin"
                                    (and (eq? audio-codec 'opus) "opusenc name=enc")
                                    (and (eq? audio-codec 'vorbis) "audioconvert")
                                    (and (eq? audio-codec 'vorbis) "audioresample")
                                    (and (eq? audio-codec 'vorbis) (tie "audio/x-raw, format=F32LE, layout=interleaved, rate={audio-rate}, channels=2"))
                                    (and (eq? audio-codec 'vorbis) "vorbisenc name=enc")
                                    "appsink name=appsink sync=false")))
        (gst_object_set_name pipeline "file")
        (with-unref ((filesrc (gst_bin_get_by_name pipeline "filesrc"))
                     (appsink (gst_bin_get_by_name pipeline "appsink")))
          (gst_app_sink_connect_signals appsink listener)
          (setup-consumer consumer listener appsink 4096)
          (g_object_set_string filesrc "location" (path-normalize location))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.pipeline pipeline)))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'file)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! pipeline #f)
    (release-consumer consumer))
  
  
  (method override (audio-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (site (preprocess)
            (process self task exit))
          (sleep .001)
          (iter))))))


;;;
;;;; File-Preprocess-Denoise-Audio-Src
;;;


(class File-Preprocess-Denoise-Audio-Src extends File-Preprocess-Audio-Src
  
  
  (slot file-pipeline initialize #f accessors generate)
  (slot file-sink     initialize #f accessors generate)
  (slot volume        initialize #f accessors generate)
  (slot denoiser      initialize #f accessors generate)
  
  
  (method override (setup-element self)
    (nextmethod self)
    ;; file
    (let ((pipeline (gst-pipeline (tie "filesrc name=filesrc")
                                  "decodebin"
                                  "audioconvert"
                                  "audioresample"
                                  denoiser-caps
                                  denoiser-filter
                                  "appsink sync=false name=sink")))
      (gst_object_set_name pipeline "file")
      (with-unref ((filesrc (gst_bin_get_by_name pipeline "filesrc"))
                   (appsink (gst_bin_get_by_name pipeline "sink")))
        (g_object_set_string filesrc "location" (path-normalize location))
        (gst_element_set_state pipeline GST_STATE_READY)
        (set! self.file-pipeline pipeline)
        (set! self.file-sink appsink)))
    ;; audio
    (let ((listener (open-stream-listener "file"))
          (pipeline (gst-pipeline "appsrc name=src"
                                  "volume name=volume"
                                  (and (eq? audio-codec 'opus) "opusenc name=enc")
                                  (and (eq? audio-codec 'vorbis) "audioconvert")
                                  (and (eq? audio-codec 'vorbis) "audioresample")
                                  (and (eq? audio-codec 'vorbis) (tie "audio/x-raw, format=F32LE, layout=interleaved, rate={audio-rate}, channels=1"))
                                  (and (eq? audio-codec 'vorbis) "vorbisenc name=enc")
                                  "appsink name=appsink sync=false")))
      (with-unref ((appsrc (gst_bin_get_by_name pipeline "src"))
                   (appsink (gst_bin_get_by_name pipeline "appsink"))
                   (volume (gst_bin_get_by_name pipeline "volume")))
        (gst-app-src-set-caps appsrc "audio/x-raw"
          "format"   'string "S16LE"
          "layout"   'string "interleaved"
          "rate"     'int    48000
          "channels" 'int    1)
        (g-object-set appsrc
                      "is-live"     'boolean #t
                      "stream-type" 'int     GST_APP_STREAM_TYPE_STREAM
                      "format"      'int     GST_FORMAT_TIME)
        (gst_app_sink_connect_signals appsink listener)
        (setup-consumer consumer listener appsink 4096)
        (gst_element_set_state pipeline GST_STATE_READY)
        (set! self.pipeline pipeline)
        (set! self.appsrc appsrc)
        (set! self.volume volume)))
    ;; denoiser
    (set! denoiser (create-denoiser file-sink appsrc volume #t #t)))
  
  
  (method override (start-element self)
    (nextmethod self)
    (gst_element_set_state file-pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state file-pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state file-pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (gst_element_set_state file-pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (set! appsrc #f)
    (gst_element_release file-pipeline)
    (set! file-pipeline #f)
    (set! file-sink #f)
    (free-denoiser denoiser)
    (set! denoiser #f)))


;;;
;;;; File-Stream-Audio-Src
;;;


(class File-Stream-Audio-Src extends Audio-Src implements Media-Stream
  
  
  (slot location  getter generate)
  (slot stream?   accessors explicit)
  (slot file      getter generate)
  (slot reader    getter generate)
  (slot time-base getter generate)
  (slot muted?    getter generate)
  (slot pause?    getter generate)
  (slot flush?    getter generate)
  
  
  (method override (initialize self location (stream?: stream? #t))
    (nextmethod self)
    (set! self.location location)
    (set! self.stream? stream?)
    (set! self.file #f)
    (set! self.reader #f)
    (set! self.time-base (new Time-Base))
    (set! self.muted? #f)
    (set! self.pause? #f)
    (set! self.flush? #f))
  
  
  (method override (start-element self)
    (nextmethod self)
    (set! file (new-file {Directory Documents} (add-extension location (audio-profile-extension))))
    (set! reader (new Stream-Reader file))
    (task-start self 'audio-stream))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (close reader)
    (set! file #f)
    (set! reader #f))
  
  
  (method override (get-stream? self)
    stream?)
  
  
  (method override (set-stream? self flag)
    (set! stream? flag))
  
  
  (method override (play-stream self)
    (task-wakeup (get-thread task)
      (lambda (exit)
        (set! pause? #f)
        (reset time-base))))
  
  
  (method override (pause-stream self)
    (task-wakeup (get-thread task)
      (lambda (exit)
        (set! pause? #t)
        (task-sleep task +inf.0 exit))))
  
  
  (method override (goto-stream self pos normalized-pts)
    (task-wakeup (get-thread task)
      (lambda (exit)
        (if (not pos)
            (if pause?
                (task-sleep task +inf.0 exit)
              (reset time-base)
              (set! flush? #t))
          (goto-position reader pos normalized-pts)
          (task-sleep task +inf.0 exit)))))
  
  
  (method override (backward-stream self frame normalized-pts)
    (when pause?
      (task-wakeup (get-thread task)
        (lambda (exit)
          (goto-frame reader frame normalized-pts)
          (task-sleep task +inf.0 exit)))))
  
  
  (method override (forward-stream self frame normalized-pts)
    (when pause?
      (task-wakeup (get-thread task)
        (lambda (exit)
          (goto-frame reader frame normalized-pts)
          (task-sleep task +inf.0 exit)))))
  
  
  (method protected (mute-stream self)
    (set! muted? #t))
  
  
  (method protected (unmute-stream self)
    (set! muted? #f))
  
  
  (method override (audio-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (if (stopping? task)
              (task-done task exit)
            ;; protect against stream? threaded change
            (let ((stream? stream?))
              (receive (buffer dts pts duration) (read-frame reader stream?)
                (if (not buffer)
                    (if stream-loop?
                        (begin
                          (close reader)
                          (set! reader (new Stream-Reader file))
                          (set! time-base (new Time-Base))
                          (iter))
                      (task-done task exit))
                  (let ((time (current-seconds))
                        (nanopts (timestamp->flonum pts)))
                    (update-start time-base time nanopts)
                    (let ((sendtime (remote->local time-base nanopts)))
                      (task-sleep task (- sendtime time) exit)
                      (when stream?
                        (if flush?
                            (set! flush? #f)
                          (site (stream)
                            (unless muted?
                              (consume consumer buffer dts pts duration))))))))))
            (iter)))))))


;;;
;;;; Audio-Sink
;;;


(definition protected coke-vs-pepsi?
  (world-setting 'world.coke-vs-pepsi? #f))


(definition protected audio-brand
  #f)

(definition protected (toggle-audio-brand)
  (set! audio-brand (if (or (not audio-brand)
                            (eq? audio-brand 'pepsi))
                        'coke
                      'pepsi)))


(class Audio-Sink extends Stream-Sink
  
  
  (slot channel             initialize #f accessors generate)
  (slot codec               initialize #f accessors generate)
  (slot caps                initialize #f accessors generate)
  (slot provider            initialize #f accessors generate)
  (slot volume              initialize #f accessors explicit)
  (slot pipeline            initialize #f accessors generate)
  (slot appsrc              initialize #f accessors generate)
  (slot volelem             initialize #f accessors generate)
  (slot panelem             initialize #f accessors generate)
  (slot stream-state        initialize 'off getter generate setter explicit)
  (slot stream-playing?     initialize #f getter generate)
  (slot moving-deviation    initialize 0. getter generate)
  (slot timestamp-offset    initialize 0  getter generate)
  (slot extra-offset        initialize 30000000 accessors generate)
  (slot buffer-count        initialize 0  getter generate)
  (slot monitor             getter generate)
  (slot brand               getter generate)
  
  
  (method override (initialize self (codec: codec #f) (caps: caps #f) (provider: provider #f) (volume: volume #f))
    (nextmethod self)
    (set! self.codec codec)
    (set! self.caps caps)
    (set! self.provider provider)
    (set! self.volume volume)
    (set! self.monitor (new Audio-Monitor))
    (if (not coke-vs-pepsi?)
        (set! self.brand #f)
      (toggle-audio-brand)
      (set! self.brand audio-brand)))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (let ((effective-name (if (not channel) "Me" (get-name (get-stream channel)))))
          (format output "{a}" effective-name)))))
  
  
  (method package (set-stream-state self state)
    (when (neq? state stream-state)
      (set! stream-state state)
      (invalidate-audio-state (current-client) self)))
  
  
  (method package virtual (setup-pipeline self)
    (let ((pipeline (gst-pipeline (format "appsrc{? caps=\"{a}\"~} name=src" caps)
                                  "queue"
                                  (and (eq? codec 'opus) "opusdec name=dec")
                                  (and (eq? codec 'vorbis) "vorbisdec name=dec")
                                  (let ((volume (or volume 1)))
                                    (tie "volume name=volume volume={volume}"))
                                  "audiopanorama method=1 name=panorama"
                                  ;; hardcoded caps for now that must match
                                  ;; the event caps pushed on the decoder pad
                                  "audioconvert"
                                  "audioresample"
                                  "audio/x-raw, format=S16LE, layout=interleaved, rate=48000, channels=2"
                                  (cond-expand
                                    (windows (if (eq? provider 'directsound)
                                                 "directsoundsink buffer-time=200000 discont-wait=0 name=sink"
                                               "wasapisink buffer-time=200000 discont-wait=0 name=sink"))
                                    (mac "osxaudiosink buffer-time=200000 discont-wait=0 name=sink")
                                    (else "autoaudiosink name=sink")))))
      (gst_object_set_name pipeline "output")
      (with-unref ((appsrc (gst_bin_get_by_name pipeline "src"))
                   (volelem (gst_bin_get_by_name pipeline "volume"))
                   (panelem (gst_bin_get_by_name pipeline "panorama")))
        (when (not caps)
          (case codec
            ((opus)
             (gst-app-src-set-caps appsrc "audio/x-opus"
               "channel-mapping-family" 'int 0))
            ((vorbis)
             (gst-app-src-set-caps appsrc "audio/x-vorbis"))))
        (g-object-set appsrc
          "is-live"     'boolean #t
          "stream-type" 'int     GST_APP_STREAM_TYPE_STREAM
          "format"      'int     GST_FORMAT_TIME)
        (gst_element_set_state pipeline GST_STATE_READY)
        (set! self.pipeline pipeline)
        (set! self.appsrc appsrc)
        (set! self.volelem volelem)
        (set! self.panelem panelem))))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (setup-pipeline self))
  
  
  (method override (start-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED)
    ;; it seems that appsrc will not generate events
    ;; and so we need to generate them ourselves as it
    ;; is critical that the audio sink receives the caps
    ;; event before going to play else when the pipeline
    ;; asks the audio sink for a provided clock the sink
    ;; will return null because its ring buffer won't have
    ;; been created in response to the caps event yet
    (with-unref ((dec (gst_bin_get_by_name pipeline "dec")))
      (with-unref ((pad (gst_element_get_static_pad dec "src")))
        (let ((caps (gst_caps_from_string caps)))
          (gst_pad_push_event pad (gst_event_new_stream_start "stream"))
          (gst_pad_push_event pad (gst_event_new_caps caps))))))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! pipeline #f)
    (set! appsrc #f)
    (set-stream-state self 'off))
  
  
  (method protected virtual (consume-audio self buffer dts pts duration)
    (when (and (not stream-playing?)
               (> buffer-count 0))
      (play-element self)
      (set! stream-playing? #t))
    (let ((perfect-offset (- (gst_element_get_running_time appsrc) pts)))
      (let ((deviation (timestamp->flonum (abs (- perfect-offset timestamp-offset))))
            (tolerance .05))
        (set! moving-deviation (/ (+ (* moving-deviation 31.) deviation) 32.))
        (when (> moving-deviation tolerance)
          (set! timestamp-offset perfect-offset)
          (set! moving-deviation 0.)
          (when show-sync?
            (format :terminal "audio timestamp-offset {r precision: 3} extra-offset {r precision: 3}{%}" (timestamp->flonum timestamp-offset) (timestamp->flonum extra-offset))))))
    (gst_app_src_write appsrc buffer (u8vector-length buffer) dts pts duration (+ timestamp-offset extra-offset))
    (increase! buffer-count))
  
  
  (method public (muted? self)
    (g_object_get_boolean volelem "mute"))
  
  
  (method public (mute self)
    (g_object_set_boolean volelem "mute" #t))
  
  
  (method public (unmute self)
    (g_object_set_boolean volelem "mute" #f))
  
  
  (method public (get-volume self)
    (g_object_get_double volelem "volume"))
  
  
  (method public (set-volume self vol)
    (g_object_set_double volelem "volume" vol))
  
  
  (method public (set-panorama self pan)
    (g_object_set_double panelem "panorama" pan)))


;;;
;;;; Monitor
;;;


(class Audio-Monitor extends Object
  
  
  (slot systemclock-name      initialize #f accessors generate)
  (slot audioclock-name       initialize #f accessors generate)
  (slot first-originclock     initialize #f getter generate)
  (slot first-realclock       initialize #f getter generate)
  (slot first-monotonicclock  initialize #f getter generate)
  (slot first-systemclock     initialize #f getter generate)
  (slot first-audioclock      initialize #f getter generate)
  (slot originclock-elapse    initialize 0. getter generate)
  (slot realclock-elapse      initialize 0. getter generate)
  (slot monotonicclock-elapse initialize 0. getter generate)
  (slot systemclock-elapse    initialize 0. getter generate)
  (slot audioclock-elapse     initialize 0. getter generate)
  (slot originclock-rate      initialize 1. getter generate)
  (slot realclock-rate        initialize 1. getter generate)
  (slot monotonicclock-rate   initialize 1. getter generate)
  (slot systemclock-rate      initialize 1. getter generate)
  (slot audioclock-rate       initialize 1. getter generate)
  
  
  (method (update self origintime realclock monotonicclock systemtime audiotime)
    (let ((originclock (timestamp->flonum origintime))
          (systemclock (timestamp->flonum systemtime))
          (audioclock (timestamp->flonum audiotime)))
      (when (not first-originclock)
        (set! first-originclock originclock)
        (set! first-realclock realclock)
        (set! first-monotonicclock monotonicclock)
        (set! first-systemclock systemclock)
        (set! first-audioclock audioclock))
      (set! originclock-elapse (- originclock first-originclock))
      (set! realclock-elapse (- realclock first-realclock))
      (set! monotonicclock-elapse (- monotonicclock first-monotonicclock))
      (set! systemclock-elapse (- systemclock first-systemclock))
      (set! audioclock-elapse (- audioclock first-audioclock))
      (record-event udp-id-debug-audio
                    -1.
                    -1.
                    -1.
                    originclock-elapse
                    realclock-elapse
                    monotonicclock-elapse
                    systemclock-elapse
                    audioclock-elapse)
      (when (> originclock-elapse 0.)
        (set! originclock-rate (/ originclock-elapse originclock-elapse))
        (set! realclock-rate (/ realclock-elapse originclock-elapse))
        (set! monotonicclock-rate (/ monotonicclock-elapse originclock-elapse))
        (set! systemclock-rate (/ systemclock-elapse originclock-elapse))
        (set! audioclock-rate (/ audioclock-elapse originclock-elapse)))))))
