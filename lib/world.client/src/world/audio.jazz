;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Audio
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.audio jazz


(import (jazz.io)
        (jazz.listener)
        (jazz.presence)
        (jazz.stream)
        (jazz.stream.syntax (phase syntax))
        (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.configure)
        (world.context)
        (world.event)
        (world.interface)
        (world.media)
        (world.settings)
        (world.stream)
        (world.support)
        (world.task)
        (world.time)
        (world.udp))


(definition protected audio-rate
  (world-setting 'world.audio-rate 48000))

(definition protected audio-codec
  (world-setting 'world.audio-codec 'vorbis))


(definition audio-show
  (world-setting 'world.audio-show #f))


;; denoiser only works for 48000 rate
(definition protected audio-denoise?
  (world-setting 'world.audio-denoise? (= audio-rate 48000)))

(definition protected (get-audio-denoise?)
  (get-denoising?))

(definition protected (set-audio-denoise? flag)
  (set-denoising? flag))

(set-audio-denoise? audio-denoise?)


(definition protected audio-properties
  (world-setting 'world.audio-properties #f))

(definition protected (set-audio-properties properties)
  (set! audio-properties properties))


;;;
;;;; Codec
;;;


(class Vorbis-Codec extends Codec
  
  
  (method override (buffer-header? self buffer)
    (let ((size (u8vector-length buffer)))
      (and (>= size 7)
           (equal? (subu8vector buffer 1 7)
                   #u8(118 111 114 98 105 115))))))


(class Opus-Codec extends Codec
  
  
  (method override (buffer-header? self buffer)
    #f))


(register-codec (new Vorbis-Codec 'vorbis 'audio))
(register-codec (new Opus-Codec 'opus 'audio))


;;;
;;;; Header
;;;


(definition protected (audio-buffer-header? buffer)
  (if (eq? audio-codec 'vorbis)
      (let ((size (u8vector-length buffer)))
        (and (>= size 7)
             (equal? (subu8vector buffer 1 7)
                     #u8(118 111 114 98 105 115))))
    #f))


;;;
;;;; Profile
;;;


(definition public (audio-profile-extension)
  "streamaudio")


(definition public (streaming-audio-extensions)
  (list (audio-profile-extension)))


;;;
;;;; Stream
;;;


(definition protected (locate-stream-audio-channel stream)
  (table-search (lambda (no channel)
                  (and (= (get-media-kind channel) udp-audio)
                       channel))
                (get-channels stream)))


;;;
;;;; Audio
;;;


(class World-Audio extends Object
  
  
  (slot outputs getter generate)
  
  
  (method override (initialize self)
    (nextmethod self)
    (set! self.outputs (make-table test: equal?)))
  
  
  ;;;
  ;;;; Output
  ;;;
  
  
  (method package (find-output self id)
    (table-ref outputs id #f))
  
  
  (method package (player-output self id (volume: volume #f))
    (or (table-ref outputs id #f)
        (let ((output (new-output self volume: volume)))
          (setup output)
          (table-set! outputs id output)
          (play output)
          output)))
  
  
  (method package (channel-output self channel (volume: volume #f))
    (let ((output (player-output self (get-no channel) volume: volume)))
      (set-channel output channel)
      output))
  
  
  (method package (visualizer-output self)
    (let ((output (new Audio-Sink codec: audio-codec)))
      (play output)
      output))
  
  
  (method (new-output self (volume: volume #f))
    (new Audio-Sink
      codec: audio-codec
      volume: volume))
  
  
  (method package (close-output self id output)
    (table-clear outputs id)
    (release output)
    (close output))
  
  
  (method package (receive-server-audio self id buffer timestamp duration)
    (let ((output (find-output self id)))
      (when output
        (if (not buffer)
            (set-stream-state output 'off)
          (when (eq? (get-stream-state output) 'off)
            (set-stream-state output 'on))
          (consume output buffer timestamp duration)
          (when udp-record-src/sink?
            (let ((origin (get-origin (get-channel output))))
              (record-event udp-id-sink-media
                            (fixnum->flonum id)
                            (fixnum->flonum origin)
                            (fixnum->flonum udp-audio)
                            -1.
                            -1.
                            -1.
                            (timestamp->flonum timestamp))))))))
  
  
  (method package (receive-visualizer-audio self output buffer timestamp duration)
    (if (not buffer)
        (set-stream-state output 'off)
      (when (eq? (get-stream-state output) 'off)
        (set-stream-state output 'on))
      (consume output buffer timestamp duration)))
  
  
  (method package (receive-audio self id/output buffer timestamp duration)
    (if (is? id/output Audio-Sink)
        (receive-visualizer-audio self id/output buffer timestamp duration)
      (receive-server-audio self id/output buffer timestamp duration))))


;;;
;;;; Audio-Src
;;;


(class Audio-Src extends Stream-Src
  
  
  (slot pipeline initialize #f accessors generate)
  (slot appsrc   initialize #f accessors generate)
  (slot task     initialize #f accessors generate)
  (slot consumer initialize #f getter generate)
  
  
  (method package virtual (start-listeners self)
    (when consumer
      (start-listener consumer)))
  
  
  (method package virtual (stop-listeners self)
    (when consumer
      (stop-listener consumer)))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (set! consumer (car sinks)))
  
  
  (method (task-start self name)
    (let ((procedure
            (lambda (task)
              (audio-loop self task))))
      (let ((task (new Task name procedure priority: audio-priority)))
        (start-listeners self)
        (start-task task)
        (set! self.task task))))
  
  
  (method (task-stop self)
    (stop-listeners self)
    (stop-task task)
    (set! task #f))
  
  
  (method protected virtual (audio-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (process self task exit)
          (iter)))))
  
  
  (method override (process self task exit)
    (gst_app_sink_process task exit consumer)))


;;;
;;;; Mic-Audio-Src
;;;


(definition protected audio-filter
  "audiodynamic threshold=0.5 ratio=0.5 characteristics=soft-knee")

(definition protected (set-audio-filter filter)
  (set! audio-filter filter))


(class Mic-Audio-Src extends Audio-Src
  
  
  (slot mic-pipeline initialize #f  accessors generate)
  (slot mic-sink     initialize #f  accessors generate)
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((properties (or audio-properties "")))
      ;; mic
      (let ((pipeline (gst-pipeline ;; provide-clock=false to use the system clock
                                    ;; this makes sure audio and video stay synced
                                    (cond-expand
                                      (windows "directsoundsrc provide-clock=false name=src")
                                      (else (tie "osxaudiosrc provide-clock=false name=src")))
                                    ;; no idea why these next two lines are necessary
                                    "audioresample"
                                    (tie "audio/x-raw, format=S16LE, layout=interleaved, rate={audio-rate}, channels=1")
                                    audio-filter
                                    "appsink name=sink")))
        (gst_object_set_name pipeline "mic")
        (with-unref ((appsink (gst_bin_get_by_name pipeline "sink")))
          (let ((data (make-u8vector 4096))
                (info (make-u64vector 2)))
            (gst_element_set_state pipeline GST_STATE_READY)
            (set! self.mic-pipeline pipeline)
            (set! self.mic-sink appsink))))
      ;; audio
      (let ((listener (open-stream-listener "mic"))
            (pipeline (gst-pipeline "appsrc name=src"
                                    (and (eq? audio-codec 'opus) (tie "opusenc {properties} name=enc"))
                                    (and (eq? audio-codec 'vorbis) "audioconvert")
                                    (and (eq? audio-codec 'vorbis) (tie "audio/x-raw, format=F32LE, layout=interleaved, rate={audio-rate}, channels=1"))
                                    (and (eq? audio-codec 'vorbis) (tie "vorbisenc {properties} name=enc"))
                                    "appsink name=sink")))
        (gst_object_set_name pipeline "audio")
        (with-unref ((appsrc (gst_bin_get_by_name pipeline "src"))
                     (appsink (gst_bin_get_by_name pipeline "sink")))
          (gst-app-src-set-caps appsrc "audio/x-raw"
            "format"   'string "S16LE"
            "layout"   'string "interleaved"
            "rate"     'int    audio-rate
            "channels" 'int    1)
          (g-object-set appsrc
            "is-live"     'boolean #t
            "stream-type" 'int     GST_APP_STREAM_TYPE_STREAM
            "format"      'int     GST_FORMAT_TIME)
          (gst_app_sink_connect_signals appsink listener)
          (setup-consumer consumer listener appsink 4096)
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.pipeline pipeline)
          (set! self.appsrc appsrc)))
      ;; denoiser
      (create-denoiser-thread mic-sink appsrc)))
  
  
  (method override (start-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED)
    (gst_element_set_state mic-pipeline GST_STATE_PAUSED)
    (task-start self 'mic))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING)
    (gst_element_set_state mic-pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED)
    (gst_element_set_state mic-pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY)
    (gst_element_set_state mic-pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (consume consumer #f #f #f)
    (gst_element_release pipeline)
    (set! pipeline #f)
    (set! appsrc #f)
    (release-consumer consumer)
    (gst_element_release mic-pipeline)
    (set! mic-pipeline #f)
    (set! mic-sink #f))
  
  
  (method override (resettable? self)
    #t)
  
  
  (method override (reset-media self channel)
    (when (eq? audio-codec 'vorbis)
      (resend-header consumer (get-no channel)))))


;;;
;;;; Audio-Consumer
;;;


(class Audio-Consumer extends Stream-Consumer
  
  
  (slot headers initialize '() accessors generate)
  (slot header  initialize #f  accessors generate)
  
  
  (method override (release-element self)
    (nextmethod self)
    (set! headers '())
    (set! header #f))
  
  
  (method override (consume self buffer timestamp duration)
    (case audio-codec
      ;; opus has no headers
      ((opus)
       (nextmethod self buffer timestamp duration))
      ((vorbis)
       (if (and buffer (audio-buffer-header? buffer))
           (begin
             (set! headers (append! headers (list (list buffer timestamp duration))))
             (when (= (length headers) 3)
               (set! header (object->u8vector headers))
               (nextmethod self (list header) #f #f)))
         (nextmethod self buffer timestamp duration)))))
   
   
  (method protected (resend-header self channel-no)
    (when header
      (if (client?)
          (let ((tier (current-client)))
            (send-client-media tier channel-no header #t -1 GST_CLOCK_TIME_NONE))
        (let ((tier (current-server)))
          (send-server-media tier channel-no header #t -1 GST_CLOCK_TIME_NONE))))))


;;;
;;;; Mic-Audio-Consumer
;;;


(class Mic-Audio-Consumer extends Audio-Consumer
  
  
  (method override (consume self buffer timestamp duration)
    (nextmethod self buffer timestamp duration)
    (when buffer
      (let ((header? (audio-buffer-header? buffer))
            (size (u8vector-length buffer)))
        (when audio-show
          (if (eq? audio-codec 'vorbis)
              (let ((type (if header?
                              '***header***
                            'data)))
                (terminal 'audio size type))
            (terminal 'audio size)))
        (when udp-record-src/sink?
          (record-event udp-id-src-media
                        -1. ;; todo channel no
                        (fixnum->flonum client-no)
                        (fixnum->flonum udp-audio)
                        -1.
                        (if header? 1. -1.)
                        (fixnum->flonum size)
                        (timestamp->flonum timestamp)))))))


;;;
;;;; File-Preprocess-Audio-Src
;;;


(class File-Preprocess-Audio-Src extends Audio-Src
  
  
  (slot location initialize #f accessors generate)
  
  
  (method override (initialize self location)
    (nextmethod self)
    (set! self.location location))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((properties (or audio-properties ""))
          (listener (open-stream-listener "preprocessaudio")))
      (let ((pipeline (gst-pipeline (tie "filesrc name=filesrc")
                                    "decodebin"
                                    (and (eq? audio-codec 'opus) (tie "opusenc {properties} name=enc"))
                                    (and (eq? audio-codec 'vorbis) "audioconvert")
                                    (and (eq? audio-codec 'vorbis) "audioresample")
                                    (and (eq? audio-codec 'vorbis) (tie "audio/x-raw, format=F32LE, layout=interleaved, rate={audio-rate}, channels=1"))
                                    (and (eq? audio-codec 'vorbis) (tie "vorbisenc {properties} name=enc"))
                                    "appsink name=appsink sync=false")))
        (gst_object_set_name pipeline "file")
        (with-unref ((filesrc (gst_bin_get_by_name pipeline "filesrc"))
                     (appsink (gst_bin_get_by_name pipeline "appsink")))
          (gst_app_sink_connect_signals appsink listener)
          (g_object_set_string filesrc "location" (path-normalize location))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.pipeline pipeline)
          (setup-consumer consumer listener appsink 4096)))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'file)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (audio-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (site (preprocess)
            (process self task exit))
          (sleep .001)
          (iter))))))


;;;
;;;; File-Stream-Audio-Src
;;;


(class File-Stream-Audio-Src extends Audio-Src implements Media-Stream
  
  
  (slot location       getter generate)
  (slot stream?        accessors explicit)
  (slot file           getter generate)
  (slot reader         getter generate)
  (slot time-base      getter generate)
  (slot last-timestamp getter generate)
  (slot mute?          getter generate)
  
  
  (method override (initialize self location (stream?: stream? #t))
    (nextmethod self)
    (set! self.location location)
    (set! self.stream? stream?)
    (set! self.file #f)
    (set! self.reader #f)
    (set! self.time-base (new Time-Base))
    (set! self.last-timestamp #f)
    (set! self.mute? #f))
  
  
  (method override (start-element self)
    (nextmethod self)
    (set! file (new-file {Directory Documents} (add-extension location (audio-profile-extension))))
    (set! reader (new Stream-Reader file))
    (task-start self 'audio-stream))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (close reader)
    (set! file #f)
    (set! reader #f))
  
  
  (method override (get-stream? self)
    stream?)
  
  
  (method override (set-stream? self flag)
    (set! stream? flag))
  
  
  (method override (play-stream self)
    (task-wakeup (get-thread task)
      (lambda (exit)
        (reset time-base))))
  
  
  (method override (pause-stream self)
    (task-wakeup (get-thread task)
      (lambda (exit)
        (task-sleep task +inf.0 exit))))
  
  
  (method override (seek-stream self pos)
    (task-wakeup (get-thread task)
      (lambda (exit)
        (seek reader pos)
        (reset time-base))))
  
  
  (method protected (mute-stream self)
    (set! mute? #t))
  
  
  (method protected (unmute-stream self)
    (set! mute? #f))
  
  
  (method override (audio-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (if (stopping? task)
              (task-done task exit)
            ;; protect against stream? threaded change
            (let ((stream? stream?))
              (receive (buffer timestamp duration) (read-frame reader stream?)
                (if (not buffer)
                    (if stream-loop?
                        (begin
                          (close reader)
                          (set! reader (new Stream-Reader file last-timestamp))
                          (set! time-base (new Time-Base))
                          (iter))
                      (task-done task exit))
                  (set! last-timestamp timestamp)
                  (let ((time (current-seconds))
                        (nanostamp (timestamp->flonum timestamp)))
                    (update-start time-base time nanostamp)
                    (let ((sendtime (remote->local time-base nanostamp)))
                      (task-sleep task (- sendtime time) exit)
                      (when stream?
                        (site (stream)
                          (unless mute?
                            (consume consumer buffer timestamp duration)))))))))
            (iter))))))
  
  
  (method override (resettable? self)
    #t)
  
  
  (method override (reset-media self channel)
    (when (eq? audio-codec 'vorbis)
      (resend-header consumer (get-no channel)))))


;;;
;;;; Audio-Sink
;;;


(class Audio-Sink extends Stream-Sink
  
  
  (slot channel      initialize #f accessors generate)
  (slot codec        initialize #f accessors generate)
  (slot volume       initialize #f accessors explicit)
  (slot pipeline     initialize #f accessors generate)
  (slot appsrc       initialize #f accessors generate)
  (slot volelem      initialize #f accessors generate)
  (slot panelem      initialize #f accessors generate)
  (slot stream-state initialize 'off getter generate setter explicit)
  
  
  (method override (initialize self (codec: codec #f) (volume: volume #f))
    (nextmethod self)
    (set! self.codec codec)
    (set! self.volume volume))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (let ((effective-name (if (not channel) "Me" (get-name (get-stream channel)))))
          (format output "{a}" effective-name)))))
  
  
  (method package (set-stream-state self state)
    (when (neq? state stream-state)
      (set! stream-state state)
      (invalidate-audio-state (current-client) self)))
  
  
  (method package virtual (setup-pipeline self)
    (let ((pipeline (gst-pipeline (tie "appsrc name=src")
                                  (and (eq? codec 'opus) "opusdec name=dec")
                                  (and (eq? codec 'vorbis) "vorbisdec name=dec")
                                  (let ((volume (or volume 1)))
                                    (tie "volume name=volume volume={volume}"))
                                  "audiopanorama method=1 name=panorama"
                                  (cond-expand
                                    (windows (and (eq? codec 'vorbis) "audioconvert"))
                                    (else #f))
                                  (cond-expand
                                    (windows (and (eq? codec 'vorbis) "audioresample"))
                                    (else #f))
                                  (cond-expand
                                    (windows (and (eq? codec 'vorbis) (tie "audio/x-raw, format=S16LE, layout=interleaved, rate={audio-rate}, channels=1")))
                                    (else #f))
                                  (cond-expand
                                    (windows "directsoundsink name=sink buffer-time=200000 latency-time=100000")
                                    (mac "osxaudiosink buffer-time=200000 name=sink")
                                    (else "autoaudiosink name=sink")))))
      (gst_object_set_name pipeline "output")
      (with-unref ((appsrc (gst_bin_get_by_name pipeline "src"))
                   (volelem (gst_bin_get_by_name pipeline "volume"))
                   (panelem (gst_bin_get_by_name pipeline "panorama")))
        (case codec
          ((opus)
           (gst-app-src-set-caps appsrc "audio/x-opus"
             "channel-mapping-family" 'int 0))
          ((vorbis)
           (gst-app-src-set-caps appsrc "audio/x-vorbis")))
        (g-object-set appsrc
          "is-live"     'boolean #t
          "stream-type" 'int     GST_APP_STREAM_TYPE_STREAM
          "format"      'int     GST_FORMAT_TIME)
        (gst_element_set_state pipeline GST_STATE_READY)
        (set! self.pipeline pipeline)
        (set! self.appsrc appsrc)
        (set! self.volelem volelem)
        (set! self.panelem panelem))))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (setup-pipeline self))
  
  
  (method override (start-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! pipeline #f)
    (set! appsrc #f)
    (set-stream-state self 'off))
  
  
  (method override (consume self buffer timestamp duration)
    (gst_app_src_write appsrc buffer (u8vector-length buffer) timestamp duration))
  
  
  (method public (muted? self)
    (g_object_get_boolean volelem "mute"))
  
  
  (method public (mute self)
    (g_object_set_boolean volelem "mute" #t))
  
  
  (method public (unmute self)
    (g_object_set_boolean volelem "mute" #f))
  
  
  (method public (get-volume self)
    (g_object_get_double volelem "volume"))
  
  
  (method public (set-volume self vol)
    (g_object_set_double volelem "volume" vol))
  
  
  (method public (set-panorama self pan)
    (g_object_set_double panelem "panorama" pan))))
