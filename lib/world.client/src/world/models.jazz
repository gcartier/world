;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Models
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is WorldScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2014
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See http://github.com/gcartier/world for details.


(module world.models jazz


(import (jazz.geometry)
        (world)
        (world.autoload)
        (world.dye)
        (world.dyes)
        (world.entity)
        (world.face)
        (world.geometry)
        (world.material)
        (world.mesh)
        (world.model)
        (world.object)
        (world.quad)
        (world.renderers)
        (world.syntax (phase syntax))
        (world.texture)
        (world.triangle))


(definition public (make-model faces (class: class #f) (rotation: rotation #f) (bounds: bounds #f))
  (let ((world (current-world)))
    (let ((model (new (or class Model) faces: faces)))
      (when rotation
        (set-rotation~ model rotation))
      (set-bounds~ model (or bounds (determine-bounds~ model)))
      model)))


;;;
;;;; Circle
;;;


(define-model Circle
  (lambda ()
    (make-circle-model))
  showcase?: #f)


(definition public (make-circle-model)
  (let ((world (current-world))
        (left -1.)
        (bottom -1.)
        (back -1.)
        (right 1.)
        (top 1.)
        (front 1.))
    (let ((material (get-block-opaque~ world))
          (uv (image-coordinates "dirty")))
      (let ((tl (uv-left uv))
            (tt (uv-top uv))
            (tr (uv-right uv))
            (tb (uv-bottom uv))
            (texture-depth (uv-depth uv)))
        (let ((faces
                (list
                  (make-face material
                             (f32vector tl tb tl tt tr tt tr tb)
                             texture-depth
                             (make-quad #f
                                        (vertex left top back) (vertex left top front) (vertex right top front) (vertex right top back))))))
          (make-model faces bounds: (cuboid left 0. back right 0. front)))))))


;;;
;;;; Sphere
;;;


(define-model Sphere
  (lambda ()
    (make-sphere-model 48 24)))


(class Color-Sphere-Model extends Model
  
  
  (property color initialize #f accessors generate)
  
  
  (method override (model-renderer)
    (get-color-renderer))
  
  
  (method override (model-bind-uniforms entity program matrix moment)
    (bind-uniforms~ program matrix moment color)))


(definition public (make-color-sphere-model slices stacks color (class: class #f))
  (let ((model (make-sphere-model slices stacks class: (or class Color-Sphere-Model))))
    (set-color~ model color)
    model))


;;;
;;;; Gravity
;;;


(define-model Gravity
  (lambda ()
    (make-color-sphere-model 48 24 ochre-dye))
  showcase?: #f)


;;;
;;;; Camera
;;;


(definition public (make-camera-model class)
  (let ((world (current-world))
        (zone (current-zone))
        (left -.15)
        (bottom -.3)
        (back -.15)
        (center 0.)
        (right .15)
        (top .3)
        (front .15))
    (let ((material (new Material)));; a try so it doesn't have a renderer
      (let ((uv (image-rect~ (get-atlas~ material) (sample-program-image~ zone 'opaque))))
        (let ((tl (uv-left uv))
              (tt (uv-top uv))
              (tr (uv-right uv))
              (tb (uv-bottom uv))
              (texture-depth (uv-depth uv)))
          (let ((faces
                  (list
                    ;; bottom
                    (make-face material
                               (f32vector tl tt tl tb tr tb tr tt)
                               texture-depth
                               (make-quad #f
                                          (vertex left  bottom front)
                                          (vertex left  bottom back)
                                          (vertex right bottom back)
                                          (vertex right bottom front)))
                    ;; front
                    (make-face material
                               (f32vector tl tt tl tb tr tb tr tt)
                               texture-depth
                               (make-triangle #f
                                              (vertex center top    center)
                                              (vertex left   bottom front)
                                              (vertex right  bottom front)))
                    ;; right
                    (make-face material
                               (f32vector tl tt tl tb tr tb tr tt)
                               texture-depth
                               (make-triangle #f
                                              (vertex center top    center)
                                              (vertex right  bottom front)
                                              (vertex right  bottom back)))
                    ;; back
                    (make-face material
                               (f32vector tl tt tl tb tr tb tr tt)
                               texture-depth
                               (make-triangle #f
                                              (vertex center top    center)
                                              (vertex right  bottom back)
                                              (vertex left   bottom back)))
                    ;; left
                    (make-face material
                               (f32vector tl tt tl tb tr tb tr tt)
                               texture-depth
                               (make-triangle #f
                                              (vertex center top    center)
                                              (vertex left   bottom back)
                                              (vertex left   bottom front))))))
            (make-model faces class: class rotation: (vertex PI/2 0. 0.))))))))


(class Camera-Model extends Model
  
  
  (method override (model-renderer)
    (get-character-renderer))
  
  
  (method override (model-bind-uniforms entity program matrix moment)
    (let ((color red-dye))
      (let ((wire-color red-dye)
            (fill-color (dye .8 .2 .2 .6)))
        (bind-uniforms~ program matrix #f moment wire-color: wire-color fill-color: fill-color)))))


(define-model Camera
  (lambda ()
    (make-camera-model Camera-Model))
  showcase?: #f)


;;;
;;;; Light
;;;


(class Light-Model extends Color-Sphere-Model
  
  
  (method override (model-bind-uniforms entity program matrix moment)
    (let ((color (get-color~ entity)))
      (let ((color (if (dye=? color white-dye)
                       (render-color~ entity)
                     color)))
        (bind-uniforms~ program matrix moment color)))))


(define-model Light-Point
  (lambda ()
    (make-color-sphere-model 48 24 white-dye class: Light-Model))
  showcase?: #f)


(define-model Light-Directional
  (lambda ()
    (make-color-sphere-model 48 24 white-dye class: Light-Model))
  showcase?: #f)


(define-model Light-Ambient
  (lambda ()
    (make-color-sphere-model 48 24 white-dye class: Light-Model))
  showcase?: #f)


;;;
;;;; Sun
;;;


(class Sun-Model extends Color-Sphere-Model
  
  
  (method override (model-bind-uniforms entity program matrix moment)
    (let ((zone (current-zone)))
      (let ((color (if (dye=? (get-sun-color~ zone) white-dye)
                       color
                     (get-color~ entity))))
        (bind-uniforms~ program matrix moment color)))))


(define-model Sun
  (lambda ()
    (make-color-sphere-model 48 24 (dye .964 .859 .005 1.) class: Sun-Model))
  showcase?: #f)


;;;
;;;; Character
;;;


(class Body-Model extends Model
  
  
  (method override (model-renderer)
    (get-character-renderer))
  
  
  (method override (model-bind-uniforms entity program matrix moment)
    (let ((color (get-color~ entity)))
      (let ((wire-color color)
            (fill-color (copy-dye color)))
        (dye-alpha-set! fill-color 0.)
        (bind-uniforms~ program matrix #f moment wire-color: wire-color fill-color: fill-color)))))


(class Eye-Model extends Model
  
  
  (method override (model-renderer)
    (get-character2-renderer))
  
  
  (method override (model-bind-uniforms entity program matrix moment)
    (bind-uniforms~ program matrix moment (dye 0. 0. 1. (get-alpha~ entity)))))


(class Wheel-Model extends Model
  
  
  (method override (model-renderer)
    (get-character-renderer))
  
  
  (method override (model-bind-uniforms entity program matrix moment)
    (let ((color (dye .6 .6 .6 1.)))
      (let ((wire-color color)
            (fill-color (copy-dye (get-color~ entity))))
        (dye-alpha-set! fill-color 0.)
        (bind-uniforms~ program matrix #f moment wire-color: wire-color fill-color: fill-color)))))


(class Saucer-Model extends Model
  
  
  (method override (model-renderer)
    (get-character-renderer))
  
  
  (method override (model-bind-uniforms entity program matrix moment)
    (let ((color white-dye))
      (let ((wire-color color)
            (fill-color (copy-dye (get-color~ entity))))
        (dye-alpha-set! fill-color 0.)
        (bind-uniforms~ program matrix #f moment wire-color: wire-color fill-color: fill-color)))))


(class Rocket-Model extends Model
  
  
  (method override (model-renderer)
    (get-character-renderer))
  
  
  (method override (model-bind-uniforms entity program matrix moment)
    (let ((color white-dye))
      (let ((wire-color color)
            (fill-color (copy-dye (get-color~ entity))))
        (dye-alpha-set! fill-color 0.)
        (bind-uniforms~ program matrix #f moment wire-color: wire-color fill-color: fill-color)))))


(definition (make-character-model vehicle (scale: scale #f) (pumps: pumps #f))
  (let ((model (make-model '()))
        (body (make-sphere-model 26 52 class: Body-Model name: 'body))
        (eyes (list (make-sphere-model 48 24 class: Eye-Model name: 'left-eye)
                    (make-sphere-model 48 24 class: Eye-Model name: 'right-eye))))
    ;; model
    (if scale
        (set-scale~ model scale)
      (set-scaling~ model .4))
    (when pumps
      (set-pumps~ model pumps))
    
    ;; eyes
    (for-each (lambda (eye rank)
                (set-position~ eye (case rank
                                     ((0) (vertex -.45 .4 .6))
                                     ((1) (vertex .45 .4 .6))))
                (set-scaling~ eye .1)
                (set-parent~ eye model))
              eyes
              (naturals 0 (length eyes)))
    
    ;; body
    (set-rotation~ body (vertex 0. PI/2 0.))
    (set-parent~ body model)
    
    ;; wheels
    (when (eq? vehicle 'wheels)
      (let ((wheels (list (make-sphere-model 15 30 class: Wheel-Model name: 'wheel1)
                          (make-sphere-model 15 30 class: Wheel-Model name: 'wheel2)
                          (make-sphere-model 15 30 class: Wheel-Model name: 'wheel3)
                          (make-sphere-model 15 30 class: Wheel-Model name: 'wheel4))))
        (for-each (lambda (wheel rank)
                    (set-position~ wheel (let ((d .75))
                                           (case rank
                                             ((0) (vertex d (- d) d))
                                             ((1) (vertex (- d) (- d) d))
                                             ((2) (vertex  d (- d) (- d)))
                                             ((3) (vertex (- d) (- d) (- d))))))
                    (set-rotation~ wheel (vertex 0. PI/2 0.))
                    (set-scaling~ wheel .25)
                    (set-parent~ wheel model))
                  wheels
                  (naturals 0 (length wheels)))))
    
    ;; hummer
    (when (eq? vehicle 'hummer)
      (let ((wheels (list (make-sphere-model 15 30 class: Wheel-Model name: 'wheel1)
                          (make-sphere-model 15 30 class: Wheel-Model name: 'wheel2)
                          (make-sphere-model 15 30 class: Wheel-Model name: 'wheel3)
                          (make-sphere-model 15 30 class: Wheel-Model name: 'wheel4))))
        (for-each (lambda (wheel rank)
                    (set-position~ wheel (let ((d 2.5)
                                               (h 3.))
                                           (case rank
                                             ((0) (vertex d (- h) d))
                                             ((1) (vertex (- d) (- h) d))
                                             ((2) (vertex  d (- h) (- d)))
                                             ((3) (vertex (- d) (- h) (- d))))))
                    (set-rotation~ wheel (vertex 0. PI/2 0.))
                    (set-scaling~ wheel 2.)
                    (set-parent~ wheel model))
                  wheels
                  (naturals 0 (length wheels)))))
    
    ;; saucer
    (when (eq? vehicle 'saucer)
      (let ((saucer (make-sphere-model 15 30 class: Saucer-Model name: 'saucer)))
        (set-position~ saucer (vertex 0. -1.4 0.))
        (set-scale~ saucer (vertex 1.9 .4 1.9))
        (set-parent~ saucer model)))
    
    ;; rocket
    (when (eq? vehicle 'rocket)
      (let ((rocket (make-sphere-model 15 30 class: Rocket-Model name: 'rocket)))
        (set-position~ rocket (vertex 0. -1.4 0.))
        (set-scale~ rocket (vertex 1.2 .4 3.0))
        (set-parent~ rocket model)))
    
    (set-bounds~ model (determine-bounds~ model))
    model))


(define-model Character
  (lambda ()
    (make-character-model #f pumps: (vertex 0. .12 0.)))
  showcase?: #f)


(define-model CharacterOnWheels
  (lambda ()
    (make-character-model 'wheels pumps: (vertex 0. .12 0.)))
  showcase?: #f)


(define-model CharacterOnHummer
  (lambda ()
    (make-character-model 'hummer))
  showcase?: #f)


(define-model CharacterOnSaucer
  (lambda ()
    (make-character-model 'saucer))
  showcase?: #f)


(define-model CharacterOnRocket
  (lambda ()
    (make-character-model 'rocket))
  showcase?: #f)


(define-model CharacterLong
  (lambda ()
    (make-character-model #f scale: (vertex .2 .4 1.)))
  showcase?: #f)


(define-model CharacterWide
  (lambda ()
    (make-character-model #f scale: (vertex 1. .4 .2)))
  showcase?: #f)


(define-model CharacterTall
  (lambda ()
    (make-character-model #f scale: (vertex .3 1.2 .3)))
  showcase?: #f)


;;;
;;;; Enemy
;;;


(class Enemy-Body-Model extends Model
  
  
  (method override (model-renderer)
    (get-character2-renderer))
  
  
  (method override (model-bind-uniforms entity program matrix moment)
    (bind-uniforms~ program matrix moment (get-color~ entity))))


(class Enemy-Eye-Model extends Model
  
  
  (method override (model-renderer)
    (get-character2-renderer))
  
  
  (method override (model-bind-uniforms entity program matrix moment)
    (bind-uniforms~ program matrix moment (dye .392 .392 .392 1.))))


(definition public (make-enemy-model)
  (let ((model (make-model '() bounds: (cuboid -1. -1. -1. 1. 1. 1.)))
        (body (make-sphere-model 26 52 class: Enemy-Body-Model name: 'body))
        (left-eye (make-sphere-model 48 24 class: Enemy-Eye-Model name: 'left-eye))
        (right-eye (make-sphere-model 48 24 class: Enemy-Eye-Model name: 'right-eye)))
    ;; left-eye
    (set-position~ left-eye (vertex -.45 .4 .8))
    (set-scaling~ left-eye .1)
    (set-parent~ left-eye model)
    
    ;; right-eye
    (set-position~ right-eye (vertex .45 .4 .8))
    (set-scaling~ right-eye .1)
    (set-parent~ right-eye model)
    
    ;; body
    (set-rotation~ body (vertex 0. PI/2 0.))
    (set-parent~ body model)
    
    model))


(define-model Wolf
  (lambda ()
    (make-enemy-model)))


(define-model Spider
  (lambda ()
    (make-enemy-model)))


;;;
;;;; Turtle
;;;


@wait-minecraft-doesnt-have-turf
(define-model Turtle
  (lambda ()
    (let ((model (make-cube-model "turf")))
      (set-scaling~ model .4)
      model)))


;;;
;;;; Missile
;;;


(class Missile-Model extends Model
  
  
  (property color initialize #f accessors generate)
  
  
  (method override (model-renderer)
    (get-character-renderer))
  
  
  (method override (model-bind-uniforms entity program matrix moment)
    (let ((wire-color color)
          (fill-color (copy-dye (get-color~ entity))))
      (dye-alpha-set! fill-color 0.)
      (bind-uniforms~ program matrix #f moment wire-color: wire-color fill-color: fill-color))))


(definition (make-missile-model color)
  (let ((model (make-sphere-model 48 24 class: Missile-Model)))
    (set-scaling~ model .05)
    (set-color~ model color)
    model))


(define-model Bullet
  (lambda ()
    (make-missile-model red-dye))
  showcase?: #f)


(define-model Bomb
  (lambda ()
    (make-missile-model blue-dye))
  showcase?: #f)


;;;
;;;; Floor
;;;


(definition public (generate-floor-model image width depth)
  (let ((world (current-world)))
    (let ((material (get-block-opaque~ world))
          (uv (image-coordinates image)))
      (let ((tl (uv-left uv))
            (tt (uv-top uv))
            (tr (uv-right uv))
            (tb (uv-bottom uv))
            (texture-depth (uv-depth uv))
            (queue (new-queue)))
        (loop (for i from (- width) to width)
              (loop (for k from (- depth) to depth)
                    (let ((x (cast <fl> i))
                          (y 0.)
                          (z (cast <fl> k)))
                      (enqueue queue
                               (make-face material
                                          (f32vector tl tb tl tt tr tt tr tb)
                                          texture-depth
                                          (make-quad #f
                                                     (vertex x y (+ z 1.))
                                                     (vertex (+ x 1.) y (+ z 1.))
                                                     (vertex (+ x 1.) y z)
                                                     (vertex x y z)))))))
        (let ((faces (queue-list queue)))
          (make-model faces))))))


(definition public (generate-floor x y z width depth)
  (let ((zone (current-zone)))
    (add-element~ zone
      (let ((model (generate-floor-model "dirty" width depth))
            (entity (new Entity parent: zone position: (vertex x y z) physical?: #t)))
        (set-model~ entity model)
        (add-element~ zone entity)))))


;;;
;;;; Wall
;;;


(definition public (generate-wall-model image width height)
  (let ((world (current-world)))
    (let ((material (get-block-opaque~ world))
          (uv (image-coordinates image)))
      (let ((tl (uv-left uv))
            (tt (uv-top uv))
            (tr (uv-right uv))
            (tb (uv-bottom uv))
            (texture-depth (uv-depth uv))
            (queue (new-queue)))
        (loop (for i from (- width) to width)
              (loop (for j from 0 to (* height 2))
                    (let ((x (cast <fl> i))
                          (y (cast <fl> j))
                          (z 0.))
                      (enqueue queue
                               (make-face material
                                          (f32vector tl tb tl tt tr tt tr tb)
                                          texture-depth
                                          (make-quad #f
                                                     (vertex x (+ y 1.) z)
                                                     (vertex (+ x 1.) (+ y 1.) z)
                                                     (vertex (+ x 1.) y z)
                                                     (vertex x y z)))))))
        (let ((faces (queue-list queue)))
          (make-model faces))))))


(definition public (generate-wall x y z width height)
  (let ((zone (current-zone)))
    (add-element~ zone
      (let ((model (generate-wall-model "dirty" width height))
            (entity (new Entity parent: zone position: (vertex x y z) physical?: #t)))
        (set-model~ entity model)
        (add-element~ zone entity)))))


;;;
;;;; Slope
;;;


(definition public (generate-slope-model image height x-count z-count)
  (let ((world (current-world)))
    (let ((material (get-block-opaque~ world))
          (uv (image-coordinates image)))
      (let ((tl (uv-left uv))
            (tt (uv-top uv))
            (tr (uv-right uv))
            (tb (uv-bottom uv))
            (texture-depth (uv-depth uv))
            (queue (new-queue))
            (width 1.)
            (depth 1.))
        (loop (for d from 0 below z-count)
              (loop (for i from 0 below x-count)
                    (let ((x (* (cast <fl> i) width))
                          (y (* (cast <fl> d) height))
                          (z (* (cast <fl> d) depth)))
                      (enqueue queue
                               (make-face material
                                          (f32vector tl tb tl tt tr tt tr tb)
                                          texture-depth
                                          (make-quad #f
                                                     (vertex x (+ y height) (+ z depth))
                                                     (vertex (+ x width) (+ y height) (+ z depth))
                                                     (vertex (+ x width) y z)
                                                     (vertex x y z)))))))
        (let ((faces (queue-list queue)))
          (make-model faces))))))


(definition public (generate-slope x y z height x-count z-count)
  (let ((zone (current-zone)))
    (add-element~ zone
      (let ((model (generate-slope-model "dirty" height x-count z-count))
            (entity (new Entity parent: zone position: (vertex x y z) physical?: #t)))
        (set-model~ entity model)
        (add-element~ zone entity)))))


;;;
;;;; Stairs
;;;


(definition public (generate-stairs-model image stairs width height depth x-count y-count z-count)
  (let ((world (current-world)))
    (let ((material (get-block-opaque~ world))
          (uv (image-coordinates image)))
      (let ((tl (uv-left uv))
            (tt (uv-top uv))
            (tr (uv-right uv))
            (tb (uv-bottom uv))
            (texture-depth (uv-depth uv))
            (queue (new-queue)))
        (loop (for d from 0 below stairs)
              (loop (for i from (- x-count) to x-count)
                    (let ((x (* (cast <fl> i) width))
                          (y (* (cast <fl> d) height))
                          (z (* (cast <fl> d) (* depth z-count))))
                      ;; front
                      (enqueue queue
                               (make-face material
                                          (f32vector tl tb tl tt tr tt tr tb)
                                          texture-depth
                                          (make-quad #f
                                                     (vertex x (+ y height) z)
                                                     (vertex (+ x width) (+ y height) z)
                                                     (vertex (+ x width) y z)
                                                     (vertex x y z))))
                      ;; flat
                      (loop (for n from 0 below z-count)
                            (let ((z (+ z (* (cast <fl> n) depth))))
                              (enqueue queue
                                       (make-face material
                                                  (f32vector tl tb tl tt tr tt tr tb)
                                                  texture-depth
                                                  (make-quad #f
                                                             (vertex x (+ y height) (+ z depth))
                                                             (vertex (+ x width) (+ y height) (+ z depth))
                                                             (vertex (+ x width) (+ y height) z)
                                                             (vertex x (+ y height) z)))))))))
        (let ((faces (queue-list queue)))
          (make-model faces))))))


(definition public (generate-stairs stairs x y z width height depth x-count y-count z-count)
  (let ((zone (current-zone)))
    (add-element~ zone
      (let ((model (generate-stairs-model "dirty" stairs width height depth x-count y-count z-count))
            (entity (new Entity parent: zone position: (vertex x y z) physical?: #t)))
        (set-model~ entity model)
        (add-element~ zone entity))))))
