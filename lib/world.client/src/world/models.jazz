;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Models
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.models jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (world)
        (world.autoload)
        (world.blocks)
        (world.dye)
        (world.dyes)
        (world.entity)
        (world.face)
        (world.generate)
        (world.geometry)
        (world.model)
        (world.object)
        (world.quad)
        (world.syntax (phase syntax))
        (world.texture)
        (world.triangle))


(definition public (make-model faces (class: class #f) (rotation: rotation #f) (bounds: bounds #f))
  (let ((world (current-world)))
    (let ((material (get-block-material~ world)))
      (let ((model (new (or class Model) faces: faces material: material)))
        (when rotation
          (set-rotation~ model rotation))
        (set-bounds~ model (or bounds (determine-bounds~ model)))
        model))))


;;;
;;;; Sphere
;;;


(define-model Sphere
  (lambda ()
    (make-sphere-model 48 24)))


(class Color-Sphere-Model extends Model
  
  
  (property color initialize #f accessors generate)
  
  
  (method override (prepare initargs)
    (nextmethod initargs)
    (set! program 'color))
  
  
  (method override (model-bind-uniforms entity program mesh matrix)
    (bind-uniforms~ program mesh matrix color)))


(definition public (make-color-sphere-model slices stacks color (class: class #f))
  (let ((model (make-sphere-model slices stacks class: (or class Color-Sphere-Model))))
    (set-color~ model color)
    model))


;;;
;;;; Gravity
;;;


(define-model Gravity
  (lambda ()
    (make-color-sphere-model 48 24 ochre-dye))
  showcase?: #f)


;;;
;;;; Light
;;;


(class Light-Model extends Color-Sphere-Model
  
  
  (method override (model-bind-uniforms entity program mesh matrix)
    (let ((color (get-color~ entity)))
      (let ((color (if (dye=? color white-dye)
                       (render-color~ entity)
                     color)))
        (bind-uniforms~ program mesh matrix color)))))


(define-model Light-Point
  (lambda ()
    (make-color-sphere-model 48 24 white-dye class: Light-Model))
  showcase?: #f)


(define-model Light-Directional
  (lambda ()
    (make-color-sphere-model 48 24 white-dye class: Light-Model))
  showcase?: #f)


(define-model Light-Ambient
  (lambda ()
    (make-color-sphere-model 48 24 white-dye class: Light-Model))
  showcase?: #f)


;;;
;;;; Sun
;;;


(class Sun-Model extends Color-Sphere-Model
  
  
  (method override (model-bind-uniforms entity program mesh matrix)
    (let ((zone (current-zone)))
      (let ((color (if (dye=? (get-sun-color~ zone) white-dye)
                       color
                     (get-color~ entity))))
        (bind-uniforms~ program mesh matrix color)))))


(define-model Sun
  (lambda ()
    (make-color-sphere-model 48 24 (dye .964 .859 .005 1.) class: Sun-Model))
  showcase?: #f)


;;;
;;;; Character
;;;


(class Body-Model extends Model
  
  
  (method override (model-mode)
    'character)
  
  
  (method override (model-polygon-mode)
    #f)
  
  
  (method override (model-bind-uniforms entity program mesh matrix)
    (let ((color (get-color~ entity)))
      (let ((wire-color color)
            (fill-color (copy-dye (get-color~ entity))))
        (dye-alpha-set! fill-color 0.)
        (bind-uniforms~ program mesh matrix #f wire-color: wire-color fill-color: fill-color)))))


(class Eye-Model extends Model
  
  
  (method override (model-mode)
    'character2)
  
  
  (method override (model-polygon-mode)
    GL_FILL)
  
  
  (method override (model-bind-uniforms entity program mesh matrix)
    (bind-uniforms~ program mesh matrix (dye 0. 0. 1. (get-alpha~ entity)))))


(class Wheel-Model extends Model
  
  
  (method override (model-mode)
    'character)
  
  
  (method override (model-polygon-mode)
    #f)
  
  
  (method override (model-bind-uniforms entity program mesh matrix)
    (let ((color (dye .5 .5 .5 1.)))
      (let ((wire-color color)
            (fill-color (copy-dye (get-color~ entity))))
        (dye-alpha-set! fill-color 0.)
        (bind-uniforms~ program mesh matrix #f wire-color: wire-color fill-color: fill-color)))))


(class Saucer-Model extends Model
  
  
  (method override (model-mode)
    'character)
  
  
  (method override (model-polygon-mode)
    #f)
  
  
  (method override (model-bind-uniforms entity program mesh matrix)
    (let ((color white-dye))
      (let ((wire-color color)
            (fill-color (copy-dye (get-color~ entity))))
        (dye-alpha-set! fill-color 0.)
        (bind-uniforms~ program mesh matrix #f wire-color: wire-color fill-color: fill-color)))))


(definition (make-character-model vehicle (scale: scale #f) (pumps: pumps #f))
  (let ((model (make-model '() bounds: (cuboid -1. -1. -1. 1. 1. 1.)))
        (body (make-sphere-model 26 52 class: Body-Model name: 'body))
        (eyes (list (make-sphere-model 48 24 class: Eye-Model name: 'left-eye)
                    (make-sphere-model 48 24 class: Eye-Model name: 'right-eye)))
        (wheels (list (make-sphere-model 15 30 class: Wheel-Model name: 'wheel1)
                      (make-sphere-model 15 30 class: Wheel-Model name: 'wheel2)
                      (make-sphere-model 15 30 class: Wheel-Model name: 'wheel3)
                      (make-sphere-model 15 30 class: Wheel-Model name: 'wheel4)))
        (saucer (make-sphere-model 15 30 class: Saucer-Model name: 'saucer)))
    ;; model
    (if scale
        (set-scale~ model scale)
      (set-scaling~ model .4))
    (when pumps
      (set-pumps~ model pumps))
    
    ;; eyes
    (for-each (lambda (eye rank)
                (set-position~ eye (case rank
                                     ((0) (vertex -.45 .4 .6))
                                     ((1) (vertex .45 .4 .6))))
                (set-scaling~ eye .1)
                (set-program~ eye 'color)
                (set-parent~ eye model))
              eyes
              (naturals 0 (length eyes)))
    
    ;; body
    (set-rotation~ body (vertex 0. PI/2 0.))
    (set-program~ body 'playerframe)
    (set-parent~ body model)
    
    ;; wheels
    (when (eq? vehicle 'wheels)
      (for-each (lambda (wheel rank)
                  (set-position~ wheel (let ((d .75))
                                         (case rank
                                           ((0) (vertex d (- d) d))
                                           ((1) (vertex (- d) (- d) d))
                                           ((2) (vertex  d (- d) (- d)))
                                           ((3) (vertex (- d) (- d) (- d))))))
                  (set-rotation~ wheel (vertex 0. PI/2 0.))
                  (set-scaling~ wheel .25)
                  (set-program~ wheel 'playerframe)
                  (set-parent~ wheel model))
                wheels
                (naturals 0 (length wheels))))
    
    ;; saucer
    (when (eq? vehicle 'saucer)
      (set-position~ saucer (vertex 0. -1.4 0.))
      (set-scale~ saucer (vertex 1.9 .4 1.9))
      (set-program~ saucer 'playerframe)
      (set-parent~ saucer model))
    
    model))


(define-model Character
  (lambda ()
    (make-character-model #f pumps: (vertex 0. .12 0.)))
  showcase?: #f)


(define-model CharacterOnWheels
  (lambda ()
    (make-character-model 'wheels pumps: (vertex 0. .12 0.)))
  showcase?: #f)


(define-model CharacterOnSaucer
  (lambda ()
    (make-character-model 'saucer))
  showcase?: #f)


(define-model CharacterLong
  (lambda ()
    (make-character-model #f scale: (vertex .2 .4 1.)))
  showcase?: #f)


(define-model CharacterWide
  (lambda ()
    (make-character-model #f scale: (vertex 1. .4 .2)))
  showcase?: #f)


(define-model CharacterTall
  (lambda ()
    (make-character-model #f scale: (vertex .3 1.2 .3)))
  showcase?: #f)


;;;
;;;; Enemy
;;;


(class Enemy-Body-Model extends Model
  
  
  (method override (model-mode)
    'character2)
  
  
  (method override (model-polygon-mode)
    GL_FILL)
  
  
  (method override (model-bind-uniforms entity program mesh matrix)
    (bind-uniforms~ program mesh matrix (get-color~ entity))))


(class Enemy-Eye-Model extends Model
  
  
  (method override (model-mode)
    'character2)
  
  
  (method override (model-polygon-mode)
    GL_FILL)
  
  
  (method override (model-bind-uniforms entity program mesh matrix)
    (bind-uniforms~ program mesh matrix (dye .392 .392 .392 1.))))


(definition public (make-enemy-model)
  (let ((model (make-model '() bounds: (cuboid -1. -1. -1. 1. 1. 1.)))
        (body (make-sphere-model 26 52 class: Enemy-Body-Model name: 'body))
        (left-eye (make-sphere-model 48 24 class: Enemy-Eye-Model name: 'left-eye))
        (right-eye (make-sphere-model 48 24 class: Enemy-Eye-Model name: 'right-eye)))
    ;; left-eye
    (set-position~ left-eye (vertex -.45 .4 .8))
    (set-scaling~ left-eye .1)
    (set-program~ left-eye 'color)
    (set-parent~ left-eye model)
    
    ;; right-eye
    (set-position~ right-eye (vertex .45 .4 .8))
    (set-scaling~ right-eye .1)
    (set-program~ right-eye 'color)
    (set-parent~ right-eye model)
    
    ;; body
    (set-rotation~ body (vertex 0. PI/2 0.))
    (set-program~ body 'color)
    (set-parent~ body model)
    
    model))


(define-model Wolf
  (lambda ()
    (make-enemy-model)))


(define-model Spider
  (lambda ()
    (make-enemy-model)))


;;;
;;;; Turtle
;;;


(define-model Turtle
  (lambda ()
    (let ((model (make-cube-model "turf")))
      (set-scaling~ model .4)
      model)))


;;;
;;;; Missile
;;;


(class Missile-Model extends Model
  
  
  (property color initialize #f accessors generate)
  
  
  (method override (model-mode)
    'character)
  
  
  (method override (model-polygon-mode)
    #f)
  
  
  (method override (model-bind-uniforms entity program mesh matrix)
    (let ((wire-color color)
          (fill-color (copy-dye (get-color~ entity))))
      (dye-alpha-set! fill-color 0.)
      (bind-uniforms~ program mesh matrix #f wire-color: wire-color fill-color: fill-color))))


(definition (make-missile-model color)
  (let ((model (make-sphere-model 48 24 class: Missile-Model)))
    (set-scaling~ model .05)
    (set-program~ model 'playerframe)
    (set-color~ model color)
    model))


(define-model Bullet
  (lambda ()
    (make-missile-model red-dye))
  showcase?: #f)


(define-model Bomb
  (lambda ()
    (make-missile-model blue-dye))
  showcase?: #f)


;;;
;;;; Floor
;;;


(definition public (generate-floor-model image width depth)
  (let ((uv (image-coordinates image)))
    (let ((tl (uv-left uv))
          (tt (uv-top uv))
          (tr (uv-right uv))
          (tb (uv-bottom uv))
          (texture-depth (uv-depth uv))
          (queue (new-queue)))
      (loop (for i from (- width) to width)
            (loop (for k from (- depth) to depth)
                  (let ((x (cast <fl> i))
                        (y 0.)
                        (z (cast <fl> k)))
                    (enqueue queue
                             (make-face image
                                        (f32vector tl tb tl tt tr tt tr tb)
                                        texture-depth
                                        (make-quad #f
                                                   (vertex x y (+ z 1.))
                                                   (vertex (+ x 1.) y (+ z 1.))
                                                   (vertex (+ x 1.) y z)
                                                   (vertex x y z)))))))
      (let ((faces (queue-list queue)))
        (make-model faces)))))


(definition public (generate-floor x y z width depth)
  (let ((zone (current-zone)))
    (add-element~ zone
      (let ((model (generate-floor-model "dirty" width depth))
            (entity (new Entity parent: zone position: (vertex x y z) physical?: #t)))
        (set-model~ entity model)
        (add-element~ zone entity)))))


;;;
;;;; Wall
;;;


(definition public (generate-wall-model image width height)
  (let ((uv (image-coordinates image)))
    (let ((tl (uv-left uv))
          (tt (uv-top uv))
          (tr (uv-right uv))
          (tb (uv-bottom uv))
          (texture-depth (uv-depth uv))
          (queue (new-queue)))
      (loop (for i from (- width) to width)
            (loop (for j from 0 to (* height 2))
                  (let ((x (cast <fl> i))
                        (y (cast <fl> j))
                        (z 0.))
                    (enqueue queue
                             (make-face image
                                        (f32vector tl tb tl tt tr tt tr tb)
                                        texture-depth
                                        (make-quad #f
                                                   (vertex x (+ y 1.) z)
                                                   (vertex (+ x 1.) (+ y 1.) z)
                                                   (vertex (+ x 1.) y z)
                                                   (vertex x y z)))))))
      (let ((faces (queue-list queue)))
        (make-model faces)))))


(definition public (generate-wall x y z width height)
  (let ((zone (current-zone)))
    (add-element~ zone
      (let ((model (generate-wall-model "dirty" width height))
            (entity (new Entity parent: zone position: (vertex x y z) physical?: #t)))
        (set-model~ entity model)
        (add-element~ zone entity)))))


;;;
;;;; Slope
;;;


(definition public (generate-slope-model image height x-count z-count)
  (let ((uv (image-coordinates image)))
    (let ((tl (uv-left uv))
          (tt (uv-top uv))
          (tr (uv-right uv))
          (tb (uv-bottom uv))
          (texture-depth (uv-depth uv))
          (queue (new-queue))
          (width 1.)
          (depth 1.))
      (loop (for d from 0 below z-count)
            (loop (for i from 0 below x-count)
                  (let ((x (* (cast <fl> i) width))
                        (y (* (cast <fl> d) height))
                        (z (* (cast <fl> d) depth)))
                    (enqueue queue
                             (make-face image
                                        (f32vector tl tb tl tt tr tt tr tb)
                                        texture-depth
                                        (make-quad #f
                                                   (vertex x (+ y height) (+ z depth))
                                                   (vertex (+ x width) (+ y height) (+ z depth))
                                                   (vertex (+ x width) y z)
                                                   (vertex x y z)))))))
      (let ((faces (queue-list queue)))
        (make-model faces)))))


(definition public (generate-slope x y z height x-count z-count)
  (let ((zone (current-zone)))
    (add-element~ zone
      (let ((model (generate-slope-model "dirty" height x-count z-count))
            (entity (new Entity parent: zone position: (vertex x y z) physical?: #t)))
        (set-model~ entity model)
        (add-element~ zone entity)))))


;;;
;;;; Stairs
;;;


(definition public (generate-stairs-model image stairs width height depth x-count y-count z-count)
  (let ((uv (image-coordinates image)))
    (let ((tl (uv-left uv))
          (tt (uv-top uv))
          (tr (uv-right uv))
          (tb (uv-bottom uv))
          (texture-depth (uv-depth uv))
          (queue (new-queue)))
      (loop (for d from 0 below stairs)
            (loop (for i from (- x-count) to x-count)
                  (let ((x (* (cast <fl> i) width))
                        (y (* (cast <fl> d) height))
                        (z (* (cast <fl> d) (* depth z-count))))
                    ;; front
                    (enqueue queue
                             (make-face image
                                        (f32vector tl tb tl tt tr tt tr tb)
                                        texture-depth
                                        (make-quad #f
                                                   (vertex x (+ y height) z)
                                                   (vertex (+ x width) (+ y height) z)
                                                   (vertex (+ x width) y z)
                                                   (vertex x y z))))
                    ;; flat
                    (loop (for n from 0 below z-count)
                          (let ((z (+ z (* (cast <fl> n) depth))))
                            (enqueue queue
                                     (make-face image
                                                (f32vector tl tb tl tt tr tt tr tb)
                                                texture-depth
                                                (make-quad #f
                                                           (vertex x (+ y height) (+ z depth))
                                                           (vertex (+ x width) (+ y height) (+ z depth))
                                                           (vertex (+ x width) (+ y height) z)
                                                           (vertex x (+ y height) z)))))))))
      (let ((faces (queue-list queue)))
        (make-model faces)))))


(definition public (generate-stairs stairs x y z width height depth x-count y-count z-count)
  (let ((zone (current-zone)))
    (add-element~ zone
      (let ((model (generate-stairs-model "dirty" stairs width height depth x-count y-count z-count))
            (entity (new Entity parent: zone position: (vertex x y z) physical?: #t)))
        (set-model~ entity model)
        (add-element~ zone entity))))))
