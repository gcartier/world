;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Sound
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.sound jazz


(import (jazz.audio)
        (jazz.geometry)
        (jazz.io)
        (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.configure)
        (world.context)
        (world.geometry)
        (world.homogeneous)
        (world.settings)
        (world.syntax (phase syntax))
        (world.task))


(definition public default-music-volume     1.)
(definition public default-ambience-volume  .1)
(definition public default-game-volume      .5)
(definition public default-interface-volume .5)


(definition public game-volume <fl+>
  #f)

(definition public (set-game-volume volume <fl+>)
  (set! game-volume volume))


(definition public interface-volume <fl+>
  #f)

(definition public (set-interface-volume volume <fl+>)
  (set! interface-volume volume))


(definition public sounds? <bool>
  #f)

(definition public (set-sounds? flag <bool>)
  (set! sounds? flag))


(definition public selection-sounds? <bool>
  #f)

(definition public (set-selection-sounds? flag <bool>)
  (set! selection-sounds? flag))


(definition protected (prepare-sounds)
  (set! game-volume (world-setting 'world.game-volume default-game-volume))
  (set! interface-volume (world-setting 'world.interface-volume default-interface-volume))
  (set! sounds? (world-setting 'world.sounds? #t))
  (set! selection-sounds? (world-setting 'world.selection-sounds? #t)))


;;;
;;;; Task
;;;


(definition public (sound-task task <Task>)
  (declare (proper-tail-calls))
  (with-task task
    (lambda (exit)
      (let (iter (previous (current-seconds)))
        (let ((time (current-seconds)))
          (let ((elapse (- time previous)))
            (unless (stopping? task)
              (site (sound on?: #t)
                (update-playing-sounds)))
            (let ((duration (- (current-seconds) time)))
              (task-sleep task sound-period duration exit))
            (iter time)))))))


;;;
;;;; Sound
;;;


(definition protected sounds
  (make-table test: equal?))


(definition protected (reset-sounds)
  (empty-table sounds))


(definition protected (cache-sound path)
  (let ((cached (table-ref sounds path 'not-found)))
    (if (neq? cached 'not-found)
        cached
      (let ((file (find-sound-file path)))
        (let ((sound (and file (new-sound file))))
          (table-set! sounds path sound)
          sound)))))


(definition (find-sound-file path)
  (let ((world (current-world)))
    (continuation-capture
      (lambda (return)
        (iterate-assets world
          (lambda (assets)
            (let ((dir (get-directory assets)))
              (let ((wav (new-file dir (add-extension path "wav"))))
                (if (exists? wav)
                    (continuation-return return wav)
                  (let ((mp3 (new-file dir (add-extension path "mp3"))))
                     (if (exists? mp3)
                         (continuation-return return mp3)
                       (let ((ogg (new-file dir (add-extension path "ogg"))))
                         (when (exists? ogg)
                           (continuation-return return ogg))))))))))
        #f))))

(definition (require-sound-file path)
  (or (find-sound-file path)
      (error "Unable to find sound: {s}" path)))


(definition protected (effective-cache-sound path/sound)
  (and sounds?
       (not (processing?))
       (neq? path/sound 'none)
       (if (is? path/sound Sound)
           path/sound
         (cache-sound path/sound))))


;;;
;;;; Playing
;;;


(definition package playing-sounds
  (make-table test: eq?))

(definition public (register-playing-sound sound (ended-proc #f))
  (table-set! playing-sounds sound ended-proc))

(definition public (unregister-playing-sound sound)
  (table-clear playing-sounds sound))


(definition package (update-playing-sounds)
  (with-task-mutex
    (lambda ()
      (let ((ended '()))
        (iterate-table playing-sounds
          (lambda (sound ended-proc)
            (when (ended? sound)
              (set! ended (cons sound ended)))))
        (for-each (lambda (sound)
                    (let ((ended-proc (table-ref playing-sounds sound)))
                      (when ended-proc
                        (ended-proc sound)))
                    (table-clear playing-sounds sound))
                  ended)))))


;;;
;;;; Ambient
;;;


(definition public (play-ambient-sound path/sound (volume: volume #f) (error?: error? #f))
  (let ((sound (effective-cache-sound path/sound)))
    (if (not sound)
        (when error?
          (error "Unable to find sound: {a}" path/sound))
      (when volume
        (set-volume sound volume))
      (register-playing-sound sound)
      (rewind sound)
      (play sound))))


(definition public (play-game-sound path)
  (play-ambient-sound path volume: game-volume))


(definition public (play-interface-sound path)
  (play-ambient-sound path volume: interface-volume))


;;;
;;;; 3d
;;;


(definition package 3d-sounds
  (make-table test: eq?))

(definition public (register-3d-sound sound position)
  (table-set! 3d-sounds sound position))

(definition public (unregister-3d-sound sound)
  (table-clear 3d-sounds sound))


(definition listener-position
  #f)

(definition listener-sight
  #f)


(definition near-distance
  5.)

(definition far-distance
  50.)

(definition infinite-distance
  60.)

(definition rolloff
  1.)


(definition package (update-3d-sounds position sight)
  (when (or (not listener-position)
            (not listener-sight)
            (not (vertex-near? position listener-position))
            (not (vertex-near? sight listener-sight)))
    (set! listener-position (copy-vertex position))
    (set! listener-sight (copy-vertex sight))
    (iterate-table 3d-sounds
      (lambda (sound position)
        (when (playing? sound)
          (update-3d-sound sound position))))))


(definition package (update-3d-sound sound position)
  ;; volume
  (let ((dist (vertex-distance position listener-position)))
    (let ((attenuation (distance-attenuation dist)))
      (set-volume sound (* game-volume attenuation))))
  ;; pan
  (let ((angle (vector-signed-angle listener-sight (vertex-& position listener-position) (f64vector 0. 1. 0.))))
    (let ((pan (sight-panning angle)))
      (set-panorama sound pan))))


(definition package (distance-attenuation dist)
  (define (inverse dist)
    (/ near-distance (+ near-distance (* rolloff (- dist near-distance)))))
  
  (cond ;; none
        ((<= dist near-distance)
         1.)
        ;; silent
        ((>= dist infinite-distance)
         0.)
        ;; linear attenuation
        ((>= dist far-distance)
         (let ((lowest (inverse far-distance)))
           (interpolate dist far-distance infinite-distance lowest 0.)))
        ;; inverse attenuation
        (else
         (inverse dist))))


(definition package (sight-panning angle)
  (cond ((between? angle 0. PI/2) (interpolate angle 0. PI/2 0. -1.))
        ((between? angle PI/2 PI) (interpolate angle PI/2 PI -1. 0.))
        ((between? angle (- PI) (- PI/2)) (interpolate angle (- PI) (- PI/2) 0. 1.))
        ((between? angle (- PI/2) 0.) (interpolate angle (- PI/2) 0. 1. 0.))))


(definition public (play-3d-sound path/sound pos (volume: volume #f) (close?: close? #f))
  (let ((sound (effective-cache-sound path/sound)))
    (when sound
      (set-volume sound (or volume game-volume))
      (register-playing-sound sound (lambda (sound)
                                      (unregister-3d-sound sound)
                                      (when close?
                                        (close sound))))
      (register-3d-sound sound pos)
      (update-3d-sound sound pos)
      (rewind sound)
      (play sound))))


(definition public (play-3d-sound-if path pos)
  (when path
    (play-3d-sound path pos)))


;;;
;;;; Steps
;;;


(definition categorized-steps
  #f)


(definition public (random-step kind)
  (let ((steps (table-ref (get-categorized-steps) kind #f)))
    (when steps
      (random-element steps))))


(definition protected (get-categorized-steps)
  (or categorized-steps
      (let ((steps (categorize-steps (collect-steps))))
        (set! categorized-steps steps)
        steps)))


(definition (categorize-steps steps)
  (let ((table (make-table test: eq?))
        (dirt (make-search-context "dirt" ignore-case?: #t))
        (grass (make-search-context "grass" ignore-case?: #t))
        (ladder (make-search-context "ladder" ignore-case?: #t))
        (snow (make-search-context "snow" ignore-case?: #t))
        (stone (make-search-context "stone" ignore-case?: #t))
        (water (make-search-context "water" ignore-case?: #t))
        (wood (make-search-context "wood" ignore-case?: #t)))
    (for-each (lambda (step)
                (cond ((search step dirt) (table-add table 'dirt step))
                      ((search step grass) (table-add table 'grass step))
                      ((search step ladder) (table-add table 'ladder step))
                      ((search step snow) (table-add table 'snow step))
                      ((search step stone) (table-add table 'stone step))
                      ((search step water) (table-add table 'water step))
                      ((search step wood) (table-add table 'wood step))
                      (else (error "Uncategorized step: {s}" step))))
              steps)
    table))


(definition (collect-steps)
  (let ((world (current-world)))
    (let ((queue (new-queue)))
      (iterate-assets world
        (lambda (assets)
          (let ((step-dir (new-directory (get-directory assets) '("sound" "step"))))
            (when (exists? step-dir)
              (iterate-directory step-dir
                (lambda (path kind)
                  (let ((path (join path "/")))
                    (when (extension=? (filename-extension path) "wav")
                      (enqueue queue (string-append "sound/step/" (filename-spine path))))))
                full?: #f
                files?: #t
                directories?: #f)))))
      (queue-list queue)))))
