;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Grid
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is WorldScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2014
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See http://github.com/gcartier/world for details.


(module world.grid jazz


(import (jazz.debuggee)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (world)
        (world.autoload)
        (world.draw)
        (world.dye)
        (world.dyes)
        (world.foreign)
        (world.generate)
        (world.geometry)
        (world.homogeneous)
        (world.material)
        (world.object)
        (world.opengl)
        (world.renderer)
        (world.syntax (phase syntax))
        (world.texture))


(definition (grid-generator level radius uv)
  (lambda (setup-proc triangle-proc quad-proc)
    (let ((diameter (* radius 2))
          (tl uv/left)
          (tt uv/top)
          (tr uv/right)
          (tb uv/bottom)
          (texture-depth (uv-depth uv)))
      (define (add-quad v1 v2 v3 v4)
        (quad-proc
          v1 #f tl tb 0
          v2 #f tr tb 0
          v3 #f tr tt 0
          v4 #f tl tt 0
          uv
          texture-depth))
      
      (setup-proc 0 (* diameter diameter))
      (let ((radius (cast <fl> radius)))
        (loop (for x <fl> from (- radius) to (- radius 1.) by 1.)
              (loop (for z <fl> from (- radius) to (- radius 1.) by 1.)
                    (let ((l x)
                          (b z)
                          (r (+ x 1.))
                          (f (+ z 1.)))
                      (add-quad (vertex l level b)
                                (vertex l level f)
                                (vertex r level f)
                                (vertex r level b)))))))))


(definition (generate-grid)
  (generate-mesh (grid-generator 0. 100 uv)))


(definition grid-mesh
  #f)

(definition grid-matrix
  (make-identity-matrix))


(definition (get-grid-mesh)
  (or grid-mesh
      (begin
        (set! grid-mesh (generate-grid))
        grid-mesh)))


(definition public (draw-grid)
  (let ((world (current-world)))
    (let ((mesh (get-grid-mesh)))
      (define (render-mesh grid-color)
        (let ((program (find-mesh-program~ world 'color)))
          (use~ program)
          (glBindVertexArray (get-vao~ program))
          (bind-uniforms~ program grid-matrix 0 0. grid-color)
          (enable-attributes~ program mesh)
          (glDrawArrays GL_LINES 0 (get-indices~ (get-vertices-buffer~ mesh)))
          (unbind-uniforms~ program)
          (glBindVertexArray 0)
          (unuse~ program)))
      
      (let ((index (position-area-index~ (current-zone) (get-position~ (current-camera))))
            (size (get-area-size~ (current-zone))))
        (let ((bx (fl& (cast <fl> (* (cast <fx> (vector-ref index 0)) size))))
              (by (fl& (cast <fl> (* (cast <fx> (vector-ref index 1)) size))))
              (bz (fl& (cast <fl> (* (cast <fx> (vector-ref index 2)) size)))))
          (case (get-grid-plane~ world)
            ((x)
             (matrix-multiply! grid-matrix
                               (make-translation-matrix& (vertex (get-grid-position~ world) by bz))
                               (make-z-rotation-matrix& PI/2))
             (render-mesh yellow-dye))
            ((y)
             (make-translation-matrix! grid-matrix
                                       (vertex bx (get-grid-position~ world) bz))
             (render-mesh green-dye))
            ((z)
             (matrix-multiply! grid-matrix
                               (make-translation-matrix& (vertex bx by (get-grid-position~ world)))
                               (make-x-rotation-matrix& PI/2))
             (render-mesh red-dye)))))))))
