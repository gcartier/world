;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Profiler Pane
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.interface.profiler jazz


(import (jazz.jml)
        (jazz.graphic)
        (jazz.tree)
        (jazz.ui)
        (world)
        (world.autoload)
        (world.interface.pane)
        (world.profiling)
        (world.settings)
        (world.syntax (phase syntax)))


(class Profiler-Pane extends World-Pane
  
  
  (form
    (<install>                                          size: {Dimension 420 639} background: {Color red: .000 green: .000 blue: .000 alpha: .650} layout-type: fill
      (<Border-View>                                    border-color: {Color Medium-Gray} border-type: edge style: entry layout-type: fill
        (<Scroller-View>                                style: document hscroll?: #t vscroll?: #t
          (<content~>                                   layout-type: fill
            (<Tree-Header>                              style: document selectable?: #f
              (<content~>
                (<Profiler-Tree>       name: sites      portfolio: :images filled-column: site show-unfocused-selection?: #f background: #f
                  (<Tree-Node-Column>  name: site       title: "Site" width: 300 controls?: #f display-images?: #f display-levels?: #f)
                  (<Tree-Label-Column> name: time       title: "Time" width: 65)
                  (<Tree-Label-Column> name: time%      title: "Percent" width: 65)
                  (<Tree-Label-Column> name: time-calls title: "Calls" width: 65)
                  (<Tree-Label-Column> name: time-rate  title: "Rate" width: 100)
                  (<Tree-Label-Column> name: memory     title: "Memory" width: 65)
                  (<Tree-Label-Column> name: memory%    title: "Percent" width: 65)
                  (<Tree-Label-Column> name: rate       title: "Rate" width: 65)))))))))
  
  
  (method (view-sites)
    (let ((world (current-world))
          (tree (locate 'sites))
          (root (sites-tree))
          (n/a "")
          (header-color {Color red: 220 green: 0 blue: 0})
          (content-color {Color Light-Gray})
          (memory-color {Color red: .004 green: .688 blue: .856}))
      (remove-every-row~ tree)
      (with-update-locked
        (lambda ()
          (receive (last-gc-heap-size last-gc-alloc last-gc-live last-gc-movable last-gc-nonmovable) (process-memory)
            (define (root-profile toplevel-nodes)
              (let ((running 0.)
                    (allocated 0.))
                (for-each (lambda (node)
                            (let ((site (car node)))
                              (let ((profile (get-profile~ site)))
                                (increase! running (site-profile-running profile))
                                (increase! allocated (site-profile-allocated profile)))))
                          toplevel-nodes)
                (values running allocated)))
            
            (define (node-name node)
              (get-name~ (car node)))
            
            (define (add-nodes father parent parent-running parent-allocated parent-called nodes)
              (for-each (lambda (node)
                          (let ((site (car node))
                                (children (cdr node)))
                            (let ((name (get-name~ site))
                                  (profile (get-profile~ site))
                                  (kind (getf (get-properties~ site) kind:)))
                              (let ((elapsed (site-profile-effective-elapsed profile))
                                    (running (site-profile-running profile))
                                    (allocated (site-profile-allocated profile))
                                    (called (site-profile-called profile)))
                                (define (compute-time running called)
                                  (and (> called 0.) (* (/ running called) 1000.)))
                                
                                (define (compute-memory allocated called)
                                  (and (> called 0.) (fxround (/ allocated called 1024.))))
                                
                                (define (compute-rate elapsed allocated)
                                  (and (> called 0.) (fxround (/ allocated elapsed 1024. 1024.))))
                                
                                (let ((time (compute-time running called))
                                      (memory (compute-memory allocated called))
                                      (rate (compute-rate elapsed allocated)))
                                  (define (compute-time%)
                                    (when (and parent-running running (> parent-running 0.))
                                      (percentage running parent-running)))
                                  
                                  (define (compute-memory%)
                                    (when (and parent-allocated allocated (> parent-allocated 0.))
                                      (percentage allocated parent-allocated)))
                                  
                                  (define (present-time-calls)
                                    (cond ((= called 0)
                                           n/a)
                                          ((not parent-called)
                                           (if (> elapsed 0.)
                                               (let ((fps (/ called elapsed)))
                                                 (if (> fps 2000.)
                                                     ">2000/s"
                                                   (format "{r precision: 0}/s" fps)))
                                             ">>>"))
                                          (else
                                           n/a)))
                                  
                                  (define (present-time-rate)
                                    (cond ((= called 0)
                                           n/a)
                                          ((not parent-called)
                                           (if (> running 0.)
                                               (let ((rate (/ called running)))
                                                 (if (> rate 2000.)
                                                     ">2000/s"
                                                   (format "{r precision: 0}/s" rate)))
                                             ">>>"))
                                          ((and parent-called called (> called 0.) (> parent-called 0.))
                                           (format "{r precision: 0}" (/ called parent-called)))
                                          (else
                                           n/a)))
                                  
                                  (define (present-memory-period)
                                    (if (> called 0.)
                                        (format "{r precision: 0}s" (/ elapsed called))
                                      n/a))
                                  
                                  (define (present-memory-count)
                                    (format "{a}" (gc-count)))
                                  
                                  (define (present-meg bytes)
                                    (format "{a}m" (meg bytes)))
                                  
                                  (define (meg bytes)
                                    (fxround (/ bytes 1024. 1024.)))
                                  
                                  (let ((time% (and (> called 0.) (compute-time%)))
                                        (memory% (and (> called 0.) (compute-memory%)))
                                        (color (if (not father) header-color content-color)))
                                    (let ((row (add-row~ tree
                                                 father: father
                                                 state: 'expanded
                                                 children: (list (new Tree-Node title: (->string name) font: {Font Label-User} color: color)
                                                                 (new Tree-Label title: (if time (format "{r precision: 0}ms" time) n/a) font: {Font Label-User} color: color)
                                                                 (new Tree-Label title: (if time% (format "{r precision: 0}%" time%) n/a) font: {Font Label-User} color: color)
                                                                 (new Tree-Label title: (if (eq? kind 'memory) (present-memory-period) (present-time-calls)) font: {Font Label-User} color: color)
                                                                 (new Tree-Label title: (if (eq? kind 'memory) (present-memory-count) (present-time-rate)) font: {Font Label-User} color: color)
                                                                 (new Tree-Label title: (if (eq? kind 'memory) (present-meg last-gc-live) (if memory (format "{a}k" memory) n/a)) font: {Font Label-User} color: (if (eq? kind 'memory) memory-color color))
                                                                 (new Tree-Label title: (if (eq? kind 'memory) (present-meg last-gc-movable) (if memory% (format "{r precision: 0}%" memory%) n/a)) font: {Font Label-User} color: (if (eq? kind 'memory) memory-color color))
                                                                 (new Tree-Label title: (if (eq? kind 'memory) (present-meg last-gc-nonmovable) (if rate (format "{a}m/s" rate) n/a)) font: {Font Label-User} color: (if (eq? kind 'memory) memory-color color)))
                                                 user-data: site)))
                                      (add-nodes row node running allocated called children))))))))
                        nodes))
            
            (let ((toplevel-nodes (cdr root)))
              (receive (root-running root-allocated) (root-profile toplevel-nodes)
                (let ((display (world-setting 'world.profiler-display #f)))
                  (let ((effective-nodes (if display
                                             (map (lambda (name) (find toplevel-nodes name key: node-name return: 'item)) display)
                                           toplevel-nodes)))
                    (add-nodes #f root root-running root-allocated #f effective-nodes)))))))))))


;;;
;;;; Profiler-Tree
;;;


(class Profiler-Tree extends Tree-View
  
  
  (method override (mouse-down evt)
    )))
