;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Inventory
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.interface.inventory jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.image)
        (jazz.io)
        (jazz.jml)
        (jazz.view)
        (jazz.view.dnd)
        (world)
        (world.autoload)
        (world.external.nbt)
        (world.interface.pane)
        (world.interface.syntax (phase syntax))
        (world.interface.tooltip)
        (world.settings)
        (world.syntax (phase syntax))
        (world.texture))


(definition show-unknown? <bool>
  (world-setting 'world.show-unknown? #f))

(definition show-useless? <bool>
  (world-setting 'world.show-useless? #f))


(definition protected slot-size
  48)


(definition slot-images
  (make-table))

(definition protected (get-slot-image id)
  (let ((world (current-world)))
    (define (determine-file)
      (if (< id 256)
          (let ((block (world.external.minecraft:blockid->block id)))
            (image-file~ (get-block-atlas~ world) (or (get-image~ block) (get-texture~ block))))
        (item-image id)))
    
    (or (table-ref slot-images id #f)
        (let ((file (determine-file)))
          (assert file)
          (receive (width height image) (cairo-surface-from-file file)
            (let ((resized-image (resize-image image slot-size slot-size)))
              (table-set! slot-images id resized-image)
              resized-image))))))


;;;
;;;; Item
;;;


(definition item-table
  #f)

(definition protected (get-item-table)
  (or item-table
      (let ((table (make-item-table)))
        (set! item-table table)
        table)))

(definition (make-item-table)
  (let ((world (current-world)))
    (let ((table (make-table test: equal?)))
      (iterate-assets~ world
        (lambda (assets)
          (let ((items-dir (new-directory~ (get-directory~ assets) "items")))
            (when (exists?~ items-dir)
              (iterate-directory~ items-dir
                (lambda (path kind)
                  (let ((path (join path "/")))
                    (when (extension=? (extract-extension path) "png")
                      (table-set! table (extract-base path) (make-file~ assets (string-append "items/" path))))))
                full?: #f
                files?: #t
                directories?: #f)))))
      table)))


(definition protected items
  (make-table test: eq?))


(class Item extends Object
  
  
  (slot name     getter generate)
  (slot id       getter generate)
  (slot texture  getter generate)
  (slot category getter generate)
  (slot armor    getter generate)
  (slot power    getter generate)
  
  
  (method override (initialize name id texture category armor power)
    (set! name~self name)
    (set! id~self id)
    (set! texture~self texture)
    (set! category~self category)
    (set! armor~self armor)
    (set! power~self power)))


(definition (register-item name id (texture: texture #f) (category: category #f) (armor: armor #f) (power: power #f))
  (table-set! items name (new Item name id texture category armor power)))


;;;
;;;; Items
;;;


(define-item IronShovel
  256
  texture: "iron_shovel")


(define-item IronPickaxe
  257
  texture: "iron_pickaxe")


(define-item IronAxe
  258
  texture: "iron_axe"
  category: 'weapon)


(define-item FlintAndSteel
  259
  texture: "flint_and_steel")


(define-item Apple
  260
  texture: "apple"
  category: 'food)


(define-item BowStandby
  261
  texture: "bow_standby"
  category: 'weapon)


(define-item Arrow
  262
  texture: "arrow"
  category: 'missile)


(define-item Coal
  263
  texture: "coal")


(define-item Diamond
  264
  texture: "diamond")


(define-item IronIngot
  265
  texture: "iron_ingot")


(define-item GoldIngot
  266
  texture: "gold_ingot")


(define-item IronSword
  267
  texture: "iron_sword"
  category: 'weapon
  power: 120)


(define-item WoodSword
  268
  texture: "wood_sword"
  category: 'weapon
  power: 30)


(define-item WoodShovel
  269
  texture: "wood_shovel")


(define-item WoodPickaxe
  270
  texture: "wood_pickaxe")


(define-item StoneSword
  272
  texture: "stone_sword"
  category: 'weapon
  power: 90)


(define-item StoneShovel
  273
  texture: "stone_shovel")


(define-item StonePickaxe
  274
  texture: "stone_pickaxe")


(define-item StoneAxe
  275
  texture: "stone_axe"
  category: 'weapon)


(define-item DiamondSword
  276
  texture: "diamond_sword"
  category: 'weapon
  power: 150)


(define-item DiamondPickaxe
  278
  texture: "diamond_pickaxe")


(define-item Stick
  280
  texture: "stick")


(define-item Bowl
  281
  texture: "bowl")


(define-item MushroomStew
  282
  texture: "mushroom_stew"
  category: 'food)


(define-item GoldSword
  283
  texture: "gold_sword"
  category: 'weapon
  power: 60)


(define-item GoldShovel
  284
  texture: "gold_shovel")


(define-item GoldAxe
  286
  texture: "gold_axe"
  category: 'weapon)


(define-item String
  287
  texture: "string")


(define-item Feather
  288
  texture: "feather")


(define-item Gunpowder
  289
  texture: "gunpowder")


(define-item IronHoe
  292
  texture: "iron_hoe")


(define-item GoldHoe
  294
  texture: "gold_hoe")


(define-item SeedsWheat
  295
  texture: "seeds_wheat")


(define-item Wheat
  296
  texture: "wheat")


(define-item Bread
  297
  texture: "bread"
  category: 'food)


(define-item LeatherHelmet
  298
  texture: "leather_helmet"
  category: 'armor
  armor: 32)


(define-item LeatherChestplate
  299
  texture: "leather_chestplate"
  category: 'armor
  armor: 48)


(define-item LeatherLeggings
  300
  texture: "leather_leggings"
  category: 'armor
  armor: 48)


(define-item LeatherBoots
  301
  texture: "leather_boots"
  category: 'armor
  armor: 32)


(define-item ChainmailHelmet
  302
  texture: "chainmail_helmet"
  category: 'armor
  armor: 64)


(define-item ChainmailChestplate
  303
  texture: "chainmail_chestplate"
  category: 'armor
  armor: 96)


(define-item ChainmailLeggings
  304
  texture: "chainmail_leggings"
  category: 'armor
  armor: 96)


(define-item ChainmailBoots
  305
  texture: "chainmail_boots"
  category: 'armor
  armor: 64)


(define-item IronHelmet
  306
  texture: "iron_helmet"
  category: 'armor
  armor: 80)


(define-item IronChestplate
  307
  texture: "iron_chestplate"
  category: 'armor
  armor: 120)


(define-item IronLeggings
  308
  texture: "iron_leggings"
  category: 'armor
  armor: 120)


(define-item IronBoots
  309
  texture: "iron_boots"
  category: 'armor
  armor: 80)


(define-item DiamondHelmet
  310
  texture: "diamond_helmet"
  category: 'armor
  armor: 96)


(define-item DiamondChestplate
  311
  texture: "diamond_chestplate"
  category: 'armor
  armor: 144)


(define-item DiamondLeggings
  312
  texture: "diamond_leggings"
  category: 'armor
  armor: 144)


(define-item DiamondBoots
  313
  texture: "diamond_boots"
  category: 'armor
  armor: 96)


(define-item GoldHelmet
  314
  texture: "gold_helmet"
  category: 'armor
  armor: 48)


(define-item GoldChestplate
  315
  texture: "gold_chestplate"
  category: 'armor
  armor: 72)


(define-item GoldLeggings
  316
  texture: "gold_leggings"
  category: 'armor
  armor: 72)


(define-item GoldBoots
  317
  texture: "gold_boots"
  category: 'armor
  armor: 48)


(define-item Flint
  318
  texture: "flint")


(define-item PorkchopRaw
  319
  texture: "porkchop_raw"
  category: 'food)


(define-item PorkchopCooked
  320
  texture: "porkchop_cooked"
  category: 'food)


(define-item Painting
  321
  texture: "painting"
  ;; category: 'later
  )


(define-item AppleGolden
  322
  texture: "apple_golden"
  category: 'food)


(define-item BucketEmpty
  325
  texture: "bucket_empty")


(define-item BucketWater
  326
  texture: "bucket_water")


(define-item BucketLava
  327
  texture: "bucket_lava")


(define-item MinecartNormal
  328
  texture: "minecart_normal"
  ;; category: 'later
  )


(define-item Saddle
  329
  texture: "saddle")


(define-item RedstoneDust
  331
  texture: "redstone_dust")


(define-item Leather
  334
  texture: "leather")


(define-item BucketMilk
  335
  texture: "bucket_milk")


(define-item Brick
  336
  texture: "brick")


(define-item ClayBall
  337
  texture: "clay_ball")


(define-item Reeds
  338
  texture: "reeds")


(define-item Paper
  339
  texture: "paper")


(define-item BookNormal
  340
  texture: "book_normal")


(define-item Slimeball
  341
  texture: "slimeball")


(define-item Compass
  345
  texture: "compass")


(define-item Clock
  347
  texture: "clock")


(define-item GlowstoneDust
  348
  texture: "glowstone_dust")


(define-item FishRaw
  349
  texture: "fish_raw"
  category: 'food)


(define-item FishCooked
  350
  texture: "fish_cooked"
  category: 'food)


(define-item DyePowderBlack
  351
  texture: "dye_powder_black")


(define-item Bone
  352
  texture: "bone"
  ;; category: 'later
  )


(define-item Sugar
  353
  texture: "sugar")


(define-item Bed
  355
  texture: "bed")


(define-item Repeater
  356
  texture: "repeater")


(define-item Shears
  359
  texture: "shears")


(define-item SeedsMelon
  362
  texture: "seeds_melon")


(define-item BeefCooked
  364
  texture: "beef_cooked"
  category: 'food)


(define-item ChickenRaw
  365
  texture: "chicken_raw"
  category: 'food)


(define-item RottenFlesh
  367
  texture: "rotten_flesh")


(define-item EnderPearl
  368
  texture: "ender_pearl")


(define-item GoldNugget
  371
  texture: "gold_nugget")


(define-item PotionBottleDrinkable
  373
  texture: "potion_bottle_drinkable"
  category: 'potion)


(define-item PotionBottleEmpty
  374
  texture: "potion_bottle_empty"
  category: 'potion)


(define-item SpiderEye
  375
  texture: "spider_eye")


(define-item BlazePowder
  377
  texture: "blaze_powder")


(define-item Cauldron
  380
  texture: "cauldron")


(define-item Record13
  2256
  texture: "record_13")


(define-item RecordCat
  2257
  texture: "record_cat")


(define-item RecordBlocks
  2258
  texture: "record_blocks")


(define-item RecordChirp
  2259
  texture: "record_chirp")


(define-item RecordFar
  2260
  texture: "record_far")


(define-item RecordMall
  2261
  texture: "record_mall")


(define-item RecordMellohi
  2262
  texture: "record_mellohi")


(define-item RecordStal
  2263
  texture: "record_stal")


(define-item RecordStrad
  2264
  texture: "record_strad")


(define-item RecordWard
  2265
  texture: "record_ward")


(define-item Record11
  2266
  texture: "record_11")


(definition id-items
  (list->table
    (map (lambda (name)
           (let ((item (table-ref items name)))
             (cons (get-id~ item) item)))
         (table-keys items))))


(definition protected (id->item id)
  (table-ref id-items id #f))


(definition protected (item-image id)
  (let ((item (id->item id)))
    (and item (table-ref (get-item-table) (get-texture~ item) #f))))


(definition protected (known-id? id)
  (or (< id 256)
      (id->item id)))


(definition protected (show-id? id)
  (or (known-id? id)
      show-unknown?))


(definition protected (useful-id? id)
  (or (< id 256)
      (let ((item (id->item id)))
        (and item (or (get-category~ item)
                      show-useless?)))))


(definition countless-placeholder
  127)

(definition (standarize-count count)
  (if (eqv? count countless-placeholder)
      #f
    count))


;;;
;;;; Slot
;;;


(class Inventory-Slot extends View
  
  
  (property id    initialize #f accessors generate)
  (property count initialize #f accessors generate)
  (property rank  initialize #f accessors generate)
  
  
  (form
    (<install> draggable?: #t tooltip?: #t))
  
  
  ;;;
  ;;;; Access
  ;;;
  
  
  (method (increase-count (delta 1))
    (when count
      (increase! count delta)
      (invalidate-view)))
  
  
  (method (decrease-count (delta 1))
    (when count
      (decrease! count delta)
      (when (<= count 0)
        (set! id #f))
      (invalidate-view)))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method override (mouse-down evt)
    (down~ parent self))
  
  
  (method override (right-mouse-down evt)
    (down~ parent self))
  
  
  ;;;
  ;;;; Drag
  ;;;
  
  
  (method override (drag-acquires-focus?)
    #f)
  
  
  ;;;
  ;;;; Drop
  ;;;
  
  
  (method override (current-drop drag-drop pos)
    (let ((sender (get-view~ (get-source~ drag-drop))))
      (new Drop-Target view: self user-data: #f)))
  
  
  (method override (receive-drop sender pos drag-drop)
    (unless (eq? sender self)
      (let ((sender-id (get-id~ sender))
            (sender-count (get-count~ sender)))
        (when sender-id
          (cond ((not id)
                 (set! id sender-id)
                 (set! count sender-count)
                 (set-id~ sender #f)
                 (set-count~ sender #f))
                ((= id sender-id)
                 (set! count (and count sender-count (+ count sender-count)))
                 (set-id~ sender #f)
                 (set-count~ sender #f))
                (else
                 (set-id~ sender id)
                 (set-count~ sender count)
                 (set! id sender-id)
                 (set! count sender-count)))
          (invalidate-view)
          (invalidate-view~ sender)))))
  
  
  (method override (drop-void)
    (set-id #f)
    (invalidate-view))
  
  
  ;;;
  ;;;; Tooltip
  ;;;
  
  
  (method override (get-tooltip-context pos)
    (define (present-text)
      (when (and id (integer? id))
        (if (< id 256)
            (let ((block (world.external.minecraft:blockid->block id)))
              `(<span>
                 (<paragraph>
                   (<text> ,(->string (get-name~ block)))
                   (<text> " ")
                   (<text> color: World-Yellow "(block)"))))
          (let ((item (id->item id)))
            (if (not item)
                "Unknown item"
              (let ((category (get-category~ item)))
                `(<span>
                   (<paragraph>
                     (<text> ,(->string (get-name~ item)))
                     (<text> " ")
                     (<text> color: World-Yellow ,(if (not category) "(item)" (format "({a} item)" category)))))))))))
    
    (let ((text (present-text))
          (bounds (get-tooltip-bounds pos)))
      (tooltip-context self text bounds)))
  
  
  ;;;
  ;;;; Draw
  ;;;
     
  
  (method override (draw surface context)
    (let ((bounds (get-bounds)))
      ;; integer test is a quick hack for minecraft 1.8 format
      (when (and id (integer? id))
        (if (known-id? id)
            (when (useful-id? id)
              (blit-surface~ surface (get-slot-image id) destination: {Point 1 1})
              (when (and count (draw-count?))
                (let ((str (->string count)))
                  (let ((extent (get-text-extent~ surface str)))
                    (draw-text~ surface (- (get-right~ bounds) (get-width~ extent)) (- (get-bottom~ bounds) (get-height~ extent)) str {Color White})))))
          (let ((str (->string id)))
            (let ((extent (get-text-extent~ surface str)))
              (let ((pos (center extent (rect-size bounds))))
                (draw-text~ surface (get-h~ pos) (get-v~ pos) str {Color Yellow}))))))
      (frame-partial-rect~ surface bounds '(left top) {Color Entry-Border})
      (frame-partial-rect~ surface bounds '(right bottom) (right/bottom-color))))
  
  
  (method protected virtual (draw-count?)
    #t)
  
  
  (method protected virtual (right/bottom-color)
    {Color Entry-Border alpha: .6}))


;;;
;;;; Inventory
;;;


(class Inventory-Pane extends World-Pane
  
  
  (slot slot-table initialize (make-table) getter generate)
  
  
  (form
    (<install> background: {Color Black alpha: 0.3}))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method protected virtual (setup-inventory offset width height)
    (loop (for x from 0 below width)
          (loop (for y from 0 below height)
                (let ((rank (+ offset (+ x (* y width)))))
                  (let ((view (new Inventory-Slot parent: self position: (new Point (* x slot-size) (* y slot-size)) size: (new Dimension slot-size slot-size) rank: rank)))
                    (table-set! slot-table rank view))))))
  
  
  (method (reset-inventory)
    (iterate-table slot-table
      (lambda (id view)
        (set-id~ view #f))))
  
  
  (method protected virtual (view-inventory)
    (let ((zone (current-zone)))
      (reset-inventory)
      (let ((level (get-level-nbt~ zone)))
        (let ((inventory (list-payload-content (tag-assoc "Inventory" (tag-assoc "Player" (tag-assoc "Data" (tag-value level)))))))
          (for-each (lambda (item)
                      (let ((id (tag-assoc "id" item))
                            (count (tag-assoc "Count" item))
                            (rank (tag-assoc "Slot" item)))
                        (when (show-id? id)
                          (let ((view (table-ref slot-table rank #f)))
                            (when view
                              (set-id~ view id)
                              (set-count~ view (standarize-count count)))))))
                    inventory)))))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method protected virtual (down evt)
    )
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method override (draw surface context)
    (let ((bounds (get-bounds)))
      (frame-partial-rect~ surface bounds '(right bottom) {Color Entry-Border}))))


;;;
;;;; Bag
;;;


(class Bag-Pane extends Inventory-Pane
  
  
  (method override (conclude initargs)
    (nextmethod initargs)
    (setup-inventory 9 9 3)))


;;;
;;;; Belt
;;;


;; global to survive role change
(definition belt-selection
  0)


(class Belt-Pane extends Inventory-Pane
  
  
  (method override (conclude initargs)
    (nextmethod initargs)
    (setup-inventory 0 9 1))
  
  
  (method override (down slot)
    (set! belt-selection (find children slot))
    (invalidate-view))
  
  
  (method (selected-slot)
    (list-ref children belt-selection))
  
  
  (method (cycle-selection d)
    (unless (= d 0)
      (set! belt-selection (modulo ((if (< d 0) + -) belt-selection 1) (length children)))
      (invalidate-view)))
  
  
  (method override (draw-children surface nodes context)
    (nextmethod surface nodes context)
    (when belt-selection
      (let ((slot (selected-slot)))
        (let ((outer (expand-rect (acquire slot (get-bounds~ slot)) 0 0 1 1)))
          (let ((inner (inflate-rect outer -1 -1)))
            (frame-rect~ surface outer {Color red: .072 green: .072 blue: .995})
            (frame-rect~ surface inner {Color red: .072 green: .072 blue: .995})))))))


;;;
;;;; Chest
;;;


(class Chest-Pane extends Inventory-Pane
  
  
  (slot section initialize #f getter generate)
  (slot data    initialize #f getter generate)
  
  
  (method override (conclude initargs)
    (nextmethod initargs)
    (setup-inventory 0 9 3))
  
  
  (method (view-chest section data)
    (set! section~self section)
    (set! data~self data)
    (reset-inventory)
    (let ((inventory (list-payload-content (tag-assoc "Items" data))))
      (for-each (lambda (item)
                  (let ((id (tag-assoc "id" item))
                        (count (tag-assoc "Count" item))
                        (rank (tag-assoc "Slot" item)))
                    (when (show-id? id)
                      (let ((view (table-ref slot-table rank)))
                        (set-id~ view id)
                        (set-count~ view (standarize-count count))))))
                inventory))))


;;;
;;;; Add
;;;


(definition public (deposit-inventory id (count: count 1))
  (let ((world (current-world)))
    (continuation-capture
      (lambda (done)
        (define (deposit view)
          (define (save&return)
            (save-inventory)
            (continuation-return done #f))
          
          (for-each (lambda (slot)
                      (when (eqv? (get-id~ slot) id)
                        (increase-count~ slot count)
                        (save&return)))
                    (get-children~ view))
          (for-each (lambda (slot)
                      (when (not (get-id~ slot))
                        (set-id~ slot id)
                        (set-count~ slot count)
                        (invalidate-view~ slot)
                        (save&return)))
                    (get-children~ view)))
        
        (let ((interface (get-interface~ world)))
          (let ((bag-pane (child~ interface 'bag))
                (belt-pane (child~ interface 'belt)))
            (deposit belt-pane)
            (deposit bag-pane)))
        (bell)
        (display-message~ world "Inventory is full!")))))


;;;
;;;; Save
;;;


(definition (inventory-save list-payload proc)
  (set-list-payload-type list-payload TAG_Compound)
  (set-list-payload-content list-payload (let ((queue (new-queue)))
                                             (define (add-slot slot)
                                               (let ((id (get-id~ slot))
                                                     (count (get-count~ slot))
                                                     (rank (get-rank~ slot)))
                                                 (when id
                                                   (enqueue queue (list (make-tag "id" TAG_Int id)
                                                                        (make-tag "Count" TAG_Int (or count countless-placeholder))
                                                                        (make-tag "Slot" TAG_Int rank))))))
                                             
                                             (proc add-slot)
                                             (queue-list queue))))


(definition protected (save-inventory)
  (let ((world (current-world))
        (zone (current-zone)))
    (let ((interface (get-interface~ world))
          (level (get-level-nbt~ zone)))
      (let ((character-pane (child~ interface 'character))
            (bag-pane (child~ interface 'bag))
            (belt-pane (child~ interface 'belt))
            (list-payload (tag-assoc "Inventory" (tag-assoc "Player" (tag-assoc "Data" (tag-value level))))))
        (inventory-save list-payload
          (lambda (add-slot)
            (for-each add-slot (collect-type Inventory-Slot (get-children~ character-pane)))
            (for-each add-slot (get-children~ belt-pane))
            (for-each add-slot (get-children~ bag-pane))))))))


(definition protected (save-chest (save-region?: save-region? #f))
  (let ((world (current-world)))
    (let ((chest (child~ (get-interface~ world) 'chest)))
      (when (get-visible?~ chest)
        (let ((list-payload (tag-assoc "Items" (get-data~ chest))))
          (inventory-save list-payload
            (lambda (add-slot)
              (for-each add-slot (get-children~ chest)))))
        (when save-region?
          (let ((section (get-section~ chest)))
            (let ((chunk (get-chunk~ section)))
              (modified~ chunk)
              (save-region~ (get-region~ chunk))))))))))
