;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Inventory
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s): Edouard Hebert


(module world.interface.inventory jazz


(import (jazz.component)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.image)
        (jazz.io)
        (jazz.markup)
        (jazz.view)
        (jazz.view.dnd)
        (gaea.dye)
        (gaea.geometry)
        (gaea.opengl.glew)
        (gaea.texture)
        (world)
        (world.asset)
        (world.assets)
        (world.block)
        (world.camera)
        (world.context)
        (world.generation.block)
        (world.generation.rendering)
        (world.interface.panel)
        (world.interface.syntax (phase syntax))
        (world.interface.tooltip)
        (world.lighting)
        (world.renderer)
        (world.renderers)
        (world.settings)
        (world.sound)
        (world.tag)
        (world.task)
        (world.texture))


(definition show-unknown? <bool>
  (world-setting 'world.show-unknown? #f))

(definition show-useless? <bool>
  (world-setting 'world.show-useless? #f))


(definition protected slot-size
  48)


(definition slot-images
  (make-table))

(definition protected (get-slot-image id variant-id)
  (let ((world (current-world)))
    (define (determine-file)
      (if (< id 256)
          (let ((block (id/variant-id->block id variant-id)))
            (let ((present (get-present block)))
              (if (or (eq? present 'texture)
                      (string? present))
                  (let ((name (if (eq? present 'texture)
                                  (get-texture block)
                                present)))
                    (and name
                         (or (get-generated-texture name)
                             (image-file (get-block-atlas world) name error?: #f)
                             ;; aec quicky
                             ;; we should generate colored png files
                             (or (let ((asset (table-ref (get-item-table) name #f)))
                                   (and asset (retrieve-file asset)))
                                 (make-file pack-assets (append pack-path (list "texture" "templates" (add-extension name "png")))))
                             @wait
                             (let ((asset (table-ref (get-item-table) name #f)))
                               (and asset (retrieve-file asset))))))
                #f)))
        (item-image id)))
    
    (or (table-ref slot-images (encode-id id variant-id) #f)
        (let ((file/surface (determine-file)))
          (and file/surface
               (bind-values (width height image) (if (pair? file/surface)
                                                     (bind (width height surface) file/surface
                                                       (values width height (get-handle surface)))
                                                   (cairo-surface-from-file file/surface))
                 (let ((resized-image (resize-image image slot-size slot-size)))
                   (table-set! slot-images (encode-id id variant-id) resized-image)
                   resized-image)))))))


;;;
;;;; Item
;;;


(definition item-table
  #f)

(definition protected (get-item-table)
  (or item-table
      (let ((table (make-item-table)))
        (set! item-table table)
        table)))

(definition (make-item-table)
  (let ((world (current-world)))
    (let ((table (make-table test: equal?)))
      (iterate-assets world
        (lambda (assets)
          (iterate-entries assets
            (lambda (path)
              (when (starts-with? path "item/")
                (when (extension=? (filename-extension path) "png")
                  (table-set! table (filename-base path) (new Asset assets path))))))))
      table)))


(definition protected items
  (make-table test: eq?))


(class Item extends Object
  
  
  (slot name       getter generate)
  (slot id         getter generate)
  (slot texture    getter generate)
  (slot quality    getter generate)
  (slot category   getter generate)
  (slot kind       getter generate)
  (slot armor      getter generate)
  (slot power      getter generate)
  (slot durability getter generate)
  (slot potency    getter generate)
  (slot use        getter generate)
  
  
  (method override (initialize self name id texture quality category kind armor power durability potency use)
    (set! self.name name)
    (set! self.id id)
    (set! self.texture texture)
    (set! self.quality quality)
    (set! self.category category)
    (set! self.kind kind)
    (set! self.armor armor)
    (set! self.power power)
    (set! self.durability durability)
    (set! self.potency potency)
    (set! self.use use))
  
  
  (method package (stackable? self)
    (and (neq? category 'armor)
         (neq? category 'weapon))))


(definition (register-item name id (texture: texture #f) (quality: quality #f) (category: category #f) (kind: kind #f) (armor: armor #f) (power: power #f) (durability: durability #f) (potency: potency #f) (use: use #f))
  (table-set! items name (new Item name id texture quality category kind armor power durability potency use)))


;;;
;;;; Uses
;;;


(definition (eat-food slot)
  (consume-food slot 'eat))


(definition (drink-food slot)
  (consume-food slot 'drink))


(definition (take-potion slot)
  (consume-potion slot))


(definition (consume-food slot type)
  (let ((world (current-world))
        (zone (current-zone))
        (me (current-me)))
    (let ((item (id->item (get-id slot)))
          (ticks 15))
      (case type
        ((eat) (eating-sound))
        ((drink) (drinking-sound)))
      (let ((eating (/ (get-potency item) (cast <fl> ticks))))
        (set-eating me eating)
        (set-eating-ticks me ticks)
        (let ((task (get-eat-task zone)))
          (task-wakeup task)))
      (let ((count (get-count slot)))
        (cond ((> count 1)
               (set-count slot (- count 1))
               (invalidate-view slot))
              (else
               (set-id slot #f)
               (set-count slot #f)
               (set-durability slot #f)
               (invalidate-view slot)))))))


(definition (consume-potion slot)
  (let ((interface (current-interface))
        (world (current-world))
        (me (current-me)))
    (let ((item (id->item (get-id slot))))
      (drinking-sound)
      (set-life me (min (+ (get-life me) (get-potency item)) 100.))
      (invalidate-view (child interface 'combat))
      (let ((count (get-count slot)))
        (cond ((> count 1)
               (set-count slot (- count 1))
               (invalidate-view slot))
              (else
               (set-id slot #f)
               (set-count slot #f)
               (set-durability slot #f)
               (invalidate-view slot)))))))


(definition (eating-sound)
  (play-ambient-sound "warcraft/user/iEating1" volume: .5))


(definition (drinking-sound)
  (play-ambient-sound "warcraft/user/iDrinking1" volume: .5)
  (thread-start!
    (new-thread
      (lambda ()
        (sleep .8)
        (play-ambient-sound "warcraft/user/iDrinking1" volume: .5)
        (sleep .75)
        (play-ambient-sound "warcraft/user/iDrinking1" volume: .25))
      'drink)))


;;;
;;;; Items
;;;


(define-item IronShovel
  256
  texture: "iron_shovel")


(define-item IronPickaxe
  257
  texture: "iron_pickaxe")


(define-item IronAxe
  258
  texture: "iron_axe"
  quality: 'green
  category: 'weapon
  kind: 'melee
  power: 120
  durability: 200)


(define-item FlintAndSteel
  259
  texture: "flint_and_steel")


(define-item Apple
  260
  texture: "apple"
  category: 'food
  potency: 50
  use: eat-food)


(define-item BowStandby
  261
  texture: "bow_standby"
  quality: 'green
  category: 'weapon
  kind: 'range
  power: 110
  durability: 100)


(define-item Arrow
  262
  texture: "arrow"
  category: 'missile
  kind: 'arrow)


(define-item Coal
  263
  texture: "coal")


(define-item Diamond
  264
  texture: "diamond")


(define-item IronIngot
  265
  texture: "iron_ingot")


(define-item GoldIngot
  266
  texture: "gold_ingot")


(define-item IronSword
  267
  texture: "iron_sword"
  quality: 'green
  category: 'weapon
  kind: 'melee
  power: 120
  durability: 200)


(define-item WoodSword
  268
  texture: "wood_sword"
  quality: 'white
  category: 'weapon
  kind: 'melee
  power: 30
  durability: 50)


(define-item WoodShovel
  269
  texture: "wood_shovel")


(define-item WoodPickaxe
  270
  texture: "wood_pickaxe")


(define-item StoneSword
  272
  texture: "stone_sword"
  quality: 'green
  category: 'weapon
  kind: 'melee
  power: 90
  durability: 100)


(define-item StoneShovel
  273
  texture: "stone_shovel")


(define-item StonePickaxe
  274
  texture: "stone_pickaxe")


(define-item StoneAxe
  275
  texture: "stone_axe"
  quality: 'green
  category: 'weapon
  kind: 'melee
  power: 90
  durability: 100)


(define-item DiamondSword
  276
  texture: "diamond_sword"
  quality: 'blue
  category: 'weapon
  kind: 'melee
  power: 150
  durability: 500)


(define-item DiamondPickaxe
  278
  texture: "diamond_pickaxe")


(define-item Stick
  280
  texture: "stick")


(define-item Bowl
  281
  texture: "bowl")


(define-item MushroomStew
  282
  texture: "mushroom_stew"
  category: 'food
  potency: 50
  use: drink-food)


(define-item GoldSword
  283
  texture: "gold_sword"
  quality: 'white
  category: 'weapon
  kind: 'melee
  power: 60
  durability: 30)


(define-item GoldShovel
  284
  texture: "gold_shovel")


(define-item GoldAxe
  286
  texture: "gold_axe"
  quality: 'white
  category: 'weapon
  kind: 'melee
  power: 60
  durability: 30)


(define-item String
  287
  texture: "string")


(define-item Feather
  288
  texture: "feather")


(define-item Gunpowder
  289
  texture: "gunpowder")


(define-item IronHoe
  292
  texture: "iron_hoe")


(define-item GoldHoe
  294
  texture: "gold_hoe")


(define-item SeedsWheat
  295
  texture: "seeds_wheat")


(define-item Wheat
  296
  texture: "wheat")


(define-item Bread
  297
  texture: "bread"
  category: 'food
  potency: 50
  use: eat-food)


(define-item LeatherHelmet
  298
  texture: "leather_helmet"
  quality: 'white
  category: 'armor
  kind: 'head
  armor: 32
  durability: 20)


(define-item LeatherChestplate
  299
  texture: "leather_chestplate"
  quality: 'white
  category: 'armor
  kind: 'chest
  armor: 48
  durability: 20)


(define-item LeatherLeggings
  300
  texture: "leather_leggings"
  quality: 'white
  category: 'armor
  kind: 'legs
  armor: 48
  durability: 20)


(define-item LeatherBoots
  301
  texture: "leather_boots"
  quality: 'white
  category: 'armor
  kind: 'boots
  armor: 32
  durability: 20)


(define-item ChainmailHelmet
  302
  texture: "chainmail_helmet"
  quality: 'green
  category: 'armor
  kind: 'head
  armor: 64
  durability: 40)


(define-item ChainmailChestplate
  303
  texture: "chainmail_chestplate"
  quality: 'green
  category: 'armor
  kind: 'chest
  armor: 96
  durability: 40)


(define-item ChainmailLeggings
  304
  texture: "chainmail_leggings"
  quality: 'green
  category: 'armor
  kind: 'legs
  armor: 96
  durability: 40)


(define-item ChainmailBoots
  305
  texture: "chainmail_boots"
  quality: 'green
  category: 'armor
  kind: 'boots
  armor: 64
  durability: 40)


(define-item IronHelmet
  306
  texture: "iron_helmet"
  quality: 'green
  category: 'armor
  kind: 'head
  armor: 80
  durability: 60)


(define-item IronChestplate
  307
  texture: "iron_chestplate"
  quality: 'green
  category: 'armor
  kind: 'chest
  armor: 120
  durability: 60)


(define-item IronLeggings
  308
  texture: "iron_leggings"
  quality: 'green
  category: 'armor
  kind: 'legs
  armor: 120
  durability: 60)


(define-item IronBoots
  309
  texture: "iron_boots"
  quality: 'green
  category: 'armor
  kind: 'boots
  armor: 80
  durability: 60)


(define-item DiamondHelmet
  310
  texture: "diamond_helmet"
  quality: 'blue
  category: 'armor
  kind: 'head
  armor: 96
  durability: 100)


(define-item DiamondChestplate
  311
  texture: "diamond_chestplate"
  quality: 'blue
  category: 'armor
  kind: 'chest
  armor: 144
  durability: 100)


(define-item DiamondLeggings
  312
  texture: "diamond_leggings"
  quality: 'blue
  category: 'armor
  kind: 'legs
  armor: 144
  durability: 100)


(define-item DiamondBoots
  313
  texture: "diamond_boots"
  quality: 'blue
  category: 'armor
  kind: 'boots
  armor: 96
  durability: 100)


(define-item GoldHelmet
  314
  texture: "gold_helmet"
  quality: 'white
  category: 'armor
  kind: 'head
  armor: 48
  durability: 20)


(define-item GoldChestplate
  315
  texture: "gold_chestplate"
  quality: 'white
  category: 'armor
  kind: 'chest
  armor: 72
  durability: 20)


(define-item GoldLeggings
  316
  texture: "gold_leggings"
  quality: 'white
  category: 'armor
  kind: 'legs
  armor: 72
  durability: 20)


(define-item GoldBoots
  317
  texture: "gold_boots"
  quality: 'white
  category: 'armor
  kind: 'boots
  armor: 48
  durability: 20)


(define-item Flint
  318
  texture: "flint")


(define-item PorkchopRaw
  319
  texture: "porkchop_raw"
  category: 'food
  potency: 25
  use: eat-food)


(define-item PorkchopCooked
  320
  texture: "porkchop_cooked"
  category: 'food
  potency: 50
  use: eat-food)


(define-item Painting
  321
  texture: "painting"
  ;; category: 'later
  )


(define-item AppleGolden
  322
  texture: "apple_golden"
  quality: 'green
  category: 'food
  potency: 100
  use: eat-food)


(define-item Sign
  323
  texture: "sign")


(define-item BucketEmpty
  325
  texture: "bucket_empty")


(define-item BucketWater
  326
  texture: "bucket_water")


(define-item BucketLava
  327
  texture: "bucket_lava")


(define-item MinecartNormal
  328
  texture: "minecart_normal"
  ;; category: 'later
  )


(define-item Saddle
  329
  texture: "saddle")


(define-item RedstoneDust
  331
  texture: "redstone_dust")


(define-item Leather
  334
  texture: "leather")


(define-item BucketMilk
  335
  texture: "bucket_milk")


(define-item Brick
  336
  texture: "brick")


(define-item ClayBall
  337
  texture: "clay_ball")


(define-item Reeds
  338
  texture: "reeds")


(define-item Paper
  339
  texture: "paper")


(define-item BookNormal
  340
  texture: "book_normal")


(define-item Slimeball
  341
  texture: "slimeball")


(define-item Compass
  345
  texture: "compass")


(define-item Clock
  347
  texture: "clock")


(define-item GlowstoneDust
  348
  texture: "glowstone_dust")


(define-item FishRaw
  349
  texture: "fish_raw"
  category: 'food
  potency: 25
  use: eat-food)


(define-item FishCooked
  350
  texture: "fish_cooked"
  category: 'food
  potency: 50
  use: eat-food)


(define-item DyePowderBlack
  351
  texture: "dye_powder_black")


(define-item Bone
  352
  texture: "bone"
  ;; category: 'later
  )


(define-item Sugar
  353
  texture: "sugar")


(define-item Bed
  355
  texture: "bed")


(define-item Repeater
  356
  texture: "repeater")


(define-item Shears
  359
  texture: "shears")


(define-item SeedsMelon
  362
  texture: "seeds_melon")


(define-item BeefCooked
  364
  texture: "beef_cooked"
  category: 'food
  potency: 50
  use: eat-food)


(define-item ChickenRaw
  365
  texture: "chicken_raw"
  category: 'food
  potency: 25
  use: eat-food)


(define-item RottenFlesh
  367
  texture: "rotten_flesh")


(define-item EnderPearl
  368
  texture: "ender_pearl")


(define-item GoldNugget
  371
  texture: "gold_nugget")


(define-item PotionBottleDrinkable
  373
  texture: "potion_bottle_drinkable"
  category: 'potion
  potency: 50
  use: take-potion)


(define-item PotionBottleEmpty
  374
  texture: "potion_bottle_empty"
  category: 'potion
  potency: 50
  use: take-potion)


(define-item SpiderEye
  375
  texture: "spider_eye")


(define-item BlazePowder
  377
  texture: "blaze_powder")


(define-item Cauldron
  380
  texture: "cauldron")


(define-item NetherStar
  399
  texture: "nether_star")


(define-item NetherBrick
  405
  texture: "netherbrick")


(define-item Record13
  2256
  texture: "record_13")


(define-item RecordCat
  2257
  texture: "record_cat")


(define-item RecordBlocks
  2258
  texture: "record_blocks")


(define-item RecordChirp
  2259
  texture: "record_chirp")


(define-item RecordFar
  2260
  texture: "record_far")


(define-item RecordMall
  2261
  texture: "record_mall")


(define-item RecordMellohi
  2262
  texture: "record_mellohi")


(define-item RecordStal
  2263
  texture: "record_stal")


(define-item RecordStrad
  2264
  texture: "record_strad")


(define-item RecordWard
  2265
  texture: "record_ward")


(define-item Record11
  2266
  texture: "record_11")


(definition id-items
  (list->table
    (map (lambda (name)
           (let ((item (table-ref items name)))
             (cons (get-id item) item)))
         (table-keys items))))


(definition protected (name->item name)
  (table-ref items name))


(definition protected (id->item id)
  (table-ref id-items id #f))


(definition protected (item-image id)
  (let ((item (id->item id)))
    (and item (let ((asset (table-ref (get-item-table) (get-texture item) #f)))
                (and asset (retrieve-file asset))))))


(definition protected (block-id? id)
  (< id 256))


(definition protected (known-id? id)
  ;; integer test is a quick hack for minecraft 1.8 format
  (and (integer? id)
       (or (block-id? id)
           (id->item id))))


(definition protected (show-id? id)
  (and (or (known-id? id)
           show-unknown?)
       (useful-id? id)))


(definition protected (useful-id? id)
  (or (block-id? id)
      (let ((item (id->item id)))
        (and item (or (get-category item)
                      show-useless?)))))


(definition protected (stackable-id? id)
  (or (block-id? id)
      (let ((item (id->item id)))
        (or (not item)
            (stackable? item)))))


(definition (read-durability value)
  (if (or (not value) (eqv? value -1))
      #f
    value))

(definition (write-durability value)
  (or value -1))


;;;
;;;; Slot
;;;


(class Inventory-Slot extends View
  
  
  (property id         initialize #f accessors generate)
  (property count      initialize #f getter    generate)
  (property durability initialize #f accessors generate)
  (property rank       initialize #f accessors generate)
  
  
  (form
    (<install> size: {Dimension 48 48} draggable?: #t tooltip?: #t))
  
  
  ;;;
  ;;;; Access
  ;;;
  
  
  (method package virtual (set-count self value <fx+>)
    (set! self.count value))
  
  
  (method package (increase-count self (delta 1))
    (increase! count delta)
    (invalidate-view self))
  
  
  (method package (decrease-count self (delta 1))
    (decrease! count delta)
    (when (<= count 0)
      (set! id #f))
    (invalidate-view self))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method override (mouse-down self evt)
    (down parent self))
  
  
  (method override (right-mouse-down self evt)
    (when id
      (let ((item (id->item id)))
        (when item
          (let ((use (get-use item)))
            (when use
              (use self)))))))
  
  
  (method override (double-click self evt)
    (let ((interface (current-interface))
          (world (current-world)))
      (let ((panel (child interface 'character)))
        (when id
          (let ((item (id->item id)))
            (when item
              (case (get-category item)
                ((armor)
                 (case (get-kind item)
                   ((head)  (drop-action (rank->slot panel 103) self) (update-armor panel))
                   ((chest) (drop-action (rank->slot panel 102) self) (update-armor panel))
                   ((legs)  (drop-action (rank->slot panel 101) self) (update-armor panel))
                   ((boots) (drop-action (rank->slot panel 100) self) (update-armor panel))))
                ((weapon)
                 (case (get-kind item)
                   ((melee) (drop-action (rank->slot panel 150) self) (update-power panel))
                   ((range) (drop-action (rank->slot panel 151) self) (update-ranged-power panel))))
                ((missile)
                 (case (get-kind item)
                   ((arrow) (drop-action (rank->slot panel 152) self)))))
              (save-inventory)))))))
  
  
  ;;;
  ;;;; Drag
  ;;;
  
  
  (method override (allow-start-drag? self pos)
    id)
  
  
  (method override (drag-acquires-focus? self)
    #f)
  
  
  ;;;
  ;;;; Drop
  ;;;
  
  
  (method protected virtual (accept-drop? self drag-drop)
    (let ((sender (get-view (get-source drag-drop))))
      (is? sender Inventory-Slot)))
  
  
  (method override (current-drop self drag-drop pos)
    (and (accept-drop? self drag-drop)
         (new Drop-Target view: self user-data: #f)))
  
  
  (method override (receive-drop self sender pos drag-drop)
    (when (and (accept-drop? self drag-drop)
               (neq? sender self))
      (drop-action self sender)))
  
  
  (method package (drop-action self sender)
    (define (update-model slot id)
      (when (inventory-block-id? id)
        (reset-inventory-block slot)))
    
    (let ((sender-id (get-id sender))
          (sender-count (get-count sender))
          (sender-durability (get-durability sender))
          (sender-filter? (is? sender world.interface.crafting:Filter-Slot))
          (self-filter? (is? self world.interface.crafting:Filter-Slot)))
      (when sender-id
        (cond ;; move
              ((not id)
               (unless sender-filter?
                 (set! id sender-id)
                 (set-count self sender-count)
                 (set! durability sender-durability)
                 (update-model self sender-id))
               (unless self-filter?
                 (set-id sender #f)
                 (set-count sender #f)
                 (set-durability sender #f)))
              ;; merge
              ((and (= id sender-id) (stackable-id? id) (not self-filter?))
               (unless sender-filter?
                 (set-count self (+ count sender-count))
                 (set-count sender #f))
               (set-id sender #f)
               (set-durability sender #f))
              ;; toggle
              (else
               (unless (and self-filter? (not sender-filter?))
                 (set-id sender id)
                 (set-count sender count)
                 (set-durability sender durability)
                 (update-model sender id))
               (unless (and sender-filter? (not self-filter?))
                 (set! id sender-id)
                 (set-count self sender-count)
                 (set! durability sender-durability)
                 (update-model self sender-id))))
        (if (is? self world.interface.crafting:Filter-Slot)
            (update-filter parent)
          (when (is? sender world.interface.crafting:Filter-Slot)
            (update-filter (get-parent sender))))
        (inventory-changed)
        (invalidate-view self)
        (invalidate-view sender))))
  
  
  (method override (drop-void self drag-drop)
    (unless (is? (get-view drag-drop) Inventory-Slot)
      (set-id self #f)
      (inventory-changed)
      (invalidate-view self)))
  
  
  ;;;
  ;;;; Tooltip
  ;;;
  
  
  (method override (get-tooltip-context self pos)
    (define (present-text)
      (and id (integer? id)
        (if (block-id? id)
            (let ((block (id/durability->block id durability)))
              `(<span>
                 (<paragraph>
                   (<text> ,(->string (get-name block)))
                   (<text> " ")
                   (<text> color: World-Yellow "(block)"))))
          (let ((item (id->item id)))
            (if (not item)
                "Unknown item"
              (let ((category (get-category item)))
                `(<span>
                   (<paragraph>
                     (<text> color: ,(case (get-quality item)
                                       ((blue) 'World-Blue)
                                       ((green) 'World-Green)
                                       (else 'White))
                       ,(->string (get-name item)))
                     (<text> " ")
                     (<text> color: World-Yellow ,(if (not category) "(item)" (format "({a} item)" category))))
                   ,@(if (not durability)
                         '()
                       (let ((item-durability (get-durability item)))
                         `(""
                           (<paragraph>
                             (<text> "Durability:")
                             (<text> " ")
                             (<text> ,(format "{a} / {a}" durability item-durability)))))))))))))
    
    (let ((text (present-text))
          (bounds (get-tooltip-bounds self pos)))
      (tooltip-context self text bounds)))
  
  
  ;;;
  ;;;; Draw
  ;;;
     
  
  (method override (draw self surface context)
    (let ((bounds (get-bounds self)))
      ;; integer test is a quick hack for minecraft 1.8 format
      (when (and id (integer? id))
        (if (known-id? id)
            (begin
              (when (and durability (> id 255))
                (let ((item-durability (get-durability (id->item id))))
                  (let ((percentage (percentage durability item-durability)))
                    (cond ((<= percentage 0.)
                           (fill-rect surface (inflate-rect bounds -1 -1) {Color World-Red alpha: .5}))
                          ((<= percentage 25.)
                           (fill-rect surface (inflate-rect bounds -1 -1) {Color Dark-Yellow alpha: .6}))))))
              (let ((image (get-slot-image id (or durability -1))))
                (when image
                  (blit-surface surface image destination: {Point 1 1})))
              (when (and (user?) (and (> count 1) (stackable-id? id)))
                (let ((str (->string count)))
                  (let ((extent (get-text-extent surface str)))
                    (draw-text surface (- (get-right bounds) (get-width extent)) (- (get-bottom bounds) (get-height extent)) str {Color White})))))
          (let ((str (->string id)))
            (let ((extent (get-text-extent surface str)))
              (let ((pos (center extent (rect-size bounds))))
                (draw-text surface (get-h pos) (get-v pos) str {Color Yellow}))))))
      (frame-partial-rect surface bounds '(left top) {Color Entry-Border})
      (frame-partial-rect surface bounds '(right bottom) (right/bottom-color self))))
  
  
  (method protected virtual (right/bottom-color self)
    {Color Entry-Border alpha: .6}))


(definition protected (inventory-block-id? id)
  (and (block-id? id)
       (let ((block (id->block id)))
         (let ((present (get-present block)))
           (and (neq? present 'texture)
                (not (string? present)))))))


(definition protected (cache-inventory-block slot id durability)
  (define (inventory-block-position)
    (let ((world (current-world)))
      (let ((pos (acquire (get-root slot) slot {Point 0 0})))
        (vertex 0.
                (- (- (/ (get-height world) 2.) (cast <fl> (get-v pos))) (/ (cast <fl> slot-size) 2.))
                (+ (- (cast <fl> (get-h pos)) (/ (get-width world) 2.)) (/ (cast <fl> slot-size) 2.))))))
  
  (let ((zone (current-zone)))
    (let ((inventory-blocks (get-inventory-blocks zone))
          (slot-rank (entity-slot-rank (get-parent slot) slot)))
      (let ((info (vector-ref inventory-blocks slot-rank)))
        (if info
            (cdr info)
          (let ((block (id/durability->block id durability))
                (scaling 28.))
            (let ((entity (new Block-Entity parent: #f position: (inventory-block-position) scale: (vertex scaling scaling scaling)))
                  (present (get-present block)))
              (if present
                  (for-each-property (lambda (property value)
                                       (case property
                                         ((translate-y:)
                                          (set-position entity (vertex+& (get-position entity) (vertex& 0. value 0.))))
                                         ((translate-z:)
                                          (set-position entity (vertex+& (get-position entity) (vertex& 0. 0. value))))
                                         ((scaling:)
                                          (set-scale entity (vertex value value value)))
                                         ((rotate-x:)
                                          (rotate-upon entity (degree->radian value) (vertex& 1. 0. 0.)))
                                         ((rotate-y:)
                                          (rotate-upon entity (degree->radian value) (vertex& 0. 1. 0.)))
                                         ((rotate-z:)
                                          (rotate-upon entity (degree->radian value) (vertex& 0. 0. 1.)))))
                                     present)
                (rotate entity (degree->radian -45.))
                (rotate-upon entity (degree->radian 30.) (vertex& 0. 0. 1.)))
              (set-model entity (get-name block))
              (bake-entity-uniform-lighting entity 60. 0. baked-sun)
              (vector-set! inventory-blocks slot-rank (cons slot entity))
              entity)))))))


(definition protected (reset-inventory-block slot)
  (let ((zone (current-zone)))
    (let ((inventory-blocks (get-inventory-blocks zone))
          (slot-rank (entity-slot-rank (get-parent slot) slot)))
      (vector-set! inventory-blocks slot-rank #f))))

(definition protected (reset-inventory-blocks)
  (let ((zone (current-zone+)))
    (when zone
      (let ((inventory-blocks (get-inventory-blocks zone)))
        (loop (for rank from 0 below (vector-length inventory-blocks))
              (vector-set! inventory-blocks rank #f))))))

(definition protected (reset-inventory-chest)
  (let ((zone (current-zone)))
    (let ((inventory-blocks (get-inventory-blocks zone)))
      (loop (for rank from 36 below (vector-length inventory-blocks))
            (vector-set! inventory-blocks rank #f)))))


(definition protected cache-inventory-camera
  (let ((inventory-camera #f))
    (lambda ()
      (or inventory-camera
          (let ((world (current-world))
                (cam (make-camera)))
            (set-screen-width cam (get-width world))
            (set-screen-height cam (get-height world))
            (set-position cam (vertex -100. 0. 0.))
            (init-lookat cam (vertex 1. 0. 0.) (vertex 0. 1. 0.))
            (set-projection cam 'orthographic)
            (derive-target cam)
            (camera-update cam)
            (prepare-projection cam)
            (prepare-view cam)
            (set! inventory-camera cam)
            cam)))))


(definition public (draw-slots)
  (let ((interface (current-interface)))
    (when (or (get-visible? (child interface 'belt))
              (get-visible? (child interface 'bag))
              (get-visible? (child interface 'chest))
              (get-visible? (child interface 'crafting)))
      (let ((preserved-camera (current-camera)))
        (prepare-view (cache-inventory-camera))
        (set-current-camera (cache-inventory-camera))
        (glClear GL_DEPTH_BUFFER_BIT)
        (draw-items)
        (set-current-camera preserved-camera)))))


(definition private (draw-items)
  (let ((interface (current-interface)))
    (define (draw-panels name)
      (let ((top-panel (child interface name)))
        (when (get-visible? top-panel)
          (iterate-panels top-panel
            draw-panel))))
    
    (define (draw-panel panel)
      (let ((table (get-slot-table panel)))
        (iterate-table table
          (lambda (rank slot)
            (let ((id (get-id slot))
                  (durability (get-durability slot)))
              (when (and id (inventory-block-id? id))
                ;; quick hack for sejour to better understand
                (let ((block (id/durability->block id durability)))
                  (when (get-generic? block)
                    (set! durability 0)))
                (let ((entity (cache-inventory-block slot id durability)))
                  (register-entity entity))))))))
    
    (reset-renderers)
    (draw-panels 'belt)
    (draw-panels 'bag)
    (draw-panels 'chest)
    (draw-panels 'crafting)
    (render-opaque)
    (render-transparent)))


(interface Inventory-Container
  
  
  (method virtual (iterate-panels self proc))
  (method virtual (entity-slot-rank self slot)))


;;;
;;;; Inventory
;;;


(class Inventory-Panel extends World-Panel implements Inventory-Container
  
  
  (slot slot-table initialize (make-table) getter generate)
  
  
  ;; removing slots background and drawing them first is
  ;; a quick hack around slots being drawn over everything
  @wait
  (form
    (<install> background: {Color Black alpha: 0.3}))
  
  
  (method override (iterate-panels self proc)
    (proc self))
  
  
  (method package (rank->slot self rank)
    (table-ref slot-table rank))
  
  
  (method override (entity-slot-rank self slot)
    (get-rank slot))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method protected virtual (setup-inventory self offset width height)
    (loop (for y from 0 below height)
          (loop (for x from 0 below width)
                (let ((rank (+ offset (+ x (* y width)))))
                  (let ((view (new Inventory-Slot parent: self position: (new Point (* x slot-size) (* y slot-size)) size: (new Dimension slot-size slot-size) rank: rank)))
                    (table-set! slot-table rank view))))))
  
  
  (method package (reset-inventory self)
    (iterate-table slot-table
      (lambda (id view)
        (set-id view #f))))
  
  
  (method package virtual (view-inventory self)
    (let ((zone (current-zone)))
      (reset-inventory self)
      (let ((level (get-level-state zone)))
        (let ((inventory (list-payload-content (tag-assoc "Inventory" (tag-assoc "Player" (tag-assoc "Data" (tag-value level)))))))
          (for-each (lambda (item)
                      (let ((id (tag-assoc "id" item))
                            (count (tag-assoc "Count" item))
                            (durability (tag-assoc "Durability" item))
                            (rank (tag-assoc "Slot" item)))
                        (when (show-id? id)
                          (let ((view (table-ref slot-table rank #f)))
                            (when view
                              (set-id view id)
                              (set-count view count)
                              (set-durability view (read-durability durability)))))))
                    inventory)))))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method package virtual (down self evt)
    )
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method override (draw self surface context)
    (let ((bounds (get-bounds self)))
      (frame-partial-rect surface bounds '(right bottom) {Color Entry-Border}))))


;;;
;;;; Bag
;;;


(class Bag-Panel extends Inventory-Panel
  
  
  (method override (conclude self initargs)
    (nextmethod self initargs)
    (setup-inventory self 9 9 3)))


;;;
;;;; Belt
;;;


;; global to survive role change
(definition protected belt-selection
  0)


(class Belt-Panel extends Inventory-Panel
  
  
  (method override (conclude self initargs)
    (nextmethod self initargs)
    (setup-inventory self 0 9 1))
  
  
  (method override (down self slot)
    (set-selection self (find children slot)))
  
  
  (method package (selected-slot self)
    (list-ref children belt-selection))
  
  
  (method package (set-selection self rank)
    (set! belt-selection rank)
    (invalidate-view self))
  
  
  (method package (cycle-selection self d)
    (unless (= d 0)
      (set-selection self (modulo ((if (< d 0) + -) belt-selection 1) (length children)))))
  
  
  (method override (draw-children self surface nodes context)
    (nextmethod self surface nodes context)
    (let ((world (current-world)))
      (when (and belt-selection (not (get-showcase world)))
        (let ((slot (selected-slot self)))
          (let ((outer (expand-rect (acquire self slot (get-bounds slot)) 0 0 1 1)))
            (let ((inner (inflate-rect outer -1 -1))
                  (color {Color red: .072 green: .072 blue: .995}))
              (frame-rect surface outer color)
              (frame-rect surface inner color))))))))


;;;
;;;; Chest
;;;


(class Chest-Panel extends Inventory-Panel
  
  
  (slot section initialize #f getter generate)
  (slot data    initialize #f getter generate)
  
  
  (method override (conclude self initargs)
    (nextmethod self initargs)
    (setup-inventory self 0 9 3))
  
  
  (method override (entity-slot-rank self slot)
    (+ 36 (get-rank slot)))
  
  
  (method package (view-chest self section data)
    (set! self.section section)
    (set! self.data data)
    (reset-inventory self)
    (let ((inventory (list-payload-content (tag-assoc "Items" data))))
      (for-each (lambda (item)
                  (let ((id (tag-assoc "id" item))
                        (count (tag-assoc "Count" item))
                        (durability (tag-assoc "Durability" item))
                        (rank (tag-assoc "Slot" item)))
                    (when (show-id? id)
                      (let ((view (rank->slot self rank)))
                        (set-id view id)
                        (set-count view count)
                        (set-durability view (read-durability durability))))))
                inventory))))


;;;
;;;; Add
;;;


(definition public (deposit-inventory block/item (count: count 1) (notify-changed?: notify-changed? #t))
  (let ((interface (current-interface))
        (world (current-world)))
    (let ((id (if (is? block/item Block) (get-id block/item) (get-id block/item)))
          (durability (if (is? block/item Block) (get-variant-id block/item) (get-durability block/item))))
      (continuation-capture
        (lambda (done)
          (define (deposit view)
            (define (save&return slot)
              (save-inventory)
              (when notify-changed?
                (inventory-changed))
              (when (is? view Belt-Panel)
                (set-visible? view #t)
                (set-selection view (get-rank slot)))
              (continuation-return done #f))
            
            ;; increase existing stack
            (for-each (lambda (slot)
                        (when (and (eqv? (get-id slot) id) (if durability (eqv? durability (get-durability slot)) #t))
                          (when (stackable-id? id)
                            (increase-count slot count))
                          (save&return slot)))
                      (get-children view))
            ;; add to first free slot
            (for-each (lambda (slot)
                        (when (not (get-id slot))
                          (set-id slot id)
                          (set-durability slot durability)
                          (set-count slot count)
                          (when (inventory-block-id? id)
                            (reset-inventory-block slot))
                          (invalidate-view slot)
                          (save&return slot)))
                      (get-children view)))
          
          (let ((bag-panel (child interface 'bag))
                (belt-panel (child interface 'belt)))
            (deposit belt-panel)
            (deposit bag-panel))
          (bell)
          (display-message world "Inventory is full!"))))))


(definition public (inventory-changed)
  (invalidate-recipes (child (current-interface) 'crafting)))


;;;
;;;; Save
;;;


(definition (inventory-save list-payload proc)
  (set-list-payload-content list-payload
                            TAG_Compound
                            (let ((queue (new-queue)))
                              (define (add-slot slot)
                                (let ((id (get-id slot))
                                      (count (get-count slot))
                                      (durability (get-durability slot))
                                      (rank (get-rank slot)))
                                  (when id
                                    (enqueue queue (list (make-tag "id" TAG_Int id)
                                                         (make-tag "Count" TAG_Int count)
                                                         (make-tag "Durability" TAG_Int (write-durability durability))
                                                         (make-tag "Slot" TAG_Int rank))))))
                              
                              (proc add-slot)
                              (queue-list queue))))


(definition protected (save-inventory)
  (let ((interface (current-interface))
        (zone (current-zone)))
    (let ((level (get-level-state zone)))
      (let ((character-panel (child interface 'character))
            (bag-panel (child interface 'bag))
            (belt-panel (child interface 'belt))
            (list-payload (tag-assoc "Inventory" (tag-assoc "Player" (tag-assoc "Data" (tag-value level))))))
        (inventory-save list-payload
          (lambda (add-slot)
            (for-each add-slot (collect-type Inventory-Slot (get-children character-panel)))
            (for-each add-slot (get-children belt-panel))
            (for-each add-slot (get-children bag-panel))))))))


(definition protected (save-chest (save-region?: save-region? #f))
  (let ((interface (current-interface)))
    (let ((chest (child interface 'chest)))
      (when (get-visible? chest)
        (let ((list-payload (tag-assoc "Items" (get-data chest))))
          (inventory-save list-payload
            (lambda (add-slot)
              (for-each add-slot (get-children chest)))))
        (when save-region?
          (let ((section (get-section chest)))
            (let ((chunk (get-chunk section)))
              (modified chunk)
              (save-region (get-region chunk))))))))))
