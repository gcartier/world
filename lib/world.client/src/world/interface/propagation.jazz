;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Propagation Debugger
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.interface.propagation jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.jml)
        (jazz.ui)
        (world)
        (world.autoload)
        (world.interface.frame)
        (world.interface.inventory)
        (world.section)
        (world.syntax (phase syntax)))


(definition protected propagation-size
  16)

(definition protected propagation-slot-size
  32)


(definition (propagation-index x y)
  (+ x (* y propagation-size)))


(definition dummy-section
  #f)

(definition (cache-dummy-section)
  (or dummy-section
      (let ((section (new World-Section #f #f #f #f)))
        (set-sector~ section #f)
        (set! dummy-section section)
        section)))


(definition propagation-reads
  0)

(definition propagation-writes
  0)

(definition propagation-start
  0)


(definition propagation-step?
  #f)

(definition propagation-last
  #f)

(definition propagation-exit
  #f)

(definition propagation-continuation
  #f)


(definition (toggle-step)
  (let ((world (current-world)))
    (set! propagation-step? (not propagation-step?))
    (set! propagation-last #f)
    (display-on/off~ world "Step" propagation-step?))
  (step-over))


(definition (step-over)
  (when propagation-continuation
    (let ((cont propagation-continuation))
      (set! propagation-continuation #f)
      (continuation-return cont #f))))


(definition protected (propagation-stepping? section)
  (and (eq? section (cache-dummy-section))
       propagation-step?))


;;;
;;;; Slot
;;;


(class Propagation-Slot extends View
  
  
  (property x     initialize #f accessors generate)
  (property y     initialize #f accessors generate)
  (property idx   initialize #f accessors generate)
  (property id    initialize 0  accessors generate)
  (property light initialize 0  accessors generate)
  
  
  ;;;
  ;;;; Draw
  ;;;
     
  
  (method override (draw surface context)
    (let ((bounds (get-bounds)))
      (when (and id (/= id 0) (< id 256))
        (blit-surface~ surface (get-slot-image id) destination: {Point 1 1})
        (unless (= id 1)
          (let ((str (->string id)))
            (let ((extent (get-text-extent~ surface str)))
              (draw-text~ surface (- (get-right~ bounds) (get-width~ extent)) (- (get-bottom~ bounds) (get-height~ extent)) str {Color White})))))
      (let ((str (->string light)))
        (let ((extent (get-text-extent~ surface str)))
          (let ((pos (center extent (rect-size bounds)))
                (color (if (eqv? propagation-last idx) {Color Red} {Color Yellow})))
            (draw-text~ surface (get-h~ pos) (get-v~ pos) str color))))
      (frame-partial-rect~ surface bounds '(left top) {Color Entry-Border})
      (frame-partial-rect~ surface bounds '(right bottom) {Color Entry-Border alpha: .6})))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (define (add-sector sector)
    )
  
  
  (define (with-field i j k proc)
    (proc (and  (>= i 0)
                (< i propagation-size)
                (= j 0)
                (>= k 0)
                (< k propagation-size)
                (cache-dummy-section))
          (propagation-index i k)))
  
  
  (method (block-ref section index)
    (increase! propagation-reads)
    (let ((slot (propagation-slot~ parent index)))
      (if slot
          (get-id~ slot)
        0)))
  
  
  (method (block-set! section index id)
    (increase! propagation-writes)
    (let ((slot (propagation-slot~ parent index)))
      (when slot
        (set-id~ slot id)
        (when propagation-step?
          (set! propagation-last index)
          (continuation-capture
            (lambda (cont)
              (set! propagation-continuation cont)
              (let ((exit propagation-exit))
                (set! propagation-exit #f)
                (continuation-return exit #f))))))))
  
  
  (method (blocklight-ref section index)
    (increase! propagation-reads)
    (let ((slot (propagation-slot~ parent index)))
      (if slot
          (get-light~ slot)
        0)))
  
  
  (method (blocklight-set! section index light)
    (increase! propagation-writes)
    (let ((slot (propagation-slot~ parent index)))
      (when slot
        (set-light~ slot light)
        (when propagation-step?
          (set! propagation-last index)
          (continuation-capture
            (lambda (cont)
              (set! propagation-continuation cont)
              (let ((exit propagation-exit))
                (set! propagation-exit #f)
                (continuation-return exit #f))))))))
  
  
  (method (skylight-ref section index)
    (increase! propagation-reads)
    0)
  
  
  (method (skylight-set! section index light)
    (increase! propagation-writes))
  
  
  (method (powerlevel-ref section index)
    (increase! propagation-reads)
    0)
  
  
  (method (powerlevel-set! section index light)
    (increase! propagation-writes))
  
  
  (method override (mouse-down evt)
    (let ((game (current-game))
          (region #f)
          (sector #f))
      (continuation-capture
        (lambda (exit)
          (set! propagation-reads 0)
          (set! propagation-writes 0)
          (set! propagation-start (real-time))
          (set! propagation-exit exit)
          (delete-block~ game region sector 1 0 x 0 y 0. 0. 0. #f #f add-sector with-field block-ref block-set! #f #f blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!)
          (set! propagation-last #f)
          (report-reads&writes)))
      (invalidate-view~ parent)
      (when propagation-exit
        (let ((exit propagation-exit))
          (set! propagation-exit #f)
          (continuation-return exit #f)))))
  
  
  (method override (right-mouse-down evt)
    (let ((game (current-game))
          (region #f)
          (sector #f))
      (continuation-capture
        (lambda (exit)
          (set! propagation-reads 0)
          (set! propagation-writes 0)
          (set! propagation-start (real-time))
          (set! propagation-exit exit)
          (let ((id (if (get-control?~ evt) 50 1)))
            (add-block~ game #f id region sector 1 0 x 0 y 0. 0. 0. #f #f add-sector with-field block-ref block-set! #f #f blocklight-ref blocklight-set! skylight-ref skylight-set! powerlevel-ref powerlevel-set!))
          (set! propagation-last #f)
          (report-reads&writes)))
      (invalidate-view~ parent)
      (when propagation-exit
        (let ((exit propagation-exit))
          (set! propagation-exit #f)
          (continuation-return exit #f)))))
  
  
  (method (report-reads&writes)
    (let ((world (current-world))
          (duration (seconds->milliseconds (- (real-time) propagation-start))))
      (display-message~ world (format "{a} read{a} and {a} write{a} ({a}ms)" propagation-reads (format-plural propagation-reads) propagation-writes (format-plural propagation-writes) duration)))))


;;;
;;;; Frame
;;;


(class Propagation-Frame extends World-Frame
  
  
  (form
    (<install>                                layout-type: border
      (<caption~>                             title: "Propagation")
      (<content~>                             layout-type: fill
        (<Propagation-View> name: propagation))))
  
  
  (method override (focus-default)
    (acquire-focus~ (locate 'propagation))))


;;;
;;;; Frame
;;;


(class Propagation-View extends View
  
  
  (slot slot-table initialize (make-table) getter generate)
  (slot data       initialize #f           getter generate)
  
  
  (form
    (<install> background: {Color Black alpha: 0.3}))
  
  
  (method override (conclude initargs)
    (nextmethod initargs)
    (setup-propagation))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method (propagation-slot index)
    (table-ref slot-table index #f))
  
  
  (method (setup-propagation)
    (loop (for x from 0 below propagation-size)
          (loop (for y from 0 below propagation-size)
                (let ((index (propagation-index x y)))
                  (let ((view (new Propagation-Slot parent: self position: (new Point (* x propagation-slot-size) (* y propagation-slot-size)) size: (new Dimension propagation-slot-size propagation-slot-size) x: x y: y idx: index)))
                    (table-set! slot-table index view))))))
  
  
  (method (reset-propagation)
    (iterate-table slot-table
      (lambda (index view)
        (set-id~ view 0)
        (set-light~ view 0)
        (invalidate-view))))
  
  
  ;;;
  ;;;; Keyboard
  ;;;
  
  
  (method override (key-press evt)
    (case (get-key~ evt)
      ((#\s)
       (continuation-capture
         (lambda (cont)
           (set! propagation-exit cont)
           (toggle-step)))
       (invalidate-view))
      ((#\r)
       (reset-propagation))
      ((#\space)
       (continuation-capture
         (lambda (cont)
           (set! propagation-exit cont)
           (step-over)))
       (invalidate-view))))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method override (draw surface context)
    (let ((bounds (get-bounds)))
      (frame-partial-rect~ surface bounds '(right bottom) {Color Entry-Border})))))
