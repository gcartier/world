;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Chronology Panel
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.interface.chronology jazz


(import (jazz.cairo)
        (jazz.component)
        (jazz.event)
        (jazz.graphic)
        (jazz.syntax (phase syntax))
        (profiler)
        (world)
        (world.autoload)
        (world.biome)
        (world.change)
        (world.context)
        (world.foreign)
        (world.geometry)
        (world.history)
        (world.interface.panel)
        (world.layer)
        (world.player)
        (world.profiling)
        (world.syntax (phase syntax)))


(proclaim (warn optimizations))


;;;
;;;; Player
;;;


(definition protected (draw-chronology)
  (let ((world (current-world))
        (interface (current-interface)))
    (let ((view (child interface 'chronology))
          (sheet (get-chronology-sheet world)))
      (unless (get-uptodate? view)
        (let ((texture (get-texture sheet)))
          (let ((surface (get-surface texture))
                (data (get-data texture)))
            (draw-view view surface data)
            (map-texture texture)
            (set-uptodate? view #t))))
      (let ((x (cast <fl> (get-left view)))
            (y (cast <fl> (get-top view)))
            (h (cast <fl> (get-height view))))
        (let ((matrix (make-translation-matrix (vertex x (- (get-height world) y h) 0.))))
          (render-sheet sheet matrix))))))


(definition protected (update-chronology (force?: force? #f))
  (let ((interface (current-interface+))
        (history (current-history)))
    (when interface
      (let ((panel (child interface 'chronology)))
        (unless (= (get-count chronology) 0)
          (unless (and (get-from panel) (not force?))
            (let ((f (chronological-time chronology (first-position chronology)))
                  (l (chronological-time chronology (last-position chronology))))
              (set-from panel (max f (- l 5.)))
              (set-to panel l)))
          (set-uptodate? panel #f))))))


;;;
;;;; Chronology
;;;


(class Chronology-Panel extends World-Panel
  
  
  (slot scale        <fl> initialize 0  accessors generate)
  (slot sampling     <fx> initialize 2  accessors generate)
  (slot from         <fl> initialize #f accessors generate)
  (slot to           <fl> initialize #f accessors generate)
  (slot uptodate?         initialize #f accessors generate)
  ;; scroll code is a copy/paste from showcase
  (slot point             initialize #f getter generate)
  (slot moved?            initialize #f getter generate)
  (slot scrolled?         initialize #f getter generate)
  (slot last-to           initialize #f getter generate)
  (slot last-seconds      initialize #f getter generate)
  (slot last-speed        initialize #f getter generate)
  (slot pulse             initialize #f getter generate)
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method override (mouse-down self evt)
    (when (and from to)
      (set! point (get-h evt))
      (set! moved? #f)
      (set! last-to to)
      (set! last-seconds (current-seconds))
      (set! last-speed #f)
      (kill-autoscroll self)))
  
  
  (method override (drag-move self evt)
    (when (and from to)
      (let ((h (get-h evt)))
        (when (and point (not (near? h point 2)) @w head @w tail)
          (let ((span (- to from)))
            (let ((delta (* (/ (cast <fl> (- h point)) (cast <fl> (get-width self))) (- span)))
                  (head (chronological-time chronology (first chronology)))
                  (tail (chronological-time chronology (last chronology))))
              (set! to (min (max (+ to delta) head) tail))
              (set! from (- to span))
              (set-uptodate? self #f)
              @w
              (let ((position (get-position camera)))
                (let ((new-z (+ (vertex-z position) delta)))
                  (vertex-z-set! position (min (max new-z head) tail))
                  (derive-target camera)
                  (camera-update camera))))
            (set! point h)
            (set! moved? #t)
            (let ((new-to to)
                  (new-seconds (current-seconds))
                  (old-to last-to)
                  (old-seconds last-seconds))
              (set! last-to new-to)
              (set! last-seconds new-seconds)
              (unless (= new-seconds old-seconds)
                (let ((new-speed (/ (- new-to old-to) (- new-seconds old-seconds)))
                      (p .9))
                  (set! last-speed (+ (* new-speed (- 1. p)) (* (or last-speed 0.) p)))))))))))

  
  (method override (mouse-up self evt)
    (when (and from to)
      (when (or (not moved?) (< (- (current-seconds) last-seconds) .1))
        (if (and moved? @w head @w tail)
            (begin
              (set! scrolled? #f)
              (start-autoscroll self))
          (set! point (get-h evt))
          (set! moved? #f)
          (set! scrolled? #f)
          (set! last-speed #f)
          (kill-autoscroll self)))))
  
  
  (method override (double-click self evt)
    )
  
  
  (method override (mouse-wheel self pos delta)
    (when (and from to)
      (let ((d (get-v delta)))
        (cond ((> d 0)
               (zoom-in self))
              ((< d 0)
               (zoom-out self))))))
  
  
  (method package (zoom-in self)
    (let ((h (get-h (mouse-position self)))
          (width (get-width self))
          (span (- to from)))
      (let ((proportion (/ (cast <fl> h) (cast <fl> width))))
        (let ((when (+ from (* span proportion)))
              (new-span (* span .75)))
          (let ((new-from (- when (* new-span proportion)))
                (new-to (+ when (* new-span (- 1. proportion)))))
            (set! from new-from)
            (set! to new-to)
            (set-uptodate? self #f))))))
  
  
  (method package (zoom-out self)
    (let ((h (get-h (mouse-position self)))
          (width (get-width self))
          (span (- to from)))
      (let ((proportion (/ (cast <fl> h) (cast <fl> width))))
        (let ((when (+ from (* span proportion)))
              (new-span (/ span .75)))
          (let ((new-from (- when (* new-span proportion)))
                (new-to (+ when (* new-span (- 1. proportion)))))
            (set! from new-from)
            (set! to new-to)
            (set-uptodate? self #f))))))
  
  
  (method (h->when self span h)
    (let ((width (get-width self)))
      (cond ((< h 0)
             from)
            ((> h width)
             to)
            (else
             (+ from (* span (/ (cast <fl> h) (cast <fl> width))))))))
  
  
  (method (when->h self when)
    (fxround (* (/ (- when from) (- to from)) (cast <fl> (get-width self)))))
  
  
  ;;;
  ;;;; Autoscroll
  ;;;
  
  
  (method (start-autoscroll self)
    (set! pulse (new Pulse 'autoscroll 0.01 (~ autoscroll-action self) delay: 0)))
  
  
  (method (kill-autoscroll self)
    (when pulse
      (close pulse)
      (set! pulse #f)))
  
  
  (method (autoscroll-action self)
    (execute-event
      (lambda ()
        (when last-speed
          (let ((actual-to to))
            (let ((scroll-to (+ actual-to (/ last-speed 100.))))
              (let ((new-to scroll-to))
                (when (/= new-to actual-to)
                  (set! scrolled? #t)
                  (let ((span (- to from)))
                    (let ((new-from (- new-to span)))
                    (set! to new-to)
                    (set! from new-from)
                    (set-uptodate? self #f)
                    (let ((head (chronological-time chronology (first chronology)))
                          (tail (chronological-time chronology (last chronology))))
                      (when (or (<= new-from head)
                                (>= new-to tail))
                        (set! scrolled? #f)
                        (kill-autoscroll self)))))))))))))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method package (update self time <fl>)
    (when (and from to)
      (let ((half (/ (- to from) 2.)))
        (set! from (- time half))
        (set! to (+ time half))
        (set-uptodate? self #f))))
  
  
  ;;;
  ;;;; Drawing
  ;;;


  (method package (draw-view self surface <Surface> data)
    (clear surface)
    (fill-rect surface (new Rect 0 0 (get-width self) (get-height self)) {Color red: .000 green: .000 blue: .000 alpha: .350})
    (draw-chronology self surface)
    (frame-rect surface (new Rect 0 0 (get-width self) (get-height self)) {Color Entry-Border}))
  
  
  (method (draw-chronology self surface <Surface>)
    (when (and from to)
      (plot-time self surface)
      (plot-history self surface)
      (plot-units self surface)
      (plot-sites self surface)))
  
  
  (method (plot-time self surface <Surface>)
    (let ((width (cast <fl> (get-width self)))
          (height (cast <fl> (get-height self)))
          (v 15.))
      (set-color surface {Color Medium-Gray})
      (set-line-width surface 1)
      (move-to surface 0 v)
      (line-to surface width v)))
  
  
  (method (plot-units self surface <Surface>)
    (let ((width (cast <fl> (get-width self)))
          (height (cast <fl> (get-height self)))
          (v 15.))
      (set-color surface {Color Medium-Gray})
      (set-line-width surface 1)
      (loop (for s from (fxceiling from) to (fxfloor to))
            (let ((h (when->h self (cast <fl> s))))
              (move-to surface h (- v 5.))
              (line-to surface h (+ v 6.))))))
  
  
  (method (plot-history self surface <Surface>)
    (let ((history (current-history)))
      (let ((width (cast <fl> (get-width self)))
            (height (cast <fl> (get-height self)))
            (first (history-first history))
            (last (history-last history))
            (now (get-now history))
            (changes (get-changes history))
            (span (- to from))
            (v 15))
        (define (plot-change n)
          (let ((time (historical-time history n)))
            (when (between? time from to)
              (let ((change (id->change (historical-change-id history n))))
                (let ((h (fxround (* (/ (- time from) span) width)))
                      (color (case (get-name change)
                               ((move) {Color Purple})
                               ((lookat) {Color Blue})
                               ((animate) {Color Blue})
                               ((edit-script update-script) {Color Ochre})
                               ((fire) {Color Green})
                               ((spawn) {Color Green})
                               ((die) {Color Red})
                               ((add-block delete-block add-entity remove-entity) {Color Green})
                               ((action interact) {Color Green})
                               (else {Color Light-Gray}))))
                  (if (= n now)
                      (fill-rect surface (new Rect (- h 2) (- v 5) (+ h 3) (+ v 6)) color)
                    (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color)))))))
        
        (loop (for n from first to last)
              (unless (= n now)
                (plot-change n)))
        (plot-change now))))
  
  
  (method (plot-sites self surface <Surface>)
    (let ((dark-purple {Color red: .464 green: .141 blue: .732})
          (purple {Color Purple})
          (cyan {Color red: .120 green: .624 blue: .616}))
      (plot-calls self surface 'memory {Color Red} 10)
      (plot-calls self surface 'register-literal {Color Yellow} 10)
      (plot-calls self surface 'registered-id {Color Green} 10)
      (plot-calls self surface 'retrieve-region dark-purple 10)
      (plot-calls self surface 'retrieve-chunk purple 10)
      (plot-calls self surface 'retrieve-entity {Color Blue} 10)
      (plot-calls self surface 'client-update cyan 10)
      (plot-calls self surface 'processor-update cyan 10)
      (plot-calls self surface 'network {Color Orange} 9)
      (plot-calls self surface 'render {Color Blue} 8)
      (plot-calls self surface 'event {Color Yellow} 7)
      (plot-calls self surface 'message {Color Yellow} 7)
      (plot-calls self surface 'player {Color Green} 6)
      (plot-calls self surface 'physical {Color Blue} 5)
      (plot-calls self surface 'visual dark-purple 4)
      (plot-calls self surface 'generate purple 3)
      ;; quicky for others
      (for-each (lambda (name)
                  (plot-calls self surface name {Color Ochre} 2))
                '(;alive animate audio creature distance eat event
                  ;gravity instantiate lava memory missile music
                  ;redstone simulation spawn sun tick water
                  ))))
  
  
  (method (plot-calls self surface <Surface> name color bar-rank <fl>)
    (set-color surface color)
    (set-line-width surface 1)
    (let ((width (cast <fl> (get-width self)))
          (height (cast <fl> (get-height self)))
          (bar-height (* bar-rank 7.5))
          (span (- to from))
          (site (find-site name)))
      (when site
        (let ((id (cast <fl> (cast <fx> (get-id site))))
              (start #f))
          (loop (for n from (first-position chronology) to (last-position chronology))
                (when (= (chronological-id chronology n) id)
                  (let ((marker (chronological-marker chronology n)))
                    (if (even? (flonum->fixnum marker))
                        (set! start (chronological-time chronology n))
                      (when start
                        (let ((end (chronological-time chronology n)))
                          (let ((f (* (/ (- start from) span) width))
                                (t (* (/ (- end from) span) width))
                                (bottom height)
                                (top (- height bar-height)))
                            (when (or (between? f 0. width)
                                      (between? t 0. width)
                                      (and (< f 0.)
                                           (> t width)))
                              (let ((left (round f))
                                    (right (round t)))
                                (move-to surface left bottom)
                                (line-to surface left top)
                                (move-to surface left top)
                                (line-to surface right top)
                                (move-to surface right top)
                                (line-to surface right bottom))))))))))))))))
