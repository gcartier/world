;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Showcase
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.interface.showcase jazz


(import (jazz.event)
        (jazz.opengl.glew)
        (world)
        (world.autoload)
        (world.camera)
        (world.draw)
        (world.dye)
        (world.dyes)
        (world.geometry)
        (world.interface.actions)
        (world.light)
        (world.lighting)
        (world.movement)
        (world.plane)
        (world.renderer)
        (world.renderers)
        (world.scene)
        (world.settings)
        (world.sound)
        (world.syntax (phase syntax))
        (world.window))


(class World-Showcase extends Scene
  
  
  (property category initialize #f accessors generate)
  
  
  (slot showing      initialize #f getter generate)
  (slot elements     initialize #f getter generate)
  (slot selection    initialize #f getter generate)
  (slot camera       initialize #f getter generate)
  (slot head         initialize #f getter generate)
  (slot tail         initialize #f getter generate)
  (slot top          initialize #f getter generate)
  (slot bottom       initialize #f getter generate)
  (slot point        initialize #f getter generate)
  (slot moved?       initialize #f getter generate)
  (slot scrolled?    initialize #f getter generate)
  (slot last-z       initialize #f getter generate)
  (slot last-seconds initialize #f getter generate)
  (slot last-speed   initialize #f getter generate)
  (slot pulse        initialize #f getter generate)
  (slot speed        initialize #f getter generate)
  
  
  ;;;
  ;;;; Activation
  ;;;
  
  
  (method protected virtual (activate)
    ;; so elements are there on first draw
    (cache-elements))
  
  
  (method protected virtual (deactivate)
    )
  
  
  ;;;
  ;;;; Category
  ;;;
  
  
  (method protected virtual  (showcase-categories)
    #f)
  
  
  (method (previous-category)
    (let ((categories (showcase-categories)))
      (when categories
        (update-category (previous-element categories category)))))
  
  
  (method (next-category)
    (let ((categories (showcase-categories)))
      (when categories
        (update-category (next-element categories category)))))
  
  
  (method (update-category cat)
    (set! category cat)
    (reset-elements)
    (when selection-sounds?
      (play-interface-sound "sound/user/selectTarget"))
    (let ((bar (showcase-bar)))
      (when (get-visible?~ bar)
        (invalidate-view~ bar))))
  
  
  ;;;
  ;;;; Elements
  ;;;
  
  
  (definition elements-mutex
    (make-mutex 'update-elements))
  
  
  (method (cache-elements)
    (let ((new-showing (showcase-showing)))
      (define (update-elements)
        (mutex-lock! elements-mutex)
        (let ((new-elements (list->vector (showcase-elements new-showing))))
          (set! showing new-showing)
          (set! elements new-elements)
          (set-selection (showcase-selection new-showing new-elements))
          (update-camera)
          (mutex-unlock! elements-mutex)
          elements))
      
      (if (and elements (eq? showing new-showing))
          elements
        (if (showcase-wait?)
            (with-window-cursor :wait
              (lambda ()
                (update-elements)))
          (update-elements)))))
  
  
  (method protected (reset-elements)
    (set! elements #f)
    (set-selection #f))
  
  
  (method protected virtual (showcase-showing)
    #f)
  
  
  (method protected virtual (showcase-vertical)
    (- 85 (case current-role
            ((user creator)
             26)
            (else
             0))))
  
  
  (method protected virtual (showcase-front)
    (- (showcase-radius)))
  
  
  (method protected virtual (showcase-back)
    (showcase-radius))
  
  
  (method protected virtual (showcase-top)
    (showcase-radius))
  
  
  (method protected virtual (showcase-bottom)
    (- (showcase-radius)))
  
  
  (method protected virtual (showcase-left)
    (- (showcase-radius)))
  
  
  (method protected virtual (showcase-right)
    (showcase-radius))
  
  
  (method protected virtual (showcase-radius)
    .5)
  
  
  (method protected virtual (showcase-spacing)
    1.)
  
  
  (method protected virtual (showcase-wait?)
    #f)
  
  
  (method protected virtual (showcase-elements showing)
    #f)
  
  
  (method protected virtual (showcase-selection showing elements)
    #f)
  
  
  (method protected virtual (element-center element)
    (get-position~ element))
  
  
  ;;;
  ;;;; Selection
  ;;;
  
  
  (method (set-selection sel)
    (let ((world (current-world)))
      (set! selection sel)
      (update-target-pane~ world)
      (refresh-interface~ world condition: '(target))))
  
  
  (method protected virtual (selection-addable?)
    #f)
  
  
  (method protected virtual (selection-update selection)
    )
  
  
  (method (draw-selection-quad quad)
    (draw-polygon quad red-dye))
  
  
  ;;;
  ;;;; Camera
  ;;;
  
  
  (method protected virtual (size-change size)
    (size-change~ (cache-camera) size)
    (update-camera))
  
  
  (method (cache-camera)
    (or camera
        (let ((world (current-world))
              (cam (make-camera)))
          (set-screen-width~ cam (get-width~ world))
          (set-screen-height~ cam (get-height~ world))
          (set-frustum-radius~ cam (showcase-spacing))
          (set-position~ cam (vertex& -10. 3.15 0.))
          (init-lookat~ cam (vertex 1. 0. 0.) (vertex 0. 1. 0.))
          (derive-target~ cam)
          (camera-update~ cam)
          (prepare-projection~ cam)
          (prepare-view~ cam)
          (set! camera cam)
          camera)))
  
  
  (method (update-camera)
    (let ((camera (cache-camera)))
      (define (bounds)
        (let ((count (vector-length (cache-elements))))
          (if (= count 0)
              (values #f #f)
            (let ((spacing (showcase-spacing)))
              (values 0.
                      (* (- count 1) spacing))))))
      
      (define (position y z)
        (let ((position (get-position~ camera)))
          (vertex! position -10. y z)
          (derive-target~ camera)
          (camera-update~ camera)))
      
      (position 0. 0.)
      (bind-values (leftmost rightmost) (bounds)
        (if (or (not leftmost) (not rightmost))
            (begin
              (set! head #f)
              (set! tail #f)
              (set! top #f)
              (set! bottom #f))
          (let ((width (fxround (get-screen-width~ camera)))
                (height (fxround (get-screen-height~ camera)))
                (vertical (showcase-vertical))
                (front (showcase-front))
                (back (showcase-back))
                (top (showcase-top))
                (bottom (showcase-bottom))
                (left (showcase-left))
                (right (showcase-right)))
            (let ((plane (new Plane (vertex front 0. 0.) (vertex -1. 0. 0.))))
              (define (screen-project h v)
                (bind-values (origin dir) (screen->world~ camera h v)
                  (let ((mvt (new Movement origin dir)))
                    (bind-values (collision-distance intersect?) (intersect-plane plane mvt)
                      (movement-end-to mvt collision-distance)))))
              
              (let ((v (- height vertical)))
                (let ((l (screen-project 12 v))
                      (r (screen-project (- width 10) v)))
                  (let ((y (+ (- (vertex-y l)) bottom)))
                    (let ((elements-width (- rightmost leftmost)))
                      (if (<= elements-width (- (vertex-z r) (vertex-z l)))
                          (begin
                            (set! head #f)
                            (set! tail #f)
                            (position y (+ leftmost (/ elements-width 2.))))
                        (set! head (+ (- leftmost (vertex-z l)) left))
                        (set! tail (max head (+ (- rightmost (vertex-z r)) right)))
                        (position y head)))))
                (update-top (get-v~ (world->screen~ camera (vertex back top 0.))))
                (update-bottom v))))))))
  
  
  (method protected virtual (update-top new-top)
    (set! top new-top))
  
  
  (method protected virtual (update-bottom new-bottom)
    (set! bottom new-bottom))
  
  
  ;;;
  ;;;; Lighting
  ;;;
  
  
  (definition model-lighting
    #f)
  
  
  (method (cache-model-lighting)
    (or model-lighting
        (let ((lighting (new Lighting)))
          (set-ambient-color~ lighting (dye 0.1 0.1 0.1 1.0))
          (set-lights~ lighting (list (new Light-Ambient position: (vertex -10. 20. -5.))))
          (set-lights-count~ lighting (length (get-lights~ lighting)))
          (set! model-lighting lighting)
          lighting)))
  
  
  (definition ambient-lighting
    #f)
  
  
  (method (cache-ambient-lighting)
    (or ambient-lighting
        (let ((lighting (new Lighting)))
          (set-ambient-color~ lighting (dye .7 .7 .7 1.0))
          (set-lights~ lighting '())
          (set-lights-count~ lighting (length (get-lights~ lighting)))
          (set! ambient-lighting lighting)
          lighting)))
  
  
  (definition texture-lighting
    #f)
  
  
  (method (cache-texture-lighting)
    (or texture-lighting
        (let ((lighting (new Lighting)))
          (set-ambient-color~ lighting (dye 0.1 0.1 0.1 1.0))
          (set-lights~ lighting (list (new Light-Ambient position: (vertex -100. 20. -5.))))
          (set-lights-count~ lighting (length (get-lights~ lighting)))
          (set! texture-lighting lighting)
          lighting)))
  
  
  (method protected virtual (showcase-lighting)
    (cache-model-lighting))
  
  
  ;;;
  ;;;; Draw
  ;;;


  (method protected virtual (draw-showcase)
    (let ((preserved-camera (current-camera))
          (preserved-lighting (current-lighting)))
      (prepare-view~ (cache-camera))
      
      ;; Setup
      (set-current-camera (cache-camera))
      (set-current-lighting (showcase-lighting))
      
      ;; Clear depth buffer
      (glClear GL_DEPTH_BUFFER_BIT)
      
      ;; Elements
      (draw-elements)
      
      ;; Selection
      (draw-selection)
      
      ;; Restore
      (set-current-lighting preserved-lighting)
      (set-current-camera preserved-camera)))


  (method protected virtual (draw-elements)
    (reset-renderers)
    (let ((camera (cache-camera))
          (elements (cache-elements)))
      (loop (for n from 0 below (vector-length elements))
            (let ((element (vector-ref elements n)))
              (when (in-frustum?~ camera (element-center element))
                (draw-element element)))))
    (render-opaque)
    (render-transparent)
    (render-orb))
  
  
  (method protected virtual (draw-element element)
    (register-entity element))
  
  
  (method protected virtual (draw-selection)
    )
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method protected virtual (in-showcase? v)
    (let ((margin 15))
      (and top bottom (between? v (- top margin) (+ bottom margin)))))
  
  
  (method protected virtual (showcase-mouse-down h v)
    (set! point h)
    (set! moved? #f)
    (set! last-z (vertex-z (get-position~ (cache-camera))))
    (set! last-seconds (current-seconds))
    (set! last-speed #f)
    (kill-autoscroll))
  
  
  (method protected virtual (showcase-mouse-drag h v)
    (when (and point (not (near? h point 2)) head tail)
      (let ((camera (cache-camera)))
        (let ((delta (/ (cast <fl> (- h point)) -100.)))
          (let ((position (get-position~ camera)))
            (let ((new-z (+ (vertex-z position) delta)))
              (vertex-z-set! position (min (max new-z head) tail))
              (derive-target~ camera)
              (camera-update~ camera))))
        (set! point h)
        (set! moved? #t)
        (let ((new-z (vertex-z (get-position~ camera)))
              (new-seconds (current-seconds))
              (old-z last-z)
              (old-seconds last-seconds))
          (set! last-z new-z)
          (set! last-seconds new-seconds)
          (unless (= new-seconds old-seconds)
            (let ((new-speed (/ (- new-z old-z) (- new-seconds old-seconds)))
                  (p .9))
              (set! last-speed (+ (* new-speed (- 1. p)) (* (or last-speed 0.) p)))))))))

  
  (method protected virtual (showcase-mouse-up h v)
    (let ((world (current-world)))
      (when (or (not moved?) (< (- (current-seconds) last-seconds) .1))
        (let ((camera (cache-camera)))
          (if (and moved? head tail)
              (begin
                (set! scrolled? #f)
                (start-autoscroll))
            (unless scrolled?
              (bind-values (position direction) (screen->world~ camera h v)
                (let ((closest (ray-closest-element position direction)))
                  (when closest
                    (bind (poly dist) closest
                      (let ((element (get-element~ poly)))
                        (unless (eq? element selection)
                          (set-selection element)
                          (selection-update selection)
                          (when selection-sounds?
                            (play-interface-sound "sound/user/selectTarget")))))))))
            (set! point h)
            (set! moved? #f)
            (set! scrolled? #f)
            (set! last-speed #f)
            (kill-autoscroll))))))
  
  
  (method protected virtual (showcase-double-click h v)
    )
  
  
  (method protected virtual (showcase-wheel reversed?)
    (when (and head tail)
      (let ((spacing (showcase-spacing))
            (camera (cache-camera)))
        (let ((position (get-position~ camera)))
          (let ((actual-z (vertex-z position)))
            (let ((scroll-z (+ actual-z (if reversed? (- spacing) spacing))))
              (let ((new-z (min (max scroll-z head) tail)))
                (when (/= new-z actual-z)
                  (set! scrolled? #t)
                  (vertex-z-set! position new-z)
                  (derive-target~ camera)
                  (camera-update~ camera)))))))))
  
  
  ;;;
  ;;;; Autoscroll
  ;;;
  
  
  (method (start-autoscroll)
    (set! pulse (new Pulse 'autoscroll 0.01 autoscroll-action delay: 0)))
  
  
  (method (kill-autoscroll)
    (when pulse
      (close~ pulse)
      (set! pulse #f)))
  
  
  (method (autoscroll-action)
    (execute-event
      (lambda ()
        (when (and head tail last-speed)
          (let ((camera (cache-camera)))
            (let ((position (get-position~ camera)))
              (let ((actual-z (vertex-z position)))
                (let ((scroll-z (+ actual-z (/ last-speed 100.))))
                  (let ((new-z (min (max scroll-z head) tail)))
                    (when (/= new-z actual-z)
                      (set! scrolled? #t)
                      (vertex-z-set! position (min (max new-z head) tail))
                      (derive-target~ camera)
                      (camera-update~ camera)
                      (when (or (<= new-z head)
                                (>= new-z tail))
                        (set! scrolled? #f)
                        (kill-autoscroll))))))))))))
  
  
  ;;;
  ;;;; Hit
  ;;;
  
  
  (method protected virtual (ray-closest-element orig <vertex> dir <vertex>)
    (let ((entities (cache-elements))
          (radius (showcase-spacing)))
      (and entities
           (let ((closest #f)
                 (distance #f))
             (loop (for n from 0 below (vector-length entities))
                   (let ((entity (vector-ref entities n)))
                     (when (ray-intersects-sphere? orig dir (get-position~ entity) radius)
                       (for-each-bounding-quad$~ entity #f
                         (lambda (p)
                           (let ((poly (copy-polygon~ p)))
                             (free-polygon$~ p)
                             (let ((cls (ray-closest-triangle~ poly orig dir #f)))
                               (when cls
                                 (bind (poly dist) cls
                                   (when (or (not distance)
                                             (< dist distance))
                                     (set! closest (list poly dist))
                                     (set! distance dist)))))))))))
             closest)))))


;;;
;;;; Showcase Bar
;;;


(definition public (showcase-bar)
  (let ((interface (current-interface)))
    (find-type~ interface World-Showcase-Bar)))


(class World-Showcase-Bar extends World-Actionbar))
