;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Showcase
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.interface.showcase jazz


(import (jazz.graphic.opengl.glew)
        (jazz.system)
        (world)
        (world.autoload)
        (world.camera)
        (world.draw)
        (world.dye)
        (world.dyes)
        (world.entity)
        (world.generate)
        (world.geometry)
        (world.material)
        (world.object)
        (world.opengl)
        (world.syntax (phase syntax))
        (world.texture))


(class World-Showcase extends Object
  
  
  (slot showing   initialize #f getter generate)
  (slot elements  initialize #f getter generate)
  (slot selection initialize #f getter generate)
  (slot camera    initialize #f getter generate)
  (slot back      initialize #f getter generate)
  (slot front     initialize #f getter generate)
  (slot head      initialize #f getter generate)
  (slot tail      initialize #f getter generate)
  (slot point     initialize #f getter generate)
  (slot moved?    initialize #f getter generate)
  
  
  ;;;
  ;;;; Activation
  ;;;
  
  
  (method protected virtual (activate)
    )
  
  
  (method protected virtual (deactivate)
    )
  
  
  ;;;
  ;;;; Elements
  ;;;
  
  
  (method (cache-elements)
    (let ((new-showing (showcase-showing)))
      (if (and elements (eq? showing new-showing))
          elements
        (let ((new-elements (list->vector (showcase-elements new-showing))))
          (set! showing new-showing)
          (set! elements new-elements)
          (set! selection (showcase-selection new-elements))
          (update-bounds)
          (update-camera)
          elements))))
  
  
  (method protected virtual (showcase-showing)
    #f)
  
  
  (method protected virtual (showcase-x)
    0.)
  
  
  (method protected virtual (showcase-y)
    -3.2)
  
  
  (method protected virtual (showcase-elements showing)
    #f)
  
  
  (method protected virtual (showcase-selection elements)
    #f)
  
  
  (method protected virtual (update-bounds)
    (let ((elements (cache-elements)))
      (let ((first (vector-ref elements 0))
            (last (vector-ref elements (- (vector-length elements) 1)))
            (x (showcase-x))
            (y (showcase-y)))
        (set! back (vertex x y (cuboid-back (get-bounds~ first))))
        (set! front (vertex x y (cuboid-front (get-bounds~ last)))))))
  
  
  ;;;
  ;;;; Selection
  ;;;
  
  
  (method protected virtual (selection-addable?)
    #f)
  
  
  (method protected virtual (selection-update selection)
    )
  
  
  ;;;
  ;;;; Camera
  ;;;
  
  
  (define screen-margin
    20)
  
  
  (method (size-change size)
    (size-change~ (cache-camera) size))
  
  
  (method (cache-camera)
    (or camera
        (let ((world (current-world))
              (cam (new Camera)))
          (set-width~ cam (get-width~ world))
          (set-height~ cam (get-height~ world))
          (vertex-copy! (get-position~ cam) (vertex -10. 0. 0.))
          (let ((lookat (get-lookat~ cam))
                (sight (vertex 1. 0. 0.))
                (up (vertex 0. 1. 0.)))
            (set-sight~ lookat sight)
            (set-up~ lookat up)
            (set-right~ lookat (cross-normal sight up)))
          (update-target~ cam)
          (setup-camera~ cam)
          (set! camera cam)
          camera)))
  
  
  (method (update-camera)
    (define (center)
      (position (/ (+ (vertex-z front) (vertex-z back)) 2.)))
    
    (define (position z)
      (let ((position (get-position~ camera)))
        (vertex-z-set! position z)
        (update-target~ camera)))
    
    (define (determine-head)
      (let ((step .1)
            (limit screen-margin))
        (let (loop (z (vertex-z back)))
          (position z)
          (if (< (get-h~ (world->screen~ camera back)) limit)
              (- z step)
            (loop (+ z step))))))
    
    (define (determine-tail)
      (let ((step .1)
            (limit (- (get-width~ camera) screen-margin)))
        (let (loop (z (vertex-z front)))
          (position z)
          (if (> (get-h~ (world->screen~ camera front)) limit)
              (+ z step)
            (loop (- z step))))))
    
    (let ((left (get-h~ (world->screen~ camera back)))
          (right (get-h~ (world->screen~ camera front))))
      (let ((width (- right left)))
        (if (<= width (get-width~ camera))
            (begin
              (set! head #f)
              (set! tail #f)
              (center))
          (set! head (determine-head))
          (set! tail (determine-tail))
          (position head)))))
  
  
  ;;;
  ;;;; Draw
  ;;;


  (method protected virtual (draw-showcase)
    ;; Preserve
    (glPushMatrix)
    (glDisable GL_LIGHTING)
    
    ;; Reset and transform the matrix
    (glMatrixMode GL_MODELVIEW)
    (glLoadIdentity)
    (setup-camera~ (cache-camera))
    
    ;; Clear depth buffer
    (glClear GL_DEPTH_BUFFER_BIT)
    
    ;; Elements
    (draw-elements)
    
    ;; Selection
    (draw-selection)
    
    ;; Restore
    (glEnable GL_LIGHTING)
    (glPopMatrix))
  
  
  (method protected virtual (draw-elements)
    )
  
  
  (method protected virtual (draw-selection)
    )
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method protected virtual (showcase-spacing)
    1.)
  
  
  (method protected virtual (showcase-mouse-down h v)
    (set! point h)
    (set! moved? #f))
  
  
  (method protected virtual (showcase-mouse-move h v)
    (when (and point (not (near? h point 2)) head tail)
      (let ((delta (/ (cast <fl> (- h point)) -100.)))
        (let ((camera (cache-camera)))
          (let ((position (get-position~ camera)))
            (let ((new-z (+ (vertex-z position) delta)))
              (vertex-z-set! position (min (max new-z head) tail))
              (update-target~ camera)))))
      (set! point h)
      (set! moved? #t)))

  
  (method protected virtual (showcase-mouse-up h v)
    (let ((world (current-world)))
      (when (not moved?)
        (receive (position direction) (screen->ray~ camera h v)
          (let ((closest (ray-closest-element position direction)))
            (when closest
              (bind (poly dist) closest
                (let ((element (get-element~ poly)))
                  (unless (eq? element selection)
                    ;; for debugging
                    (set-?s element)
                    (set! selection element)
                    (selection-update selection)
                    (when (find-setting 'world.selection-sounds? #t)
                      (play-sound-file~ world "sound/user/selectTarget"))))))))
        (set! point h)
        (set! moved? #f))))
  
  
  (method protected virtual (showcase-wheel reversed?)
    (let ((spacing (showcase-spacing))
          (camera (cache-camera)))
      (let ((position (get-position~ camera)))
        (let ((new-z (+ (vertex-z position) (if reversed? (- spacing) spacing))))
          (vertex-z-set! position (min (max new-z head) tail))
          (update-target~ camera)))))
  
  
  ;;;
  ;;;; Hit
  ;;;
  
  
  (method protected virtual (ray-closest-element orig <f64vector> dir <f64vector>)
    (let ((entities (cache-elements)))
      (when entities
        (let ((closest #f)
              (distance #f))
          (loop (for n from 0 below (vector-length entities))
                (let ((entity (vector-ref entities n)))
                  (when (ray-intersects-sphere? orig dir (get-center~ entity) (get-radius~ entity))
                    (for-each-bounding-quad~ entity #f #f
                      (lambda (poly)
                        (let ((cls (ray-closest-triangle~ poly orig dir #f)))
                          (when cls
                            (bind (poly dist) cls
                              (when (or (not distance)
                                        (< dist distance))
                                (set! closest (list poly dist))
                                (set! distance dist))))))))))
          closest))))))
