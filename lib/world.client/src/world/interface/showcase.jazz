;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Showcase
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.interface.showcase jazz


(import (jazz.graphic.opengl.glew)
        (jazz.library)
        (jazz.system)
        (world)
        (world.autoload)
        (world.camera)
        (world.draw)
        (world.dye)
        (world.dyes)
        (world.entity)
        (world.generate)
        (world.geometry)
        (world.material)
        (world.object)
        (world.opengl)
        (world.renderer)
        (world.syntax (phase syntax))
        (world.texture))


(class World-Showcase extends Object
  
  
  (slot showing      initialize #f getter generate)
  (slot elements     initialize #f getter generate)
  (slot selection    initialize #f getter generate)
  (slot camera       initialize #f getter generate)
  (slot back         initialize #f getter generate)
  (slot front        initialize #f getter generate)
  (slot head         initialize #f getter generate)
  (slot tail         initialize #f getter generate)
  (slot point        initialize #f getter generate)
  (slot moved?       initialize #f getter generate)
  (slot scrolled?    initialize #f getter generate)
  (slot last-z       initialize #f getter generate)
  (slot last-seconds initialize #f getter generate)
  (slot last-speed   initialize #f getter generate)
  (slot pulse        initialize #f getter generate)
  (slot speed        initialize #f getter generate)
  
  
  ;;;
  ;;;; Activation
  ;;;
  
  
  (method protected virtual (activate)
    ;; so elements are there on first draw
    (cache-elements))
  
  
  (method protected virtual (deactivate)
    )
  
  
  ;;;
  ;;;; Elements
  ;;;
  
  
  (method (cache-elements)
    (let ((new-showing (showcase-showing)))
      (if (and elements (eq? showing new-showing))
          elements
        (let ((new-elements (list->vector (showcase-elements new-showing))))
          (set! showing new-showing)
          (set! elements new-elements)
          (set! selection (showcase-selection new-showing new-elements))
          (update-bounds)
          (update-camera)
          elements))))
  
  
  (method protected virtual (showcase-showing)
    #f)
  
  
  (method protected virtual (showcase-margin)
    .5)
  
  
  (method protected virtual (showcase-spacing)
    1.)
  
  
  (method protected virtual (showcase-x)
    0.)
  
  
  (method protected virtual (showcase-y)
    -3.2)
  
  
  (method protected virtual (showcase-z)
    0.)
  
  
  (method protected virtual (showcase-elements showing)
    #f)
  
  
  (method protected virtual (showcase-selection showing elements)
    #f)
  
  
  (method protected virtual (element-center element)
    (get-position~ element))
  
  
  (method (update-bounds)
    (let ((count (vector-length (cache-elements))))
      (if (= count 0)
          (begin
            (set! back #f)
            (set! front #f))
        (let ((margin (showcase-margin))
              (spacing (showcase-spacing))
              (x (showcase-x))
              (y (showcase-y))
              (z (showcase-z)))
          (set! back (vertex x y (- z margin)))
          (set! front (vertex x y (+ (* (- count 1) spacing) (- z) margin)))))))
  
  
  ;;;
  ;;;; Selection
  ;;;
  
  
  (method protected virtual (selection-addable?)
    #f)
  
  
  (method protected virtual (selection-update selection)
    )
  
  
  ;;;
  ;;;; Camera
  ;;;
  
  
  (method (size-change size)
    (size-change~ (cache-camera) size))
  
  
  (method (cache-camera)
    (or camera
        (let ((world (current-world))
              (cam (new Camera)))
          (set-width~ cam (get-width~ world))
          (set-height~ cam (get-height~ world))
          (set-frustum-radius~ cam (showcase-spacing))
          (vertex-copy! (get-position~ cam) (vertex -10. 0. 0.))
          (let ((lookat (get-lookat~ cam))
                (sight (vertex 1. 0. 0.))
                (up (vertex 0. 1. 0.)))
            (set-sight~ lookat sight)
            (set-up~ lookat up)
            (set-right~ lookat (cross-normal sight up)))
          (update-target~ cam)
          (setup-camera~ cam)
          (set! camera cam)
          camera)))
  
  
  (method (update-camera)
    (let ((camera (cache-camera)))
      (define (center)
        (position (/ (+ (vertex-z front) (vertex-z back)) 2.)))
      
      (define (position z)
        (let ((position (get-position~ camera)))
          (vertex-z-set! position z)
          (update-target~ camera)))
      
      (define (determine-head)
        (let ((step .1)
              (limit 0.))
          (let (loop (z (vertex-z back)))
            (position z)
            (if (< (get-h~ (world->screen~ camera back)) limit)
                (- z step)
              (loop (+ z step))))))
      
      (define (determine-tail)
        (let ((step .1)
              (limit (get-width~ camera)))
          (let (loop (z (vertex-z front)))
            (position z)
            (if (> (get-h~ (world->screen~ camera front)) limit)
                (+ z step)
              (loop (- z step))))))
      
      (if (or (not back) (not front))
          (begin
            (set! head #f)
            (set! tail #f)
            (position 0.))
        (position 0.)
        (let ((left (get-h~ (world->screen~ camera back)))
              (right (get-h~ (world->screen~ camera front))))
          (let ((width (- right left)))
            (if (<= width (get-width~ camera))
                (begin
                  (set! head #f)
                  (set! tail #f)
                  (center))
              (set! head (determine-head))
              (set! tail (determine-tail))
              (position head)))))))
  
  
  ;;;
  ;;;; Draw
  ;;;


  (method protected virtual (draw-showcase)
    ;; Preserve
    (glPushMatrix)
    (glDisable GL_LIGHTING)
    
    ;; Reset and transform the matrix
    (glMatrixMode GL_MODELVIEW)
    (glLoadIdentity)
    (setup-camera~ (cache-camera))
    
    ;; Clear depth buffer
    (glClear GL_DEPTH_BUFFER_BIT)
    
    ;; Elements
    (draw-elements)
    
    ;; Selection
    (draw-selection)
    
    ;; Restore
    (glEnable GL_LIGHTING)
    (glPopMatrix))


  (method protected virtual (draw-elements)
    (reset-renderes)
    (let ((camera (cache-camera))
          (elements (cache-elements)))
      (loop (for n from 0 below (vector-length elements))
            (let ((element (vector-ref elements n)))
              (when (in-frustum?~ camera (element-center element))
                (register-entity element)))))
    (render-opaque)
    (render-transparent)
    (render-character))
  
  
  (method protected virtual (draw-selection)
    )
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method protected virtual (showcase-mouse-down h v)
    (set! point h)
    (set! moved? #f)
    (set! last-z (vertex-z (get-position~ (cache-camera))))
    (set! last-seconds (current-seconds))
    (set! last-speed #f)
    (kill-autoscroll))
  
  
  (method protected virtual (showcase-mouse-move h v)
    (when (and point (not (near? h point 2)) head tail)
      (let ((camera (cache-camera)))
        (let ((delta (/ (cast <fl> (- h point)) -100.)))
          (let ((position (get-position~ camera)))
            (let ((new-z (+ (vertex-z position) delta)))
              (vertex-z-set! position (min (max new-z head) tail))
              (update-target~ camera))))
        (set! point h)
        (set! moved? #t)
        (let ((new-z (vertex-z (get-position~ camera)))
              (new-seconds (current-seconds))
              (old-z last-z)
              (old-seconds last-seconds))
          (set! last-z new-z)
          (set! last-seconds new-seconds)
          (unless (= new-seconds old-seconds)
            (let ((new-speed (/ (- new-z old-z) (- new-seconds old-seconds)))
                  (p .9))
              (set! last-speed (+ (* new-speed (- 1. p)) (* (or last-speed 0.) p)))))))))

  
  (method protected virtual (showcase-mouse-up h v)
    (let ((world (current-world)))
      (when (or (not moved?) (< (- (current-seconds) last-seconds) .1))
        (let ((camera (cache-camera)))
          (if moved?
              (begin
                (set! scrolled? #f)
                (start-autoscroll))
            (unless scrolled?
              (receive (position direction) (screen->ray~ camera h v)
                (let ((closest (ray-closest-element position direction)))
                  (when closest
                    (bind (poly dist) closest
                      (let ((element (get-element~ poly)))
                        (unless (eq? element selection)
                          ;; for debugging
                          (set-?s element)
                          (set! selection element)
                          (selection-update selection)
                          (when (find-setting 'world.selection-sounds? #t)
                            (play-sound-file~ world "sound/user/selectTarget")))))))))
            (set! point h)
            (set! moved? #f)
            (set! scrolled? #f)
            (set! last-speed #f)
            (kill-autoscroll))))))
  
  
  (method protected virtual (showcase-wheel reversed?)
    (let ((spacing (showcase-spacing))
          (camera (cache-camera)))
      (let ((position (get-position~ camera)))
        (let ((actual-z (vertex-z position)))
          (let ((scroll-z (+ actual-z (if reversed? (- spacing) spacing))))
            (let ((new-z (min (max scroll-z head) tail)))
              (when (/= new-z actual-z)
                (set! scrolled? #t)
                (vertex-z-set! position new-z)
                (update-target~ camera))))))))
  
  
  ;;;
  ;;;; Autoscroll
  ;;;
  
  
  (method (start-autoscroll)
    (set! pulse (new Pulse 'autoscroll 0.01 autoscroll-action delay: 0)))
  
  
  (method (kill-autoscroll)
    (when pulse
      (close~ pulse)
      (set! pulse #f)))
  
  
  (method (autoscroll-action)
    (let ((camera (cache-camera)))
      (let ((position (get-position~ camera)))
        (let ((actual-z (vertex-z position)))
          (let ((scroll-z (+ actual-z (/ last-speed 100.))))
            (let ((new-z (min (max scroll-z head) tail)))
              (when (/= new-z actual-z)
                (set! scrolled? #t)
                (vertex-z-set! position (min (max new-z head) tail))
                (update-target~ camera)
                (when (or (<= new-z head)
                          (>= new-z tail))
                  (set! scrolled? #f)
                  (kill-autoscroll)))))))))
  
  
  ;;;
  ;;;; Hit
  ;;;
  
  
  (method protected virtual (ray-closest-element orig <f64vector> dir <f64vector>)
    (let ((entities (cache-elements))
          (radius (showcase-spacing)))
      (when entities
        (let ((closest #f)
              (distance #f))
          (loop (for n from 0 below (vector-length entities))
                (let ((entity (vector-ref entities n)))
                  (when (ray-intersects-sphere? orig dir (get-position~ entity) radius)
                    (for-each-bounding-quad~ entity #f #f
                      (lambda (poly)
                        (let ((cls (ray-closest-triangle~ poly orig dir #f)))
                          (when cls
                            (bind (poly dist) cls
                              (when (or (not distance)
                                        (< dist distance))
                                (set! closest (list poly dist))
                                (set! distance dist))))))))))
          closest))))))
