;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Compass Pane
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.interface.compass jazz


(import (jazz.cairo)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.jml)
        (jazz.ui)
        (world)
        (world.actor)
        (world.autoload)
        (world.geometry)
        (world.interface.inventory)
        (world.interface.pane)
        (world.interface.text)
        (world.interface.tooltip)
        (world.player)
        (world.settings)
        (world.syntax (phase syntax)))


;;;
;;;; Pane
;;;


(class Compass-Pane extends World-Pane
  
  
  (slot scale initialize 1. accessors generate)


  (method override (draw surface context)
    (let ((zone (current-zone))
          (me (current-me)))
      (let ((context (get-context~ surface))
            (bounds (get-bounds)))
        (let ((width (cast <fl> (rect-width bounds)))
              (height (cast <fl> (rect-height bounds))))
          (let ((cx (/ width 2.))
                (cy (/ height 2.))
                (radius (- (/ width 2.) 2.)))
            ;; background
            (cairo_arc context cx cy radius 0. PI*2)
            (cairo_clip context)
            (cairo_set_source_rgba context 0. 0. 0. .3)
            (cairo_arc context cx cy radius 0. PI*2)
            (cairo_fill context)
            ;; border
            (cairo_reset_clip context)
            (cairo_set_line_width context 2.5)
            (cairo_set_source_rgba context 1. 1. 1. .6)
            (cairo_arc context cx cy radius 0. PI*2)
            (cairo_stroke context)
            ;; me
            (let ((w 4.)
                  (h 12.))
              (with-preserved-matrix~ surface
                (lambda ()
                  (cairo_translate context cx cy)
                  (cairo_rotate context (vector-signed-angle (get-sight~ me) (vertex 0. 0. 1.) (vertex 0. 1. 0.)))
                  (cairo_move_to context (- w) 0.)
                  (cairo_line_to context 0. h)
                  (cairo_line_to context w 0.)
                  (cairo_line_to context (- w) 0.)
                  (cairo_set_source_rgba context 1. 1. 0. 1.)
                  (cairo_fill context))))
            ;; players
            (let ((position (get-position~ me))
                  (sight (get-sight~ me)))
              (for-each (lambda (player)
                          (unless (eq? player me)
                            (with-preserved-matrix~ surface
                              (lambda ()
                                (cairo_translate context cx cy)
                                (let ((delta (vertex- (get-position~ player) position)))
                                  (define (draw-player x y)
                                    (let ((radius 4.5))
                                      ;; fill
                                      (cairo_set_source_rgba context 1. 0. 0. 1.)
                                      (cairo_arc context x y radius 0. PI*2)
                                      (cairo_fill context)
                                      ;; border
                                      @w (
                                      (cairo_set_line_width context 1.)
                                      (cairo_set_source_rgba context 1. 1. 0. 1.)
                                      (cairo_arc context x y radius 0. PI*2)
                                      (cairo_stroke context))))
                                  
                                  (let ((dx (vertex-x delta))
                                        (dz (vertex-z delta)))
                                    (if (and (= dx 0.)
                                             (= dz 0.))
                                        (draw-player 0. 0.)
                                      ;; there must be a simpler way
                                      (let ((dir (vertex-scalar/ (vertex& dx 0. dz) scale)))
                                        (when (<= (vertex-norm dir) (- radius 3.))
                                          (let ((angle (vector-signed-angle sight (get-sight~ player) (vertex 0. 1. 0.))))
                                            (let ((dir (rotate-upon angle (vertex 0. 1. 0.) dir)))
                                              (cairo_rotate context angle)
                                              (draw-player (vertex-x dir) (vertex-z dir)))))))))))))
                        (get-actors~ zone))))))))))
