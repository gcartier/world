;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Compass Panel
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.interface.compass jazz


(import (jazz.cairo)
        (jazz.component)
        (jazz.geometry)
        (jazz.graphic)
        (world)
        (world.context)
        (world.geometry)
        (world.interface.panel)
        (world.interface.tooltip))


;;;
;;;; Player
;;;


(definition protected (layout-compass)
  (let ((window (current-window))
        (world (current-world)))
    (let ((world-width (get-width window))
          (world-height (get-height window))
          (sheet (get-compass-sheet world)))
      (let ((h (- world-width (get-width sheet)))
            (v 0))
        (set-position sheet (new Point h v))))))


(definition protected (draw-compass)
  (let ((world (current-world))
        (interface (current-interface)))
    (let ((view (child interface 'compass))
          (sheet (get-compass-sheet world)))
      (unless (get-uptodate? view)
        (let ((texture (get-texture sheet)))
          (let ((surface (get-surface texture))
                (data (get-data texture)))
            (draw-view view surface data)
            (flush surface)
            (map-texture texture)
            (set-uptodate? view #t))))
      (render-sheet sheet))))


;;;
;;;; Compass
;;;


(class Compass-Panel extends World-Panel
  
  
  (slot scale     initialize 1.                  accessors generate)
  (slot players   initialize (make-vector 64 #f) getter generate)
  (slot xs        initialize (make-f64vector 64) getter generate)
  (slot ys        initialize (make-f64vector 64) getter generate)
  (slot count     initialize 0                   getter generate)
  (slot uptodate? initialize #f                  accessors generate)
  
  
  ;;;
  ;;;; Drawing
  ;;;


  (method package (draw-view self surface data)
    (let ((me (current-me)))
      (let ((context (get-context surface))
            (bounds (get-bounds self)))
        (let ((width (cast <fl> (- (rect-width bounds) 10)))
              (height (cast <fl> (- (rect-height bounds) 10))))
          (let ((cx (+ 5. (/ width 2.)))
                (cy (+ 5. (/ height 2.)))
                (radius (- (/ width 2.) 2.))
                (old-count count))
            (clear surface)
            ;; background
            (cairo_arc context cx cy radius 0. PI*2)
            (cairo_clip context)
            (cairo_set_source_rgba context 0. 0. 0. .3)
            (cairo_arc context cx cy radius 0. PI*2)
            (cairo_fill context)
            ;; border
            (cairo_reset_clip context)
            (cairo_set_line_width context 2.5)
            (cairo_set_source_rgba context 1. 1. 1. .6)
            (cairo_arc context cx cy radius 0. PI*2)
            (cairo_stroke context)
            ;; me
            (let ((w 4.)
                  (h 12.))
              (with-preserved-matrix surface
                (lambda ()
                  (cairo_translate context cx cy)
                  (cairo_rotate context (vector-signed-angle (get-sight me) (vertex 0. 0. 1.) (vertex 0. 1. 0.)))
                  (cairo_move_to context (- w) 0.)
                  (cairo_line_to context 0. h)
                  (cairo_line_to context w 0.)
                  (cairo_line_to context (- w) 0.)
                  (cairo_set_source_rgba context 1. 1. 0. 1.)
                  (cairo_fill context))))
            ;; players
            (vector-set! players 0 me)
            (f64vector-set! xs 0 cx)
            (f64vector-set! ys 0 cy)
            (set! count 1)
            (let ((position (get-position me))
                  (sight (get-sight me)))
              (receive (left top) (cairo_user_to_device context 0. 0.)
                (for-each (lambda (player)
                            (unless (eq? player me)
                              (with-preserved-matrix surface
                                (lambda ()
                                  (let ((delta (vertex- (get-position player) position)))
                                    (define (draw-player x y near?)
                                      (let ((radius 4.5))
                                        (cairo_set_source_rgba context 1. 0. 0. 1.)
                                        (cairo_arc context x y radius 0. PI*2)
                                        (if near?
                                            (cairo_fill context)
                                          (cairo_stroke context)))
                                      (receive (x y) (cairo_user_to_device context x y)
                                        (vector-set! players count player)
                                        (f64vector-set! xs count (- x left))
                                        (f64vector-set! ys count (- y top))
                                        (increase! count)))
                                    
                                    (let ((dx (vertex-x delta))
                                          (dz (vertex-z delta)))
                                      (if (and (= dx 0.)
                                               (= dz 0.))
                                          (draw-player 0. 0. #t)
                                        (let ((dir (vertex-scalar/ (vertex& dx 0. dz) scale)))
                                          (let ((distance (vertex-norm dir)))
                                            (let ((near? (<= distance (- radius 3.)))
                                                  (angle (vector-signed-angle sight (get-sight player) (vertex 0. 1. 0.))))
                                              (let ((dir (rotate-vertex-upon angle (vertex 0. 1. 0.) dir)))
                                                (cairo_translate context cx cy)
                                                (cairo_rotate context angle)
                                                (if near?
                                                    (draw-player (vertex-x dir) (vertex-z dir) #t)
                                                  (let ((dir (vertex-scalar* (vertex-normalize dir) radius)))
                                                    (draw-player (vertex-x dir) (vertex-z dir) #f))))))))))))))
                          (nearest-players self))))
            ;; so we do not leak memory
            (when (> old-count count)
              (loop (for n from count below old-count)
                    (vector-set! players n #f))))))))
  
  
  (method (nearest-players self)
    (let ((zone (current-zone))
          (me (current-me)))
      (let ((position (get-position me)))
        (let ((players (sort < (get-players zone) key: (lambda (player)
                                                          (vertex-distance (get-position player) position)))))
          (if (<= (length players) 64)
              players
            (subseq players 0 64))))))
  
  
  ;;;
  ;;;; Tooltip
  ;;;
  
  
  (method override (get-tooltip? self)
    #t)
  
  
  (method override (get-tooltip-bounds self pos)
    (let ((nearest (nearest-player self pos)))
      (when nearest
        (nearest-bounds self nearest))))
  
  
  (definition nearest-tolerance
    7)
  
  
  (method (nearest-player self pos)
    (let ((nearest #f))
      (loop (for rank from 0 below count)
            (when (and (in-rect? pos (nearest-bounds self rank))
                       (or (not nearest)
                           (< (distance (nearest-position self rank) pos) (distance (nearest-position self nearest) pos))))
              (set! nearest rank)))
      nearest))
  
  
  (method (nearest-position self rank)
    (let ((h (fxround (f64vector-ref xs rank)))
          (v (fxround (f64vector-ref ys rank))))
      (new Point h v)))
  
  
  (method (nearest-bounds self rank)
    (let ((h (fxround (f64vector-ref xs rank)))
          (v (fxround (f64vector-ref ys rank))))
      (new Rect (- h nearest-tolerance) (- v nearest-tolerance) (+ h nearest-tolerance) (+ v nearest-tolerance))))
    
  
  (method override (tooltip-use-position? self)
    #t)

  
  (method override (tooltip-default-popup? self)
    #t)
  
  
  (method override (get-tooltip-context self pos)
    (define (present-player player)
      `(<span>
         (<paragraph>
           (<text> color: World-Green ,(->string (or (get-name player) (anonymous (current-tier))))))))
    
    (let ((nearest (nearest-player self pos)))
      (and nearest
           (let ((text (present-player (vector-ref players nearest)))
                 (bounds (nearest-bounds self nearest)))
             (tooltip-context self text bounds padding: 0)))))))
