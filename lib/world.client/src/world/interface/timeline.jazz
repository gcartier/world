;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Timeline Panel
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.interface.timeline jazz


(import (jazz.component)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.time)
        (world)
        (world.biome)
        (world.change)
        (world.chronology)
        (world.context)
        (world.evolution)
        (world.geometry)
        (world.history)
        (world.interface.panel)
        (world.profiling)
        (world.settings)
        (world.udp))


(definition protected chronology-orange  {Color red: .995 green: .699 blue: .292})
(definition protected chronology-yellow  {Color red: .995 green: .946 blue: .005})
(definition protected chronology-green   {Color red: .125 green: .995 blue: .129})
(definition protected chronology-cyan    {Color red: .112 green: .856 blue: .845})
(definition protected chronology-blue    {Color red: .216 green: .274 blue: .953})
(definition protected chronology-purple  {Color red: .478 green: .333 blue: .995})
(definition protected chronology-magenta {Color red: .945 green: .405 blue: .995})
(definition protected chronology-red     {Color red: .995 green: .185 blue: .197})


(definition protected timeline-text-color
  (world-setting 'world.timeline-text {Color Dark-Gray}))


;;;
;;;; Player
;;;


(definition protected (draw-timeline)
  (let ((world (current-world))
        (interface (current-interface)))
    (let ((view (child interface 'timeline))
          (sheet (get-timeline-sheet world)))
      (unless (get-uptodate? view)
        (let ((texture (get-texture sheet)))
          (let ((surface (get-surface texture))
                (data (get-data texture)))
            (draw-view view surface data)
            (map-texture texture)
            (set-uptodate? view #t))))
      (let ((x (cast <fl> (get-left view)))
            (y (cast <fl> (get-top view)))
            (h (cast <fl> (get-height view))))
        (let ((matrix (make-translation-matrix (vertex x (- (get-height world) y h) 0.))))
          (render-sheet sheet matrix))))))


(definition protected (refresh-timeline)
  (let ((interface (current-interface+))
        @together
        (history (current-history)))
    (when interface
      (let ((panel (child interface 'timeline)))
        @together
        (when (not (get-history panel))
          (set-history panel (current-history)))
        (when (not (get-chronology panel))
          (set-chronology panel (current-chronology)))
        (when (not (get-evolution panel))
          (set-evolution panel (current-evolution)))
        (when (not (get-from panel))
          (set-uptodate? panel #f))))))


;;;
;;;; Sites
;;;


(proclaim (not check bounds zero)
          (warn optimizations))


(class Site-Look extends Object
  
  
  (slot rank  <fx+>    getter generate)
  (slot color <Color+> getter generate)
  
  
  (method override (initialize self rank color)
    (nextmethod self)
    (set! self.rank rank)
    (set! self.color color)))


(definition protected site-looks <table>
  (make-table test: eq?))

(definition protected default-site-look <Site-Look+>
  #f)

(definition public (register-site-look name rank color) <void>
  (let ((look (new Site-Look rank color)))
    (if name
        (table-set! site-looks name look)
      (set! default-site-look look))))

(definition public (registered-site-look name) <Site-Look+>
  (table-ref site-looks name #f))


(proclaim (not check types))


(definition protected id-site-looks <vector>
  (make-vector 256 #t))

(definition protected (id->site-look id <fx>) <Site-Look+>
  (let ((value (vector-ref id-site-looks id)))
    (if (eq? value #t)
        (let ((site (id->site id)))
          (let ((look (registered-site-look (get-name site))))
            (vector-set! id-site-looks id look)
            look))
      value)))


(proclaim (default check types))


;;;
;;;; Timeline
;;;


(class Timeline-Panel extends World-Panel
  
  
  (slot tier                         initialize #f accessors generate)
  (slot scale           <fl>         initialize 0  accessors generate)
  (slot sampling        <fx>         initialize 2  accessors generate)
  (slot from            <fl+>        initialize #f accessors generate)
  (slot to              <fl+>        initialize #f accessors generate)
  (slot span            <fl>         initialize 5. accessors generate)
  (slot now             <fl+>        initialize #f accessors generate)
  (slot base-time       <fl>         initialize 0. accessors generate)
  (slot history         <History>    initialize #f accessors generate)
  (slot chronology      <Chronology> initialize #f accessors generate)
  (slot evolution       <Evolution>  initialize #f accessors generate)
  (slot evolution-range              initialize #f accessors generate)
  (slot evolution-from  <fl+>        initialize #f accessors generate)
  (slot evolution-to    <fl+>        initialize #f accessors generate)
  (slot cpu%            <fl+>        initialize #f accessors generate)
  (slot live?                        initialize #t accessors generate)
  (slot replay?                      initialize #f accessors generate)
  (slot uptodate?                    initialize #f accessors generate)
  ;; scroll code is a copy/paste from showcase
  (slot point                        initialize #f getter generate)
  (slot moved?                       initialize #f getter generate)
  (slot scrolled?                    initialize #f getter generate)
  (slot last-to                      initialize #f getter generate)
  (slot last-seconds                 initialize #f getter generate)
  (slot last-speed                   initialize #f getter generate)
  (slot pulse                        initialize #f getter generate)
  (slot labels                       initialize #f getter generate)
  ;; experimental quicky
  (slot missings                     initialize #f getter generate)
  ;; experimental quicky
  (slot highlighted                  initialize #f getter generate)
  (slot boxes                        initialize #f getter generate)
  
  
  ;;;
  ;;;; Bounds
  ;;;
  
  
  (method protected (update-span self)
    (set! span (- to from)))
  
  
  (method protected (set-bounds self f t)
    (assert (<= f t)
      (set! from f)
      (set! to t)))
  
  
  (method (with-bounds self proc)
    (if (not from)
        (let ((head (timeline-head self))
              (tail (timeline-tail self)))
          (let ((from (max head (- tail span)))
                (to tail))
            (proc from to)))
      (proc from to)))
  
  
  (method (timeline-head self) <fl>
    (chronological-time chronology (first-position chronology)))
  
  
  (method (timeline-tail self) <fl>
    (chronological-time chronology (last-position chronology)))
  
  
  (method (live-information self)
    (unless live?
      @together
      (set! history (current-history))
      (set! chronology (current-chronology))
      (set! evolution (current-evolution))
      (set! cpu% #f)
      (set! live? #t)))
  
  
  (method (copy-information self)
    (when live?
      @together
      (set! history (copy-history (current-history)))
      (set! chronology (copy-chronology (current-chronology)))
      (set! evolution (copy-evolution (current-evolution)))
      (set! cpu% (chronology-cpu% chronology))
      (set! live? #f)))
  
  
  ;; to redo?
  (method (update self time)
    )
  
  
  (method protected (setup-replay self base-time)
    (let ((head (timeline-head self))
          (tail (timeline-tail self)))
      (set-now self #f)
      (set-bounds self head tail)
      (set-base-time self base-time)
      (update-span self)
      (set-replay? self #t)
      (set-live? self #f)
      (set! cpu% (chronology-cpu% chronology))
      (redraw self)))
  
  
  (method protected virtual (view-update self)
    )
  
  
  (method protected virtual (now-update self)
    )


  (proclaim (not warn optimizations))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method override (mouse-down self evt)
    (copy-information self)
    (with-bounds self
      (lambda (from~ to~)
        (set! point (get-h evt))
        (set! moved? #f)
        (set! last-to to~)
        (set! last-seconds (current-seconds))
        (set! last-speed #f)
        (kill-autoscroll self))))
  
  
  (method override (drag-move self evt)
    (let ((h (get-h evt)))
      (when (and point (not (near? h point 2)))
        (with-bounds self
          (lambda (from~ to~)
            (let ((delta (* (/ (cast <fl> (- h point)) (cast <fl> (get-width self))) (- span)))
                  (head (timeline-head self))
                  (tail (timeline-tail self)))
              (let ((new-from (+ from~ delta))
                    (new-to (+ to~ delta)))
                (cond ((> new-to tail)
                       (set-bounds self (- tail span) tail))
                      ((< new-from head)
                       (set-bounds self head (+ head span)))
                      (else
                       (set-bounds self new-from new-to))))
              (update-span self)
              (redraw self))
            (set! point h)
            (set! moved? #t)
            (let ((new-to to)
                  (new-seconds (current-seconds))
                  (old-to last-to)
                  (old-seconds last-seconds))
              (set! last-to new-to)
              (set! last-seconds new-seconds)
              (unless (= new-seconds old-seconds)
                (let ((new-speed (/ (- new-to old-to) (- new-seconds old-seconds)))
                      (p .9))
                  (set! last-speed (+ (* new-speed (- 1. p)) (* (or last-speed 0.) p)))))))))))

  
  (method override (mouse-up self evt)
    (if (or (not moved?) (< (- (current-seconds) last-seconds) .1))
        (if moved?
            (begin
              (set! scrolled? #f)
              (start-autoscroll self))
          (with-bounds self
            (lambda (from to)
              (set! point (get-h evt))
              (set! moved? #f)
              (set! scrolled? #f)
              (set! last-speed #f)
              (set! now (h->when self from to point))
              (redraw self)
              (now-update self)
              (kill-autoscroll self))))
      (view-update self)))
  
  
  (method override (right-mouse-up self evt)
    (live-information self)
    (set! from #f)
    (set! to #f)
    (redraw self)
    (view-update self))
  
  
  (method override (mouse-wheel self pos delta)
    (let ((d (get-v delta)))
      (cond ((> d 0)
             (zoom-in self))
            ((< d 0)
             (zoom-out self)))))
  
  
  (method package (zoom-in self)
    (let ((head (timeline-head self))
          (tail (timeline-tail self)))
      (let ((max-span (- tail head)))
        (if (not from)
            (set! span (min max-span (* span .75)))
          (let ((h (get-h (mouse-position self)))
                (width (get-width self)))
            (let ((proportion (/ (cast <fl> h) (cast <fl> width))))
              (let ((when (+ from (* span proportion)))
                    (new-span (min max-span (* span .75))))
                (let ((new-from (- when (* new-span proportion)))
                      (new-to (+ when (* new-span (- 1. proportion)))))
                  (set-bounds self (max head new-from) (min tail new-to))
                  (update-span self))))))))
    (redraw self)
    (view-update self))
  
  
  (method package (zoom-out self)
    (let ((head (timeline-head self))
          (tail (timeline-tail self)))
      (let ((max-span (- tail head)))
        (if (not from)
            (set! span (min max-span (/ span .75)))
          (let ((h (get-h (mouse-position self)))
                (width (get-width self)))
            (let ((proportion (/ (cast <fl> h) (cast <fl> width))))
              (let ((when (+ from (* span proportion)))
                    (new-span (min max-span (/ span .75))))
                (let ((new-from (- when (* new-span proportion)))
                      (new-to (+ when (* new-span (- 1. proportion)))))
                  (set-bounds self (max head new-from) (min tail new-to))
                  (update-span self))))))))
    (redraw self)
    (view-update self))
  
  
  (method package (zoom-reset self)
    (set-bounds self (timeline-head self) (timeline-tail self))
    (update-span self)
    (redraw self)
    (view-update self))


  (proclaim (warn optimizations))
  
  
  (method (h->when self from to h)
    (let ((width (get-width self)))
      (cond ((< h 0)
             from)
            ((> h width)
             to)
            (else
             (+ from (* span (/ (cast <fl> h) (cast <fl> width))))))))
  
  
  (method (when->h self from to span when)
    (fxround (* (/ (- when from) span) (cast <fl> (get-width self)))))


  (proclaim (not warn optimizations))
  
  
  ;;;
  ;;;; Autoscroll
  ;;;
  
  
  (method (start-autoscroll self)
    (set! pulse (new Pulse 'autoscroll 0.01 (~ autoscroll-action self) delay: 0)))
  
  
  (method (kill-autoscroll self)
    (when pulse
      (close pulse)
      (set! pulse #f)))
  
  
  (method (autoscroll-action self)
    (when (and last-speed (not live?))
      (let ((actual-to to))
        (let ((scroll-to (+ actual-to (/ last-speed 100.))))
          (let ((new-to scroll-to))
            (when (/= new-to actual-to)
              (set! scrolled? #t)
              (let ((new-from (- new-to span)))
                (let ((head (timeline-head self))
                      (tail (timeline-tail self)))
                  (cond ((> new-to tail)
                         (set-bounds self (- tail span) tail))
                        ((< new-from head)
                         (set-bounds self head (+ head span)))
                        (else
                         (set-bounds self new-from new-to)))
                  (update-span self)
                  (redraw self)
                  (when (or (<= new-from head)
                            (>= new-to tail))
                    (set! scrolled? #f)
                    (kill-autoscroll self)
                    (view-update self))))))))))
  
  
  ;;;
  ;;;; Draw
  ;;;


  (proclaim (warn optimizations))
  
  
  (method (redraw self)
    (if replay?
        (invalidate-view self)
      (set-uptodate? self #f)))
  
  
  (method override (draw self surface context)
    ;; quick solution
    (let ((interface (current-interface)))
      (unless (eq? self (child interface 'timeline))
        (draw-view self surface #f))))


  (method package (draw-view self surface <Surface> data)
    (clear surface)
    (fill-rect surface (new Rect 0 0 (get-width self) (get-height self)) {Color red: .000 green: .000 blue: .000 alpha: .450})
    (draw-timeline self surface)
    (frame-rect surface (new Rect 0 0 (get-width self) (get-height self)) (border-color self)))
  
  
  (method (draw-timeline self surface <Surface>)
    (when (and @together history chronology evolution)
      (when live?
        (set! cpu% (chronology-cpu% chronology)))
      (with-bounds self
        (lambda (from to)
          (let ((timer (new Timer))
                (history-duration #f)
                (chronology-duration #f)
                (evolution-duration #f)
                (evolutions-duration #f)
                (now-duration #f))
            (set! labels '())
            (set! missings '())
            (set! highlighted '())
            (set! boxes '())
            (plot-time self surface from to)
            (plot-units self surface from to)
            @together
            (let ((timer (new Timer)))
              (plot-history self surface from to)
              (set! history-duration (real-duration timer)))
            (let ((timer (new Timer)))
              (plot-chronology self surface from to)
              (set! chronology-duration (real-duration timer)))
            (let ((timer (new Timer)))
              (plot-evolution self surface from to)
              (set! evolution-duration (real-duration timer)))
            (let ((timer (new Timer)))
              (plot-evolutions self surface from to)
              (set! evolutions-duration (real-duration timer)))
            (let ((timer (new Timer)))
              (plot-now self surface from to)
              (set! now-duration (real-duration timer)))
            (plot-info self surface history-duration chronology-duration evolution-duration evolutions-duration now-duration (real-duration timer)))))))
  
  
  (method (plot-info self surface <Surface> history-duration chronology-duration evolution-duration evolutions-duration now-duration duration)
    (set-font surface {Font Label})
    (when tier
      (let ((title tier))
        (draw-text surface 5 3 title timeline-text-color)))
    (when cpu%
      (let ((title (format "CPU: {r precision: 1}%" cpu%)))
        (draw-text surface 80 3 title timeline-text-color)))
    (when evolution-from
      (let ((range (- evolution-to evolution-from)))
        (let ((title (format "Shown: {a}s{? {a}~}"
                             (cond ((= range .5) ".5")
                                   ((= range 2.) "2")
                                   (else "6"))
                             evolution-range)))
          (draw-text surface 165 3 title timeline-text-color))))
    (when title
      (let ((title (format "{a} ({a})" title (present-seconds duration))))
        (let ((width (get-width self))
              (extent (get-text-extent surface title)))
          (draw-text surface (- width (get-width extent) 5) 3 title timeline-text-color)))
      (when (world-setting 'world.timeline-durations? #f)
        (let ((title (format "chrono {a} evo {a} evos {a} now {a}"
                             (present-seconds chronology-duration)
                             (present-seconds evolution-duration)
                             (present-seconds evolutions-duration)
                             (present-seconds now-duration))))
          (let ((width (get-width self))
                (extent (get-text-extent surface title)))
            (draw-text surface (- width (get-width extent) 5) 17 title timeline-text-color))))))
  
  
  (method protected virtual (border-color self)
    {Color Entry-Border})
  
  
  (method (plot-time self surface <Surface> from <fl> to <fl>)
    (let ((width (cast <fl> (get-width self)))
          (height (cast <fl> (get-height self))))
      (let ((v (/ height 2.)))
        (set-color surface {Color Medium-Gray alpha: .7})
        (set-line-width surface 1)
        (move-to surface 0 v)
        (line-to surface width v))))
  
  
  (method (plot-units self surface <Surface> from <fl> to <fl>)
    (let ((width (cast <fl> (get-width self)))
          (height (cast <fl> (get-height self)))
          (from (- from base-time))
          (to (- to base-time)))
      (let ((span (min (- to from) span)))
        (let ((v (/ height 2.)))
          (set-color surface {Color Medium-Gray alpha: .7})
          (set-line-width surface 1)
          (loop (for s from (fxceiling from) to (fxfloor to))
                (let ((h (when->h self from to span (cast <fl> s))))
                  (move-to surface h (- v 3.))
                  (line-to surface h (+ v 4.))))))))
  
  
  ;;;
  ;;;; Evolution
  ;;;
  
  
  ;; quicky to be unified with plot-evolution of course
  (method protected virtual (plot-evolutions self surface <Surface> from <fl> to <fl>)
    )
  
  
  (method (plot-evolution self surface <Surface> from <fl> to <fl>)
    (let ((head (timeline-head self))
          (tail (timeline-tail self)))
      (define (find-first) <fx+>
        (loop (for n from (first-position evolution) to (last-position evolution))
              (when (>= (evolutionary-udp-time evolution n) head)
                (return n))
              (finally #f)))
      
      (define (find-last first <fx>) <fx>
        (loop (for n from first to (last-position evolution))
              (when (> (evolutionary-udp-time evolution n) tail)
                (return (- n 1)))
              (finally (last-position evolution))))
      
      (let ((width (cast <fl> (get-width self)))
            (height (cast <fl> (get-height self)))
            (span (min (- to from) span))
            (dark-purple {Color red: .464 green: .141 blue: .732})
            (rtt-scale (if local? 5000. 150.))
            (previous-rtt-h #f)
            (previous-rtt-v #f)
            (missing-scale 5.)
            (previous-missing-h #f)
            (previous-missing-v #f)
            (now-h (and now (when->h self from to span now)))
            (first (find-first)))
        (when first
          (let ((last (find-last first)))
            (define (find-head) <fx>
              (loop (for n from first to last)
                    (when (>= (evolutionary-udp-time evolution n) from)
                      (return n))
                    (finally first)))
            
            (define (find-tail head <fx>) <fx>
              (loop (for n from head to last)
                    (when (> (evolutionary-udp-time evolution n) to)
                      (return (- n 1)))
                    (finally last)))
            
            (define (find-previous head <fx> id <fl>) <fx+>
              (loop (for n from (- head 1) downto first)
                    (when (= (evolutionary-udp-id evolution n) id)
                      (return n))
                    (finally #f)))
            
            (define (find-next tail <fx> id <fl>) <fx+>
              (loop (for n from (+ tail 1) to last)
                    (when (= (evolutionary-udp-id evolution n) id)
                      (return n))
                    (finally #f)))
            
            (let ((head (find-head)))
              (let ((tail (find-tail head)))
                (set-line-width surface 1.)
                (loop (for n from head to tail)
                      (let ((time (evolutionary-udp-time evolution n))
                            (id (evolutionary-udp-id evolution n)))
                        (let ((h (fxround (* (/ (- time from) span) width))))
                          (ecase id
                            @wait
                            ((udp-id-connect)
                             (let ((color {Color Yellow})
                                   (v 13))
                               (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color)))
                            @wait
                            ((udp-id-connected)
                             (let ((color {Color Green})
                                   (v 13))
                               (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color)))
                            @convert
                            ((udp-id-send-media)
                             (let ((kind (flonum->fixnum (evolutionary-udp-kind evolution n)))
                                   (off? (= (evolutionary-udp-data1 evolution n) 0.)))
                               (let ((color (if off?
                                                {Color Medium-Gray}
                                              (ecase kind
                                                ((udp-audio) {Color Purple})
                                                (else {Color Blue}))))
                                     (v 13))
                                 (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color))))
                            ((udp-id-receive-ack)
                             (let ((color {Color Green})
                                   (v 21))
                               (set-color surface {Color Green})
                               (let ((rtt (evolutionary-udp-data3 evolution n)))
                                 (let ((v (fxround (- 95. (* rtt rtt-scale)))))
                                   (when (not previous-rtt-h)
                                     (let ((n (find-previous head id)))
                                       (when n
                                         (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                               (v (fxround (- 95. (* (evolutionary-udp-data3 evolution n) rtt-scale)))))
                                           (set! previous-rtt-h h)
                                           (set! previous-rtt-v v)))))
                                   (when previous-rtt-h
                                     (move-to surface previous-rtt-h previous-rtt-v)
                                     (line-to surface h v))
                                   (set! previous-rtt-h h)
                                   (set! previous-rtt-v v)))))
                            @wait
                            ((udp-id-resend-packet)
                             (let ((found (evolutionary-udp-data1 evolution n)))
                               (let ((color (if (= found 1.)
                                                {Color Orange}
                                              {Color Red}))
                                     (v 29))
                                 (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color))))
                            ((udp-id-missing-packet)
                             (let ((kind (flonum->fixnum (evolutionary-udp-kind evolution n))))
                               (let ((color {Color Red})
                                     (left (- h 2))
                                     (right (+ h 3))
                                     (v (if (= kind udp-audio) 37 44)))
                                 (let ((rect (new Rect left (- v 2) right (+ v 3))))
                                   (fill-rect surface rect color)
                                   (when (and now (between? now-h left right))
                                     (let ((sequence (flonum->fixnum (evolutionary-udp-data1 evolution n))))
                                       (unless (memv? sequence missings)
                                         (set! missings (cons sequence missings)))))))))
                            ((udp-id-invalid-smaller udp-id-invalid-greater)
                             (let ((color {Color Purple})
                                   (v 45))
                               (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color)))
                            @convert
                            ((udp-id-discard udp-id-missing)
                             (let ((color (if (= id udp-id-discard)
                                              {Color Purple}
                                            {Color Red}))
                                   (v 37))
                               (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color))
                             (when (= id udp-id-missing)
                               (set-color surface {Color Red})
                               (let ((missing (evolutionary-udp-data1 evolution n))
                                     (processed (evolutionary-udp-data2 evolution n)))
                                 (let ((v (fxround (- 95. (* (percentage missing processed) missing-scale)))))
                                   (when (not previous-missing-h)
                                     (let ((n (find-previous head id)))
                                       (when n
                                         (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                               (v (fxround (- 95. (* (percentage (evolutionary-udp-data1 evolution n) (evolutionary-udp-data2 evolution n)) missing-scale)))))
                                           (set! previous-missing-h h)
                                           (set! previous-missing-v v)))))
                                   (when previous-missing-h
                                     (move-to surface previous-missing-h previous-missing-v)
                                     (line-to surface h v))
                                   (set! previous-missing-h h)
                                   (set! previous-missing-v v)))))))))
                (when previous-rtt-h
                  (let ((n (find-next tail udp-id-receive-ack)))
                    (set-color surface {Color Green})
                    (move-to surface previous-rtt-h previous-rtt-v)
                    (if (not n)
                        (line-to surface width previous-rtt-v)
                      (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                            (v (fxround (- 95. (* (evolutionary-udp-data3 evolution n) rtt-scale)))))
                        (line-to surface h v)))))
                @convert
                (when previous-missing-h
                  (let ((n (find-next tail udp-id-missing)))
                    (set-color surface {Color Red})
                    (move-to surface previous-missing-h previous-missing-v)
                    (if (not n)
                        (line-to surface width previous-missing-v)
                      (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                            (v (fxround (- 95. (* (percentage (evolutionary-udp-data1 evolution n) (evolutionary-udp-data2 evolution n)) missing-scale)))))
                        (line-to surface h v))))))))))))
  
  
  ;;;
  ;;;; History
  ;;;
  
  
  (method (plot-history self surface <Surface> from <fl> to <fl>)
    (let ((head (timeline-head self))
          (tail (timeline-tail self)))
      (define (find-first)
        (loop (for n from (history-first history) to (history-last history))
              (when (>= (historical-time history n) head)
                (return n))
              (finally #f)))
      
      (define (find-last first)
        (loop (for n from first to (history-last history))
              (when (> (historical-time history n) tail)
                (return (- n 1)))
              (finally (history-last history))))
      
    (let ((width (cast <fl> (get-width self)))
          (height (cast <fl> (get-height self)))
          (now (get-now history))
          (changes (get-changes history))
          (span (min (- to from) span))
          (v (- (get-height self) 87))
          (first (find-first)))
      (when (and first (<= first tail))
        (let ((last (find-last first)))
          (define (plot-change n)
            (let ((time (historical-time history n)))
              (when (between? time from to)
                (let ((change (id->change (historical-change-id history n))))
                  (let ((h (fxround (* (/ (- time from) span) width)))
                        (color (case (get-name change)
                                 ((move) {Color Purple})
                                 ((lookat) {Color Blue})
                                 ((animate) {Color Blue})
                                 ((edit-script update-script) {Color Ochre})
                                 ((fire) {Color Green})
                                 ((spawn) {Color Green})
                                 ((die) {Color Red})
                                 ((add-block delete-block add-entity remove-entity) {Color Green})
                                 ((action interact) {Color Green})
                                 (else {Color Light-Gray}))))
                    (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color))))))
          
          (loop (for n from first to last)
                (unless (= n now)
                  (plot-change n)))
          (plot-change now))))))
  
  
  ;;;
  ;;;; Chronology
  ;;;
  
  
  (method (plot-chronology self surface <Surface> from <fl> to <fl>)
    (let ((width (cast <fl> (get-width self)))
          (height (cast <fl> (get-height self)))
          (span (min (- to from) span))
          (first (first-position chronology))
          (last (last-position chronology))
          (starts (make-vector (site-id-count) #f)))
      (define (find-head/starts!) <fx>
        (continuation-capture
          (lambda (return)
            (loop (for n from first to last)
                  (let ((id (flonum->fixnum (chronological-id chronology n)))
                        (time (chronological-time chronology n)))
                    (if (>= time from)
                        (continuation-return return n)
                      (let ((marker (chronological-marker chronology n)))
                        (if (even? (flonum->fixnum marker))
                            (vector-set! starts id time)
                          (vector-set! starts id #f))))))
            first)))
      
      (define (find-tail head) <fx>
        (continuation-capture
          (lambda (return)
            (loop (for n from head to last)
                  (when (> (chronological-time chronology n) to)
                    (continuation-return return (- n 1))))
            last)))
      
      (when (world-setting 'world.timeline-colors? #f)
        (fill-rect surface (new Rect   0   0  20 110) chronology-orange)
        (fill-rect surface (new Rect  20  11  40 110) chronology-yellow)
        (fill-rect surface (new Rect  40  22  60 110) chronology-green)
        (fill-rect surface (new Rect  60  33  80 110) chronology-cyan)
        (fill-rect surface (new Rect  80  44 100 110) chronology-blue)
        (fill-rect surface (new Rect 100  55 120 110) chronology-purple)
        (fill-rect surface (new Rect 120  66 140 110) chronology-magenta)
        (fill-rect surface (new Rect   0  77  30 110) {Color Yellow})
        (fill-rect surface (new Rect  30  77  60 110) {Color Yellow})
        (fill-rect surface (new Rect  60  77  90 110) {Color Green})
        (fill-rect surface (new Rect  90  77 140 110) {Color Blue})
        (fill-rect surface (new Rect   0  88 140 110) {Color Orange})
        (fill-rect surface (new Rect   0  99 140 110) {Color Red})
        @wait
        (fill-rect surface (new Rect  30   0  40 110) {Color Dark-Gray})
        (let ((text-color {Color Light-Gray}))
          (set-font surface {Font Label})
          (draw-text surface   3 -3 "audio" text-color)
          (draw-text surface  23  8 "video" text-color)
          (draw-text surface  43 19 "udp-release" text-color)
          (draw-text surface  63 30 "udp-state" text-color)
          (draw-text surface  83 41 "udp-receive" text-color)
          (draw-text surface 103 52 "udp-process" text-color)
          (draw-text surface 123 63 "video-output" text-color)
          (draw-text surface   7 74 "network" text-color)
          (draw-text surface  65 74 "tick" text-color)
          (draw-text surface  97 74 "render" text-color)
          (draw-text surface  32 85 "message/event" text-color)
          (draw-text surface  53 96 "memory" text-color)))
      
      (let ((head (find-head/starts!)))
        (let ((tail (find-tail head)))
          (define (plot-call rank <fx> color <Color> id <fx> start <fl> end <fl>)
            (let ((bar-height (* (cast <fl> rank) 7.)))
              (let ((f (* (/ (- start from) span) width))
                    (t (* (/ (- end from) span) width))
                    (bottom height)
                    (top (- height bar-height)))
                (when (or (between? f 0. width)
                          (between? t 0. width)
                          (and (< f 0.)
                               (> t width)))
                  (let ((left (fxfloor f))
                        (top (fxfloor top))
                        (right (fxceiling t))
                        (bottom (fxceiling bottom)))
                    (let ((rect (new Rect left top right bottom)))
                      (fill-rect surface rect color)
                      (when (and now (between? now start end))
                        (set! boxes (cons rect boxes))
                        (let ((name (get-name (id->site id)))
                              (duration (- end start)))
                          (let ((text (format "{a} ({a})" name (present-seconds duration))))
                            (set! labels (cons (cons (- top 16) text) labels)))))))))))
          
          (loop (for layer from 10 downto 1)
                (loop (for n from head to tail)
                      (let ((id (flonum->fixnum (chronological-id chronology n)))
                            (marker (chronological-marker chronology n))
                            (time (chronological-time chronology n)))
                        (let ((look (or (id->site-look id) default-site-look)))
                          (when look
                            (let ((rank (get-rank look)))
                              (when (and rank (= rank layer))
                                (if (even? (flonum->fixnum marker))
                                    (vector-set! starts id time)
                                  (let ((start (or (vector-ref starts id) from)))
                                    (let ((end time))
                                      (proclaim (not check types))
                                      (plot-call rank (get-color look) id start end)))
                                  (vector-set! starts id #f))))))))
                (loop (for id from 0 below (site-id-count))
                      (let ((look (or (id->site-look id) default-site-look)))
                        (when look
                          (let ((rank (get-rank look)))
                            (when (and rank (= rank layer))
                              (let ((start (vector-ref starts id)))
                                (when start
                                  (let ()
                                    (proclaim (not check types))
                                    (plot-call rank (get-color look) id start to))))))))))))))
  
  
  ;;;
  ;;;; Now
  ;;;
  
  
  (method (plot-now self surface <Surface> from <fl> to <fl>)
    (when (and now (not live?))
      (let ((h (when->h self from to span now))
            (height (cast <fl> (get-height self)))
            (text-color {Color Light-Gray}))
        ;; line
        (set-color surface {Color White})
        (set-line-width surface 1.5)
        (move-to surface h 0)
        (line-to surface h height)
        ;; evolution
        (when evolution-from
          (let ((h (when->h self from to span evolution-from)))
            (set-color surface {Color Gray alpha: .4})
            (set-line-width surface 1.)
            (move-to surface h 0)
            (line-to surface h height)))
        (when evolution-to
          (let ((h (when->h self from to span evolution-to)))
            (set-color surface {Color Gray alpha: .4})
            (set-line-width surface 1.)
            (move-to surface h 0)
            (line-to surface h height)))
        ;; time
        (let ((height (cast <fl> (get-height self))))
          (let ((s (format "{r precision: 3}" (if together? (- now base-time) (- now (floor kernel-boot)))))
                (v (/ height 2.)))
            (let ((width (get-text-width surface s)))
              (let ((h (if (< h 60) (+ (fxround h) 4) (- (fxround h) width 4)))
                    (v (+ (fxround v) 1)))
                (set-font surface {Font Label})
                (draw-text surface h v s text-color)))))
        ;; labels
        (for-each (lambda (label)
                    (bind (v . text) label
                      (let ((h (+ (fxround h) 4))
                            (v (+ (fxround v) 1)))
                        (draw-text surface h v text text-color))))
                  labels)
        ;; missings
        (when (not-null? missings)
          (let ((v 46))
            (let ((h (+ (fxround h) 4))
                  (v (+ (fxround v) 1))
                  (text (let ((count (length missings)))
                          (if (> count 5)
                              (format "missing ({a} total)" count)
                            (format "missing {l}" (sort < missings))))))
              (draw-text surface h v text text-color))))
        ;; highlighted
        (when (not-null? highlighted)
          (let ((v 100))
            (let ((h (+ (fxround h) 4))
                  (v (+ (fxround v) 1))
                  (text (format "{l}" (map evolution-id->abbrev highlighted))))
              (draw-text surface h v text text-color))))
        ;; boxes
        (for-each (lambda (box)
                    (frame-rect surface box {Color White}))
                  boxes)
        ;; rtt
        @wait
        (let ((rtt-scale (if local? 5000. 250.)))
          (define (find-before time id)
            (loop (for n from (last-position evolution) downto (first-position evolution))
                  (when (and (= (evolutionary-udp-id evolution n) id)
                             (< (evolutionary-udp-time evolution n) time))
                    (return n))
                  (finally #f)))
          
          (define (find-after time id)
            (loop (for n from (first-position evolution) to (last-position evolution))
                  (when (and (= (evolutionary-udp-id evolution n) id)
                             (> (evolutionary-udp-time evolution n) time))
                    (return n))
                  (finally #f)))
          
          (let ((before (find-before now udp-id-receive-ack)))
            (when before
              (let ((actual-after (find-after now udp-id-receive-ack)))
                (let ((after (or actual-after before)))
                  (let ((b (evolutionary-udp-data1 evolution before))
                        (a (evolutionary-udp-data1 evolution after)))
                    (let ((bv (fxround (- 95. (* b rtt-scale))))
                          (av (fxround (- 95. (* a rtt-scale)))))
                      (let ((vert (if actual-after
                                      (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) bv av)
                                    bv))
                            (rtt (if actual-after
                                     (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) b a)
                                   b)))
                        (let ((s (format "{a}ms" (fxround (* rtt 1000.)))))
                          (let ((extent (get-text-extent surface s)))
                            (let ((width (get-width extent))
                                  (height (get-height extent)))
                              (let ((h (+ (fxround h) 4))
                                    (v (max (min (fxround (- vert (/ height 2.))) 86) 0)))
                                (fill-rect surface (h/v/width/height->rect h v width height) {Color Black})
                                (draw-text surface h v s text-color)))))))))))))
        ;; missing
        (let ((missing-scale 5.))
          (define (find-before time id)
            (loop (for n from (last-position evolution) downto (first-position evolution))
                  (when (and (= (evolutionary-udp-id evolution n) id)
                             (< (evolutionary-udp-time evolution n) time))
                    (return n))
                  (finally #f)))
          
          (define (find-after time id)
            (loop (for n from (first-position evolution) to (last-position evolution))
                  (when (and (= (evolutionary-udp-id evolution n) id)
                             (> (evolutionary-udp-time evolution n) time))
                    (return n))
                  (finally #f)))
          
          #f @convert
          (let ((before (find-before now udp-id-missing)))
            (when before
              (let ((actual-after (find-after now udp-id-missing)))
                (let ((after (or actual-after before)))
                  (let ((b (percentage (evolutionary-udp-data1 evolution before) (evolutionary-udp-data2 evolution before)))
                        (a (percentage (evolutionary-udp-data1 evolution after) (evolutionary-udp-data2 evolution after))))
                    (let ((bv (fxround (- 95. (* b missing-scale))))
                          (av (fxround (- 95. (* a missing-scale)))))
                      (let ((vert (if actual-after
                                      (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) bv av)
                                    bv))
                            (missing (if actual-after
                                         (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) b a)
                                       b)))
                        (let ((s (format "{r precision: 1}%" missing)))
                          (let ((extent (get-text-extent surface s)))
                            (let ((width (get-width extent))
                                  (height (get-height extent)))
                              (let ((h (+ (fxround h) 4))
                                    (v (max (min (fxround (- vert (/ height 2.))) 86) 0)))
                                (fill-rect surface (h/v/width/height->rect h v width height) {Color Black})
                                (draw-text surface h v s text-color))))))))))))))))))
