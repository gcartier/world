;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Timeline Panel
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.interface.timeline jazz


(import (jazz.cairo)
        (jazz.component)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.math)
        (jazz.platform)
        (jazz.screen)
        (jazz.stream)
        (jazz.time)
        (gaea.geometry)
        (gaea.math)
        (world)
        (world.biome)
        (world.change)
        (world.chronology)
        (world.context)
        (world.event)
        (world.evolution)
        (world.history)
        (world.interface)
        (world.interface.panel)
        (world.interface.profiler)
        (world.interface.widgets)
        (world.profiling)
        (world.render)
        (world.settings)
        (world.task)
        (world.udp))


(definition protected chronology-red     {Color red: .995 green: .185 blue: .197})
(definition protected chronology-orange  {Color red: .995 green: .699 blue: .292})
(definition protected chronology-yellow  {Color red: .995 green: .946 blue: .005})
(definition protected chronology-green   {Color red: .125 green: .995 blue: .129})
(definition protected chronology-cyan    {Color red: .112 green: .856 blue: .845})
(definition protected chronology-blue    {Color red: .216 green: .274 blue: .953})
(definition protected chronology-purple  {Color red: .478 green: .333 blue: .995})
(definition protected chronology-magenta {Color red: .799 green: .373 blue: .918})
(definition protected chronology-gray    {Color Dark-Gray})


(definition protected timeline-text-color
  (world-setting 'world.timeline-text {Color Dark-Gray}))

(definition protected timeline-knees?
  (world-setting 'world.timeline-knees? #f))

(definition protected timeline-traffic?
  (world-setting 'world.timeline-traffic? #f))

(definition protected timeline-roundtrip?
  (world-setting 'world.timeline-roundtrip? #t))

(definition protected timeline-latency?
  (world-setting 'world.timeline-latency? #t))

(definition protected timeline-contour?
  (world-setting 'world.timeline-contour? #f))

(definition protected timeline-keyframes?
  (world-setting 'world.timeline-keyframes? #f))

(definition protected timeline-elapse?
  (world-setting 'world.timeline-elapse? #f))


(definition protected visualizer-quantum
  (world-setting 'world.visualizer-quantum .01))


(definition protected visualizer-speed
  (world-setting 'world.visualizer-speed 1.))

(definition speed-factors
  '(.25 .33 .5 .67 .75 .8 .9 1. 1.1 1.25 1.5 1.75 2. 2.5 3. 4. 5.))


(definition log-colors
  (vector {Color White}
          {Color Red}
          {Color Orange}
          {Color Yellow}
          {Color Green}
          {Color Cyan}
          {Color Cyan}
          {Color Cyan}))


(definition protected all-chronology?
  #f)

(definition protected (set-all-chronology? flag)
  (set! all-chronology? flag))
 
 
(definition protected plot?
  #t)

(definition protected (set-plot? flag)
  (set! plot? flag))


(definition protected (estimate-variance evolution)
  ;; accurate variance is obtained when the round trip is symetrical
  ;; for now we guess that the most symetrical round trip is the smallest one
  (with-mutex evolution
    (lambda ()
      (let ((most-accurate-variance #f)
            (smallest-round-trip #f))
        (loop (for n from (first-position evolution) to (last-position evolution))
              (let ((id (evolutionary-udp-id evolution n)))
                (when (= id udp-id-receive-ack)
                  (let ((round-trip (evolutionary-udp-receive-ack-round-trip evolution n)))
                    (when (or (not smallest-round-trip)
                              (< round-trip smallest-round-trip))
                      (let ((ack-sent (evolutionary-udp-receive-ack-ack-sent evolution n))
                            (ack-received (evolutionary-udp-time evolution n)))
                        (let ((variance (- ack-received ack-sent (/ round-trip 2))))
                          (set! most-accurate-variance variance)
                          (set! smallest-round-trip round-trip))))))))
        (values most-accurate-variance smallest-round-trip)))))


;;;
;;;; Evolution
;;;


(definition protected (layout-evolution)
  (let ((window (current-window))
        (world (current-world)))
    (let ((world-width (get-width window))
          (world-height (get-height window))
          (sheet (get-evolution-sheet world)))
      (let ((h (center (get-width sheet) world-width))
            (v 10))
        (set-position sheet (new Point h v))))))


(definition protected (draw-evolution)
  (let ((world (current-world))
        (interface (current-interface)))
    (let ((view (child interface 'evolution))
          (sheet (get-evolution-sheet world)))
      (unless (get-uptodate? view)
        (let ((texture (get-texture sheet)))
          (let ((surface (get-surface texture))
                (data (get-data texture)))
            (draw-view-data view surface data)
            (flush surface)
            (map-texture texture)
            (set-uptodate? view #t))))
      (render-sheet sheet))))


(definition protected (refresh-evolution)
  (let ((interface (current-interface+)))
    (when interface
      (let ((panel (child interface 'evolution)))
        (when (not (get-sites panel))
          (setup-sites panel (sites-metadata)))
        (when (not (get-chronology panel))
          (set-chronology panel (current-chronology)))
        (when (not (get-evolution panel))
          (set-evolution panel (current-evolution)))
        (when (not (get-from panel))
          (set-uptodate? panel #f))))))


;;;
;;;; History
;;;


(definition protected (layout-history)
  (let ((window (current-window))
        (world (current-world)))
    (let ((world-width (get-width window))
          (world-height (get-height window))
          (sheet (get-history-sheet world)))
      (let ((h (center (get-width sheet) world-width))
            (v 10))
        (set-position sheet (new Point h v))))))


(definition protected (draw-history)
  (let ((world (current-world))
        (interface (current-interface)))
    (let ((view (child interface 'history))
          (sheet (get-history-sheet world)))
      (unless (get-uptodate? view)
        (let ((texture (get-texture sheet)))
          (let ((surface (get-surface texture))
                (data (get-data texture)))
            (draw-view-data view surface data)
            (flush surface)
            (map-texture texture)
            (set-uptodate? view #t))))
      (render-sheet sheet))))


(definition protected (refresh-history)
  (let ((interface (current-interface+)))
    (when interface
      (let ((panel (child interface 'history)))
        (when (not (get-sites panel))
          (setup-sites panel (sites-metadata)))
        (when (not (get-chronology panel))
          (set-chronology panel (current-chronology)))
        (when (not (get-history panel))
          (set-history panel (current-history)))
        (when (not (get-from panel))
          (set-uptodate? panel #f))))))


;;;
;;;; Sites
;;;


(proclaim (not check bounds)
          (warn optimizations))


(class Site-Look extends Object
  
  
  (slot name               getter generate)
  (slot default?   <bool>  getter generate)
  (slot rank       <fx>    getter generate)
  (slot color      <Color> getter generate)
  
  
  (method override (initialize self name default? rank color)
    (nextmethod self)
    (set! self.name name)
    (set! self.default? default?)
    (set! self.rank rank)
    (set! self.color color))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name)))))


(definition protected site-looks <table>
  (make-table test: eq?))

(definition protected default-site-rank <fx+>
  #f)

(definition protected default-site-color <Color+>
  #f)

(definition public (default-site-look rank color)
  (set! default-site-rank rank)
  (set! default-site-color color))

(definition public (register-site-look name rank color) <void>
  (let ((look (new Site-Look name #f rank color)))
    (table-set! site-looks name look)))

(definition public (registered-site-look name) <Site-Look+>
  (table-ref site-looks name #f))


(proclaim (default check types))


;;;
;;;; Events
;;;


(proclaim (not check bounds zero)
          (warn optimizations))


(class Event-Look extends Object
  
  
  (slot rank  <fx+>    getter generate)
  (slot color <Color+> getter generate)
  
  
  (method override (initialize self rank color)
    (nextmethod self)
    (set! self.rank rank)
    (set! self.color color)))


(definition protected event-looks <table>
  (make-table test: eq?))

(definition protected default-event-look <Event-Look+>
  #f)

(definition public (register-event-look id rank color) <void>
  (let ((look (new Event-Look rank color)))
    (if id
        (table-set! event-looks (flonum->fixnum id) look)
      (set! default-event-look look))))

(definition public (registered-event-look id) <Event-Look+>
  (table-ref event-looks id #f))


(proclaim (not check types))


(definition protected id-event-looks <vector>
  (make-vector 2048 #t))

(definition protected (id->event-look id <fx>) <Event-Look+>
  (let ((value (vector-ref id-event-looks id)))
    (if (eq? value #t)
        (let ((look (registered-event-look id)))
          (vector-set! id-event-looks id look)
          look)
      value)))


(proclaim (default check types))


(definition protected (reset-event-looks)
  (set! event-looks (make-table test: eq?))
  (set! default-event-look #f)
  (set! id-event-looks (make-vector 2048 #t)))


;;;
;;;; Timeline
;;;


(class Timeline-Panel extends World-Panel
  
  
  (slot tier                          initialize #f  accessors generate)
  (slot origin                        initialize #f  accessors generate)
  (slot channel                       initialize #f  accessors generate)
  (slot scale            <fl>         initialize 0   accessors generate)
  (slot sampling         <fx>         initialize 2   accessors generate)
  (slot start            <fl+>        initialize #f  accessors generate)
  (slot end              <fl+>        initialize #f  accessors generate)
  (slot from             <fl+>        initialize #f  accessors generate)
  (slot to               <fl+>        initialize #f  accessors generate)
  (slot span             <fl>         initialize 5.  accessors generate)
  (slot now              <fl+>        initialize #f  accessors generate)
  (slot drawn-from       <fl+>        initialize #f  accessors generate)
  (slot drawn-to         <fl+>        initialize #f  accessors generate)
  (slot frozen-start     <fl+>        initialize #f  getter generate)
  (slot frozen-end       <fl+>        initialize #f  getter generate)
  (slot sites            <table+>     initialize #f  getter generate)
  (slot sites-count      <fx>         initialize 0   getter generate)
  (slot memory-site-id   <fx+>        initialize #f  getter generate)
  (slot id-site-looks    <vector>     initialize #f  getter generate)
  (slot base-time        <fl>         initialize 0.  accessors generate)
  (slot chronology       <Chronology> initialize #f  accessors generate)
  (slot history          <History+>   initialize #f  accessors generate)
  (slot evolution        <Evolution+> initialize #f  accessors generate)
  (slot evolution-range               initialize #f  accessors generate)
  (slot evolution-left   <fl+>        initialize #f  accessors generate)
  (slot evolution-right  <fl+>        initialize #f  accessors generate)
  (slot latency-kind     <fx>         initialize #f  accessors generate)
  (slot lowest-latency   <fl+>        initialize #f  accessors generate)
  (slot cpu%             <fl+>        initialize #f  accessors generate)
  (slot live?                         initialize #t  accessors generate)
  (slot replay?                       initialize #f  accessors generate)
  (slot uptodate?                     initialize #f  accessors generate)
  (slot image-surface                 initialize #f  accessors generate)
  (slot image-valid?                  initialize #f  accessors generate)
  (slot visualizer-start <fl+>        initialize #f  accessors generate)
  (slot visualizer-end   <fl+>        initialize #f  accessors generate)
  (slot visualize?                    initialize #f  getter generate)
  (slot variance         <fl+>        initialize #f  getter generate)
  (slot variance-rtt     <fl+>        initialize #f  getter generate)
  ;; scroll code is a copy/paste from showcase
  (slot point                         initialize #f  getter generate)
  (slot moved?                        initialize #f  getter generate)
  (slot scrolled?                     initialize #f  getter generate)
  (slot last-to                       initialize #f  getter generate)
  (slot last-seconds                  initialize #f  getter generate)
  (slot last-speed                    initialize #f  getter generate)
  (slot pulse                         initialize #f  getter generate)
  (slot widgets                       initialize (new Widgets) getter generate)
  (slot boxes                         initialize #f  getter generate)
  (slot labels                        initialize #f  getter generate)
  (slot playing?                      initialize #f  getter generate)
  (slot play-thread                   initialize #f  getter generate)
  (slot full-mode?                    initialize #f  accessors generate)
  (slot events-mode                   initialize #f  accessors generate)
  (slot grid-mode                     initialize 'evolution accessors generate)
  (slot discards                      initialize #f  getter generate)
  (slot missings                      initialize #f  getter generate)
  (slot highlighted                   initialize #f  getter generate)
  (slot elapses                       initialize #f  getter generate)
  (slot graphs                        initialize '() getter generate)
  (slot graph-scale      <fl>         initialize 1.  getter generate)
  (slot rtt-scale        <fl>         initialize #f  getter generate)
  (slot latency-scale    <fl>         initialize #f  getter generate)
  (slot delivery-scale   <fl>         initialize #f  getter generate)
  (slot pacing-scale     <fl>         initialize #f  getter generate)
  (slot window-scale     <fl>         initialize #f  getter generate)
  (slot traffic-scale    <fl>         initialize #f  getter generate)
  (slot missing-scale    <fl>         initialize #f  getter generate)
  (slot plot-traffic?                 initialize timeline-traffic? accessors generate)
  (slot plot-roundtrip?               initialize timeline-roundtrip? accessors generate)
  (slot plot-latency?                 initialize timeline-latency? accessors generate)
  (slot plot-contour?                 initialize timeline-contour? accessors generate)
  (slot upload?                       initialize #t  accessors generate)
  (slot lite?                         initialize #f  accessors generate)
  (slot show-knees?                   initialize timeline-knees? accessors generate)
  (slot border-color                  initialize {Color Entry-Border} accessors generate)
  
  
  (method override (prepare self rest)
    (nextmethod self rest)
    (set! latency-kind udp-audio)
    (set! rtt-scale (* 41. graph-scale))
    (set! latency-scale (* 32. graph-scale))
    (set! delivery-scale (* 4.75 graph-scale))
    (set! pacing-scale (* 4.75 graph-scale))
    (set! window-scale (* 180.75 graph-scale))
    (set! traffic-scale (* .045 graph-scale))
    (set! missing-scale (* 5. graph-scale)))
  
  
  ;;;
  ;;;; Image
  ;;;
  
  
  (method override (size-change self size)
    (nextmethod self size)
    (when image-surface
      (close image-surface)
      (set! image-surface #f)))
  
  
  (method (cache-image-surface self)
    (or image-surface
        (let ((scale-factor (main-screen-scale-factor)))
          (define (new-image-surface width height)
            (let ((surface (new Image-Surface (new Dimension width height)))
                  (scale (cast <fl> scale-factor)))
              (cairo_surface_set_device_scale (get-handle surface) scale scale)
              surface))
          
          (let ((width (scale->device (get-width self) scale-factor))
                (height (scale->device (get-height self) scale-factor)))
            (let ((surface (new-image-surface width height)))
              (set! image-surface surface)
              (set! image-valid? #f)
              surface)))))
  
  
  (method protected (invalidate-image self)
    (set! image-valid? #f))
  
  
  (method protected (set-graph-scale self scale)
    (set! graph-scale scale)
    (invalidate-image self)
    (invalidate-view self))
  
  
  ;;;
  ;;;; Bounds
  ;;;
  
  
  (method protected (update-span self)
    (set! span (- to from)))
  
  
  (method protected (set-bounds self f t)
    (assert (<= f t)
      (set! from f)
      (set! to t)))
  
  
  (method (with-bounds self proc)
    (if (not from)
        (let ((start (timeline-start self))
              (end (timeline-end self)))
          (let ((from (max start (- end span)))
                (to end))
            (proc from to)))
      (proc from to)))
  
  
  (method package (set-elapses self elap)
    (unless (equal? elap elapses)
      (set! elapses elap)
      (invalidate-view self)))
  
  
  (method package (freeze-time self)
    (set! frozen-start (timeline-start self))
    (set! frozen-end (timeline-end self)))
  
  
  (method package (thaw-time self)
    (set! frozen-start #f)
    (set! frozen-end #f))
  
  
  (method package (time-frozen? self)
    (boolean frozen-start))
  
  
  (method protected virtual (timeline-start self) <fl>
    (define (fresh-start)
      (if (empty? chronology)
          (if evolution
              (evolutionary-time evolution (first-position evolution))
            (historical-time history (first-position history)))
        (chronological-time chronology (first-position chronology))))
    
    (or frozen-start
        (if live?
            (fresh-start)
          (or start
              (let ((start (fresh-start)))
                (set! self.start start)
                start)))))
  
  
  (method protected virtual (timeline-end self) <fl>
    (define (fresh-end)
      (if (empty? chronology)
          (if evolution
              (evolutionary-time evolution (last-position evolution))
            (historical-time history (last-position history)))
        (chronological-time chronology (last-position chronology))))
    
    (or frozen-end
        (if live?
            (fresh-end)
          (or end
              (let ((end (fresh-end)))
                (set! self.end end)
                end)))))
  
  
  (method protected (reset-start/end self)
    (set! start #f)
    (set! end #f))
  
  
  (proclaim (not check types))
  
  
  (method protected (setup-sites self alist)
    (set! sites (list->table alist))
    (set! sites-count (table-length sites))
    (set! memory-site-id (table-find sites 'memory))
    (set! id-site-looks (make-vector 256 #f)))
  
  
  (method (id->site-look self id <fx>) <Site-Look>
    (or (vector-ref id-site-looks id)
        (let ((name (table-ref (allege sites) id)))
          (let ((look (or (and name (registered-site-look name))
                          (new Site-Look name #t default-site-rank default-site-color))))
            (vector-set! id-site-looks id look)
            look))))
  
  
  (proclaim (default check types))

  
  (method package (setup-live-information self)
    (unless live?
      (set! live? #t)
      (set! from #f)
      (set! to #f)
      (set! lowest-latency #f)
      (setup-sites self (sites-metadata))
      (live-information self)
      (set! cpu% #f)))
  
  
  (method package (setup-copy-information self)
    (when live?
      (set! live? #f)
      (setup-sites self (sites-metadata))
      (copy-information self)
      (set! cpu% (chronology-cpu% chronology sites-count))))
  
  
  (method protected virtual (live-information self)
    (set! history (current-history))
    (set! chronology (current-chronology))
    (set! evolution (current-evolution)))
  
  
  (method protected virtual (copy-information self)
    (set! history (copy-history (current-history)))
    (set! chronology (copy-chronology (current-chronology)))
    (set! evolution (copy-evolution (current-evolution))))
  
  
  ;; to redo?
  (method (update self time)
    )
  
  
  (method protected (setup-replay self base-time)
    (let ((start (timeline-start self))
          (end (timeline-end self)))
      (set-now self #f)
      (set-bounds self start end)
      (set-base-time self base-time)
      (update-span self)
      (set-replay? self #t)
      (set-live? self #f)
      (set! lowest-latency #f)
      (set! cpu% (chronology-cpu% chronology sites-count))
      (receive (var rtt) (estimate-variance evolution)
        (set! variance var)
        (set! variance-rtt rtt))
      (redraw self)))
  
  
  (method (rtt->v self rtt <fl>) <fl>
    ;; quick fix until I figure why rtt is sometimes -1.
    (let ((effective-rtt (if (= rtt -1.) 0. rtt)))
      (- evolution-base (* effective-rtt rtt-scale .9))
      @w
      (- evolution-base (* (sqrt effective-rtt) rtt-scale))))
  
  
  (method (latency->v self latency <fl>) <fl>
    (let ((effective-latency (- latency (allege lowest-latency))))
      (- evolution-base (* effective-latency latency-scale .9)))
    @w
    ;; quick fix until guaranteed positive
    (let ((effective-latency (abs (- latency (allege lowest-latency)))))
      (if evolution-proportional?
          (let ((time-scale (/ (cast <fl> (get-width self)) span)))
            (- evolution-base (* effective-latency time-scale)))
        (- evolution-base (* effective-latency latency-scale .9)))
      @w
      (- 85. (* (sqrt effective-latency) latency-scale))))
  
  
  (method (queue->v self queue-rate <fl>) <fl>
    (- 80. (* (sqrt queue-rate) delivery-scale .4)))
  
  
  (method (send->v self send-rate <fl>) <fl>
    (- 80. (* (sqrt send-rate) delivery-scale .4)))
  
  
  (method (pacing->v self pacing <fl>) <fl>
    (- 80. (* (sqrt pacing) pacing-scale .4)))
  
  
  (method (window->v self window <fl>) <fl>
    (- 80. (* (sqrt window) window-scale .4)))
  
  
  (method (traffic->v self traffic <fl>) <fl>
    ;; quick fix until traffic makes sense
    (let ((traffic (abs traffic)))
      (- 80. (* (sqrt traffic) traffic-scale .4))))
  
  
  (method protected virtual (view-update self)
    )
  
  
  (method protected virtual (now-update self)
    )


  (proclaim (not warn optimizations))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method override (mouse-down self evt)
    @not-sure
    (setup-copy-information self)
    (with-bounds self
      (lambda (from~ to~)
        (if (and (not live?) (not (find-widget widgets (get-position evt))) (between? (get-v evt) (- evolution-timeline 10) (+ evolution-timeline 10)))
            (begin
              (set! visualize? #t)
              (set! now (h->when self from to (get-h evt)))
              (redraw self)
              (now-update self))
          (set! visualize? #f)
          (set! point (get-h evt))
          (set! moved? #f)
          (set! last-to to~)
          (set! last-seconds (current-seconds))
          (set! last-speed #f)
          (kill-autoscroll self)))))
  
  
  (method override (drag-move self evt)
    (let ((h (get-h evt)))
      (if visualize?
          (begin
            (set! now (h->when self from to (get-h evt)))
            (redraw self)
            (now-update self))
        (when (and point (not (near? h point 2)))
          (with-bounds self
            (lambda (from~ to~)
              (let ((delta (* (/ (cast <fl> (- h point)) (cast <fl> (get-width self))) (- span)))
                    (start (timeline-start self))
                    (end (timeline-end self)))
                (let ((new-from (+ from~ delta))
                      (new-to (+ to~ delta)))
                  (cond ((> new-to end)
                         (set-bounds self (- end span) end))
                        ((< new-from start)
                         (set-bounds self start (+ start span)))
                        (else
                         (set-bounds self new-from new-to))))
                (update-span self)
                (redraw self))
              (set! point h)
              (set! moved? #t)
              (let ((new-to to)
                    (new-seconds (current-seconds))
                    (old-to last-to)
                    (old-seconds last-seconds))
                (set! last-to new-to)
                (set! last-seconds new-seconds)
                (unless (= new-seconds old-seconds)
                  (let ((new-speed (/ (- new-to old-to) (- new-seconds old-seconds)))
                        (p .9))
                    (set! last-speed (+ (* new-speed (- 1. p)) (* (or last-speed 0.) p))))))))))))

  
  (method override (mouse-up self evt)
    (if visualize?
        (begin
          (set! visualize? #f)
          (set! now (h->when self from to (get-h evt)))
          (redraw self)
          (now-update self))
      (if (or (not moved?) (< (- (current-seconds) last-seconds) .1))
          (if moved?
              (begin
                (set! scrolled? #f)
                (start-autoscroll self))
            (with-bounds self
              (lambda (from to)
                (set! point (get-h evt))
                (set! moved? #f)
                (set! scrolled? #f)
                (set! last-speed #f)
                (set! now (h->when self from to point))
                (redraw self)
                (now-update self)
                (kill-autoscroll self))))
        (view-update self))))
  
  
  (method override (right-mouse-up self evt)
    (if (not live?)
        (zoom-reset self)
      (setup-live-information self)
      (set! from #f)
      (set! to #f)
      (set! span 5.)
      (redraw self)
      (view-update self)))
  
  
  (method override (mouse-wheel self pos delta)
    (let ((d (get-v delta)))
      (if (alt-down?)
          (cond ((> d 0)
                 (scale-up self))
                ((< d 0)
                 (scale-down self)))
        (cond ((> d 0)
               (zoom-in self))
              ((< d 0)
               (zoom-out self))))))
  
  
  (method package (zoom-in self)
    (let ((start (timeline-start self))
          (end (timeline-end self)))
      (let ((max-span (- end start)))
        (if (not from)
            (set! span (min max-span (* span .75)))
          (let ((h (get-h (mouse-position self)))
                (width (get-width self)))
            (let ((proportion (/ (cast <fl> h) (cast <fl> width))))
              (let ((when (+ from (* span proportion)))
                    (new-span (min max-span (* span .75))))
                (let ((new-from (- when (* new-span proportion)))
                      (new-to (+ when (* new-span (- 1. proportion)))))
                  (set-bounds self (max start new-from) (min end new-to))
                  (update-span self))))))))
    (redraw self)
    (view-update self))
  
  
  (method package (zoom-out self)
    (let ((start (timeline-start self))
          (end (timeline-end self)))
      (let ((max-span (- end start)))
        (if (not from)
            (set! span (min max-span (/ span .75)))
          (let ((h (get-h (mouse-position self)))
                (width (get-width self)))
            (let ((proportion (/ (cast <fl> h) (cast <fl> width))))
              (let ((when (+ from (* span proportion)))
                    (new-span (min max-span (/ span .75))))
                (let ((new-from (- when (* new-span proportion)))
                      (new-to (+ when (* new-span (- 1. proportion)))))
                  (set-bounds self (max start new-from) (min end new-to))
                  (update-span self))))))))
    (redraw self)
    (view-update self))
  
  
  (method package (zoom-reset self)
    (set-bounds self (timeline-start self) (timeline-end self))
    (update-span self)
    (redraw self)
    (view-update self))
  
  
  (method (scale-up self)
    (set-graph-scale self (/ graph-scale .9 @w .75)))
  
  
  (method (scale-down self)
    (set-graph-scale self (* graph-scale .9 @w .75)))


  (proclaim (warn optimizations))
  
  
  (method protected (h->when self from to h)
    (let ((width (get-width self)))
      (cond ((< h 0)
             from)
            ((> h width)
             to)
            (else
             (+ from (* span (/ (cast <fl> h) (cast <fl> width))))))))
  
  
  (method protected (when->h self from <fl> to <fl> span <fl> when <fl>) <fx>
    (fxround (* (/ (- when from) span) (cast <fl> (get-width self)))))


  (proclaim (not warn optimizations))
  
  
  ;;;
  ;;;; Autoscroll
  ;;;
  
  
  (method (start-autoscroll self)
    (set! pulse (new Pulse 'autoscroll 0.01 (~ autoscroll-action self) delay: 0)))
  
  
  (method (kill-autoscroll self)
    (when pulse
      (close pulse)
      (set! pulse #f)))
  
  
  (method (autoscroll-action self)
    (when (and last-speed (not live?))
      (let ((actual-to to))
        (let ((scroll-to (+ actual-to (/ last-speed 100.))))
          (let ((new-to scroll-to))
            (when (/= new-to actual-to)
              (set! scrolled? #t)
              (let ((new-from (- new-to span)))
                (let ((start (timeline-start self))
                      (end (timeline-end self)))
                  (cond ((> new-to end)
                         (set-bounds self (- end span) end))
                        ((< new-from start)
                         (set-bounds self start (+ start span)))
                        (else
                         (set-bounds self new-from new-to)))
                  (update-span self)
                  (redraw self)
                  (when (or (<= new-from start)
                            (>= new-to end))
                    (set! scrolled? #f)
                    (kill-autoscroll self)
                    (view-update self))))))))))
  
  
  ;;;
  ;;;; Graph
  ;;;
  
  
  (method public (register-graphs self graphs)
    (set! self.graphs graphs)
    (invalidate-view self))
  
  
  ;;;
  ;;;; Draw
  ;;;


  (proclaim (warn optimizations))
  
  
  (method package (redraw self)
    (unless visualize?
      (set! image-valid? #f))
    (if replay?
        (invalidate-view self)
      (set-uptodate? self #f)))
  
  
  (method override (draw self surface <Surface> context)
    ;; quick solution
    (let ((interface (current-interface)))
      (unless (or (eq? self (child interface 'evolution))
                  (eq? self (child interface 'history)))
        ;; quick hack
        (when (and chronology evolution)
          (with-bounds self
            (lambda (from to)
              (set! drawn-from from)
              (set! drawn-to to)
              (let ((image-surface (cache-image-surface self)))
                (when (not image-valid?)
                  (draw-view self image-surface from to #f)
                  (set! image-valid? #t))
                (blit-surface surface image-surface)
                (plot-now self surface from to))))))))
  
  
  (method package (draw-view-data self surface <Surface> data)
    (with-bounds self
      (lambda (from to)
        (set! drawn-from from)
        (set! drawn-to to)
        (draw-view self surface from to data)
        (plot-now self surface from to))))


  (method package (draw-view self surface <Surface> from <fl> to <fl> data)
    (clear surface)
    (fill-rect surface (new Rect 0 0 (get-width self) (get-height self)) {Color red: .000 green: .000 blue: .000 alpha: .450})
    (draw-timeline self surface)
    (when border-color
      (frame-rect surface (new Rect 0 0 (get-width self) (get-height self)) border-color)))
  
  
  (method (draw-timeline self surface <Surface>)
    (when chronology
      (let ((timer (new Timer))
            (cpu-duration #f)
            (history-duration #f)
            (chronology-duration #f)
            (evolution-duration #f)
            (highlight-duration #f)
            (nowinfo-duration #f))
        (when (and plot? live? (not lite?) (not timeline-less?))
          (let ((timer (new Timer)))
            (set! cpu% (chronology-cpu% chronology sites-count))
            (set! cpu-duration (real-duration timer))))
        (with-bounds self
          (lambda (from to)
            (reset widgets)
            (set! boxes '())
            (set! labels '())
            (set! discards '())
            (set! missings '())
            (set! highlighted '())
            ;; time
            (when plot?
              (plot-time self surface from to))
            ;; history
            (when plot?
              (let ((timer (new Timer)))
                (when (and history (plot-history? self))
                  (plot-history self surface from to))
                (set! history-duration (real-duration timer))))
            (when plot?
            (unless timeline-less?
            (unless lite?
              (if events-mode
                  ;; events
                  (let ((timer (new Timer)))
                    (unless full-mode?
                      (plot-events self surface from to))
                    (set! chronology-duration (real-duration timer)))
                ;; chronology
                (let ((timer (new Timer)))
                  (when (plot-chronology? self)
                    (unless full-mode?
                      (with-mutex chronology
                        (lambda ()
                          (plot-chronology self surface from to)))))
                  (set! chronology-duration (real-duration timer)))))))
            ;; evolution
            (when plot?
              (let ((timer (new Timer)))
                (when evolution
                  (set! latency-kind udp-audio @w (if (control-down?) udp-video udp-audio))
                  (plot-evolution self surface from to))
                (set! evolution-duration (real-duration timer))))
            ;; highlight
            (when plot?
              (let ((timer (new Timer)))
                (plot-highlight self surface from to)
                (set! highlight-duration (real-duration timer))))
            ;; nowinfo
            (when plot?
              (let ((timer (new Timer)))
                (plot-nowinfo self surface from to)
                (set! nowinfo-duration (real-duration timer))))
            ;; info
            (plot-info self surface cpu-duration history-duration chronology-duration evolution-duration highlight-duration nowinfo-duration (real-duration timer)))))))
  
  
  (method protected virtual (plot-info self surface <Surface> cpu-duration history-duration chronology-duration evolution-duration highlight-duration nowinfo-duration duration)
    (let ((left 5)
          (right (- (get-width self) 5)))
      (define (left-widget name title)
        (let ((right (+ left (draw-text surface left 3 title timeline-text-color))))
          (add-widget widgets name (new Rect left 0 right 22))
          (set! left (+ right 20))))
      
      (define (right-widget name title)
        (let ((extent (get-text-extent surface title)))
          (let ((left (- right (get-width extent))))
            (let ((width (draw-text surface left 3 title timeline-text-color)))
              (add-widget widgets name (new Rect left 0 right 22))))))
      
      (set-font surface {Font Label})
      (when tier
        (left-widget 'tier tier))
      (when cpu%
        (left-widget 'cpu (format "CPU: {r precision: 1}%" cpu%)))
      (when upload?
        (let ((info (upload-info (current-udp))))
          (when info
            (left-widget 'upload info))))
      (when evolution-range
        (left-widget 'range (format "Shown: {a}" evolution-range)))
      (when variance
        (left-widget 'variance (format "Variance: {r precision: 3} ({r precision: 3}) " variance variance-rtt)))
      (when title
        (right-widget 'title (if (not timeline-elapse?) title (format "{a} ({a})" title (present-seconds duration)))))
      (when elapses
        (let ((title (format "Elapses: {l detail: :human}" elapses)))
          (draw-text surface 5 40 title timeline-text-color)))
      (when (world-setting 'world.timeline-durations? #f)
        (let ((first? #t)
              (v (if title 17 3)))
          (define (present name duration)
            (if (not duration)
                ""
              (let ((str (format "{a} {a}" name (present-seconds duration))))
                (prog1 (if first?
                           str
                         (string-append ", " str))
                  (set! first? #f)))))
          
          (let ((title (string-append
                         (present "" duration)
                         (present "cpu" cpu-duration)
                         (present "chrono" chronology-duration)
                         (present "evo" evolution-duration)
                         (present "highlight" highlight-duration)
                         (present "now" nowinfo-duration))))
            (let ((width (get-width self))
                  (extent (get-text-extent surface title)))
              (draw-text surface (- width (get-width extent) 5) v title timeline-text-color)))))
      (let ((title (if (eq? grid-mode 'evolution) "Events" "Moments"))
            (right (- (get-width self) 5))
            (top 117))
        (let ((extent (get-text-extent surface title)))
          (let ((left (- right (get-width extent))))
            (draw-text surface left top title timeline-text-color)
            (add-widget widgets 'grid (new Rect left (- top 3) right (+ top 20))))))))
  
  
  (method (plot-time self surface <Surface> from <fl> to <fl>)
    (let ((width (cast <fl> (get-width self)))
          (height (cast <fl> (get-height self)))
          (span (min (- to from) span)))
      (let ((v (cast <fl> evolution-timeline) @w (/ height 2.)))
        ;; time
        (set-color surface {Color Medium-Gray alpha: .7})
        (set-line-width surface 1)
        (move-to surface 0 v)
        (line-to surface width v)
        ;; units
        (let ((from (- from base-time))
              (to (- to base-time)))
          (let ((span (min (- to from) span)))
            (set-color surface {Color Medium-Gray alpha: .7})
            (set-line-width surface 1)
            (loop (for s from (fxceiling from) to (fxfloor to))
                  (let ((h (when->h self from to span (cast <fl> s))))
                    (move-to surface h (- v 3.))
                    (line-to surface h (+ v 4.))))))
        ;; moments
        (when evolution
          (set-line-width surface 1)
          (with-mutex evolution
            (lambda ()
              (loop (for n from (first-position evolution) to (last-position evolution))
                    (when (= (evolutionary-udp-id evolution n) udp-id-moment)
                      (let ((time (evolutionary-udp-time evolution n))
                            (level (evolutionary-udp-data1 evolution n)))
                        (let ((h (when->h self from to span time)))
                          (plot-moment self surface h (flonum->fixnum level)))))))))
        ;; bookmarks
        (when evolution
          (set-color surface {Color White})
          (set-line-width surface 1)
          (with-mutex evolution
            (lambda ()
              (loop (for n from (first-position evolution) to (last-position evolution))
                    (when (= (evolutionary-udp-id evolution n) udp-id-bookmark)
                      (let ((time (evolutionary-udp-time evolution n)))
                        (let ((h (when->h self from to span time)))
                          (move-to surface (- h 3) (- v 3.))
                          (line-to surface (+ h 4) (+ v 4.))
                          (move-to surface (+ h 4) (- v 3.))
                          (line-to surface (- h 3) (+ v 4.)))))))))
        ;; keyframes
        (when (and timeline-keyframes? (not timeline-less?))
          (set-color surface {Color Purple alpha: .85})
          (set-line-width surface 1)
          (with-mutex evolution
            (lambda ()
              (loop (for n from (first-position evolution) to (last-position evolution))
                    (when (= (flonum->fixnum (evolutionary-udp-kind evolution n)) udp-video)
                      (let ((id (evolutionary-udp-id evolution n)))
                        (when (or (= id udp-id-play-frame)
                                  (= id udp-id-freeze-frame))
                          (when (frame-keyframe? (flonum->fixnum (evolutionary-udp-data3 evolution n)))
                            (let ((time (evolutionary-udp-time evolution n)))
                              (let ((h (cast <fl> (when->h self from to span time)))
                                    (color {Color Purple}))
                                (ellipse$fl$ surface (new Rect$fl$ (- h 2.) (- v 2.) (+ h 3.) (+ v 3.)) color color))))))))))))))
  
  
  (method (plot-moment self surface <Surface> h level)
    (let ((v evolution-timeline)
          (color (vector-ref log-colors level)))
      (set-line-width surface 1)
      (set-color surface color)
      (move-to surface (- h 3) (- v 3.))
      (line-to surface (+ h 4) (+ v 4.))
      (move-to surface (+ h 4) (- v 3.))
      (line-to surface (- h 3) (+ v 4.))))
  
  
  ;;;
  ;;;; Evolution
  ;;;
  
  
  (method protected virtual (plot-evolution self surface <Surface> from <fl> to <fl>)
    (let ((start (timeline-start self))
          (end (timeline-end self))
          (evolution (allege evolution)))
      (define (find-first) <fx+>
        (loop (for n from (first-position evolution) to (last-position evolution))
              (when (>= (evolutionary-udp-time evolution n) start)
                (return n))
              (finally #f)))
      
      (define (find-last first <fx>) <fx>
        (loop (for n from first to (last-position evolution))
              (when (> (evolutionary-udp-time evolution n) end)
                (return (- n 1)))
              (finally (last-position evolution))))
      
      (with-mutex evolution
        (lambda ()
          (let ((width (cast <fl> (get-width self)))
                (height (cast <fl> (get-height self)))
                (span (min (- to from) span))
                (dark-purple {Color red: .464 green: .141 blue: .732})
                (insert-count 0)
                (last-audio-early -100)
                (last-video-early -100)
                (last-audio-late -100)
                (last-video-late -100)
                (previous-raw-latency-h #f)
                (previous-raw-latency-v #f)
                (previous-latency-h #f)
                (previous-latency-v #f)
                (previous-latency <fl+> #f)
                (previous-contour-latency-h #f)
                (previous-contour-latency-v #f)
                (previous-contour-latency <fl+> #f)
                (previous-rtt-h #f)
                (previous-rtt-v #f)
                (previous-queue-h #f)
                (previous-queue-v #f)
                (previous-send-h #f)
                (previous-send-v #f)
                (previous-pacing-h #f)
                (previous-pacing-v #f)
                (previous-window-h #f)
                (previous-window-v #f)
                (previous-traffic-send-h #f)
                (previous-traffic-send-v #f)
                (previous-traffic-receive-h #f)
                (previous-traffic-receive-v #f)
                (previous-missing-h #f)
                (previous-missing-v #f)
                (graphs (map new graphs))
                (now-h (and now (when->h self from to span now)))
                (first (find-first)))
            (when first
              (let ((last (find-last first)))
                (define (find-head) <fx>
                  (loop (for n from first to last)
                        (when (>= (evolutionary-udp-time evolution n) from)
                          (return n))
                        (finally first)))
                
                (define (find-tail head <fx>) <fx>
                  (loop (for n from head to last)
                        (when (> (evolutionary-udp-time evolution n) to)
                          (return (- n 1)))
                        (finally last)))
                
                (define (find-previous head <fx> id <fl>) <fx+>
                  (loop (for n from (- head 1) downto first)
                        (when (= (evolutionary-udp-id evolution n) id)
                          (return n))
                        (finally #f)))
                
                (define (find-next tail <fx> id <fl>) <fx+>
                  (loop (for n from (+ tail 1) to last)
                        (when (= (evolutionary-udp-id evolution n) id)
                          (return n))
                        (finally #f)))
                
                (let ((head (find-head)))
                  (let ((tail (find-tail head))
                        (sampling (cond ((<= span 1.) 1)
                                        ((>= span 60.) 100)
                                        (else (fxround (interpolate span 1. 60. 1. 100.)))))
                        (last-heartbeat-sequence #f))
                    (define (find-lowest-latency kind)
                      (let ((lowest-latency <fl+> #f))
                        (loop (for n from head to tail)
                              (let ((id (evolutionary-udp-id evolution n)))
                                (when (and (= id udp-id-insert-packet)
                                           (eqv? (flonum->fixnum (evolutionary-udp-origin evolution n)) origin)
                                           (eqv? (flonum->fixnum (evolutionary-udp-kind evolution n)) kind)
                                           (or (not channel) (= (flonum->fixnum (evolutionary-udp-channel evolution n)) channel)))
                                  (let ((raw-latency (evolutionary-udp-insert-packet-raw-latency evolution n)))
                                    (when (or (not lowest-latency)
                                              (< raw-latency lowest-latency))
                                      (set! lowest-latency raw-latency))))))
                        (or lowest-latency 0.)))
                    
                    (set! lowest-latency 0.)
                    @wait-as-this-makes-it-harder-to-debug-real-latency
                    (when #t;(not lowest-latency)
                      (set! lowest-latency (find-lowest-latency latency-kind)))
                    (set-line-width surface 1.)
                    (for-each (lambda (graph)
                                (draw-context graph self surface from to span sampling evolution))
                              graphs)
                    (loop (for n from head to tail)
                          (let ((time (evolutionary-udp-time evolution n))
                                (id (evolutionary-udp-id evolution n)))
                            (let ((h (fxround (* (/ (- time from) span) width))))
                              (define (plot-latency raw-color latency-color)
                                (when (and plot-latency?
                                           (eqv? (flonum->fixnum (evolutionary-udp-origin evolution n)) origin)
                                           (eqv? (flonum->fixnum (evolutionary-udp-kind evolution n)) latency-kind)
                                           (or (not channel) (= (flonum->fixnum (evolutionary-udp-channel evolution n)) channel)))
                                  (set-line-width surface 1.)
                                  (set-color surface raw-color)
                                  (let ((raw-latency (evolutionary-udp-insert-packet-raw-latency evolution n)))
                                    (let ((v (fxround (latency->v self raw-latency))))
                                      (when (not previous-raw-latency-h)
                                        (let ((n (find-previous head id)))
                                          (when n
                                            (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                                  (v (fxround (latency->v self (evolutionary-udp-insert-packet-raw-latency evolution n)))))
                                              (set! previous-raw-latency-h h)
                                              (set! previous-raw-latency-v v)))))
                                      (when previous-raw-latency-h
                                        (move-to surface previous-raw-latency-h previous-raw-latency-v)
                                        (line-to surface h v))
                                      (when show-knees?
                                        (ellipse surface (new Rect (- h 1) (- v 1) (+ h 2) (+ v 2)) {Color Blue} {Color Blue}))
                                      (set! previous-raw-latency-h h)
                                      (set! previous-raw-latency-v v)))
                                  (set-line-width surface 1.)
                                  (let ((latency (evolutionary-udp-insert-packet-effective-latency evolution n)))
                                    (let ((v (fxround (latency->v self (if (= latency +inf.flo) (or previous-latency 0.) latency))))
                                          (color (if @less (= latency +inf.flo) {Color Dark-Red} latency-color)))
                                      (set-color surface color)
                                      (when (not previous-latency-h)
                                        (let ((n (find-previous head id)))
                                          (when n
                                            (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                                  (v (fxround (latency->v self (evolutionary-udp-insert-packet-effective-latency evolution n)))))
                                              (set! previous-latency-h h)
                                              (set! previous-latency-v v)))))
                                      (when previous-latency-h
                                        (move-to surface previous-latency-h previous-latency-v)
                                        (line-to surface h v))
                                      (when show-knees?
                                        (ellipse surface (new Rect (- h 1) (- v 1) (+ h 2) (+ v 2)) color color))
                                      (set! previous-latency-h h)
                                      (set! previous-latency-v v)
                                      (when (/= latency +inf.flo)
                                        (set! previous-latency latency))))))
                              
                              (ecase id
                                ((udp-id-insert-packet)
                                 (when plot-latency?
                                   (when (= insert-count 0)
                                     (if (= latency-kind udp-audio)
                                         (plot-latency {Color Blue} {Color red: .005 green: .466 blue: .995})
                                       (plot-latency {Color red: .632 green: .005 blue: .995} {Color red: .790 green: .436 blue: .995})))
                                   (when timeline-fast?
                                     (set! insert-count (modulo (+ insert-count 1) 10)))))
                                ((udp-id-contour-latency)
                                 (when (and plot-contour?
                                            (eqv? (flonum->fixnum (evolutionary-udp-kind evolution n)) udp-audio))
                                   (set-line-width surface 1.)
                                   (set-color surface {Color Orange})
                                   (let ((contour-latency (evolutionary-udp-contour-latency evolution n)))
                                     (let ((v (fxround (latency->v self contour-latency))))
                                       (when (not previous-contour-latency-h)
                                         (let ((n (find-previous head id)))
                                           (when n
                                             (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                                   (v (fxround (latency->v self (evolutionary-udp-contour-latency evolution n)))))
                                               (set! previous-contour-latency-h h)
                                               (set! previous-contour-latency-v v)))))
                                       (when previous-contour-latency-h
                                         (move-to surface previous-contour-latency-h previous-contour-latency-v)
                                         (line-to surface h previous-contour-latency-v)
                                         (move-to surface h previous-contour-latency-v)
                                         (line-to surface h v)
                                         @w
                                         (ellipse surface (new Rect (- h 1) (- v 1) (+ h 2) (+ v 2)) {Color Orange} {Color Orange}))
                                       (set! previous-contour-latency-h h)
                                       (set! previous-contour-latency-v v)
                                       (set! previous-contour-latency contour-latency)))))
                                ((udp-id-receive-ack)
                                 (when (and plot-roundtrip? (not timeline-less?))
                                 (let ((heartbeat-sequence (flonum->fixnum (evolutionary-udp-receive-ack-heartbeat-sequence evolution n)))
                                       (rtt (evolutionary-udp-receive-ack-round-trip evolution n))
                                       (expected-sequence (and last-heartbeat-sequence (+ last-heartbeat-sequence 1))))
                                   (let ((v (fxround (rtt->v self rtt)))
                                         (color (if (or (not expected-sequence)
                                                        (= heartbeat-sequence expected-sequence))
                                                    {Color Green}
                                                  {Color Red})))
                                     (set! last-heartbeat-sequence heartbeat-sequence)
                                     (set-line-width surface .8)
                                     (set-color surface color)
                                     (when (not previous-rtt-h)
                                       (let ((n (find-previous head id)))
                                         (when n
                                           (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                                 (v (fxround (rtt->v self (evolutionary-udp-receive-ack-round-trip evolution n)))))
                                             (set! previous-rtt-h h)
                                             (set! previous-rtt-v v)))))
                                     (when previous-rtt-h
                                       (move-to surface previous-rtt-h previous-rtt-v)
                                       (line-to surface h v)
                                       (when show-knees?
                                         (when expected-sequence
                                           (let ((gap (- heartbeat-sequence expected-sequence)))
                                             (when (> gap 1)
                                               (let ((hdiv (/ (cast <fl> (- h previous-rtt-h)) (cast <fl> gap)))
                                                     (vdiv (/ (cast <fl> (- v previous-rtt-v)) (cast <fl> gap))))
                                                 (loop (for n from 1 below gap)
                                                       (let ((h (+ previous-rtt-h (* n hdiv)))
                                                             (v (+ previous-rtt-v (* n vdiv))))
                                                         (ellipse$fl$ surface (new Rect$fl$ (- h 1) (- v 1) (+ h 2) (+ v 2)) {Color Red} {Color Black})))))))
                                         (ellipse surface (new Rect (- h 1) (- v 1) (+ h 2) (+ v 2)) {Color Green} {Color Green})))
                                     (set! previous-rtt-h h)
                                     (set! previous-rtt-v v)
                                     (set-line-width surface 1.)))))
                                ((udp-id-queue-rate)
                                 (let ((color {Color Dark-Purple}))
                                   (set-line-width surface 1.)
                                   (set-color surface color)
                                   (let ((delivery (evolutionary-udp-queue-rate-average evolution n)))
                                     (let ((v (fxround (queue->v self delivery))))
                                       (when (not previous-queue-h)
                                         (let ((n (find-previous head id)))
                                           (when n
                                             (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                                   (v (fxround (queue->v self (evolutionary-udp-queue-rate-average evolution n)))))
                                               (set! previous-queue-h h)
                                               (set! previous-queue-v v)))))
                                       (when previous-queue-h
                                         (move-to surface previous-queue-h previous-queue-v)
                                         (line-to surface h v))
                                       (set! previous-queue-h h)
                                       (set! previous-queue-v v)))))
                                ((udp-id-send-rate)
                                 (when (= (modulo (evolutionary-udp-bbr-order evolution n) 10) 0)
                                   (let ((color {Color Purple}))
                                     (set-line-width surface 1.)
                                     (set-color surface color)
                                     (let ((delivery (evolutionary-udp-send-rate-average evolution n)))
                                       (let ((v (fxround (send->v self delivery))))
                                         (when (not previous-send-h)
                                           (let ((n (find-previous head id)))
                                             (when n
                                               (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                                     (v (fxround (send->v self (evolutionary-udp-send-rate-average evolution n)))))
                                                 (set! previous-send-h h)
                                                 (set! previous-send-v v)))))
                                         (when previous-send-h
                                           (move-to surface previous-send-h previous-send-v)
                                           (line-to surface h v))
                                         (set! previous-send-h h)
                                         (set! previous-send-v v))))))
                                ((udp-id-bbr-pacing)
                                 (let ((color {Color Blue}))
                                   (set-line-width surface 1.)
                                   (set-color surface color)
                                   (let ((pacing (evolutionary-udp-bbr-pacing evolution n)))
                                     (let ((v (fxround (pacing->v self pacing))))
                                       (when (not previous-pacing-h)
                                         (let ((n (find-previous head id)))
                                           (when n
                                             (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                                   (v (fxround (pacing->v self (evolutionary-udp-bbr-pacing evolution n)))))
                                               (set! previous-pacing-h h)
                                               (set! previous-pacing-v v)))))
                                       (when previous-pacing-h
                                         (move-to surface previous-pacing-h previous-pacing-v)
                                         (line-to surface h v))
                                       (set! previous-pacing-h h)
                                       (set! previous-pacing-v v)))))
                                ((udp-id-bbr-window)
                                 (let ((color {Color Red}))
                                   (set-line-width surface 1.)
                                   (set-color surface color)
                                   (let ((window (evolutionary-udp-bbr-window evolution n)))
                                     (let ((v (fxround (window->v self window))))
                                       (when (not previous-window-h)
                                         (let ((n (find-previous head id)))
                                           (when n
                                             (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                                   (v (fxround (window->v self (evolutionary-udp-bbr-window evolution n)))))
                                               (set! previous-window-h h)
                                               (set! previous-window-v v)))))
                                       (when previous-window-h
                                         (move-to surface previous-window-h previous-window-v)
                                         (line-to surface h v))
                                       (set! previous-window-h h)
                                       (set! previous-window-v v)))))
                                ((udp-id-bbr-state)
                                 (unless timeline-less?
                                   (let ((mode (evolutionary-udp-data2 evolution n))
                                         (phase (evolutionary-udp-data3 evolution n)))
                                     (plot-bbr-state self surface h mode phase))))
                                ((udp-id-traffic-rate)
                                 (when (and plot-traffic? (not timeline-less?))
                                   (let ((color {Color Purple}))
                                     (set-line-width surface 1.)
                                     (set-color surface color)
                                     (let ((traffic (evolutionary-udp-traffic-rate-last-upload-rate evolution n)))
                                       (let ((v (fxround (traffic->v self traffic))))
                                         (when (not previous-traffic-send-h)
                                           (let ((n (find-previous head id)))
                                             (when n
                                               (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                                     (v (fxround (traffic->v self (evolutionary-udp-traffic-rate-last-upload-rate evolution n)))))
                                                 (set! previous-traffic-send-h h)
                                                 (set! previous-traffic-send-v v)))))
                                         (when previous-traffic-send-h
                                           (move-to surface previous-traffic-send-h previous-traffic-send-v)
                                           (line-to surface h v))
                                         (when show-knees?
                                           (ellipse surface (new Rect (- h 1) (- v 1) (+ h 2) (+ v 2)) color color))
                                         (set! previous-traffic-send-h h)
                                         (set! previous-traffic-send-v v))))
                                   (let ((color {Color Dark-Purple}))
                                     (set-line-width surface 1.)
                                     (set-color surface color)
                                     (let ((traffic (evolutionary-udp-traffic-rate-last-download-rate evolution n)))
                                       (unless (= traffic -1.)
                                         (let ((v (fxround (traffic->v self traffic))))
                                           (when (not previous-traffic-receive-h)
                                             (let ((n (find-previous head id)))
                                               (when n
                                                 (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                                       (v (fxround (traffic->v self (evolutionary-udp-traffic-rate-last-download-rate evolution n)))))
                                                   (set! previous-traffic-receive-h h)
                                                   (set! previous-traffic-receive-v v)))))
                                           (when previous-traffic-receive-h
                                             (move-to surface previous-traffic-receive-h previous-traffic-receive-v)
                                             (line-to surface h v))
                                           (when show-knees?
                                             (ellipse surface (new Rect (- h 1) (- v 1) (+ h 2) (+ v 2)) color color))
                                           (set! previous-traffic-receive-h h)
                                           (set! previous-traffic-receive-v v)))))))
                                @wait
                                ((udp-id-resend-packet)
                                 (let ((found (evolutionary-udp-sequence evolution n)))
                                   (let ((color (if (= found 1.)
                                                    {Color Orange}
                                                  {Color Red}))
                                         (v 29))
                                     (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color))))
                                ((udp-id-discard-packet udp-id-lost-packet)
                                 (let ((kind (flonum->fixnum (evolutionary-udp-kind evolution n))))
                                   (plot-discard/lost self surface h id kind)
                                   (let ((left (- h 2))
                                         (right (+ h 3)))
                                     (when (and now-h (between? now-h left right))
                                       (let ((sequence (evolutionary-udp-sequence evolution n)))
                                         (if (= id udp-id-discard-packet)
                                             (unless (memv? sequence discards)
                                               (set! discards (cons sequence discards)))
                                           (unless (memv? sequence missings)
                                             (set! missings (cons sequence missings)))))))))
                                ((udp-id-media-early)
                                 (let ((kind (flonum->fixnum (evolutionary-udp-kind evolution n))))
                                   (ecase kind
                                     ((udp-audio)
                                      (when (>= h (+ last-audio-early 5))
                                        (plot-media-early self surface h kind)
                                        (set! last-audio-early h)))
                                     (else
                                      (when (>= h (+ last-video-early 5))
                                        (plot-media-early self surface h kind)
                                        (set! last-video-early h))))))
                                ((udp-id-media-late)
                                 (let ((kind (flonum->fixnum (evolutionary-udp-kind evolution n))))
                                   (ecase kind
                                     ((udp-audio)
                                      (when (>= h (+ last-audio-late 5))
                                        (plot-media-late self surface h kind)
                                        (set! last-audio-late h)))
                                     (else
                                      (when (>= h (+ last-video-late 5))
                                        (plot-media-late self surface h kind)
                                        (set! last-video-late h))))))
                                ((udp-id-purge-ring)
                                 (let ((kind (flonum->fixnum (evolutionary-udp-kind evolution n)))
                                       (reason (evolutionary-udp-data3 evolution n)))
                                   (plot-purge-ring self surface h reason kind)))
                                ((udp-id-garbage-collect)
                                 (plot-garbage-collect self surface h)))
                              (for-each (lambda (graph)
                                          (draw-graph graph self surface from to span sampling evolution n time id h now-h))
                                        graphs))))
                    (set-line-width surface 1.)
                    (when (and plot-latency? previous-raw-latency-h)
                      (let ((n (find-next tail udp-id-insert-packet)))
                        (set-color surface {Color Blue})
                        (move-to surface previous-raw-latency-h previous-raw-latency-v)
                        (if (not n)
                            (line-to surface width previous-raw-latency-v)
                          (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                (v (fxround (latency->v self (evolutionary-udp-insert-packet-raw-latency evolution n)))))
                            (line-to surface h v)))))
                    (when (and plot-latency? previous-latency-h)
                      (let ((n (find-next tail udp-id-insert-packet)))
                        (set-color surface {Color red: .005 green: .466 blue: .995})
                        (move-to surface previous-latency-h previous-latency-v)
                        (if (not n)
                            (line-to surface width previous-latency-v)
                          (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                (v (fxround (latency->v self (evolutionary-udp-insert-packet-effective-latency evolution n)))))
                            (line-to surface h v)))))
                    (when (and plot-contour? previous-contour-latency-h)
                      (let ((n (find-next tail udp-id-contour-latency)))
                        (set-color surface {Color Orange})
                        (move-to surface previous-contour-latency-h previous-contour-latency-v)
                        (if (not n)
                            (line-to surface width previous-contour-latency-v)
                          (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                (v (fxround (latency->v self (evolutionary-udp-contour-latency evolution n)))))
                            (line-to surface h v)))))
                    (when (and plot-roundtrip? previous-rtt-h)
                      (let ((n (find-next tail udp-id-receive-ack)))
                        (set-color surface {Color Green})
                        (move-to surface previous-rtt-h previous-rtt-v)
                        (if (not n)
                            (line-to surface width previous-rtt-v)
                          (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                (v (fxround (rtt->v self (evolutionary-udp-receive-ack-round-trip evolution n)))))
                            (line-to surface h v)))))
                    (when previous-queue-h
                      (let ((n (find-next tail udp-id-queue-rate)))
                        (set-color surface {Color Purple})
                        (move-to surface previous-queue-h previous-queue-v)
                        (if (not n)
                            (line-to surface width previous-queue-v)
                          (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                (v (fxround (queue->v self (evolutionary-udp-queue-rate-average evolution n)))))
                            (line-to surface h v)))))
                    (when previous-send-h
                      (let ((n (find-next tail udp-id-send-rate)))
                        (set-color surface {Color Purple})
                        (move-to surface previous-send-h previous-send-v)
                        (if (not n)
                            (line-to surface width previous-send-v)
                          (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                (v (fxround (send->v self (evolutionary-udp-send-rate-average evolution n)))))
                            (line-to surface h v)))))
                    (when previous-pacing-h
                      (let ((n (find-next tail udp-id-bbr-pacing)))
                        (set-color surface {Color Blue})
                        (move-to surface previous-pacing-h previous-pacing-v)
                        (if (not n)
                            (line-to surface width previous-pacing-v)
                          (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                (v (fxround (pacing->v self (evolutionary-udp-bbr-pacing evolution n)))))
                            (line-to surface h v)))))
                    (when previous-window-h
                      (let ((n (find-next tail udp-id-bbr-window)))
                        (set-color surface {Color Red})
                        (move-to surface previous-window-h previous-window-v)
                        (if (not n)
                            (line-to surface width previous-window-v)
                          (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                (v (fxround (window->v self (evolutionary-udp-bbr-window evolution n)))))
                            (line-to surface h v)))))
                    (when (and previous-traffic-send-h plot-traffic? (not timeline-less?))
                      (let ((n (find-next tail udp-id-traffic-rate)))
                        (set-color surface {Color Purple})
                        (move-to surface previous-traffic-send-h previous-traffic-send-v)
                        (if (not n)
                            (line-to surface width previous-traffic-send-v)
                          (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                (v (fxround (traffic->v self (evolutionary-udp-traffic-rate-last-upload-rate evolution n)))))
                            (line-to surface h v)))))
                    (when (and previous-traffic-receive-h plot-traffic? (not timeline-less?))
                      (let ((n (find-next tail udp-id-traffic-rate)))
                        (set-color surface {Color Dark-Purple})
                        (move-to surface previous-traffic-receive-h previous-traffic-receive-v)
                        (if (not n)
                            (line-to surface width previous-traffic-receive-v)
                          (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                (v (fxround (traffic->v self (evolutionary-udp-traffic-rate-last-download-rate evolution n)))))
                            (line-to surface h v))))))))))))))
  
  
  (method (plot-discard/lost self surface <Surface> h <fx> id <fl> kind <fx>)
    (let ((color (if (= kind udp-audio) {Color Yellow} {Color World-Darker-Green}))
          (left (- h 2))
          (right (+ h 3))
          (v (if (= kind udp-audio) 36 44)))
      (let ((rect (new Rect left (- v 2) right (+ v 3))))
        (if (= id udp-id-discard-packet)
            (fill-rect surface rect color)
          (frame-rect surface rect color)))))
  
  
  (method (plot-purge-ring self surface <Surface> h <fx> reason <fl> kind <fx>)
    (let ((color (if (= kind udp-audio) {Color Yellow} {Color World-Darker-Green}))
          (v (if (= kind udp-audio) 36 44)))
      (set-color surface color)
      (ecase reason
        ((udp-purge-gap)
         (move-to surface (- h 6) v)
         (line-to surface (+ h 5) v)
         (set-color surface chronology-red)
         (move-to surface (+ h 2) (- v 2))
         (line-to surface (- h 3) (+ v 3)))
        ((udp-purge-seek)
         (move-to surface (- h 3) (- v 3))
         (line-to surface (+ h 4) (+ v 4))
         (move-to surface (+ h 4) (- v 3))
         (line-to surface (- h 3) (+ v 4))))))
  
  
  (method (plot-media-early self surface <Surface> h <fx> kind <fx>)
    (let ((v 52)
          (color (if (= kind udp-audio) {Color Yellow} {Color World-Darker-Green})))
      (set-line-width surface 1)
      (set-color surface color)
      (move-to surface (- h 3) (- v 3))
      (line-to surface (+ h 4) (+ v 4))))
  
  
  (method (plot-media-late self surface <Surface> h <fx> kind <fx>)
    (let ((v 52)
          (color (if (= kind udp-audio) {Color Yellow} {Color World-Darker-Green})))
      (set-line-width surface 1)
      (set-color surface color)
      (move-to surface (+ h 4) (- v 3))
      (line-to surface (- h 3) (+ v 4))))
  
  
  (method (plot-bbr-state self surface <Surface> h <fx> mode <fl> phase <fl>)
    (define phases
      #(Invalid Startup Drain ProbeRTT Up Down Cruise Refill))
    
    (define (parse)
      (case (vector-ref phases (flonum->fixnum phase))
        ((Startup) (values {Color Blue} 'up))
        ((Drain) (values {Color Green} 'down))
        ((ProbeRTT) (values {Color Orange} 'down))
        ((Up) (values {Color Red} 'up))
        ((Down) (values {Color Red} 'down))
        ((Cruise) (values {Color Purple} 'down))
        ((Refill) (values {Color Purple} 'up))))
    
    (receive (color direction) (parse)
      (let ((v (- evolution-timeline 8)))
        (set-color surface color)
        (draw-arrow-tip surface (- h 2) (- v 2) 5 direction))))
  
  
  (method (plot-garbage-collect self surface <Surface> h <fx>)
    (let ((color {Color Red})
          (v 18))
      (draw-diamond surface (- h 3) (- v 2) color)))
  
  
  (method protected virtual (plot-highlight self surface <Surface> from <fl> to <fl>)
    )
  
  
  ;;;
  ;;;; History
  ;;;
  
  
  (method protected virtual (plot-history? self)
    (not live?))
  
  
  (method (plot-history self surface <Surface> from <fl> to <fl>)
    (let ((start (timeline-start self))
          (end (timeline-end self))
          (history (allege history)))
      (define (find-first)
        (loop (for n from (history-first history) to (history-last history))
              (when (>= (historical-time history n) start)
                (return n))
              (finally #f)))
      
      (define (find-last first)
        (loop (for n from first to (history-last history))
              (when (> (historical-time history n) end)
                (return (- n 1)))
              (finally (history-last history))))
      
      (let ((width (cast <fl> (get-width self)))
            (height (cast <fl> (get-height self)))
            (now (get-now history))
            (changes (get-changes history))
            (span (min (- to from) span))
            (v (- (get-height self) 87))
            (first (find-first)))
        (when (and first @convert (<= first tail))
          (let ((last (find-last first)))
            (define (plot-change n)
              (let ((time (historical-time history n)))
                (when (between? time from to)
                  (let ((change (id->change (historical-change-id history n))))
                    (let ((h (fxround (* (/ (- time from) span) width)))
                          (color (case (get-name change)
                                   ((move) {Color Blue})
                                   ((lookat) {Color Purple})
                                   ((animate) {Color Purple})
                                   ((edit-script update-script) {Color Ochre})
                                   ((fire) {Color Green})
                                   ((spawn) {Color Green})
                                   ((die) {Color Red})
                                   ((add-block delete-block add-entity remove-entity) {Color Green})
                                   ((action interact) {Color Green})
                                   (else {Color Light-Gray}))))
                      (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color))))))
            
            (loop (for n from first to last)
                  (unless (= n now)
                    (plot-change n)))
            (plot-change now))))))
  
  
  ;;;
  ;;;; Chronology
  ;;;
  
  
  (method protected virtual (plot-chronology? self)
    (not live?))
  
  
  (method protected virtual (plot-chronology self surface <Surface> from <fl> to <fl>)
    (let ((chronology (allege chronology)))
      (let ((width (cast <fl> (get-width self)))
            (height (cast <fl> (get-height self)))
            (span (min (- to from) span))
            (first (first-position chronology))
            (last (last-position chronology))
            (starts (make-table test: eqv?)))
        (define (find-head/starts!) <fx>
          (continuation-capture
            (lambda (return)
              (loop (for n from first to last)
                    (let ((id (flonum->fixnum (chronological-id chronology n)))
                          (time (chronological-time chronology n)))
                      (if (>= time from)
                          (continuation-return return n)
                        (let ((marker (flonum->fixnum (chronological-marker chronology n))))
                          (if (even? marker)
                              (table-set! starts marker n)
                            (table-set! starts (- marker 1) #f))))))
              first)))
        
        (define (find-tail head) <fx>
          (continuation-capture
            (lambda (return)
              (loop (for n from head to last)
                    (when (> (chronological-time chronology n) to)
                      (continuation-return return (- n 1))))
              last)))
        
        (set-font surface {Font Label})
        (let ((title "Chronology")
              (left 5)
              (top 117))
          (let ((width (draw-text surface left top title timeline-text-color)))
            (add-widget widgets 'events (new Rect left (- top 3) (+ left width) (+ top 20)))))
        (when (world-setting 'world.timeline-colors? #f)
          (fill-rect surface (new Rect   0   0  20 110) chronology-orange)
          (fill-rect surface (new Rect  20  11  40 110) chronology-yellow)
          (fill-rect surface (new Rect  40  22  60 110) chronology-green)
          (fill-rect surface (new Rect  60  33  80 110) chronology-cyan)
          (fill-rect surface (new Rect  80  44 100 110) chronology-blue)
          (fill-rect surface (new Rect 100  55 120 110) chronology-purple)
          (fill-rect surface (new Rect 120  66 140 110) chronology-magenta)
          (fill-rect surface (new Rect   0  77  30 110) {Color Yellow})
          (fill-rect surface (new Rect  30  77  60 110) {Color Yellow})
          (fill-rect surface (new Rect  60  77  90 110) {Color Green})
          (fill-rect surface (new Rect  90  77 140 110) {Color Blue})
          (fill-rect surface (new Rect   0  88 140 110) {Color Orange})
          (fill-rect surface (new Rect   0  99 140 110) {Color Red})
          @wait
          (fill-rect surface (new Rect  30   0  40 110) {Color Dark-Gray})
          (let ((text-color {Color Light-Gray}))
            (set-font surface {Font Label})
            (draw-text surface   3 -3 "audio" text-color)
            (draw-text surface  23  8 "video" text-color)
            (draw-text surface  43 19 "udp-release" text-color)
            (draw-text surface  63 30 "udp-heartbeat" text-color)
            (draw-text surface  83 41 "udp-receive" text-color)
            (draw-text surface 103 52 "udp-process" text-color)
            (draw-text surface 123 63 "video-output" text-color)
            (draw-text surface   7 74 "network" text-color)
            (draw-text surface  65 74 "tick" text-color)
            (draw-text surface  97 74 "render" text-color)
            (draw-text surface  32 85 "message/event" text-color)
            (draw-text surface  53 96 "memory" text-color)))
        
        (let ((head (find-head/starts!)))
          (let ((tail (find-tail head))
                (profiler-start #f)
                (profiler-end #f))
            (define (plot-call name rank <fx> color <Color> start <fl> end <fl>)
              (let ((bar-height (* (cast <fl> rank) 7.)))
                (let ((f (* (/ (- start from) span) width))
                      (t (* (/ (- end from) span) width))
                      (bottom height)
                      (top (- height bar-height)))
                  (when (or (between? f 0. width)
                            (between? t 0. width)
                            (and (< f 0.)
                                 (> t width)))
                    (let ((left (fxfloor f))
                          (top (fxfloor top))
                          (right (fxceiling t))
                          (bottom (fxceiling bottom)))
                      (let ((rect (new Rect left top right bottom)))
                        (fill-rect surface rect color)
                        (when (and now (between? now start end))
                          (set! boxes (cons rect boxes))
                          (let ((duration (- end start)))
                            (let ((text (format "{a} ({a})" name (present-seconds duration))))
                              (when (or (not profiler-start)
                                        (< start profiler-start))
                                (set! profiler-start start))
                              (when (or (not profiler-end)
                                        (> end profiler-end))
                                (set! profiler-end end))
                              (set! labels (cons (list (if (even? rank) 'right 'left) (- top 16) text) labels)))))))))))
            
            (define (start-time marker)
              (let ((n (table-ref starts marker #f)))
                (and n (chronological-time chronology n))))
            
            (loop (for layer from 10 downto 1)
                  (loop (for n from head to tail)
                        (let ((id (flonum->fixnum (chronological-id chronology n)))
                              (marker (flonum->fixnum (chronological-marker chronology n)))
                              (time (chronological-time chronology n)))
                          (let ((look (id->site-look self id)))
                            (let ((rank (get-rank look)))
                              (when (and (= rank layer) (or all-chronology? (not (get-default? look))))
                                (if (even? marker)
                                    (table-set! starts marker n)
                                  (let ((start-marker (- marker 1)))
                                    (let ((start (or (start-time start-marker) from)))
                                      (let ((end time))
                                        (proclaim (not check types))
                                        (plot-call (get-name look) rank (get-color look) (->flonum start) end)))
                                    (table-set! starts start-marker #f))))))))
                  ;; starts without matching end
                  (iterate-table starts
                    (lambda (marker n)
                      (when n
                        (let ((id (flonum->fixnum (chronological-id chronology n))))
                          (let ((look (id->site-look self id)))
                            (let ((rank (get-rank look)))
                              (when (and (= rank layer) (or all-chronology? (not (get-default? look))))
                                (let ((start (chronological-time chronology n)))
                                  (proclaim (not check types))
                                  (plot-call (get-name look) rank (get-color look) (->flonum start) to))))))))))
            ;; memory overrides all
            (loop (for n from head to tail)
                  (let ((id (flonum->fixnum (chronological-id chronology n))))
                    (when (and memory-site-id (= id memory-site-id))
                      (let ((marker (flonum->fixnum (chronological-marker chronology n)))
                            (time (chronological-time chronology n)))
                        (let ((look (id->site-look self id)))
                          (let ((rank (get-rank look)))
                            (if (even? marker)
                                (table-set! starts marker n)
                              (let ((start-marker (- marker 1)))
                                (let ((start (or (start-time start-marker) from)))
                                  (let ((end time))
                                    (proclaim (not check types))
                                    (plot-call (get-name look) rank (get-color look) (->flonum start) end)))
                                (table-set! starts start-marker #f)))))))))
            (when (not live?)
              (set-profiler-range (and profiler-start (new Range profiler-start profiler-end)))))))))
  
  
  ;;;
  ;;;; Events
  ;;;
  
  
  (method protected virtual (plot-events self surface <Surface> from to)
    )
  
  
  ;;;
  ;;;; Now
  ;;;
  
  
  (method (plot-now self surface <Surface> from <fl> to <fl>)
    (when (and now (not live?))
      (let ((h (when->h self from to span now))
            (height (cast <fl> (get-height self)))
            (text-color {Color Light-Gray}))
        ;; line
        (set-color surface {Color White})
        (set-line-width surface 1.5)
        (move-to surface h 1)
        (line-to surface h (- height 1))
        ;; text
        (let ((s (format "{r precision: 3}" (- now base-time)))
              (v evolution-timeline))
          (let ((width (get-text-width surface s)))
            (let ((h (if (< h 60) (+ (fxround h) 4) (- (fxround h) width 4)))
                  (v (- (+ (fxround v) 1) 9)))
              (set-font surface {Font Label})
              (draw-text surface h v s text-color)))))))
  
  
  (method virtual (plot-nowinfo self surface <Surface> from <fl> to <fl>)
    (when (and now (not live?))
      (let ((h (when->h self from to span now))
            (height (cast <fl> (get-height self)))
            (text-color {Color Light-Gray}))
        ;; evolution
        (unless (or full-mode? visualize? (not evolution))
          (when evolution-left
            (let ((h (when->h self from to span evolution-left)))
              (set-color surface {Color Gray alpha: .4})
              (set-line-width surface 1.)
              (move-to surface h 0)
              (line-to surface h height)))
          (when evolution-right
            (let ((h (when->h self from to span evolution-right)))
              (set-color surface {Color Gray alpha: .4})
              (set-line-width surface 1.)
              (move-to surface h 0)
              (line-to surface h height))))
        ;; boxes
        (for-each (lambda (box)
                    (frame-rect surface box {Color White}))
                  boxes)
        ;; labels
        (for-each (lambda (info)
                    (bind (side . labels) info
                      (for-each (lambda (info)
                                  (bind (v . labels) info
                                    (let ((texts (map third labels)))
                                      (let ((title (format "{l detail: :human}" texts)))
                                        (let ((size (get-text-extent surface title)))
                                          (let ((width (get-width size))
                                                (height (get-height size)))
                                            (let ((h (case side
                                                       ((left) (- (fxround h) width 4))
                                                       ((right) (+ (fxround h) 4))))
                                                  (v (+ (fxround v) 1)))
                                              (fill-rect surface (new Rect h (+ v 1) (+ h width) (+ v height 2)) {Color Black alpha: .4})
                                              (draw-text surface h v title text-color))))))))
                                (partition labels key: second))))
                  (partition (remove-duplicates labels test: equal?) key: first))
        ;; highlighted
        (when (not-null? highlighted)
          (let ((v 100))
            (let ((h (+ (fxround h) 4))
                  (v (- (+ (fxround v) 1) 9))
                  (text (format "{l}" (map evolution-id->abbrev highlighted))))
              (draw-text surface h v text text-color))))
        (let ((labels '()))
          (define (add-label side vert str)
            (set! labels (cons (list side vert str) labels)))
          
          ;; giveup
          (when (or (not-null? discards)
                    (not-null? missings))
            (let ((vert 53))
              (let ((discard-text (and (not-null? discards)
                                       (let ((count (length discards)))
                                         (if (> count 5)
                                             (format "discard ({a} total)" count)
                                           (format "discard {l}" (sort < discards))))))
                    (missing-text (and (not-null? missings)
                                       (let ((count (length missings)))
                                         (if (> count 5)
                                             (format "missing ({a} total)" count)
                                           (format "missing {l}" (sort < missings)))))))
                (let ((text (if (and discard-text missing-text)
                                (format "{a} {a}" discard-text missing-text)
                              (or discard-text
                                  missing-text))))
                  (add-label 'right vert text)))))
          ;; latency
          (unless (or (not plot-latency?) full-mode? visualize? (not evolution))
            (let ()
              (define (find-before time id)
                (loop (for n from (last-position evolution) downto (first-position evolution))
                      (when (and (= (evolutionary-udp-id evolution n) id)
                                 (< (evolutionary-udp-time evolution n) time)
                                 (eqv? (flonum->fixnum (evolutionary-udp-origin evolution n)) origin)
                                 (eqv? (flonum->fixnum (evolutionary-udp-kind evolution n)) latency-kind)
                                 (or (not channel) (= (flonum->fixnum (evolutionary-udp-channel evolution n)) channel)))
                        (return n))
                      (finally #f)))
              
              (define (find-after time id)
                (loop (for n from (first-position evolution) to (last-position evolution))
                      (when (and (= (evolutionary-udp-id evolution n) id)
                                 (> (evolutionary-udp-time evolution n) time)
                                 (eqv? (flonum->fixnum (evolutionary-udp-origin evolution n)) origin)
                                 (eqv? (flonum->fixnum (evolutionary-udp-kind evolution n)) latency-kind)
                                 (or (not channel) (= (flonum->fixnum (evolutionary-udp-channel evolution n)) channel)))
                        (return n))
                      (finally #f)))
              
              (with-mutex evolution
                (lambda ()
                  (let ((before (find-before now udp-id-insert-packet)))
                    (when before
                      (let ((actual-after (find-after now udp-id-insert-packet)))
                        (let ((after (or actual-after before)))
                          (let ((b (evolutionary-udp-insert-packet-raw-latency evolution before))
                                (a (evolutionary-udp-insert-packet-raw-latency evolution after)))
                            (let ((bv (fxround (latency->v self b)))
                                  (av (fxround (latency->v self a))))
                              (let ((vert (if actual-after
                                              (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) bv av)
                                            bv))
                                    (raw-latency (if actual-after
                                                     (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) b a)
                                                   b)))
                                (let ((str (present-seconds (+ raw-latency 1.5) @kaa raw-latency)))
                                  (add-label 'left vert str)))))
                          (let ((b (evolutionary-udp-insert-packet-effective-latency evolution before))
                                (a (evolutionary-udp-insert-packet-effective-latency evolution after)))
                            (let ((bv (fxround (latency->v self b)))
                                  (av (fxround (latency->v self a)))
                                  (inf? (or (= a +inf.flo) (= b +inf.flo))))
                              (let ((vert (if actual-after
                                              (if inf?
                                                  0.
                                                (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) bv av))
                                            bv))
                                    (latency (if actual-after
                                                 (if inf?
                                                     +inf.flo
                                                   (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) b a))
                                               b)))
                                (let ((str (if (= latency +inf.flo) "+inf" (present-seconds (+ latency 1.5) @kaa latency))))
                                  (add-label 'left vert str)))))))))))))
          ;; rtt
          (when (and plot-roundtrip? (not timeline-less?))
          (unless (or full-mode? visualize? (not evolution))
            (let ()
              (define (find-before time id) <fx+>
                (loop (for n from (last-position evolution) downto (first-position evolution))
                      (when (and (= (evolutionary-udp-id evolution n) id)
                                 (< (evolutionary-udp-time evolution n) time))
                        (return n))
                      (finally #f)))
              
              (define (find-after time id) <fx+>
                (loop (for n from (first-position evolution) to (last-position evolution))
                      (when (and (= (evolutionary-udp-id evolution n) id)
                                 (> (evolutionary-udp-time evolution n) time))
                        (return n))
                      (finally #f)))
              
              (with-mutex evolution
                (lambda ()
                  (let ((before (find-before now udp-id-receive-ack)))
                    (when before
                      (let ((actual-after (find-after now udp-id-receive-ack)))
                        (let ((after (or actual-after before)))
                          (let ((b (evolutionary-udp-receive-ack-round-trip evolution before))
                                (a (evolutionary-udp-receive-ack-round-trip evolution after)))
                            (let ((bv (fxround (rtt->v self b)))
                                  (av (fxround (rtt->v self a))))
                              (let ((vert (if actual-after
                                              (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) bv av)
                                            bv))
                                    (rtt (if actual-after
                                             (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) b a)
                                           b)))
                                (let ((str (present-seconds rtt)))
                                  (add-label 'right vert str))))))))))))))
          ;; traffic
          (unless (or full-mode? visualize? (not evolution) (not plot-traffic?) timeline-less?)
            (let ()
              (define (find-before time id)
                (loop (for n from (last-position evolution) downto (first-position evolution))
                      (when (and (= (evolutionary-udp-id evolution n) id)
                                 (< (evolutionary-udp-time evolution n) time))
                        (return n))
                      (finally #f)))
              
              (define (find-after time id)
                (loop (for n from (first-position evolution) to (last-position evolution))
                      (when (and (= (evolutionary-udp-id evolution n) id)
                                 (> (evolutionary-udp-time evolution n) time))
                        (return n))
                      (finally #f)))
              
              (with-mutex evolution
                (lambda ()
                  (let ((before (find-before now udp-id-traffic-rate)))
                    (when before
                      (let ((actual-after (find-after now udp-id-traffic-rate)))
                        (let ((after (or actual-after before)))
                          ;; send
                          (let ((b (evolutionary-udp-traffic-rate-last-upload-rate evolution before))
                                (a (evolutionary-udp-traffic-rate-last-upload-rate evolution after)))
                            (let ((bv (fxround (traffic->v self b)))
                                  (av (fxround (traffic->v self a))))
                              (let ((vert (if actual-after
                                              (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) bv av)
                                            bv))
                                    (traffic (if actual-after
                                                 (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) b a)
                                               b)))
                                (let ((str (format "{r precision: 1}Mbps" (bytes->mbps traffic))))
                                  (add-label 'left vert str)))))
                          ;; receive
                          (let ((b (evolutionary-udp-traffic-rate-last-download-rate evolution before))
                                (a (evolutionary-udp-traffic-rate-last-download-rate evolution after)))
                            (let ((bv (fxround (traffic->v self b)))
                                  (av (fxround (traffic->v self a))))
                              (let ((vert (if actual-after
                                              (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) bv av)
                                            bv))
                                    (traffic (if actual-after
                                                 (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) b a)
                                               b)))
                                (let ((str (format "{r precision: 1}Mbps" (bytes->mbps traffic))))
                                  (add-label 'right vert str)))))))))))))
          ;; labels
          (plot-labels self surface h text-color labels)))))
  
  
  (method protected (plot-labels self surface <Surface> h text-color labels)
    (for-each (lambda (partition)
                (bind (side . labels) partition
                  (define (preprocess sorted)
                    (map (lambda (info)
                           (bind (side vert str) info
                             (let ((extent (get-text-extent surface str)))
                               (let ((width (get-width extent))
                                     (height (get-height extent)))
                                 (let ((top (max (min (fxround (- vert (/ height 2.))) (- (fxround evolution-base) @w evolution-height (* (if (eq? side 'left) 18 11) evolution-scale))) 0)))
                                   (let ((bottom (+ top height)))
                                     (list width height top bottom str)))))))
                         sorted))
                  
                  (let ((sorted (preprocess (sort < labels key: second))))
                    (let (loop (scan sorted))
                      (define (overlapping)
                        (let (collect (ceiling #f) (overlap '()) (rest scan))
                          (if (null? rest)
                              (values overlap rest)
                            (let ((info (car rest)))
                              (bind (width height top bottom str) info
                                (if (and ceiling (>= top ceiling))
                                    (values overlap rest)
                                  (collect bottom (append overlap (list info)) (cdr rest))))))))
                      
                      (define (spread overlap)
                        (let ((first (first overlap))
                              (last (last overlap))
                              (height (apply + (map second overlap))))
                          (let ((mid (/ (cast <fl> (+ (third first) (fourth last))) 2.)))
                            (fxround (- mid (/ (cast <fl> height) 2.))))))
                      
                      (when (not-null? scan)
                        (receive (overlap rest) (overlapping)
                          (let (iter (v (spread overlap)) (lst overlap))
                            (when (not-null? lst)
                              (bind (width height top bottom str) (car lst)
                                (let ((h (case side
                                           ((left) (- (fxround h) width 4))
                                           ((right) (+ (fxround h) 4)))))
                                  (draw-text surface h v str text-color))
                                (iter (+ v height) (cdr lst)))))
                          (loop rest)))))))
              (partition labels key: first)))
  
  
  ;;;
  ;;;; Play
  ;;;
  
  
  (method protected (set-playing? self flag)
    (unless (eq? flag playing?)
      (if flag
          (start-playing self)
        (stop-playing self))))
  
  
  (method protected virtual (start-playing self)
    (let ((thread
            (new-thread
              (lambda ()
                (play-loop self))
              'play)))
      (when (not now)
        (set! now from))
      (thread-start! thread)
      (set! visualize? #t)
      (set! play-thread thread)
      (set! playing? #t)))
  
  
  (method protected virtual (stop-playing self)
    ;; quicky to test
    (thread-terminate! play-thread)
    (set! visualize? #f)
    (set! play-thread #f)
    (set! playing? #f)
    (redraw self)
    (now-update self))
  
  
  (method protected virtual (play-loop self)
    )
  
  
  (method protected (step-forward self elapse (reset-proc #f))
    (increase! now elapse)
    (let ((over (- now visualizer-end)))
      (if (> over 0.)
          (begin
            (when reset-proc
              (reset-proc))
            (set! now (+ visualizer-start over))
            (set-bounds self visualizer-start (+ visualizer-start span)))
        (let ((over (- now to)))
          (when (> over 0.)
            (set-bounds self to (+ to span))))))
    (redraw self)
    (now-update self))
  
  
  (method protected (step-backward self elapse)
    (decrease! now elapse)
    (let ((over (- visualizer-start now)))
      (if (> over 0.)
          (begin
            (set! now (- visualizer-end over))
            (set-bounds self (- visualizer-end span) visualizer-end))
        (let ((over (- from now)))
          (when (> over 0.)
            (set-bounds self (- from span) from)))))
    (redraw self)
    (now-update self))
  
  
  (method protected (play-faster self)
    (set! visualizer-speed (/ visualizer-speed .75))
    @not-sure
    (let ((speed (next-element speed-factors visualizer-speed cycle?: #f)))
      (if (not speed)
          (bell)
        (set! visualizer-speed speed))))
  
  
  (method protected (play-slower self)
    (set! visualizer-speed (* visualizer-speed .75))
    @not-sure
    (let ((speed (previous-element speed-factors visualizer-speed cycle?: #f)))
      (if (not speed)
          (bell)
        (set! visualizer-speed speed)))))


;;;
;;;; Graph
;;;


(class Graph extends Object
  
  
  (method protected virtual (draw-context self timeline surface from to span sampling evolution)
    )
  
  
  (method protected virtual (draw-graph self timeline surface from to span sampling evolution n time id h now-h)
    )))
