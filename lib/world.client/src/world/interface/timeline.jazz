;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Timeline Panel
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.interface.timeline jazz


(import (jazz.component)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.time)
        (world)
        (world.biome)
        (world.change)
        (world.context)
        (world.evolution)
        (world.geometry)
        (world.history)
        (world.interface.panel)
        (world.profiling)
        (world.settings)
        (world.udp))


(proclaim (warn optimizations))


;;;
;;;; Player
;;;


(definition protected (draw-timeline)
  (let ((world (current-world))
        (interface (current-interface)))
    (let ((view (child interface 'timeline))
          (sheet (get-timeline-sheet world)))
      (unless (get-uptodate? view)
        (let ((texture (get-texture sheet)))
          (let ((surface (get-surface texture))
                (data (get-data texture)))
            (draw-view view surface data)
            (map-texture texture)
            (set-uptodate? view #t))))
      (let ((x (cast <fl> (get-left view)))
            (y (cast <fl> (get-top view)))
            (h (cast <fl> (get-height view))))
        (let ((matrix (make-translation-matrix (vertex x (- (get-height world) y h) 0.))))
          (render-sheet sheet matrix))))))


(definition protected (refresh-timeline)
  (let ((interface (current-interface+))
        (history (current-history)))
    (when interface
      (let ((panel (child interface 'timeline)))
        (when (not (get-evolution panel))
          (set-evolution panel (current-evolution)))
        (when (not (get-history panel))
          (set-history panel (current-history)))
        (when (not (get-chronology panel))
          (set-chronology panel (current-chronology)))
        (when (not (get-from panel))
          (set-uptodate? panel #f))))))


;;;
;;;; Timeline
;;;


(class Timeline-Panel extends World-Panel
  
  
  (slot scale        <fl>         initialize 0  accessors generate)
  (slot sampling     <fx>         initialize 2  accessors generate)
  (slot from         <fl+>        initialize #f accessors generate)
  (slot to           <fl+>        initialize #f accessors generate)
  (slot span         <fl>         initialize 5. accessors generate)
  (slot now          <fl+>        initialize #f accessors generate)
  (slot evolution    <Evolution>  initialize #f accessors generate)
  (slot history      <History>    initialize #f accessors generate)
  (slot chronology   <Chronology> initialize #f accessors generate)
  (slot live?                     initialize #t accessors generate)
  (slot uptodate?                 initialize #f accessors generate)
  ;; scroll code is a copy/paste from showcase
  (slot point                     initialize #f getter generate)
  (slot moved?                    initialize #f getter generate)
  (slot scrolled?                 initialize #f getter generate)
  (slot last-to                   initialize #f getter generate)
  (slot last-seconds              initialize #f getter generate)
  (slot last-speed                initialize #f getter generate)
  (slot pulse                     initialize #f getter generate)
  
  
  ;;;
  ;;;; Bounds
  ;;;
  
  
  (method (update-span self)
    (set! span (- to from)))
  
  
  (method (set-bounds self f t)
    (assert (<= f t)
      (set! from f)
      (set! to t)))
  
  
  (method (with-bounds self proc)
    (if (not from)
        (let ((head (timeline-head self))
              (tail (timeline-tail self)))
          (let ((from (max head (- tail span)))
                (to tail))
            (proc from to)))
      (proc from to)))
  
  
  (method (timeline-head self)
    (chronological-time chronology (first-position chronology)))
  
  
  (method (timeline-tail self)
    (chronological-time chronology (last-position chronology)))
  
  
  (method (live-information self)
    (unless live?
      (set! evolution (current-evolution))
      (set! history (current-history))
      (set! chronology (current-chronology))
      (set! live? #t)))
  
  
  (method (copy-information self)
    (when live?
      (set! evolution (copy-evolution (current-evolution)))
      (set! history (copy-history (current-history)))
      (set! chronology (copy-chronology (current-chronology)))
      (set! live? #f)))
  
  
  ;; to redo?
  (method (update self time)
    )
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method override (mouse-down self evt)
    (copy-information self)
    (with-bounds self
      (lambda (from~ to~)
        (set! point (get-h evt))
        (set! moved? #f)
        (set! last-to to~)
        (set! last-seconds (current-seconds))
        (set! last-speed #f)
        (kill-autoscroll self))))
  
  
  (method override (drag-move self evt)
    (let ((h (get-h evt)))
      (when (and point (not (near? h point 2)))
        (with-bounds self
          (lambda (from~ to~)
            (let ((delta (* (/ (cast <fl> (- h point)) (cast <fl> (get-width self))) (- span)))
                  (head (timeline-head self))
                  (tail (timeline-tail self)))
              (let ((new-from (+ from~ delta))
                    (new-to (+ to~ delta)))
                (cond ((> new-to tail)
                       (set-bounds self (- tail span) tail))
                      ((< new-from head)
                       (set-bounds self head (+ head span)))
                      (else
                       (set-bounds self new-from new-to))))
              (update-span self)
              (set-uptodate? self #f))
            (set! point h)
            (set! moved? #t)
            (let ((new-to to)
                  (new-seconds (current-seconds))
                  (old-to last-to)
                  (old-seconds last-seconds))
              (set! last-to new-to)
              (set! last-seconds new-seconds)
              (unless (= new-seconds old-seconds)
                (let ((new-speed (/ (- new-to old-to) (- new-seconds old-seconds)))
                      (p .9))
                  (set! last-speed (+ (* new-speed (- 1. p)) (* (or last-speed 0.) p)))))))))))

  
  (method override (mouse-up self evt)
    (when (or (not moved?) (< (- (current-seconds) last-seconds) .1))
      (if moved?
          (begin
            (set! scrolled? #f)
            (start-autoscroll self))
        (with-bounds self
          (lambda (from to)
            (set! point (get-h evt))
            (set! moved? #f)
            (set! scrolled? #f)
            (set! last-speed #f)
            (set! now (h->when self from to point))
            (set-uptodate? self #f)
            (kill-autoscroll self))))))
  
  
  (method override (right-mouse-up self evt)
    (live-information self)
    (set! from #f)
    (set! to #f)
    (set-uptodate? self #f))
  
  
  (method override (mouse-wheel self pos delta)
    (let ((d (get-v delta)))
      (cond ((> d 0)
             (zoom-in self))
            ((< d 0)
             (zoom-out self)))))
  
  
  (method package (zoom-in self)
    (let ((head (timeline-head self))
          (tail (timeline-tail self)))
      (let ((max-span (- tail head)))
        (if (not from)
            (set! span (min max-span (* span .75)))
          (let ((h (get-h (mouse-position self)))
                (width (get-width self)))
            (let ((proportion (/ (cast <fl> h) (cast <fl> width))))
              (let ((when (+ from (* span proportion)))
                    (new-span (min max-span (* span .75))))
                (let ((new-from (- when (* new-span proportion)))
                      (new-to (+ when (* new-span (- 1. proportion)))))
                  (set-bounds self (max head new-from) (min tail new-to))
                  (update-span self))))))))
    (set-uptodate? self #f))
  
  
  (method package (zoom-out self)
    (let ((head (timeline-head self))
          (tail (timeline-tail self)))
      (let ((max-span (- tail head)))
        (if (not from)
            (set! span (min max-span (/ span .75)))
          (let ((h (get-h (mouse-position self)))
                (width (get-width self)))
            (let ((proportion (/ (cast <fl> h) (cast <fl> width))))
              (let ((when (+ from (* span proportion)))
                    (new-span (min max-span (/ span .75))))
                (let ((new-from (- when (* new-span proportion)))
                      (new-to (+ when (* new-span (- 1. proportion)))))
                  (set-bounds self (max head new-from) (min tail new-to))
                  (update-span self))))))))
    (set-uptodate? self #f))
  
  
  (method (h->when self from to h)
    (let ((width (get-width self)))
      (cond ((< h 0)
             from)
            ((> h width)
             to)
            (else
             (+ from (* span (/ (cast <fl> h) (cast <fl> width))))))))
  
  
  (method (when->h self from to span when)
    (fxround (* (/ (- when from) span) (cast <fl> (get-width self)))))
  
  
  ;;;
  ;;;; Autoscroll
  ;;;
  
  
  (method (start-autoscroll self)
    (set! pulse (new Pulse 'autoscroll 0.01 (~ autoscroll-action self) delay: 0)))
  
  
  (method (kill-autoscroll self)
    (when pulse
      (close pulse)
      (set! pulse #f)))
  
  
  (method (autoscroll-action self)
    (when (and last-speed (not live?))
      (let ((actual-to to))
        (let ((scroll-to (+ actual-to (/ last-speed 100.))))
          (let ((new-to scroll-to))
            (when (/= new-to actual-to)
              (set! scrolled? #t)
              (let ((new-from (- new-to span)))
                (let ((head (timeline-head self))
                      (tail (timeline-tail self)))
                  (cond ((> new-to tail)
                         (set-bounds self (- tail span) tail))
                        ((< new-from head)
                         (set-bounds self head (+ head span)))
                        (else
                         (set-bounds self new-from new-to)))
                  (update-span self)
                  (set-uptodate? self #f)
                  (when (or (<= new-from head)
                            (>= new-to tail))
                    (set! scrolled? #f)
                    (kill-autoscroll self))))))))))
  
  
  ;;;
  ;;;; Draw
  ;;;


  (method package (draw-view self surface <Surface> data)
    (clear surface)
    (fill-rect surface (new Rect 0 0 (get-width self) (get-height self)) {Color red: .000 green: .000 blue: .000 alpha: .450})
    (draw-timeline self surface)
    (frame-rect surface (new Rect 0 0 (get-width self) (get-height self)) {Color Entry-Border}))
  
  
  (method (draw-timeline self surface <Surface>)
    (with-bounds self
      (lambda (from to)
        (plot-time self surface from to)
        (plot-units self surface from to)
        (plot-evolution self surface from to)
        (plot-history self surface from to)
        (plot-chronology self surface from to)
        (plot-now self surface from to))))
  
  
  (method (plot-time self surface <Surface> from <fl> to <fl>)
    (let ((width (cast <fl> (get-width self)))
          (height (cast <fl> (get-height self))))
      (let ((v (/ height 2.)))
        (set-color surface {Color Medium-Gray alpha: .7})
        (set-line-width surface 1)
        (move-to surface 0 v)
        (line-to surface width v))))
  
  
  (method (plot-units self surface <Surface> from <fl> to <fl>)
    (let ((width (cast <fl> (get-width self)))
          (height (cast <fl> (get-height self)))
          (span (min (- to from) span)))
      (let ((v (/ height 2.)))
        (set-color surface {Color Medium-Gray alpha: .7})
        (set-line-width surface 1)
        (loop (for s from (fxceiling from) to (fxfloor to))
              (let ((h (when->h self from to span (cast <fl> s))))
                (move-to surface h (- v 3.))
                (line-to surface h (+ v 4.)))))))
  
  
  ;;;
  ;;;; Evolution
  ;;;
  
  
  (method (plot-evolution self surface from to)
    (let ((head (timeline-head self))
          (tail (timeline-tail self)))
      (define (find-first)
        (loop (for n from (first-position evolution) to (last-position evolution))
              (when (>= (evolutionary-time evolution n) head)
                (return n))
              (finally #f)))
      
      (define (find-last first)
        (loop (for n from first to (last-position evolution))
              (when (> (evolutionary-time evolution n) tail)
                (return (- n 1)))
              (finally (last-position evolution))))
      
      (let ((width (cast <fl> (get-width self)))
            (height (cast <fl> (get-height self)))
            (span (min (- to from) span))
            (dark-purple {Color red: .464 green: .141 blue: .732})
            (rtt-scale (if local? 5000. 250.))
            (previous-rtt-h #f)
            (previous-rtt-v #f)
            (missing-scale 5.)
            (previous-missing-h #f)
            (previous-missing-v #f)
            (first (find-first)))
        (when (and first (<= first tail))
          (let ((last (find-last first)))
            (define (find-head)
              (loop (for n from first to last)
                    (when (>= (evolutionary-time evolution n) from)
                      (return n))
                    (finally first)))
            
            (define (find-tail head)
              (loop (for n from head to last)
                    (when (> (evolutionary-time evolution n) to)
                      (return (- n 1)))
                    (finally last)))
            
            (define (find-previous head id)
              (loop (for n from (- head 1) downto first)
                    (when (= (evolutionary-id evolution n) id)
                      (return n))
                    (finally #f)))
            
            (define (find-next tail id)
              (loop (for n from (+ tail 1) to last)
                    (when (= (evolutionary-id evolution n) id)
                      (return n))
                    (finally #f)))
            
            (let ((head (find-head)))
              (let ((tail (find-tail head)))
                (set-line-width surface 1.5)
                (loop (for n from head to tail)
                      (let ((time (evolutionary-time evolution n))
                            (id (evolutionary-id evolution n)))
                        (let ((h (fxround (* (/ (- time from) span) width))))
                          (ecase id
                            ((udp-id-connect)
                             (let ((color {Color Yellow})
                                   (v 13))
                               (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color)))
                            ((udp-id-connected)
                             (let ((color {Color Green})
                                   (v 13))
                               (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color)))
                            @convert
                            ((udp-id-send-media)
                             (let ((kind (flonum->fixnum (evolutionary-data1 evolution n)))
                                   (off? (= (evolutionary-data3 evolution n) 0.)))
                               (let ((color (if off?
                                                {Color Medium-Gray}
                                              (ecase kind
                                                ((udp-audio) {Color Purple})
                                                (else {Color Blue}))))
                                     (v 13))
                                 (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color))))
                            ((udp-id-receive-ack)
                             (let ((color {Color Green})
                                   (v 21))
                               (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color)
                               (set-color surface {Color Green})
                               (let ((rtt (evolutionary-data3 evolution n)))
                                 (let ((v (fxround (- 95. (* rtt rtt-scale)))))
                                   (when (not previous-rtt-h)
                                     (let ((n (find-previous head id)))
                                       (when n
                                         (let ((h (when->h self from to span (evolutionary-time evolution n)))
                                               (v (fxround (- 95. (* (evolutionary-data3 evolution n) rtt-scale)))))
                                           (set! previous-rtt-h h)
                                           (set! previous-rtt-v v)))))
                                   (when previous-rtt-h
                                     (move-to surface previous-rtt-h previous-rtt-v)
                                     (line-to surface h v))
                                   (set! previous-rtt-h h)
                                   (set! previous-rtt-v v)))))
                            ((udp-id-receive-nack)
                             (let ((found (evolutionary-data3 evolution n)))
                               (let ((color (if (= found 1.)
                                                {Color Orange}
                                              {Color Red}))
                                     (v 29))
                                 (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color))))
                            @convert
                            ((udp-id-discard udp-id-missing)
                             (let ((color (if (= id udp-id-discard)
                                              {Color Purple}
                                            {Color Red}))
                                   (v 37))
                               (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color))
                             (when (= id udp-id-missing)
                               (set-color surface {Color Red})
                               (let ((missing (evolutionary-data3 evolution n))
                                     (processed (evolutionary-data4 evolution n)))
                                 (let ((v (fxround (- 95. (* (percentage missing processed) missing-scale)))))
                                   (when (not previous-missing-h)
                                     (let ((n (find-previous head id)))
                                       (when n
                                         (let ((h (when->h self from to span (evolutionary-time evolution n)))
                                               (v (fxround (- 95. (* (percentage (evolutionary-data3 evolution n) (evolutionary-data4 evolution n)) missing-scale)))))
                                           (set! previous-missing-h h)
                                           (set! previous-missing-v v)))))
                                   (when previous-missing-h
                                     (move-to surface previous-missing-h previous-missing-v)
                                     (line-to surface h v))
                                   (set! previous-missing-h h)
                                   (set! previous-missing-v v)))))))))
                (when previous-rtt-h
                  (let ((n (find-next tail udp-id-receive-ack)))
                    (set-color surface {Color Green})
                    (move-to surface previous-rtt-h previous-rtt-v)
                    (if (not n)
                        (line-to surface width previous-rtt-v)
                      (let ((h (when->h self from to span (evolutionary-time evolution n)))
                            (v (fxround (- 95. (* (evolutionary-data3 evolution n) rtt-scale)))))
                        (line-to surface h v)))))
                @convert
                (when previous-missing-h
                  (let ((n (find-next tail udp-id-missing)))
                    (set-color surface {Color Red})
                    (move-to surface previous-missing-h previous-missing-v)
                    (if (not n)
                        (line-to surface width previous-missing-v)
                      (let ((h (when->h self from to span (evolutionary-time evolution n)))
                            (v (fxround (- 95. (* (percentage (evolutionary-data3 evolution n) (evolutionary-data4 evolution n)) missing-scale)))))
                        (line-to surface h v))))))))))))
  
  
  ;;;
  ;;;; History
  ;;;
  
  
  (method (plot-history self surface <Surface> from <fl> to <fl>)
    (let ((head (timeline-head self))
          (tail (timeline-tail self)))
      (define (find-first)
        (loop (for n from (history-first history) to (history-last history))
              (when (>= (historical-time history n) head)
                (return n))
              (finally #f)))
      
      (define (find-last first)
        (loop (for n from first to (history-last history))
              (when (> (historical-time history n) tail)
                (return (- n 1)))
              (finally (history-last history))))
      
    (let ((width (cast <fl> (get-width self)))
          (height (cast <fl> (get-height self)))
          (now (get-now history))
          (changes (get-changes history))
          (span (min (- to from) span))
          (v (- (get-height self) 87))
          (first (find-first)))
      (when (and first (<= first tail))
        (let ((last (find-last first)))
          (define (plot-change n)
            (let ((time (historical-time history n)))
              (when (between? time from to)
                (let ((change (id->change (historical-change-id history n))))
                  (let ((h (fxround (* (/ (- time from) span) width)))
                        (color (case (get-name change)
                                 ((move) {Color Purple})
                                 ((lookat) {Color Blue})
                                 ((animate) {Color Blue})
                                 ((edit-script update-script) {Color Ochre})
                                 ((fire) {Color Green})
                                 ((spawn) {Color Green})
                                 ((die) {Color Red})
                                 ((add-block delete-block add-entity remove-entity) {Color Green})
                                 ((action interact) {Color Green})
                                 (else {Color Light-Gray}))))
                    (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color))))))
          
          (loop (for n from first to last)
                (unless (= n now)
                  (plot-change n)))
          (plot-change now))))))
  
  
  ;;;
  ;;;; Chronology
  ;;;
  
  
  (method (plot-chronology self surface <Surface> from <fl> to <fl>)
    (let ((width (cast <fl> (get-width self)))
          (height (cast <fl> (get-height self)))
          (span (min (- to from) span))
          (first (first-position chronology))
          (last (last-position chronology))
          (starts (make-vector (site-id-count) #f)))
      (define (find-head)
        (loop (for n from first to last)
              (for id = (flonum->fixnum (chronological-id chronology n)))
              (for time = (chronological-time chronology n))
              (when (>= time from)
                (return n))
              (let ((marker (chronological-marker chronology n)))
                (if (even? (flonum->fixnum marker))
                    (vector-set! starts id time)
                  (vector-set! starts id #f)))
              (finally first)))
      
      (define (find-tail head)
        (loop (for n from head to last)
              (when (> (chronological-time chronology n) to)
                (return (- n 1)))
              (finally last)))
      
      (let ((head (find-head)))
        (let ((tail (find-tail head)))
          (define (plot-site name color bar-rank <fl>)
            (let ((bar-height (* bar-rank 7.5))
                  (site (find-site name)))
              (when site
                (let ((id (get-id site)))
                  (define (plot-call start end)
                    (let ((f (* (/ (- start from) span) width))
                          (t (* (/ (- end from) span) width))
                          (bottom height)
                          (top (- height bar-height)))
                      (when (or (between? f 0. width)
                                (between? t 0. width)
                                (and (< f 0.)
                                     (> t width)))
                        (let ((left (fxfloor f))
                              (top (fxfloor top))
                              (right (fxceiling t))
                              (bottom (fxceiling bottom)))
                          (fill-rect surface (new Rect left top right bottom) color)))))
                  
                  (loop (for n from head to tail)
                        (when (= (flonum->fixnum (chronological-id chronology n)) id)
                          (let ((marker (chronological-marker chronology n)))
                            (if (even? (flonum->fixnum marker))
                                (vector-set! starts id (chronological-time chronology n))
                              (let ((start (or (vector-ref starts id) from)))
                                (let ((end (chronological-time chronology n)))
                                  (plot-call start end)))
                              (vector-set! starts id #f)))))
                  (let ((start (vector-ref starts id)))
                    (when start
                      (plot-call start to)))))))
          
          (let ((dark-purple {Color red: .464 green: .141 blue: .732})
                (purple {Color Purple})
                (cyan {Color red: .120 green: .624 blue: .616}))
            (plot-site 'register-literal {Color Yellow} 10)
            (plot-site 'registered-id {Color Green} 10)
            (plot-site 'retrieve-region dark-purple 10)
            (plot-site 'retrieve-chunk purple 10)
            (plot-site 'retrieve-entity {Color Blue} 10)
            (plot-site 'client-update cyan 10)
            (plot-site 'processor-update cyan 10)
            (plot-site 'udp-release {Color Ochre} 10)
            (plot-site 'udp-receive {Color Ochre} 10)
            (plot-site 'udp-process {Color Ochre} 10)
            (plot-site 'network {Color Orange} 9)
            (plot-site 'render {Color Blue} 8)
            (plot-site 'event {Color Yellow} 7)
            (plot-site 'message {Color Yellow} 7)
            (plot-site 'player {Color Green} 6)
            (plot-site 'physical {Color Blue} 5)
            (plot-site 'visual dark-purple 4)
            (plot-site 'generate purple 3)
            (plot-site 'memory {Color Red} 2)
            ;; quicky for others
            (for-each (lambda (name)
                        (plot-site name {Color Ochre} 1))
                      '(;alive animate audio creature distance eat event
                        ;gravity instantiate lava memory missile music
                        ;redstone simulation spawn sun tick water
                        )))))))
  
  
  ;;;
  ;;;; Now
  ;;;
  
  
  (method (plot-now self surface <Surface> from <fl> to <fl>)
    (when (and now (not live?))
      (let ((h (when->h self from to span now))
            (height (cast <fl> (get-height self)))
            (text-color {Color Light-Gray}))
        ;; line
        (set-color surface {Color White})
        (set-line-width surface 1.5)
        (move-to surface h 0)
        (line-to surface h height)
        ;; time
        (let ((height (cast <fl> (get-height self))))
          (let ((s (format "{r precision: 3}" (- now (floor kernel-boot))))
                (v (/ height 2.)))
            (let ((h (+ (fxround h) 4))
                  (v (+ (fxround v) 1)))
              (set-font surface {Font Label})
              (draw-text surface h v s text-color))))
        ;; rtt
        (let ((rtt-scale (if local? 5000. 250.)))
          (define (find-before time id)
            (loop (for n from (last-position evolution) downto (first-position evolution))
                  (when (and (= (evolutionary-id evolution n) id)
                             (< (evolutionary-time evolution n) time))
                    (return n))
                  (finally #f)))
          
          (define (find-after time id)
            (loop (for n from (first-position evolution) to (last-position evolution))
                  (when (and (= (evolutionary-id evolution n) id)
                             (> (evolutionary-time evolution n) time))
                    (return n))
                  (finally #f)))
          
          (let ((before (find-before now udp-id-receive-ack)))
            (when before
              (let ((actual-after (find-after now udp-id-receive-ack)))
                (let ((after (or actual-after before)))
                  (let ((b (evolutionary-data3 evolution before))
                        (a (evolutionary-data3 evolution after)))
                    (let ((bv (fxround (- 95. (* b rtt-scale))))
                          (av (fxround (- 95. (* a rtt-scale)))))
                      (let ((vert (if actual-after
                                      (interpolate now (evolutionary-time evolution before) (evolutionary-time evolution after) bv av)
                                    bv))
                            (rtt (if actual-after
                                     (interpolate now (evolutionary-time evolution before) (evolutionary-time evolution after) b a)
                                   b)))
                        (let ((s (format "{a}ms" (fxround (* rtt 1000.)))))
                          (let ((extent (get-text-extent surface s)))
                            (let ((width (get-width extent))
                                  (height (get-height extent)))
                              (let ((h (+ (fxround h) 4))
                                    (v (max (min (fxround (- vert (/ height 2.))) 86) 0)))
                                (fill-rect surface (h/v/width/height->rect h v width height) {Color Black})
                                (draw-text surface h v s text-color)))))))))))))
        ;; missing
        (let ((missing-scale 5.))
          (define (find-before time id)
            (loop (for n from (last-position evolution) downto (first-position evolution))
                  (when (and (= (evolutionary-id evolution n) id)
                             (< (evolutionary-time evolution n) time))
                    (return n))
                  (finally #f)))
          
          (define (find-after time id)
            (loop (for n from (first-position evolution) to (last-position evolution))
                  (when (and (= (evolutionary-id evolution n) id)
                             (> (evolutionary-time evolution n) time))
                    (return n))
                  (finally #f)))
          
          #f @convert
          (let ((before (find-before now udp-id-missing)))
            (when before
              (let ((actual-after (find-after now udp-id-missing)))
                (let ((after (or actual-after before)))
                  (let ((b (percentage (evolutionary-data3 evolution before) (evolutionary-data4 evolution before)))
                        (a (percentage (evolutionary-data3 evolution after) (evolutionary-data4 evolution after))))
                    (let ((bv (fxround (- 95. (* b missing-scale))))
                          (av (fxround (- 95. (* a missing-scale)))))
                      (let ((vert (if actual-after
                                      (interpolate now (evolutionary-time evolution before) (evolutionary-time evolution after) bv av)
                                    bv))
                            (missing (if actual-after
                                         (interpolate now (evolutionary-time evolution before) (evolutionary-time evolution after) b a)
                                       b)))
                        (let ((s (format "{r precision: 1}%" missing)))
                          (let ((extent (get-text-extent surface s)))
                            (let ((width (get-width extent))
                                  (height (get-height extent)))
                              (let ((h (+ (fxround h) 4))
                                    (v (max (min (fxround (- vert (/ height 2.))) 86) 0)))
                                (fill-rect surface (h/v/width/height->rect h v width height) {Color Black})
                                (draw-text surface h v s text-color))))))))))))))))))
