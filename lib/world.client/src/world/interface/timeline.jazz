;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Timeline Panel
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.interface.timeline jazz


(import (jazz.component)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.time)
        (world)
        (world.biome)
        (world.change)
        (world.chronology)
        (world.context)
        (world.event)
        (world.evolution)
        (world.geometry)
        (world.history)
        (world.interface.panel)
        (world.profiling)
        (world.render)
        (world.settings)
        (world.task)
        (world.udp))


(definition protected chronology-orange  {Color red: .995 green: .699 blue: .292})
(definition protected chronology-yellow  {Color red: .995 green: .946 blue: .005})
(definition protected chronology-green   {Color red: .125 green: .995 blue: .129})
(definition protected chronology-cyan    {Color red: .112 green: .856 blue: .845})
(definition protected chronology-blue    {Color red: .216 green: .274 blue: .953})
(definition protected chronology-purple  {Color red: .478 green: .333 blue: .995})
(definition protected chronology-magenta {Color red: .871 green: .373 blue: .918})
(definition protected chronology-red     {Color red: .995 green: .185 blue: .197})


(definition protected timeline-text-color
  (world-setting 'world.timeline-text {Color Dark-Gray}))


(definition protected visualizer-speed
  (world-setting 'world.visualizer-speed 1.))

(definition speed-factors
  '(.25 .33 .5 .67 .75 .8 .9 1. 1.1 1.25 1.5 1.75 2. 2.5 3. 4. 5.))


(definition protected graph-latency?
  #t)

(definition protected (set-graph-latency? flag)
  (set! graph-latency? flag))


;;;
;;;; Player
;;;


(definition protected (draw-timeline)
  (let ((world (current-world))
        (interface (current-interface)))
    (let ((view (child interface 'timeline))
          (sheet (get-timeline-sheet world)))
      (unless (get-uptodate? view)
        (let ((texture (get-texture sheet)))
          (let ((surface (get-surface texture))
                (data (get-data texture)))
            (draw-view view surface data)
            (map-texture texture)
            (set-uptodate? view #t))))
      (let ((x (cast <fl> (get-left view)))
            (y (cast <fl> (get-top view)))
            (h (cast <fl> (get-height view))))
        (let ((matrix (make-translation-matrix (vertex x (- (get-height world) y h) 0.))))
          (render-sheet sheet matrix))))))


(definition protected (refresh-timeline)
  (let ((interface (current-interface+))
        @together
        (history (current-history)))
    (when interface
      (let ((panel (child interface 'timeline)))
        @together
        (when (not (get-history panel))
          (set-history panel (current-history)))
        (when (not (get-chronology panel))
          (set-chronology panel (current-chronology)))
        (when (not (get-evolution panel))
          (set-evolution panel (current-evolution)))
        (when (not (get-from panel))
          (set-uptodate? panel #f))))))


;;;
;;;; Sites
;;;


(proclaim (not check bounds zero)
          (warn optimizations))


(class Site-Look extends Object
  
  
  (slot rank  <fx+>    getter generate)
  (slot color <Color+> getter generate)
  
  
  (method override (initialize self rank color)
    (nextmethod self)
    (set! self.rank rank)
    (set! self.color color)))


(definition protected site-looks <table>
  (make-table test: eq?))

(definition protected default-site-look <Site-Look+>
  #f)

(definition public (register-site-look name rank color) <void>
  (let ((look (new Site-Look rank color)))
    (if name
        (table-set! site-looks name look)
      (set! default-site-look look))))

(definition public (registered-site-look name) <Site-Look+>
  (table-ref site-looks name #f))


(proclaim (not check types))


(definition protected id-site-looks <vector>
  (make-vector 256 #t))

(definition protected (id->site-look id <fx>) <Site-Look+>
  (let ((value (vector-ref id-site-looks id)))
    (if (eq? value #t)
        (let ((site (id->site id)))
          (let ((look (registered-site-look (get-name site))))
            (vector-set! id-site-looks id look)
            look))
      value)))


(proclaim (default check types))


;;;
;;;; Timeline
;;;


(class Timeline-Panel extends World-Panel
  
  
  (slot tier                          initialize #f  accessors generate)
  (slot origin                        initialize #f  accessors generate)
  (slot media-kind                    initialize #f  accessors generate)
  (slot scale            <fl>         initialize 0   accessors generate)
  (slot sampling         <fx>         initialize 2   accessors generate)
  (slot start            <fl+>        initialize #f  accessors generate)
  (slot end              <fl+>        initialize #f  accessors generate)
  (slot from             <fl+>        initialize #f  accessors generate)
  (slot to               <fl+>        initialize #f  accessors generate)
  (slot span             <fl>         initialize 5.  accessors generate)
  (slot now              <fl+>        initialize #f  accessors generate)
  (slot base-time        <fl>         initialize 0.  accessors generate)
  (slot history          <History>    initialize #f  accessors generate)
  (slot chronology       <Chronology> initialize #f  accessors generate)
  (slot evolution        <Evolution>  initialize #f  accessors generate)
  (slot evolution-range               initialize #f  accessors generate)
  (slot evolution-left   <fl+>        initialize #f  accessors generate)
  (slot evolution-right  <fl+>        initialize #f  accessors generate)
  (slot cpu%             <fl+>        initialize #f  accessors generate)
  (slot live?                         initialize #t  accessors generate)
  (slot replay?                       initialize #f  accessors generate)
  (slot uptodate?                     initialize #f  accessors generate)
  (slot visualizer-start <fl+>        initialize #f  accessors generate)
  (slot visualizer-end   <fl+>        initialize #f  accessors generate)
  (slot visualize?                    initialize #f  getter generate)
  ;; scroll code is a copy/paste from showcase
  (slot point                         initialize #f  getter generate)
  (slot moved?                        initialize #f  getter generate)
  (slot scrolled?                     initialize #f  getter generate)
  (slot last-to                       initialize #f  getter generate)
  (slot last-seconds                  initialize #f  getter generate)
  (slot last-speed                    initialize #f  getter generate)
  (slot pulse                         initialize #f  getter generate)
  (slot labels                        initialize #f  getter generate)
  (slot playing?                      initialize #f  getter generate)
  (slot play-thread                   initialize #f  getter generate)
  (slot full-mode?                    initialize #f  accessors generate)
  (slot discards                      initialize #f  getter generate)
  (slot missings                      initialize #f  getter generate)
  (slot highlighted                   initialize #f  getter generate)
  (slot boxes                         initialize #f  getter generate)
  (slot elapses                       initialize #f  getter generate)
  (slot graphs                        initialize '() getter generate)
  (slot graph-button                  initialize #f  getter generate)
  
  
  ;;;
  ;;;; Bounds
  ;;;
  
  
  (method protected (update-span self)
    (set! span (- to from)))
  
  
  (method protected (set-bounds self f t)
    (assert (<= f t)
      (set! from f)
      (set! to t)))
  
  
  (method (with-bounds self proc)
    (if (not from)
        (let ((start (timeline-start self))
              (end (timeline-end self)))
          (let ((from (max start (- end span)))
                (to end))
            (proc from to)))
      (proc from to)))
  
  
  (method package (set-elapses self elap)
    (unless (equal? elap elapses)
      (set! elapses elap)
      (invalidate-view self)))
  
  
  ;; quicky
  (method protected virtual (together-timeline? self)
    #f)
  
  
  (method protected virtual (timeline-start self) <fl>
    (if live?
        (chronological-time chronology (first-position chronology))
      (or start
          (let ((start (if (empty? chronology)
                           (evolutionary-time evolution (first-position evolution))
                         (chronological-time chronology (first-position chronology)))))
            (set! self.start start)
            start))))
  
  
  (method protected virtual (timeline-end self) <fl>
    (if live?
        (chronological-time chronology (last-position chronology))
      (or end
          (let ((end (if (empty? chronology)
                         (evolutionary-time evolution (last-position evolution))
                       (chronological-time chronology (last-position chronology)))))
            (set! self.end end)
            end))))
  
  
  (method protected (reset-start/end self)
    (set! start #f)
    (set! end #f))
  
  
  (method (live-information self)
    (unless live?
      @together
      (set! history (current-history))
      (set! chronology (current-chronology))
      (set! evolution (current-evolution))
      (set! cpu% #f)
      (set! live? #t)))
  
  
  (method (copy-information self)
    (when live?
      @together
      (set! history (copy-history (current-history)))
      (set! chronology (copy-chronology (current-chronology)))
      (set! evolution (copy-evolution (current-evolution)))
      (set! cpu% (chronology-cpu% chronology))
      (set! live? #f)))
  
  
  ;; to redo?
  (method (update self time)
    )
  
  
  (method protected (setup-replay self base-time)
    (let ((start (timeline-start self))
          (end (timeline-end self)))
      (set-now self #f)
      (set-bounds self start end)
      (set-base-time self base-time)
      (update-span self)
      (set-replay? self #t)
      (set-live? self #f)
      (set! cpu% (chronology-cpu% chronology))
      (redraw self)))
  
  
  (method protected virtual (view-update self)
    )
  
  
  (method protected virtual (now-update self)
    )


  (proclaim (not warn optimizations))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method override (mouse-down self evt)
    (copy-information self)
    (with-bounds self
      (lambda (from~ to~)
        (if (and (together-timeline? self) (between? (get-v evt) 85 115))
            (begin
              (set! visualize? #t)
              (set! now (h->when self from to (get-h evt)))
              (redraw self)
              (now-update self))
          (set! visualize? #f)
          (set! point (get-h evt))
          (set! moved? #f)
          (set! last-to to~)
          (set! last-seconds (current-seconds))
          (set! last-speed #f)
          (kill-autoscroll self)))))
  
  
  (method override (drag-move self evt)
    (let ((h (get-h evt)))
      (if visualize?
          (begin
            (set! now (h->when self from to (get-h evt)))
            (redraw self)
            (now-update self))
        (when (and point (not (near? h point 2)))
          (with-bounds self
            (lambda (from~ to~)
              (let ((delta (* (/ (cast <fl> (- h point)) (cast <fl> (get-width self))) (- span)))
                    (start (timeline-start self))
                    (end (timeline-end self)))
                (let ((new-from (+ from~ delta))
                      (new-to (+ to~ delta)))
                  (cond ((> new-to end)
                         (set-bounds self (- end span) end))
                        ((< new-from start)
                         (set-bounds self start (+ start span)))
                        (else
                         (set-bounds self new-from new-to))))
                (update-span self)
                (redraw self))
              (set! point h)
              (set! moved? #t)
              (let ((new-to to)
                    (new-seconds (current-seconds))
                    (old-to last-to)
                    (old-seconds last-seconds))
                (set! last-to new-to)
                (set! last-seconds new-seconds)
                (unless (= new-seconds old-seconds)
                  (let ((new-speed (/ (- new-to old-to) (- new-seconds old-seconds)))
                        (p .9))
                    (set! last-speed (+ (* new-speed (- 1. p)) (* (or last-speed 0.) p))))))))))))

  
  (method override (mouse-up self evt)
    (if visualize?
        (begin
          (set! visualize? #f)
          (set! now (h->when self from to (get-h evt)))
          (redraw self)
          (now-update self))
      (if (or (not moved?) (< (- (current-seconds) last-seconds) .1))
          (if moved?
              (begin
                (set! scrolled? #f)
                (start-autoscroll self))
            (with-bounds self
              (lambda (from to)
                (set! point (get-h evt))
                (set! moved? #f)
                (set! scrolled? #f)
                (set! last-speed #f)
                (set! now (h->when self from to point))
                (redraw self)
                (now-update self)
                (kill-autoscroll self))))
        (view-update self))))
  
  
  (method override (right-mouse-up self evt)
    (live-information self)
    (set! from #f)
    (set! to #f)
    (redraw self)
    (view-update self))
  
  
  (method override (mouse-wheel self pos delta)
    (let ((d (get-v delta)))
      (cond ((> d 0)
             (zoom-in self))
            ((< d 0)
             (zoom-out self)))))
  
  
  (method package (zoom-in self)
    (let ((start (timeline-start self))
          (end (timeline-end self)))
      (let ((max-span (- end start)))
        (if (not from)
            (set! span (min max-span (* span .75)))
          (let ((h (get-h (mouse-position self)))
                (width (get-width self)))
            (let ((proportion (/ (cast <fl> h) (cast <fl> width))))
              (let ((when (+ from (* span proportion)))
                    (new-span (min max-span (* span .75))))
                (let ((new-from (- when (* new-span proportion)))
                      (new-to (+ when (* new-span (- 1. proportion)))))
                  (set-bounds self (max start new-from) (min end new-to))
                  (update-span self))))))))
    (redraw self)
    (view-update self))
  
  
  (method package (zoom-out self)
    (let ((start (timeline-start self))
          (end (timeline-end self)))
      (let ((max-span (- end start)))
        (if (not from)
            (set! span (min max-span (/ span .75)))
          (let ((h (get-h (mouse-position self)))
                (width (get-width self)))
            (let ((proportion (/ (cast <fl> h) (cast <fl> width))))
              (let ((when (+ from (* span proportion)))
                    (new-span (min max-span (/ span .75))))
                (let ((new-from (- when (* new-span proportion)))
                      (new-to (+ when (* new-span (- 1. proportion)))))
                  (set-bounds self (max start new-from) (min end new-to))
                  (update-span self))))))))
    (redraw self)
    (view-update self))
  
  
  (method package (zoom-reset self)
    (set-bounds self (timeline-start self) (timeline-end self))
    (update-span self)
    (redraw self)
    (view-update self))


  (proclaim (warn optimizations))
  
  
  (method protected (h->when self from to h)
    (let ((width (get-width self)))
      (cond ((< h 0)
             from)
            ((> h width)
             to)
            (else
             (+ from (* span (/ (cast <fl> h) (cast <fl> width))))))))
  
  
  (method protected (when->h self from to span when)
    (fxround (* (/ (- when from) span) (cast <fl> (get-width self)))))


  (proclaim (not warn optimizations))
  
  
  ;;;
  ;;;; Autoscroll
  ;;;
  
  
  (method (start-autoscroll self)
    (set! pulse (new Pulse 'autoscroll 0.01 (~ autoscroll-action self) delay: 0)))
  
  
  (method (kill-autoscroll self)
    (when pulse
      (close pulse)
      (set! pulse #f)))
  
  
  (method (autoscroll-action self)
    (when (and last-speed (not live?))
      (let ((actual-to to))
        (let ((scroll-to (+ actual-to (/ last-speed 100.))))
          (let ((new-to scroll-to))
            (when (/= new-to actual-to)
              (set! scrolled? #t)
              (let ((new-from (- new-to span)))
                (let ((start (timeline-start self))
                      (end (timeline-end self)))
                  (cond ((> new-to end)
                         (set-bounds self (- end span) end))
                        ((< new-from start)
                         (set-bounds self start (+ start span)))
                        (else
                         (set-bounds self new-from new-to)))
                  (update-span self)
                  (redraw self)
                  (when (or (<= new-from start)
                            (>= new-to end))
                    (set! scrolled? #f)
                    (kill-autoscroll self)
                    (view-update self))))))))))
  
  
  ;;;
  ;;;; Graph
  ;;;
  
  
  (method public (register-graphs self graphs)
    (set! self.graphs graphs)
    (invalidate-view self))
  
  
  ;;;
  ;;;; Draw
  ;;;


  (proclaim (warn optimizations))
  
  
  (method package (redraw self)
    (if replay?
        (invalidate-view self)
      (set-uptodate? self #f)))
  
  
  (method override (draw self surface context)
    ;; quick solution
    (let ((interface (current-interface)))
      (unless (eq? self (child interface 'timeline))
        (draw-view self surface #f))))


  (method package (draw-view self surface <Surface> data)
    (clear surface)
    (fill-rect surface (new Rect 0 0 (get-width self) (get-height self)) {Color red: .000 green: .000 blue: .000 alpha: .450})
    (draw-timeline self surface)
    (frame-rect surface (new Rect 0 0 (get-width self) (get-height self)) (border-color self)))
  
  
  (method (draw-timeline self surface <Surface>)
    (when (and @together history chronology evolution)
      (when live?
        (set! cpu% (chronology-cpu% chronology)))
      (with-bounds self
        (lambda (from to)
          (let ((timer (new Timer))
                (history-duration #f)
                (chronology-duration #f)
                (evolution-duration #f)
                (highlight-duration #f)
                (now-duration #f))
            (set! labels '())
            (set! discards '())
            (set! missings '())
            (set! highlighted '())
            (set! boxes '())
            ;; time
            (plot-time self surface from to)
            ;; history
            @together
            (let ((timer (new Timer)))
              (plot-history self surface from to)
              (set! history-duration (real-duration timer)))
            ;; chronology
            (let ((timer (new Timer)))
              (when (or (not together?) (not live?))
                (unless (or full-mode? visualize?)
                  (plot-chronology self surface from to)))
              (set! chronology-duration (real-duration timer)))
            ;; evolution
            (let ((timer (new Timer)))
              (unless (or full-mode? visualize?)
                (plot-evolution self surface from to))
              (set! evolution-duration (real-duration timer)))
            ;; highlight
            (let ((timer (new Timer)))
              (plot-highlight self surface from to)
              (set! highlight-duration (real-duration timer)))
            ;; now
            (let ((timer (new Timer)))
              (plot-now self surface from to)
              (set! now-duration (real-duration timer)))
            ;; info
            (plot-info self surface history-duration chronology-duration evolution-duration highlight-duration now-duration (real-duration timer)))))))
  
  
  (method (plot-info self surface <Surface> history-duration chronology-duration evolution-duration highlight-duration now-duration duration)
    (set-font surface {Font Label})
    (when tier
      (let ((title tier))
        (draw-text surface 5 3 title timeline-text-color)))
    (when cpu%
      (let ((title (format "CPU: {r precision: 1}%" cpu%)))
        (draw-text surface (if tier 80 5) 3 title timeline-text-color)))
    (when evolution-range
      (let ((title (format "Shown: {a}" evolution-range)))
        (draw-text surface (if cpu% 165 80) 3 title timeline-text-color)))
    (when elapses
      (let ((title (format "Elapses: {l detail: :human}" elapses)))
        (draw-text surface 5 40 title timeline-text-color)))
    (when title
      (let ((title (format "{a} ({a})" title (present-seconds duration))))
        (let ((width (get-width self))
              (extent (get-text-extent surface title)))
          (let ((h (- width (get-width extent) 5)))
            (draw-text surface (- width (get-width extent) 5) 3 title timeline-text-color)
            (let ((title (format "graph")))
              (let ((h (- h 60)))
                (draw-text surface h 3 title timeline-text-color)
                (set! graph-button h))))))
      (when (world-setting 'world.timeline-durations? #f)
        (let ((title (format "chrono {a} evo {a} highlight {a} now {a}"
                             (present-seconds chronology-duration)
                             (present-seconds evolution-duration)
                             (present-seconds highlight-duration)
                             (present-seconds now-duration))))
          (let ((width (get-width self))
                (extent (get-text-extent surface title)))
            (draw-text surface (- width (get-width extent) 5) 17 title timeline-text-color))))))
  
  
  (method protected virtual (border-color self)
    {Color Entry-Border})
  
  
  (method (plot-time self surface <Surface> from <fl> to <fl>)
    (let ((width (cast <fl> (get-width self)))
          (height (cast <fl> (get-height self))))
      ;; time
      (let ((v (/ height 2.)))
        (set-color surface {Color Medium-Gray alpha: .7})
        (set-line-width surface 1)
        (move-to surface 0 v)
        (line-to surface width v))
      ;; units
      (let ((from (- from base-time))
            (to (- to base-time)))
        (let ((span (min (- to from) span)))
          (let ((v (/ height 2.)))
            (set-color surface {Color Medium-Gray alpha: .7})
            (set-line-width surface 1)
            (loop (for s from (fxceiling from) to (fxfloor to))
                  (let ((h (when->h self from to span (cast <fl> s))))
                    (move-to surface h (- v 3.))
                    (line-to surface h (+ v 4.)))))))
      ;; bookmarks
      (let ((v (/ height 2.)))
        (set-color surface {Color Red alpha: .85})
        (set-line-width surface 1)
        (loop (for n from (first-position evolution) to (last-position evolution))
              (when (= (evolutionary-udp-id evolution n) udp-id-bookmark)
                (let ((time (evolutionary-udp-time evolution n)))
                  (let ((h (when->h self from to span time)))
                    (move-to surface (- h 3) (- v 3.))
                    (line-to surface (+ h 4) (+ v 4.))
                    (move-to surface (+ h 4) (- v 3.))
                    (line-to surface (- h 3) (+ v 4.)))))))
      ;; headers
      (unless live?
        (let ((v (/ height 2.)))
          (set-color surface {Color Purple alpha: .85})
          (set-line-width surface 1)
          (loop (for n from (first-position evolution) to (last-position evolution))
                (when (= (flonum->fixnum (evolutionary-udp-kind evolution n)) udp-video)
                  (let ((id (evolutionary-udp-id evolution n)))
                    (when (or (= id udp-id-play-frame)
                              (= id udp-id-freeze-frame))
                      (when (= (evolutionary-udp-data3 evolution n) 123456.)
                        (let ((time (evolutionary-udp-time evolution n)))
                          (let ((h (cast <fl> (when->h self from to span time)))
                                (color {Color Purple}))
                            (ellipse$fl$ surface (new Rect$fl$ (- h 1.5) (- v 1.5) (+ h 2.5) (+ v 2.5)) color color))))))))))))
  
  
  ;;;
  ;;;; Evolution
  ;;;
  
  
  (method (plot-evolution self surface <Surface> from <fl> to <fl>)
    (let ((start (timeline-start self))
          (end (timeline-end self)))
      (define (find-first) <fx+>
        (loop (for n from (first-position evolution) to (last-position evolution))
              (when (>= (evolutionary-udp-time evolution n) start)
                (return n))
              (finally #f)))
      
      (define (find-last first <fx>) <fx>
        (loop (for n from first to (last-position evolution))
              (when (> (evolutionary-udp-time evolution n) end)
                (return (- n 1)))
              (finally (last-position evolution))))
      
      (let ((width (cast <fl> (get-width self)))
            (height (cast <fl> (get-height self)))
            (span (min (- to from) span))
            (dark-purple {Color red: .464 green: .141 blue: .732})
            (latency-scale 100.)
            (previous-latency-h #f)
            (previous-latency-v #f)
            (rtt-scale (if local? 5000. 150.))
            (previous-rtt-h #f)
            (previous-rtt-v #f)
            (traffic-scale .15)
            (previous-traffic-h #f)
            (previous-traffic-v #f)
            (missing-scale 5.)
            (previous-missing-h #f)
            (previous-missing-v #f)
            (graphs (map new graphs))
            (now-h (and now (when->h self from to span now)))
            (first (find-first)))
        (when first
          (let ((last (find-last first)))
            (define (find-head) <fx>
              (loop (for n from first to last)
                    (when (>= (evolutionary-udp-time evolution n) from)
                      (return n))
                    (finally first)))
            
            (define (find-tail head <fx>) <fx>
              (loop (for n from head to last)
                    (when (> (evolutionary-udp-time evolution n) to)
                      (return (- n 1)))
                    (finally last)))
            
            (define (find-previous head <fx> id <fl>) <fx+>
              (loop (for n from (- head 1) downto first)
                    (when (= (evolutionary-udp-id evolution n) id)
                      (return n))
                    (finally #f)))
            
            (define (find-next tail <fx> id <fl>) <fx+>
              (loop (for n from (+ tail 1) to last)
                    (when (= (evolutionary-udp-id evolution n) id)
                      (return n))
                    (finally #f)))
            
            (let ((head (find-head)))
              (let ((tail (find-tail head))
                    (sampling (cond ((<= span 1.) 1)
                                    ((>= span 60.) 100)
                                    (else (fxround (interpolate span 1. 60. 1. 100.))))))
                (set-line-width surface 1.)
                (for-each (lambda (graph)
                            (draw-context graph surface from to span sampling evolution))
                          graphs)
                (loop (for n from head to tail)
                      (let ((time (evolutionary-udp-time evolution n))
                            (id (evolutionary-udp-id evolution n)))
                        (let ((h (fxround (* (/ (- time from) span) width))))
                          (ecase id
                            @wait
                            ((udp-id-connect)
                             (let ((color {Color Yellow})
                                   (v 13))
                               (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color)))
                            @wait
                            ((udp-id-connected)
                             (let ((color {Color Green})
                                   (v 13))
                               (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color)))
                            @convert
                            ((udp-id-send-media)
                             (let ((kind (flonum->fixnum (evolutionary-udp-kind evolution n)))
                                   (off? (= (evolutionary-udp-data1 evolution n) 0.)))
                               (let ((color (if off?
                                                {Color Medium-Gray}
                                              (ecase kind
                                                ((udp-audio) {Color Purple})
                                                (else {Color Blue}))))
                                     (v 13))
                                 (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color))))
                            ((udp-id-insert-packet)
                             (when (and graph-latency?
                                        (eqv? (flonum->fixnum (evolutionary-udp-origin evolution n)) origin)
                                        (eqv? (flonum->fixnum (evolutionary-udp-kind evolution n)) media-kind))
                               (let ((v 21))
                                 (set-color surface {Color Blue})
                                 (let ((latency (evolutionary-udp-data6 evolution n)))
                                   (let ((v (fxround (- 35. (* latency latency-scale)))))
                                     (when (not previous-latency-h)
                                       (let ((n (find-previous head id)))
                                         (when n
                                           (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                                 (v (fxround (- 35. (* (evolutionary-udp-data6 evolution n) latency-scale)))))
                                             (set! previous-latency-h h)
                                             (set! previous-latency-v v)))))
                                     (when previous-latency-h
                                       (move-to surface previous-latency-h previous-latency-v)
                                       (line-to surface h v))
                                     (set! previous-latency-h h)
                                     (set! previous-latency-v v))))))
                            ((udp-id-receive-ack)
                             (let ((v 21))
                               (set-color surface {Color Green})
                               (let ((rtt (evolutionary-udp-data3 evolution n)))
                                 (let ((v (fxround (- 95. (* rtt rtt-scale)))))
                                   (when (not previous-rtt-h)
                                     (let ((n (find-previous head id)))
                                       (when n
                                         (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                               (v (fxround (- 95. (* (evolutionary-udp-data3 evolution n) rtt-scale)))))
                                           (set! previous-rtt-h h)
                                           (set! previous-rtt-v v)))))
                                   (when previous-rtt-h
                                     (move-to surface previous-rtt-h previous-rtt-v)
                                     (line-to surface h v))
                                   (set! previous-rtt-h h)
                                   (set! previous-rtt-v v)))))
                            ((udp-id-traffic-rate)
                             (let ((v 21))
                               (set-color surface {Color Purple})
                               (let ((traffic (evolutionary-udp-data4 evolution n)))
                                 (let ((v (fxround (- 95. (* traffic traffic-scale)))))
                                   (when (not previous-traffic-h)
                                     (let ((n (find-previous head id)))
                                       (when n
                                         (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                               (v (fxround (- 95. (* (evolutionary-udp-data4 evolution n) traffic-scale)))))
                                           (set! previous-traffic-h h)
                                           (set! previous-traffic-v v)))))
                                   (when previous-traffic-h
                                     (move-to surface previous-traffic-h previous-traffic-v)
                                     (line-to surface h v))
                                   (set! previous-traffic-h h)
                                   (set! previous-traffic-v v)))))
                            @wait
                            ((udp-id-resend-packet)
                             (let ((found (evolutionary-udp-data1 evolution n)))
                               (let ((color (if (= found 1.)
                                                {Color Orange}
                                              {Color Red}))
                                     (v 29))
                                 (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color))))
                            ((udp-id-discard-packet udp-id-missing-packet)
                             (let ((kind (flonum->fixnum (evolutionary-udp-kind evolution n))))
                               (let ((color (if (= kind udp-audio) {Color Orange} {Color Red}))
                                     (left (- h 2))
                                     (right (+ h 3))
                                     (v (if (= kind udp-audio) 37 44)))
                                 (let ((rect (new Rect left (- v 2) right (+ v 3))))
                                   (if (= id udp-id-discard-packet)
                                       (fill-rect surface rect color)
                                     (frame-rect surface rect color))
                                   (when (and now-h (between? now-h left right))
                                     (let ((sequence (evolutionary-udp-sequence evolution n)))
                                       (if (= id udp-id-discard-packet)
                                           (unless (memv? sequence discards)
                                             (set! discards (cons sequence discards)))
                                         (unless (memv? sequence missings)
                                           (set! missings (cons sequence missings))))))))))
                            @convert
                            ((udp-id-discard udp-id-missing)
                             (let ((color (if (= id udp-id-discard)
                                              {Color Purple}
                                            {Color Red}))
                                   (v 37))
                               (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color))
                             (when (= id udp-id-missing)
                               (set-color surface {Color Red})
                               (let ((missing (evolutionary-udp-data1 evolution n))
                                     (processed (evolutionary-udp-data2 evolution n)))
                                 (let ((v (fxround (- 95. (* (percentage missing processed) missing-scale)))))
                                   (when (not previous-missing-h)
                                     (let ((n (find-previous head id)))
                                       (when n
                                         (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                               (v (fxround (- 95. (* (percentage (evolutionary-udp-data1 evolution n) (evolutionary-udp-data2 evolution n)) missing-scale)))))
                                           (set! previous-missing-h h)
                                           (set! previous-missing-v v)))))
                                   (when previous-missing-h
                                     (move-to surface previous-missing-h previous-missing-v)
                                     (line-to surface h v))
                                   (set! previous-missing-h h)
                                   (set! previous-missing-v v))))))
                          (for-each (lambda (graph)
                                      (draw-graph graph surface from to span sampling evolution n time id h now-h))
                                    graphs))))
                (when (and graph-latency? previous-latency-h)
                  (let ((n (find-next tail udp-id-receive-ack)))
                    (set-color surface {Color Blue})
                    (move-to surface previous-latency-h previous-latency-v)
                    (if (not n)
                        (line-to surface width previous-latency-v)
                      (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                            (v (fxround (- 35. (* (evolutionary-udp-data6 evolution n) latency-scale)))))
                        (line-to surface h v)))))
                (when previous-rtt-h
                  (let ((n (find-next tail udp-id-receive-ack)))
                    (set-color surface {Color Green})
                    (move-to surface previous-rtt-h previous-rtt-v)
                    (if (not n)
                        (line-to surface width previous-rtt-v)
                      (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                            (v (fxround (- 95. (* (evolutionary-udp-data3 evolution n) rtt-scale)))))
                        (line-to surface h v)))))
                (when previous-traffic-h
                  (let ((n (find-next tail udp-id-traffic-rate)))
                    (set-color surface {Color Purple})
                    (move-to surface previous-traffic-h previous-traffic-v)
                    (if (not n)
                        (line-to surface width previous-traffic-v)
                      (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                            (v (fxround (- 95. (* (evolutionary-udp-data4 evolution n) traffic-scale)))))
                        (line-to surface h v)))))
                @convert
                (when previous-missing-h
                  (let ((n (find-next tail udp-id-missing)))
                    (set-color surface {Color Red})
                    (move-to surface previous-missing-h previous-missing-v)
                    (if (not n)
                        (line-to surface width previous-missing-v)
                      (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                            (v (fxround (- 95. (* (percentage (evolutionary-udp-data1 evolution n) (evolutionary-udp-data2 evolution n)) missing-scale)))))
                        (line-to surface h v))))))))))))
  
  
  (method protected virtual (plot-highlight self surface <Surface> from <fl> to <fl>)
    )
  
  
  ;;;
  ;;;; History
  ;;;
  
  
  (method (plot-history self surface <Surface> from <fl> to <fl>)
    (let ((start (timeline-start self))
          (end (timeline-end self)))
      (define (find-first)
        (loop (for n from (history-first history) to (history-last history))
              (when (>= (historical-time history n) start)
                (return n))
              (finally #f)))
      
      (define (find-last first)
        (loop (for n from first to (history-last history))
              (when (> (historical-time history n) end)
                (return (- n 1)))
              (finally (history-last history))))
      
    (let ((width (cast <fl> (get-width self)))
          (height (cast <fl> (get-height self)))
          (now (get-now history))
          (changes (get-changes history))
          (span (min (- to from) span))
          (v (- (get-height self) 87))
          (first (find-first)))
      (when (and first (<= first tail))
        (let ((last (find-last first)))
          (define (plot-change n)
            (let ((time (historical-time history n)))
              (when (between? time from to)
                (let ((change (id->change (historical-change-id history n))))
                  (let ((h (fxround (* (/ (- time from) span) width)))
                        (color (case (get-name change)
                                 ((move) {Color Purple})
                                 ((lookat) {Color Blue})
                                 ((animate) {Color Blue})
                                 ((edit-script update-script) {Color Ochre})
                                 ((fire) {Color Green})
                                 ((spawn) {Color Green})
                                 ((die) {Color Red})
                                 ((add-block delete-block add-entity remove-entity) {Color Green})
                                 ((action interact) {Color Green})
                                 (else {Color Light-Gray}))))
                    (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color))))))
          
          (loop (for n from first to last)
                (unless (= n now)
                  (plot-change n)))
          (plot-change now))))))
  
  
  ;;;
  ;;;; Chronology
  ;;;
  
  
  (method (plot-chronology self surface <Surface> from <fl> to <fl>)
    (let ((width (cast <fl> (get-width self)))
          (height (cast <fl> (get-height self)))
          (span (min (- to from) span))
          (first (first-position chronology))
          (last (last-position chronology))
          (starts (make-vector (site-id-count) #f)))
      (define (find-head/starts!) <fx>
        (continuation-capture
          (lambda (return)
            (loop (for n from first to last)
                  (let ((id (flonum->fixnum (chronological-id chronology n)))
                        (time (chronological-time chronology n)))
                    (if (>= time from)
                        (continuation-return return n)
                      (let ((marker (chronological-marker chronology n)))
                        (if (even? (flonum->fixnum marker))
                            (vector-set! starts id time)
                          (vector-set! starts id #f))))))
            first)))
      
      (define (find-tail head) <fx>
        (continuation-capture
          (lambda (return)
            (loop (for n from head to last)
                  (when (> (chronological-time chronology n) to)
                    (continuation-return return (- n 1))))
            last)))
      
      (when (world-setting 'world.timeline-colors? #f)
        (fill-rect surface (new Rect   0   0  20 110) chronology-orange)
        (fill-rect surface (new Rect  20  11  40 110) chronology-yellow)
        (fill-rect surface (new Rect  40  22  60 110) chronology-green)
        (fill-rect surface (new Rect  60  33  80 110) chronology-cyan)
        (fill-rect surface (new Rect  80  44 100 110) chronology-blue)
        (fill-rect surface (new Rect 100  55 120 110) chronology-purple)
        (fill-rect surface (new Rect 120  66 140 110) chronology-magenta)
        (fill-rect surface (new Rect   0  77  30 110) {Color Yellow})
        (fill-rect surface (new Rect  30  77  60 110) {Color Yellow})
        (fill-rect surface (new Rect  60  77  90 110) {Color Green})
        (fill-rect surface (new Rect  90  77 140 110) {Color Blue})
        (fill-rect surface (new Rect   0  88 140 110) {Color Orange})
        (fill-rect surface (new Rect   0  99 140 110) {Color Red})
        @wait
        (fill-rect surface (new Rect  30   0  40 110) {Color Dark-Gray})
        (let ((text-color {Color Light-Gray}))
          (set-font surface {Font Label})
          (draw-text surface   3 -3 "audio" text-color)
          (draw-text surface  23  8 "video" text-color)
          (draw-text surface  43 19 "udp-release" text-color)
          (draw-text surface  63 30 "udp-state" text-color)
          (draw-text surface  83 41 "udp-receive" text-color)
          (draw-text surface 103 52 "udp-process" text-color)
          (draw-text surface 123 63 "video-output" text-color)
          (draw-text surface   7 74 "network" text-color)
          (draw-text surface  65 74 "tick" text-color)
          (draw-text surface  97 74 "render" text-color)
          (draw-text surface  32 85 "message/event" text-color)
          (draw-text surface  53 96 "memory" text-color)))
      
      (let ((head (find-head/starts!)))
        (let ((tail (find-tail head)))
          (define (plot-call rank <fx> color <Color> id <fx> start <fl> end <fl>)
            (let ((bar-height (* (cast <fl> rank) 7.)))
              (let ((f (* (/ (- start from) span) width))
                    (t (* (/ (- end from) span) width))
                    (bottom height)
                    (top (- height bar-height)))
                (when (or (between? f 0. width)
                          (between? t 0. width)
                          (and (< f 0.)
                               (> t width)))
                  (let ((left (fxfloor f))
                        (top (fxfloor top))
                        (right (fxceiling t))
                        (bottom (fxceiling bottom)))
                    (let ((rect (new Rect left top right bottom)))
                      (fill-rect surface rect color)
                      (when (and now (between? now start end))
                        (set! boxes (cons rect boxes))
                        (let ((name (get-name (id->site id)))
                              (duration (- end start)))
                          (let ((text (format "{a} ({a})" name (present-seconds duration))))
                            (set! labels (cons (cons (- top 16) text) labels)))))))))))
          
          (loop (for layer from 10 downto 1)
                (loop (for n from head to tail)
                      (let ((id (flonum->fixnum (chronological-id chronology n)))
                            (marker (chronological-marker chronology n))
                            (time (chronological-time chronology n)))
                        (let ((look (or (id->site-look id) default-site-look)))
                          (when look
                            (let ((rank (get-rank look)))
                              (when (and rank (= rank layer))
                                (if (even? (flonum->fixnum marker))
                                    (vector-set! starts id time)
                                  (let ((start (or (vector-ref starts id) from)))
                                    (let ((end time))
                                      (proclaim (not check types))
                                      (plot-call rank (get-color look) id start end)))
                                  (vector-set! starts id #f))))))))
                (loop (for id from 0 below (site-id-count))
                      (let ((look (or (id->site-look id) default-site-look)))
                        (when look
                          (let ((rank (get-rank look)))
                            (when (and rank (= rank layer))
                              (let ((start (vector-ref starts id)))
                                (when start
                                  (let ()
                                    (proclaim (not check types))
                                    (plot-call rank (get-color look) id start to))))))))))))))
  
  
  ;;;
  ;;;; Now
  ;;;
  
  
  (method (plot-now self surface <Surface> from <fl> to <fl>)
    (when (and now (not live?))
      (let ((h (when->h self from to span now))
            (height (cast <fl> (get-height self)))
            (text-color {Color Light-Gray}))
        ;; line
        (set-color surface {Color White})
        (set-line-width surface 1.5)
        (move-to surface h 0)
        (line-to surface h height)
        ;; evolution
        (when evolution-left
          (let ((h (when->h self from to span evolution-left)))
            (set-color surface {Color Gray alpha: .4})
            (set-line-width surface 1.)
            (move-to surface h 0)
            (line-to surface h height)))
        (when evolution-right
          (let ((h (when->h self from to span evolution-right)))
            (set-color surface {Color Gray alpha: .4})
            (set-line-width surface 1.)
            (move-to surface h 0)
            (line-to surface h height)))
        ;; time
        (let ((height (cast <fl> (get-height self))))
          (let ((s (format "{r precision: 3}" (if together? (- now base-time) (- now (floor kernel-boot)))))
                (v (/ height 2.)))
            (let ((width (get-text-width surface s)))
              (let ((h (if (< h 60) (+ (fxround h) 4) (- (fxround h) width 4)))
                    (v (- (+ (fxround v) 1) 9)))
                (set-font surface {Font Label})
                (draw-text surface h v s text-color)))))
        ;; labels
        (for-each (lambda (label)
                    (bind (v . text) label
                      (let ((h (+ (fxround h) 4))
                            (v (+ (fxround v) 1)))
                        (draw-text surface h v text text-color))))
                  labels)
        ;; giveup
        (when (or (not-null? discards)
                  (not-null? missings))
          (let ((v 46))
            (let ((h (+ (fxround h) 4))
                  (v (+ (fxround v) 1))
                  (discard-text (and (not-null? discards)
                                     (let ((count (length discards)))
                                       (if (> count 5)
                                           (format "discard ({a} total)" count)
                                         (format "discard {l}" (sort < discards))))))
                  (missing-text (and (not-null? missings)
                                     (let ((count (length missings)))
                                       (if (> count 5)
                                           (format "missing ({a} total)" count)
                                         (format "missing {l}" (sort < missings)))))))
              (let ((text (if (and discard-text missing-text)
                              (format "{a} {a}" discard-text missing-text)
                            (or discard-text
                                missing-text))))
                (draw-text surface h v text text-color)))))
        ;; highlighted
        (when (not-null? highlighted)
          (let ((v 100))
            (let ((h (+ (fxround h) 4))
                  (v (- (+ (fxround v) 1) 9))
                  (text (format "{l}" (map evolution-id->abbrev highlighted))))
              (draw-text surface h v text text-color))))
        ;; boxes
        (for-each (lambda (box)
                    (frame-rect surface box {Color White}))
                  boxes)
        ;; latency
        (unless (or full-mode? visualize? (not graph-latency?))
          (let ((latency-scale 100.))
            (define (find-before time id)
              (loop (for n from (last-position evolution) downto (first-position evolution))
                    (when (and (= (evolutionary-udp-id evolution n) id)
                               (< (evolutionary-udp-time evolution n) time))
                      (return n))
                    (finally #f)))
            
            (define (find-after time id)
              (loop (for n from (first-position evolution) to (last-position evolution))
                    (when (and (= (evolutionary-udp-id evolution n) id)
                               (> (evolutionary-udp-time evolution n) time))
                      (return n))
                    (finally #f)))
            
            (let ((before (find-before now udp-id-insert-packet)))
              (when before
                (let ((actual-after (find-after now udp-id-insert-packet)))
                  (let ((after (or actual-after before)))
                    (let ((b (evolutionary-udp-data6 evolution before))
                          (a (evolutionary-udp-data6 evolution after)))
                      (let ((bv (fxround (- 35. (* b latency-scale))))
                            (av (fxround (- 35. (* a latency-scale)))))
                        (let ((vert (if actual-after
                                        (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) bv av)
                                      bv))
                              (latency (if actual-after
                                           (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) b a)
                                         b)))
                          (let ((s (present-seconds latency)))
                            (let ((extent (get-text-extent surface s)))
                              (let ((width (get-width extent))
                                    (height (get-height extent)))
                                (let ((h (+ (fxround h) 4))
                                      (v (max (min (fxround (- vert (/ height 2.))) 86) 0)))
                                  ;(fill-rect surface (h/v/width/height->rect h v width height) {Color Black})
                                  (draw-text surface h v s text-color))))))))))))))
        ;; rtt
        (unless (or full-mode? visualize?)
          (let ((rtt-scale (if local? 5000. 150.)))
            (define (find-before time id)
              (loop (for n from (last-position evolution) downto (first-position evolution))
                    (when (and (= (evolutionary-udp-id evolution n) id)
                               (< (evolutionary-udp-time evolution n) time))
                      (return n))
                    (finally #f)))
            
            (define (find-after time id)
              (loop (for n from (first-position evolution) to (last-position evolution))
                    (when (and (= (evolutionary-udp-id evolution n) id)
                               (> (evolutionary-udp-time evolution n) time))
                      (return n))
                    (finally #f)))
            
            (let ((before (find-before now udp-id-receive-ack)))
              (when before
                (let ((actual-after (find-after now udp-id-receive-ack)))
                  (let ((after (or actual-after before)))
                    (let ((b (evolutionary-udp-data3 evolution before))
                          (a (evolutionary-udp-data3 evolution after)))
                      (let ((bv (fxround (- 95. (* b rtt-scale))))
                            (av (fxround (- 95. (* a rtt-scale)))))
                        (let ((vert (if actual-after
                                        (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) bv av)
                                      bv))
                              (rtt (if actual-after
                                       (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) b a)
                                     b)))
                          (let ((s (present-seconds rtt)))
                            (let ((extent (get-text-extent surface s)))
                              (let ((width (get-width extent))
                                    (height (get-height extent)))
                                (let ((h (+ (fxround h) 4))
                                      (v (max (min (fxround (- vert (/ height 2.))) 86) 0)))
                                  ;(fill-rect surface (h/v/width/height->rect h v width height) {Color Black})
                                  (draw-text surface h v s text-color))))))))))))))
        ;; traffic
        (unless (or full-mode? visualize?)
          (let ((traffic-scale .15))
            (define (find-before time id)
              (loop (for n from (last-position evolution) downto (first-position evolution))
                    (when (and (= (evolutionary-udp-id evolution n) id)
                               (< (evolutionary-udp-time evolution n) time))
                      (return n))
                    (finally #f)))
            
            (define (find-after time id)
              (loop (for n from (first-position evolution) to (last-position evolution))
                    (when (and (= (evolutionary-udp-id evolution n) id)
                               (> (evolutionary-udp-time evolution n) time))
                      (return n))
                    (finally #f)))
            
            (let ((before (find-before now udp-id-traffic-rate)))
              (when before
                (let ((actual-after (find-after now udp-id-traffic-rate)))
                  (let ((after (or actual-after before)))
                    (let ((b (evolutionary-udp-data4 evolution before))
                          (a (evolutionary-udp-data4 evolution after)))
                      (let ((bv (fxround (- 95. (* b traffic-scale))))
                            (av (fxround (- 95. (* a traffic-scale)))))
                        (let ((vert (if actual-after
                                        (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) bv av)
                                      bv))
                              (traffic (if actual-after
                                           (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) b a)
                                         b)))
                          (let ((s (format "{r precision: 0}/s" traffic)))
                            (let ((extent (get-text-extent surface s)))
                              (let ((width (get-width extent))
                                    (height (get-height extent)))
                                (let ((h (+ (fxround h) 4))
                                      (v (max (min (fxround (- vert (/ height 2.))) 86) 0)))
                                  ;(fill-rect surface (h/v/width/height->rect h v width height) {Color Black})
                                  (draw-text surface h v s text-color))))))))))))))
        ;; missing
        (let ((missing-scale 5.))
          (define (find-before time id)
            (loop (for n from (last-position evolution) downto (first-position evolution))
                  (when (and (= (evolutionary-udp-id evolution n) id)
                             (< (evolutionary-udp-time evolution n) time))
                    (return n))
                  (finally #f)))
          
          (define (find-after time id)
            (loop (for n from (first-position evolution) to (last-position evolution))
                  (when (and (= (evolutionary-udp-id evolution n) id)
                             (> (evolutionary-udp-time evolution n) time))
                    (return n))
                  (finally #f)))
          
          #f @convert
          (let ((before (find-before now udp-id-missing)))
            (when before
              (let ((actual-after (find-after now udp-id-missing)))
                (let ((after (or actual-after before)))
                  (let ((b (percentage (evolutionary-udp-data1 evolution before) (evolutionary-udp-data2 evolution before)))
                        (a (percentage (evolutionary-udp-data1 evolution after) (evolutionary-udp-data2 evolution after))))
                    (let ((bv (fxround (- 95. (* b missing-scale))))
                          (av (fxround (- 95. (* a missing-scale)))))
                      (let ((vert (if actual-after
                                      (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) bv av)
                                    bv))
                            (missing (if actual-after
                                         (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) b a)
                                       b)))
                        (let ((s (format "{r precision: 1}%" missing)))
                          (let ((extent (get-text-extent surface s)))
                            (let ((width (get-width extent))
                                  (height (get-height extent)))
                              (let ((h (+ (fxround h) 4))
                                    (v (max (min (fxround (- vert (/ height 2.))) 86) 0)))
                                (fill-rect surface (h/v/width/height->rect h v width height) {Color Black})
                                (draw-text surface h v s text-color))))))))))))))))
  
  
  ;;;
  ;;;; Play
  ;;;
  
  
  (method protected (set-playing? self flag)
    (unless (eq? flag playing?)
      (if flag
          (start-playing self)
        (stop-playing self))))
  
  
  (method protected virtual (start-playing self)
    (let ((thread
            (new-thread
              (lambda ()
                (play-loop self))
              'play)))
      (when (not now)
        (set! now from))
      (thread-start! thread)
      (set! visualize? #t)
      (set! play-thread thread)
      (set! playing? #t)))
  
  
  (method protected virtual (stop-playing self)
    ;; quicky to test
    (thread-terminate! play-thread)
    (set! visualize? #f)
    (set! play-thread #f)
    (set! playing? #f)
    (redraw self)
    (now-update self))
  
  
  (method protected virtual (play-loop self)
    )
  
  
  (method protected (step-forward self elapse)
    (increase! now elapse)
    (let ((over (- now visualizer-end)))
      (if (> over 0.)
          (begin
            (set! now (+ visualizer-start over))
            (set-bounds self visualizer-start (+ visualizer-start span)))
        (let ((over (- now to)))
          (when (> over 0.)
            (set-bounds self to (+ to span))))))
    (redraw self)
    (now-update self))
  
  
  (method protected (step-backward self elapse)
    (decrease! now elapse)
    (let ((over (- visualizer-start now)))
      (if (> over 0.)
          (begin
            (set! now (- visualizer-end over))
            (set-bounds self (- visualizer-end span) visualizer-end))
        (let ((over (- from now)))
          (when (> over 0.)
            (set-bounds self (- from span) from)))))
    (redraw self)
    (now-update self))
  
  
  (method protected (play-faster self)
    (set! visualizer-speed (/ visualizer-speed .75))
    @not-sure
    (let ((speed (next-element speed-factors visualizer-speed cycle?: #f)))
      (if (not speed)
          (bell)
        (set! visualizer-speed speed))))
  
  
  (method protected (play-slower self)
    (set! visualizer-speed (* visualizer-speed .75))
    @not-sure
    (let ((speed (previous-element speed-factors visualizer-speed cycle?: #f)))
      (if (not speed)
          (bell)
        (set! visualizer-speed speed)))))


;;;
;;;; Graph
;;;


(class Graph extends Object
  
  
  (method protected virtual (draw-context self surface from to span sampling evolution)
    )
  
  
  (method protected virtual (draw-graph self surface from to span sampling evolution n time id h now-h)
    )))
