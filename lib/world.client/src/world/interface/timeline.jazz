;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Timeline Panel
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.interface.timeline jazz


(import (jazz.component)
        (jazz.event)
        (jazz.graphic)
        (world)
        (world.biome)
        (world.change)
        (world.context)
        (world.evolution)
        (world.geometry)
        (world.history)
        (world.interface.panel)
        (world.profiling)
        (world.settings)
        (world.udp))


(proclaim (warn optimizations))


;;;
;;;; Player
;;;


(definition protected (draw-timeline)
  (let ((world (current-world))
        (interface (current-interface)))
    (let ((view (child interface 'timeline))
          (sheet (get-timeline-sheet world)))
      (unless (get-uptodate? view)
        (let ((texture (get-texture sheet)))
          (let ((surface (get-surface texture))
                (data (get-data texture)))
            (draw-view view surface data)
            (map-texture texture)
            (set-uptodate? view #t))))
      (let ((x (cast <fl> (get-left view)))
            (y (cast <fl> (get-top view)))
            (h (cast <fl> (get-height view))))
        (let ((matrix (make-translation-matrix (vertex x (- (get-height world) y h) 0.))))
          (render-sheet sheet matrix))))))


(definition protected (refresh-timeline)
  (let ((interface (current-interface+))
        (history (current-history)))
    (when interface
      (unless (= (get-count chronology) 0)
        (let ((panel (child interface 'timeline)))
          (when (not (get-evolution panel))
            (set-evolution panel (current-evolution)))
          (when (not (get-history panel))
            (set-history panel (current-history)))
          (when (not (get-chronology panel))
            (set-chronology panel (current-chronology)))
          (when (not (get-from panel))
            (set-uptodate? panel #f)))))))


;;;
;;;; Timeline
;;;


(class Timeline-Panel extends World-Panel
  
  
  (slot scale        <fl>  initialize 0  accessors generate)
  (slot sampling     <fx>  initialize 2  accessors generate)
  (slot from         <fl+> initialize #f accessors generate)
  (slot to           <fl+> initialize #f accessors generate)
  (slot span         <fl>  initialize 5. accessors generate)
  (slot evolution          initialize #f accessors generate)
  (slot history            initialize #f accessors generate)
  (slot chronology         initialize #f accessors generate)
  (slot live?              initialize #t accessors generate)
  (slot uptodate?          initialize #f accessors generate)
  ;; scroll code is a copy/paste from showcase
  (slot point              initialize #f getter generate)
  (slot moved?             initialize #f getter generate)
  (slot scrolled?          initialize #f getter generate)
  (slot last-to            initialize #f getter generate)
  (slot last-seconds       initialize #f getter generate)
  (slot last-speed         initialize #f getter generate)
  (slot pulse              initialize #f getter generate)
  
  
  ;;;
  ;;;; Bounds
  ;;;
  
  
  (method (update-span self)
    (set! span (- to from)))
  
  
  (method (with-bounds self proc)
    (if (not from)
        (let ((head (timeline-head self))
              (tail (timeline-tail self)))
          (let ((from (max head (- tail span)))
                (to tail))
            (proc from to)))
      (proc from to)))
  
  
  (method (timeline-head self)
    (let ((head +inf.0))
      (define (process sec)
        (when (< sec head)
          (set! head sec)))
      
      (when (> (get-count evolution) 0)
        (process (evolutionary-time evolution (first-position evolution))))
      (when (> (get-count history) 0)
        (process (historical-time history (first-position history))))
      (when (> (get-count chronology) 0)
        (process (chronological-time chronology (first-position chronology))))
      head))
  
  
  (method (timeline-tail self)
    (let ((tail -inf.0))
      (define (process sec)
        (when (> sec tail)
          (set! tail sec)))
      
      (when (> (get-count evolution) 0)
        (process (evolutionary-time evolution (last-position evolution))))
      (when (> (get-count history) 0)
        (process (historical-time history (last-position history))))
      (when (> (get-count chronology) 0)
        (process (chronological-time chronology (last-position chronology))))
      tail))
  
  
  (method (live-information self)
    (unless live?
      (set! evolution (current-evolution))
      (set! history (current-history))
      (set! chronology (current-chronology))
      (set! live? #t)))
  
  
  (method (copy-information self)
    (when live?
      (set! evolution (copy-evolution (current-evolution)))
      (set! history (copy-history (current-history)))
      (set! chronology (copy-chronology (current-chronology)))
      (set! live? #f)))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method override (mouse-down self evt)
    (with-bounds self
      (lambda (from~ to~)
        (set! point (get-h evt))
        (set! moved? #f)
        (set! last-to to~)
        (set! last-seconds (current-seconds))
        (set! last-speed #f)
        (kill-autoscroll self))))
  
  
  (method override (drag-move self evt)
    (let ((h (get-h evt)))
      (when (and point (not (near? h point 2)))
        (copy-information self)
        (with-bounds self
          (lambda (from~ to~)
            (let ((delta (* (/ (cast <fl> (- h point)) (cast <fl> (get-width self))) (- span)))
                  (head (timeline-head self))
                  (tail (timeline-tail self)))
              (let ((new-from (+ from~ delta))
                    (new-to (+ to~ delta)))
                (cond ((> new-to tail)
                       (set! to tail)
                       (set! from (- to span)))
                      ((< new-from head)
                       (set! from head)
                       (set! to (+ from span)))
                      (else
                       (set! from new-from)
                       (set! to new-to))))
              (update-span self)
              (set-uptodate? self #f))
            (set! point h)
            (set! moved? #t)
            (let ((new-to to)
                  (new-seconds (current-seconds))
                  (old-to last-to)
                  (old-seconds last-seconds))
              (set! last-to new-to)
              (set! last-seconds new-seconds)
              (unless (= new-seconds old-seconds)
                (let ((new-speed (/ (- new-to old-to) (- new-seconds old-seconds)))
                      (p .9))
                  (set! last-speed (+ (* new-speed (- 1. p)) (* (or last-speed 0.) p)))))))))))

  
  (method override (mouse-up self evt)
    (when (or (not moved?) (< (- (current-seconds) last-seconds) .1))
      (if moved?
          (begin
            (set! scrolled? #f)
            (start-autoscroll self))
        (set! point (get-h evt))
        (set! moved? #f)
        (set! scrolled? #f)
        (set! last-speed #f)
        (kill-autoscroll self))))
  
  
  (method override (double-click self evt)
    (live-information self)
    (set! from #f)
    (set! to #f)
    (set-uptodate? self #f))
  
  
  (method override (mouse-wheel self pos delta)
    (let ((d (get-v delta)))
      (cond ((> d 0)
             (zoom-in self))
            ((< d 0)
             (zoom-out self)))))
  
  
  (method package (zoom-in self)
    (let ((head (timeline-head self))
          (tail (timeline-tail self)))
      (let ((max-span (- tail head)))
        (if (not from)
            (set! span (min max-span (* span .75)))
          (let ((h (get-h (mouse-position self)))
                (width (get-width self)))
            (let ((proportion (/ (cast <fl> h) (cast <fl> width))))
              (let ((when (+ from (* span proportion)))
                    (new-span (min max-span (* span .75))))
                (let ((new-from (- when (* new-span proportion)))
                      (new-to (+ when (* new-span (- 1. proportion)))))
                  (set! from (max head new-from))
                  (set! to (min tail new-to))
                  (update-span self))))))))
    (set-uptodate? self #f))
  
  
  (method package (zoom-out self)
    (let ((head (timeline-head self))
          (tail (timeline-tail self)))
      (let ((max-span (- tail head)))
        (if (not from)
            (set! span (min max-span (/ span .75)))
          (let ((h (get-h (mouse-position self)))
                (width (get-width self)))
            (let ((proportion (/ (cast <fl> h) (cast <fl> width))))
              (let ((when (+ from (* span proportion)))
                    (new-span (min max-span (/ span .75))))
                (let ((new-from (- when (* new-span proportion)))
                      (new-to (+ when (* new-span (- 1. proportion)))))
                  (set! from (max head new-from))
                  (set! to (min tail new-to))
                  (update-span self))))))))
    (set-uptodate? self #f))
  
  
  (method (h->when self span h)
    (let ((width (get-width self)))
      (cond ((< h 0)
             from)
            ((> h width)
             to)
            (else
             (+ from (* span (/ (cast <fl> h) (cast <fl> width))))))))
  
  
  (method (when->h self from to span when)
    (fxround (* (/ (- when from) span) (cast <fl> (get-width self)))))
  
  
  ;;;
  ;;;; Autoscroll
  ;;;
  
  
  (method (start-autoscroll self)
    (set! pulse (new Pulse 'autoscroll 0.01 (~ autoscroll-action self) delay: 0)))
  
  
  (method (kill-autoscroll self)
    (when pulse
      (close pulse)
      (set! pulse #f)))
  
  
  (method (autoscroll-action self)
    (execute-event
      (lambda ()
        (when last-speed
          (let ((actual-to to))
            (let ((scroll-to (+ actual-to (/ last-speed 100.))))
              (let ((new-to scroll-to))
                (when (/= new-to actual-to)
                  (set! scrolled? #t)
                  (let ((new-from (- new-to span)))
                    (let ((head (timeline-head self))
                          (tail (timeline-tail self)))
                      (cond ((> new-to tail)
                             (set! to tail)
                             (set! from (- to span)))
                            ((< new-from head)
                             (set! from head)
                             (set! to (+ from span)))
                            (else
                             (set! from new-from)
                             (set! to new-to)))
                      (update-span self)
                      (set-uptodate? self #f)
                      (when (or (<= new-from head)
                                (>= new-to tail))
                        (set! scrolled? #f)
                        (kill-autoscroll self))))))))))))
  
  
  ;;;
  ;;;; Drawing
  ;;;


  (method package (draw-view self surface <Surface> data)
    (clear surface)
    (fill-rect surface (new Rect 0 0 (get-width self) (get-height self)) {Color red: .000 green: .000 blue: .000 alpha: .350})
    (draw-timeline self surface)
    (frame-rect surface (new Rect 0 0 (get-width self) (get-height self)) {Color Entry-Border}))
  
  
  (method (draw-timeline self surface <Surface>)
    (with-bounds self
      (lambda (from to)
        (plot-time self surface)
        (plot-units self surface from to)
        (plot-evolution self surface from to)
        (plot-history self surface from to)
        (plot-chronology self surface from to))))
  
  
  (method (plot-time self surface <Surface>)
    (let ((width (cast <fl> (get-width self)))
          (height (cast <fl> (get-height self))))
      (let ((v (/ height 2.)))
        (set-color surface {Color Medium-Gray alpha: .7})
        (set-line-width surface 1)
        (move-to surface 0 v)
        (line-to surface width v))))
  
  
  (method (plot-units self surface <Surface> from <fl> to <fl>)
    (let ((width (cast <fl> (get-width self)))
          (height (cast <fl> (get-height self)))
          (span (min (- to from) span)))
      (let ((v (/ height 2.)))
        (set-color surface {Color Medium-Gray alpha: .7})
        (set-line-width surface 1)
        (loop (for s from (fxceiling from) to (fxfloor to))
              (let ((h (when->h self from to span (cast <fl> s))))
                (move-to surface h (- v 3.))
                (line-to surface h (+ v 4.)))))))
  
  
  (method (plot-evolution self surface from to)
    (let ((width (cast <fl> (get-width self)))
          (height (cast <fl> (get-height self)))
          (span (min (- to from) span))
          (dark-purple {Color red: .464 green: .141 blue: .732})
          (rtt-scale (if local? 5000. 250.))
          (previous-rtt-h #f)
          (previous-rtt-v #f))
      (set-color surface {Color Green})
      (set-line-width surface 1)
      (loop (for n from (first-position evolution) to (last-position evolution))
            (let ((time (evolutionary-time evolution n))
                  (id (evolutionary-id evolution n)))
              (when (between? time from to)
                (let ((h (fxround (* (/ (- time from) span) width))))
                  (ecase id
                    ((udp-id-connect)
                     (let ((color {Color Yellow})
                           (v 13))
                       (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color)))
                    ((udp-id-connected)
                     (let ((color {Color Green})
                           (v 13))
                       (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color)))
                    ((udp-id-send-media)
                     (let ((kind (flonum->fixnum (evolutionary-data1 evolution n)))
                           (off? (= (evolutionary-data3 evolution n) 0.)))
                       (let ((color (if off?
                                        {Color Medium-Gray}
                                      (ecase kind
                                        ((udp-audio) {Color Purple})
                                        (else {Color Blue}))))
                             (v 13))
                         (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color))))
                    ((udp-id-receive-ack)
                     (let ((color {Color Green})
                           (v 21))
                       (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color)
                       (let ((rtt (evolutionary-data3 evolution n)))
                         (let ((v (fxround (- 95. (* rtt rtt-scale)))))
                           (fill-rect surface (new Rect (- h 1) (- v 1) (+ h 2) (+ v 2)) color)
                           (when previous-rtt-h
                             (move-to surface previous-rtt-h previous-rtt-v)
                             (line-to surface h v))
                           (set! previous-rtt-h h)
                           (set! previous-rtt-v v)))))
                    ((udp-id-receive-nack)
                     (let ((found (evolutionary-data3 evolution n)))
                       (let ((color (if (= found 1.)
                                        {Color Orange}
                                      {Color Red}))
                             (v 29))
                         (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color))))
                    ((udp-id-discard-resent udp-id-missing-resent)
                     (let ((color (if (= id udp-id-discard-resent)
                                      {Color Purple}
                                    {Color Red}))
                           (v 37))
                       (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color))))))))))
  
  
  (method (plot-history self surface <Surface> from <fl> to <fl>)
    (let ((width (cast <fl> (get-width self)))
          (height (cast <fl> (get-height self)))
          (first (history-first history))
          (last (history-last history))
          (now (get-now history))
          (changes (get-changes history))
          (span (min (- to from) span))
          (v (- (get-height self) 87)))
      (define (plot-change n)
        (let ((time (historical-time history n)))
          (when (between? time from to)
            (let ((change (id->change (historical-change-id history n))))
              (let ((h (fxround (* (/ (- time from) span) width)))
                    (color (case (get-name change)
                             ((move) {Color Purple})
                             ((lookat) {Color Blue})
                             ((animate) {Color Blue})
                             ((edit-script update-script) {Color Ochre})
                             ((fire) {Color Green})
                             ((spawn) {Color Green})
                             ((die) {Color Red})
                             ((add-block delete-block add-entity remove-entity) {Color Green})
                             ((action interact) {Color Green})
                             (else {Color Light-Gray}))))
                (if (= n now)
                    (fill-rect surface (new Rect (- h 2) (- v 5) (+ h 3) (+ v 6)) color)
                  (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color)))))))
      
      (loop (for n from first to last)
            (unless (= n now)
              (plot-change n)))
      (plot-change now)))
  
  
  (method (plot-chronology self surface <Surface> from <fl> to <fl>)
    (define (plot-site name color bar-rank <fl>)
      (set-color surface color)
      (set-line-width surface 1)
      (let ((width (cast <fl> (get-width self)))
            (height (cast <fl> (get-height self)))
            (bar-height (* bar-rank 7.5))
            (span (min (- to from) span))
            (site (find-site name)))
        (when site
          (let ((id (cast <fl> (cast <fx> (get-id site))))
                (start #f))
            (loop (for n from (first-position chronology) to (last-position chronology))
                  (when (= (chronological-id chronology n) id)
                    (let ((marker (chronological-marker chronology n)))
                      (if (even? (flonum->fixnum marker))
                          (set! start (chronological-time chronology n))
                        (when start
                          (let ((end (chronological-time chronology n)))
                            (let ((f (* (/ (- start from) span) width))
                                  (t (* (/ (- end from) span) width))
                                  (bottom height)
                                  (top (- height bar-height)))
                              (when (or (between? f 0. width)
                                        (between? t 0. width)
                                        (and (< f 0.)
                                             (> t width)))
                                (let ((left (fxfloor f))
                                      (top (fxfloor top))
                                      (right (fxceiling t))
                                      (bottom (fxceiling bottom)))
                                  (fill-rect surface (new Rect left top right bottom) color))))))))))))))
    
    (let ((dark-purple {Color red: .464 green: .141 blue: .732})
          (purple {Color Purple})
          (cyan {Color red: .120 green: .624 blue: .616}))
      (plot-site 'memory {Color Red} 10)
      (plot-site 'register-literal {Color Yellow} 10)
      (plot-site 'registered-id {Color Green} 10)
      (plot-site 'retrieve-region dark-purple 10)
      (plot-site 'retrieve-chunk purple 10)
      (plot-site 'retrieve-entity {Color Blue} 10)
      (plot-site 'client-update cyan 10)
      (plot-site 'processor-update cyan 10)
      (plot-site 'udp-release {Color Ochre} 10)
      (plot-site 'udp-receive {Color Ochre} 10)
      (plot-site 'udp-process {Color Ochre} 10)
      (plot-site 'network {Color Orange} 9)
      (plot-site 'render {Color Blue} 8)
      (plot-site 'event {Color Yellow} 7)
      (plot-site 'message {Color Yellow} 7)
      (plot-site 'player {Color Green} 6)
      (plot-site 'physical {Color Blue} 5)
      (plot-site 'visual dark-purple 4)
      (plot-site 'generate purple 3)
      ;; quicky for others
      (for-each (lambda (name)
                  (plot-site name {Color Ochre} 2))
                '(;alive animate audio creature distance eat event
                  ;gravity instantiate lava memory missile music
                  ;redstone simulation spawn sun tick water
                  ))))))
