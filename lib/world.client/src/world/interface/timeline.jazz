;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Timeline Panel
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.interface.timeline jazz


(import (jazz.cairo)
        (jazz.component)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.platform)
        (jazz.screen)
        (jazz.time)
        (world)
        (world.biome)
        (world.change)
        (world.chronology)
        (world.context)
        (world.event)
        (world.evolution)
        (world.geometry)
        (world.history)
        (world.interface.panel)
        (world.interface.profiler)
        (world.math)
        (world.profiling)
        (world.render)
        (world.settings)
        (world.task)
        (world.udp))


(definition protected chronology-red     {Color red: .995 green: .185 blue: .197})
(definition protected chronology-orange  {Color red: .995 green: .699 blue: .292})
(definition protected chronology-yellow  {Color red: .995 green: .946 blue: .005})
(definition protected chronology-green   {Color red: .125 green: .995 blue: .129})
(definition protected chronology-cyan    {Color red: .112 green: .856 blue: .845})
(definition protected chronology-blue    {Color red: .216 green: .274 blue: .953})
(definition protected chronology-purple  {Color red: .478 green: .333 blue: .995})
(definition protected chronology-magenta {Color red: .871 green: .373 blue: .918})
(definition protected chronology-gray    {Color Dark-Gray})


(definition protected timeline-text-color
  (world-setting 'world.timeline-text {Color Dark-Gray}))

(definition protected timeline-knees?
  (world-setting 'world.timeline-knees? #f))


(definition protected visualizer-quantum
  (world-setting 'world.visualizer-quantum .01))


(definition protected visualizer-speed
  (world-setting 'world.visualizer-speed 1.))

(definition speed-factors
  '(.25 .33 .5 .67 .75 .8 .9 1. 1.1 1.25 1.5 1.75 2. 2.5 3. 4. 5.))


(definition log-colors
  (vector {Color White}
          {Color Red}
          {Color Orange}
          {Color Yellow}
          {Color Green}
          {Color Cyan}))


(definition protected all-chronology?
  #f)

(definition protected (set-all-chronology? flag)
  (set! all-chronology? flag))


(definition protected graph-latency?
  #t)

(definition protected (set-graph-latency? flag)
  (set! graph-latency? flag))


(definition protected (estimate-variance evolution)
  ;; accurate variance is obtained when the round trip is symetrical
  ;; for now we guess that the most symetrical round trip is the smallest one
  (let ((most-accurate-variance #f)
        (smallest-round-trip #f))
    (loop (for n from (first-position evolution) to (last-position evolution))
          (let ((id (evolutionary-udp-id evolution n)))
            (when (= id udp-id-receive-ack)
              (let ((round-trip (evolutionary-udp-receive-ack-round-trip evolution n)))
                (when (or (not smallest-round-trip)
                          (< round-trip smallest-round-trip))
                  (let ((ack-sent (evolutionary-udp-receive-ack-ack-sent evolution n))
                        (ack-received (evolutionary-udp-time evolution n)))
                    (let ((variance (- ack-received ack-sent (/ round-trip 2))))
                      (set! most-accurate-variance variance)
                      (set! smallest-round-trip round-trip))))))))
    (values most-accurate-variance smallest-round-trip)))


;;;
;;;; Evolution
;;;


(definition protected (layout-evolution)
  (let ((window (current-window))
        (world (current-world)))
    (let ((world-width (get-width window))
          (world-height (get-height window))
          (sheet (get-evolution-sheet world)))
      (let ((h (center (get-width sheet) world-width))
            (v 10))
        (set-position sheet (new Point h v))))))


(definition protected (draw-evolution)
  (let ((world (current-world))
        (interface (current-interface)))
    (let ((view (child interface 'evolution))
          (sheet (get-evolution-sheet world)))
      (unless (get-uptodate? view)
        (let ((texture (get-texture sheet)))
          (let ((surface (get-surface texture))
                (data (get-data texture)))
            (draw-view-data view surface data)
            (flush surface)
            (map-texture texture)
            (set-uptodate? view #t))))
      (render-sheet sheet))))


(definition protected (refresh-evolution)
  (let ((interface (current-interface+)))
    (when interface
      (let ((panel (child interface 'evolution)))
        (when (not (get-sites panel))
          (setup-sites panel (sites-metadata)))
        (when (not (get-chronology panel))
          (set-chronology panel (current-chronology)))
        (when (not (get-evolution panel))
          (set-evolution panel (current-evolution)))
        (when (not (get-from panel))
          (set-uptodate? panel #f))))))


;;;
;;;; History
;;;


(definition protected (layout-history)
  (let ((window (current-window))
        (world (current-world)))
    (let ((world-width (get-width window))
          (world-height (get-height window))
          (sheet (get-history-sheet world)))
      (let ((h (center (get-width sheet) world-width))
            (v 10))
        (set-position sheet (new Point h v))))))


(definition protected (draw-history)
  (let ((world (current-world))
        (interface (current-interface)))
    (let ((view (child interface 'history))
          (sheet (get-history-sheet world)))
      (unless (get-uptodate? view)
        (let ((texture (get-texture sheet)))
          (let ((surface (get-surface texture))
                (data (get-data texture)))
            (draw-view-data view surface data)
            (flush surface)
            (map-texture texture)
            (set-uptodate? view #t))))
      (render-sheet sheet))))


(definition protected (refresh-history)
  (let ((interface (current-interface+)))
    (when interface
      (let ((panel (child interface 'history)))
        (when (not (get-sites panel))
          (setup-sites panel (sites-metadata)))
        (when (not (get-chronology panel))
          (set-chronology panel (current-chronology)))
        (when (not (get-history panel))
          (set-history panel (current-history)))
        (when (not (get-from panel))
          (set-uptodate? panel #f))))))


;;;
;;;; Sites
;;;


(proclaim (not check bounds)
          (warn optimizations))


(class Site-Look extends Object
  
  
  (slot identifier         getter generate)
  (slot default?   <bool>  getter generate)
  (slot rank       <fx>    getter generate)
  (slot color      <Color> getter generate)
  
  
  (method override (initialize self identifier default? rank color)
    (nextmethod self)
    (set! self.identifier identifier)
    (set! self.default? default?)
    (set! self.rank rank)
    (set! self.color color))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" identifier)))))


(definition protected site-looks <table>
  (make-table test: eq?))

(definition protected default-site-rank <fx+>
  #f)

(definition protected default-site-color <Color+>
  #f)

(definition public (default-site-look rank color)
  (set! default-site-rank rank)
  (set! default-site-color color))

(definition public (register-site-look identifier rank color) <void>
  (let ((look (new Site-Look identifier #f rank color)))
    (table-set! site-looks identifier look)))

(definition public (registered-site-look identifier) <Site-Look+>
  (table-ref site-looks identifier #f))


(proclaim (default check types))


;;;
;;;; Events
;;;


(proclaim (not check bounds zero)
          (warn optimizations))


(class Event-Look extends Object
  
  
  (slot rank  <fx+>    getter generate)
  (slot color <Color+> getter generate)
  
  
  (method override (initialize self rank color)
    (nextmethod self)
    (set! self.rank rank)
    (set! self.color color)))


(definition protected event-looks <table>
  (make-table test: eq?))

(definition protected default-event-look <Event-Look+>
  #f)

(definition public (register-event-look id rank color) <void>
  (let ((look (new Event-Look rank color)))
    (if id
        (table-set! event-looks (flonum->fixnum id) look)
      (set! default-event-look look))))

(definition public (registered-event-look id) <Event-Look+>
  (table-ref event-looks id #f))


(proclaim (not check types))


(definition protected id-event-looks <vector>
  (make-vector 2048 #t))

(definition protected (id->event-look id <fx>) <Event-Look+>
  (let ((value (vector-ref id-event-looks id)))
    (if (eq? value #t)
        (let ((look (registered-event-look id)))
          (vector-set! id-event-looks id look)
          look)
      value)))


(proclaim (default check types))


(definition protected (reset-event-looks)
  (set! event-looks (make-table test: eq?))
  (set! default-event-look #f)
  (set! id-event-looks (make-vector 2048 #t)))


;;;
;;;; Timeline
;;;


(class Timeline-Panel extends World-Panel
  
  
  (slot tier                          initialize #f  accessors generate)
  (slot origin                        initialize #f  accessors generate)
  (slot scale            <fl>         initialize 0   accessors generate)
  (slot sampling         <fx>         initialize 2   accessors generate)
  (slot start            <fl+>        initialize #f  accessors generate)
  (slot end              <fl+>        initialize #f  accessors generate)
  (slot from             <fl+>        initialize #f  accessors generate)
  (slot to               <fl+>        initialize #f  accessors generate)
  (slot span             <fl>         initialize 5.  accessors generate)
  (slot now              <fl+>        initialize #f  accessors generate)

  (slot drawn-from       <fl+>        initialize #f  accessors generate)
  (slot drawn-to         <fl+>        initialize #f  accessors generate)
  (slot frozen-start     <fl+>        initialize #f  getter generate)
  (slot frozen-end       <fl+>        initialize #f  getter generate)
  (slot sites                         initialize #f  getter generate)
  (slot sites-count                   initialize #f  getter generate)
  (slot id-site-looks    <vector>     initialize #f  getter generate)
  (slot base-time        <fl>         initialize 0.  accessors generate)
  (slot chronology       <Chronology> initialize #f  accessors generate)
  (slot history          <History+>   initialize #f  accessors generate)
  (slot evolution        <Evolution+> initialize #f  accessors generate)
  (slot evolution-range               initialize #f  accessors generate)
  (slot evolution-left   <fl+>        initialize #f  accessors generate)
  (slot evolution-right  <fl+>        initialize #f  accessors generate)
  (slot lowest-latency   <fl+>        initialize #f  accessors generate)
  (slot cpu%             <fl+>        initialize #f  accessors generate)
  (slot live?                         initialize #t  accessors generate)
  (slot replay?                       initialize #f  accessors generate)
  (slot uptodate?                     initialize #f  accessors generate)
  (slot image-surface                 initialize #f  accessors generate)
  (slot image-valid?                  initialize #f  accessors generate)
  (slot visualizer-start <fl+>        initialize #f  accessors generate)
  (slot visualizer-end   <fl+>        initialize #f  accessors generate)
  (slot visualize?                    initialize #f  getter generate)
  (slot variance         <fl+>        initialize #f  getter generate)
  (slot variance-rtt     <fl+>        initialize #f  getter generate)
  ;; scroll code is a copy/paste from showcase
  (slot point                         initialize #f  getter generate)
  (slot moved?                        initialize #f  getter generate)
  (slot scrolled?                     initialize #f  getter generate)
  (slot last-to                       initialize #f  getter generate)
  (slot last-seconds                  initialize #f  getter generate)
  (slot last-speed                    initialize #f  getter generate)
  (slot pulse                         initialize #f  getter generate)
  (slot boxes                         initialize #f  getter generate)
  (slot labels                        initialize #f  getter generate)
  (slot playing?                      initialize #f  getter generate)
  (slot play-thread                   initialize #f  getter generate)
  (slot full-mode?                    initialize #f  accessors generate)
  (slot events-mode                   initialize #f  accessors generate)
  (slot discards                      initialize #f  getter generate)
  (slot missings                      initialize #f  getter generate)
  (slot highlighted                   initialize #f  getter generate)
  (slot elapses                       initialize #f  getter generate)
  (slot graphs                        initialize '() getter generate)
  (slot graph-button                  initialize #f  getter generate)
  (slot graph-scale                   initialize 1.  getter generate)
  (slot rtt-scale                     initialize #f  getter generate)
  (slot latency-scale                 initialize #f  getter generate)
  (slot traffic-scale                 initialize #f  getter generate)
  (slot missing-scale                 initialize #f  getter generate)
  (slot lite?                         initialize #f  accessors generate)
  (slot show-knees?                   initialize timeline-knees? accessors generate)
  (slot border-color                  initialize {Color Entry-Border} accessors generate)
  
  
  (method override (prepare self rest)
    (nextmethod self rest)
    (set! rtt-scale (* 41. graph-scale))
    (set! latency-scale (* 32. graph-scale))
    (set! traffic-scale (* .045 graph-scale))
    (set! missing-scale (* 5. graph-scale)))
  
  
  ;;;
  ;;;; Image
  ;;;
  
  
  (method override (size-change self size)
    (nextmethod self size)
    (when image-surface
      (close image-surface)
      (set! image-surface #f)))
  
  
  (method (cache-image-surface self)
    (or image-surface
        (let ((scale-factor (main-screen-scale-factor)))
          (define (new-image-surface width height)
            (let ((surface (new Image-Surface (new Dimension width height)))
                  (scale (cast <fl> scale-factor)))
              (cairo_surface_set_device_scale (get-handle surface) scale scale)
              surface))
          
          (let ((width (* scale-factor (get-width self)))
                (height (* scale-factor (get-height self))))
            (let ((surface (new-image-surface width height)))
              (set! image-surface surface)
              (set! image-valid? #f)
              surface)))))
  
  
  (method protected (invalidate-image self)
    (set! image-valid? #f))
  
  
  (method protected (set-graph-scale self scale)
    (set! graph-scale scale)
    (invalidate-image self)
    (invalidate-view self))
  
  
  ;;;
  ;;;; Bounds
  ;;;
  
  
  (method protected (update-span self)
    (set! span (- to from)))
  
  
  (method protected (set-bounds self f t)
    (assert (<= f t)
      (set! from f)
      (set! to t)))
  
  
  (method (with-bounds self proc)
    (if (not from)
        (let ((start (timeline-start self))
              (end (timeline-end self)))
          (let ((from (max start (- end span)))
                (to end))
            (proc from to)))
      (proc from to)))
  
  
  (method package (set-elapses self elap)
    (unless (equal? elap elapses)
      (set! elapses elap)
      (invalidate-view self)))
  
  
  (method package (freeze-time self)
    (set! frozen-start (timeline-start self))
    (set! frozen-end (timeline-end self)))
  
  
  (method package (thaw-time self)
    (set! frozen-start #f)
    (set! frozen-end #f))
  
  
  (method package (time-frozen? self)
    (boolean frozen-start))
  
  
  (method package (toggle-frozen self)
    (if (time-frozen? self)
        (thaw-time self)
      (freeze-time self)))
  
  
  (method protected virtual (timeline-start self) <fl>
    (or frozen-start
        (if live?
            (chronological-time chronology (first-position chronology))
          (or start
              (let ((start (if (empty? chronology)
                               (if evolution
                                   (evolutionary-time evolution (first-position evolution))
                                 (historical-time history (first-position history)))
                             (chronological-time chronology (first-position chronology)))))
                (set! self.start start)
                start)))))
  
  
  (method protected virtual (timeline-end self) <fl>
    (or frozen-end
        (if live?
            (chronological-time chronology (last-position chronology))
          (or end
              (let ((end (if (empty? chronology)
                             (if evolution
                                 (evolutionary-time evolution (last-position evolution))
                               (historical-time history (last-position history)))
                           (chronological-time chronology (last-position chronology)))))
                (set! self.end end)
                end)))))
  
  
  (method protected (reset-start/end self)
    (set! start #f)
    (set! end #f))
  
  
  (proclaim (not check types))
  
  
  (method protected (setup-sites self alist)
    (set! sites (list->table alist))
    (set! sites-count (table-length sites))
    (set! id-site-looks (make-vector 256 #f)))
  
  
  (method (id->site-look self id <fx>) <Site-Look>
    (or (vector-ref id-site-looks id)
        (let ((identifier (table-ref sites id)))
          (let ((look (or (and identifier (registered-site-look identifier))
                          (new Site-Look identifier #t default-site-rank default-site-color))))
            (vector-set! id-site-looks id look)
            look))))
  
  
  (proclaim (default check types))

  
  (method package (setup-live-information self)
    (unless live?
      (set! live? #t)
      (set! from #f)
      (set! to #f)
      (set! lowest-latency #f)
      (setup-sites self (sites-metadata))
      (live-information self)
      (set! cpu% #f)))
  
  
  (method package (setup-copy-information self)
    (when live?
      (set! live? #f)
      (setup-sites self (sites-metadata))
      (copy-information self)
      (set! cpu% (chronology-cpu% chronology sites-count))))
  
  
  (method protected virtual (live-information self)
    (set! history (current-history))
    (set! chronology (current-chronology))
    (set! evolution (current-evolution)))
  
  
  (method protected virtual (copy-information self)
    (set! history (copy-history (current-history)))
    (set! chronology (copy-chronology (current-chronology)))
    (set! evolution (copy-evolution (current-evolution))))
  
  
  ;; to redo?
  (method (update self time)
    )
  
  
  (method protected (setup-replay self base-time)
    (let ((start (timeline-start self))
          (end (timeline-end self)))
      (set-now self #f)
      (set-bounds self start end)
      (set-base-time self base-time)
      (update-span self)
      (set-replay? self #t)
      (set-live? self #f)
      (set! lowest-latency #f)
      (set! cpu% (chronology-cpu% chronology sites-count))
      (receive (var rtt) (estimate-variance evolution)
        (set! variance var)
        (set! variance-rtt rtt))
      (redraw self)))
  
  
  (method (rtt->v self rtt)
    ;; quick fix until I figure why rtt is sometimes -1.
    (let ((effective-rtt (if (= rtt -1.) 0. rtt)))
      (- 100. (* (sqrt effective-rtt) rtt-scale))))
  
  
  (method (latency->v self latency)
    ;; quick fix until guaranteed positive
    (let ((effective-latency (abs (- latency lowest-latency))))
      (- 85. (* (sqrt effective-latency) latency-scale))))
  
  
  (method (traffic->v self traffic)
    ;; quick fix until traffic makes sense
    (let ((traffic (abs traffic)))
      (- 80. (* (sqrt traffic) traffic-scale))))
  
  
  (method (missing->v self percent-missing)
    (- 100. (* percent-missing missing-scale)))
  
  
  (method protected virtual (view-update self)
    )
  
  
  (method protected virtual (now-update self)
    )


  (proclaim (not warn optimizations))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method override (mouse-down self evt)
    @not-sure
    (setup-copy-information self)
    (with-bounds self
      (lambda (from~ to~)
        (if (and (not live?) (let ((mid (fxround/ (get-height self) 2)))
                               (between? (get-v evt) (- mid 10) (+ mid 10))))
            (begin
              (set! visualize? #t)
              (set! now (h->when self from to (get-h evt)))
              (redraw self)
              (now-update self))
          (set! visualize? #f)
          (set! point (get-h evt))
          (set! moved? #f)
          (set! last-to to~)
          (set! last-seconds (current-seconds))
          (set! last-speed #f)
          (kill-autoscroll self)))))
  
  
  (method override (drag-move self evt)
    (let ((h (get-h evt)))
      (if visualize?
          (begin
            (set! now (h->when self from to (get-h evt)))
            (redraw self)
            (now-update self))
        (when (and point (not (near? h point 2)))
          (with-bounds self
            (lambda (from~ to~)
              (let ((delta (* (/ (cast <fl> (- h point)) (cast <fl> (get-width self))) (- span)))
                    (start (timeline-start self))
                    (end (timeline-end self)))
                (let ((new-from (+ from~ delta))
                      (new-to (+ to~ delta)))
                  (cond ((> new-to end)
                         (set-bounds self (- end span) end))
                        ((< new-from start)
                         (set-bounds self start (+ start span)))
                        (else
                         (set-bounds self new-from new-to))))
                (update-span self)
                (redraw self))
              (set! point h)
              (set! moved? #t)
              (let ((new-to to)
                    (new-seconds (current-seconds))
                    (old-to last-to)
                    (old-seconds last-seconds))
                (set! last-to new-to)
                (set! last-seconds new-seconds)
                (unless (= new-seconds old-seconds)
                  (let ((new-speed (/ (- new-to old-to) (- new-seconds old-seconds)))
                        (p .9))
                    (set! last-speed (+ (* new-speed (- 1. p)) (* (or last-speed 0.) p))))))))))))

  
  (method override (mouse-up self evt)
    (if visualize?
        (begin
          (set! visualize? #f)
          (set! now (h->when self from to (get-h evt)))
          (redraw self)
          (now-update self))
      (if (or (not moved?) (< (- (current-seconds) last-seconds) .1))
          (if moved?
              (begin
                (set! scrolled? #f)
                (start-autoscroll self))
            (with-bounds self
              (lambda (from to)
                (set! point (get-h evt))
                (set! moved? #f)
                (set! scrolled? #f)
                (set! last-speed #f)
                (set! now (h->when self from to point))
                (redraw self)
                (now-update self)
                (kill-autoscroll self))))
        (view-update self))))
  
  
  (method override (right-mouse-up self evt)
    (if (not live?)
        (zoom-reset self)
      (setup-live-information self)
      (set! from #f)
      (set! to #f)
      (set! span 5.)
      (redraw self)
      (view-update self)))
  
  
  (method override (mouse-wheel self pos delta)
    (let ((d (get-v delta)))
      (if (alt-down?)
          (cond ((> d 0)
                 (scale-up self))
                ((< d 0)
                 (scale-down self)))
        (cond ((> d 0)
               (zoom-in self))
              ((< d 0)
               (zoom-out self))))))
  
  
  (method package (zoom-in self)
    (let ((start (timeline-start self))
          (end (timeline-end self)))
      (let ((max-span (- end start)))
        (if (not from)
            (set! span (min max-span (* span .75)))
          (let ((h (get-h (mouse-position self)))
                (width (get-width self)))
            (let ((proportion (/ (cast <fl> h) (cast <fl> width))))
              (let ((when (+ from (* span proportion)))
                    (new-span (min max-span (* span .75))))
                (let ((new-from (- when (* new-span proportion)))
                      (new-to (+ when (* new-span (- 1. proportion)))))
                  (set-bounds self (max start new-from) (min end new-to))
                  (update-span self))))))))
    (redraw self)
    (view-update self))
  
  
  (method package (zoom-out self)
    (let ((start (timeline-start self))
          (end (timeline-end self)))
      (let ((max-span (- end start)))
        (if (not from)
            (set! span (min max-span (/ span .75)))
          (let ((h (get-h (mouse-position self)))
                (width (get-width self)))
            (let ((proportion (/ (cast <fl> h) (cast <fl> width))))
              (let ((when (+ from (* span proportion)))
                    (new-span (min max-span (/ span .75))))
                (let ((new-from (- when (* new-span proportion)))
                      (new-to (+ when (* new-span (- 1. proportion)))))
                  (set-bounds self (max start new-from) (min end new-to))
                  (update-span self))))))))
    (redraw self)
    (view-update self))
  
  
  (method package (zoom-reset self)
    (set-bounds self (timeline-start self) (timeline-end self))
    (update-span self)
    (redraw self)
    (view-update self))
  
  
  (method (scale-up self)
    (set-graph-scale self (/ graph-scale .75)))
  
  
  (method (scale-down self)
    (set-graph-scale self (* graph-scale .75)))


  (proclaim (warn optimizations))
  
  
  (method protected (h->when self from to h)
    (let ((width (get-width self)))
      (cond ((< h 0)
             from)
            ((> h width)
             to)
            (else
             (+ from (* span (/ (cast <fl> h) (cast <fl> width))))))))
  
  
  (method protected (when->h self from to span when)
    (fxround (* (/ (- when from) span) (cast <fl> (get-width self)))))


  (proclaim (not warn optimizations))
  
  
  ;;;
  ;;;; Autoscroll
  ;;;
  
  
  (method (start-autoscroll self)
    (set! pulse (new Pulse 'autoscroll 0.01 (~ autoscroll-action self) delay: 0)))
  
  
  (method (kill-autoscroll self)
    (when pulse
      (close pulse)
      (set! pulse #f)))
  
  
  (method (autoscroll-action self)
    (when (and last-speed (not live?))
      (let ((actual-to to))
        (let ((scroll-to (+ actual-to (/ last-speed 100.))))
          (let ((new-to scroll-to))
            (when (/= new-to actual-to)
              (set! scrolled? #t)
              (let ((new-from (- new-to span)))
                (let ((start (timeline-start self))
                      (end (timeline-end self)))
                  (cond ((> new-to end)
                         (set-bounds self (- end span) end))
                        ((< new-from start)
                         (set-bounds self start (+ start span)))
                        (else
                         (set-bounds self new-from new-to)))
                  (update-span self)
                  (redraw self)
                  (when (or (<= new-from start)
                            (>= new-to end))
                    (set! scrolled? #f)
                    (kill-autoscroll self)
                    (view-update self))))))))))
  
  
  ;;;
  ;;;; Graph
  ;;;
  
  
  (method public (register-graphs self graphs)
    (set! self.graphs graphs)
    (invalidate-view self))
  
  
  ;;;
  ;;;; Draw
  ;;;


  (proclaim (warn optimizations))
  
  
  (method package (redraw self)
    (unless visualize?
      (set! image-valid? #f))
    (if replay?
        (invalidate-view self)
      (set-uptodate? self #f)))
  
  
  (method override (draw self surface context)
    ;; quick solution
    (let ((interface (current-interface)))
      (unless (or (eq? self (child interface 'evolution))
                  (eq? self (child interface 'history)))
        ;; quick hack
        (when (and chronology evolution)
          (with-bounds self
            (lambda (from to)
              (set! drawn-from from)
              (set! drawn-to to)
              (let ((image-surface (cache-image-surface self)))
                (when (not image-valid?)
                  (draw-view self image-surface from to #f)
                  (set! image-valid? #t))
                (blit-surface surface image-surface)
                (plot-now self surface from to))))))))
  
  
  (method package (draw-view-data self surface <Surface> data)
    (with-bounds self
      (lambda (from to)
        (set! drawn-from from)
        (set! drawn-to to)
        (draw-view self surface from to data)
        (plot-now self surface from to))))


  (method package (draw-view self surface <Surface> from <fl> to <fl> data)
    (clear surface)
    (fill-rect surface (new Rect 0 0 (get-width self) (get-height self)) {Color red: .000 green: .000 blue: .000 alpha: .450})
    (draw-timeline self surface)
    (when border-color
      (frame-rect surface (new Rect 0 0 (get-width self) (get-height self)) border-color)))
  
  
  (method (draw-timeline self surface <Surface>)
    (when chronology
      (let ((timer (new Timer))
            (cpu-duration #f)
            (history-duration #f)
            (chronology-duration #f)
            (evolution-duration #f)
            (highlight-duration #f)
            (nowinfo-duration #f))
        (when (and live? (not lite?))
          (let ((timer (new Timer)))
            (set! cpu% (chronology-cpu% chronology sites-count))
            (set! cpu-duration (real-duration timer))))
        (with-bounds self
          (lambda (from to)
            (set! boxes '())
            (set! labels '())
            (set! discards '())
            (set! missings '())
            (set! highlighted '())
            ;; time
            (plot-time self surface from to)
            ;; history
            (let ((timer (new Timer)))
              (when (and history (plot-history? self))
                (plot-history self surface from to))
              (set! history-duration (real-duration timer)))
            (unless lite?
              (if events-mode
                  ;; events
                  (let ((timer (new Timer)))
                    (unless full-mode?
                      (plot-events self surface from to))
                    (set! chronology-duration (real-duration timer)))
                ;; chronology
                (let ((timer (new Timer)))
                  (when (plot-chronology? self)
                    (unless full-mode?
                      (with-mutex chronology
                        (lambda ()
                          (plot-chronology self surface from to)))))
                  (set! chronology-duration (real-duration timer)))))
            ;; evolution
            (let ((timer (new Timer)))
              (when evolution
                (plot-evolution self surface from to))
              (set! evolution-duration (real-duration timer)))
            ;; highlight
            (let ((timer (new Timer)))
              (plot-highlight self surface from to)
              (set! highlight-duration (real-duration timer)))
            ;; nowinfo
            (let ((timer (new Timer)))
              (plot-nowinfo self surface from to)
              (set! nowinfo-duration (real-duration timer)))
            ;; info
            (plot-info self surface cpu-duration history-duration chronology-duration evolution-duration highlight-duration nowinfo-duration (real-duration timer)))))))
  
  
  (method (plot-info self surface <Surface> cpu-duration history-duration chronology-duration evolution-duration highlight-duration nowinfo-duration duration)
    (set-font surface {Font Label})
    (when tier
      (let ((title tier))
        (draw-text surface 5 3 title timeline-text-color)))
    (when cpu%
      (let ((title (format "CPU: {r precision: 1}%" cpu%)))
        (draw-text surface (if tier 80 5) 3 title timeline-text-color)))
    (when evolution-range
      (let ((title (format "Shown: {a}" evolution-range)))
        (draw-text surface (if cpu% 165 80) 3 title timeline-text-color)))
    (when variance
      (let ((title (format "Variance: {r precision: 3} ({r precision: 3}) " variance variance-rtt)))
        (draw-text surface (if cpu% 305 220) 3 title timeline-text-color)))
    (when elapses
      (let ((title (format "Elapses: {l detail: :human}" elapses)))
        (draw-text surface 5 40 title timeline-text-color)))
    (when title
      (let ((title (format "{a} ({a})" title (present-seconds duration))))
        (let ((width (get-width self))
              (extent (get-text-extent surface title)))
          (let ((h (- width (get-width extent) 5)))
            (draw-text surface (- width (get-width extent) 5) 3 title timeline-text-color)
            (let ((title (format "graph")))
              (let ((h (- h 60)))
                (draw-text surface h 3 title timeline-text-color)
                (set! graph-button h)))))))
    (when (world-setting 'world.timeline-durations? #f)
      (let ((first? #t)
            (v (if title 17 3)))
        (define (present name duration)
          (if (not duration)
              ""
            (let ((str (format "{a} {a}" name (present-seconds duration))))
              (prog1 (if first?
                         str
                       (string-append ", " str))
                (set! first? #f)))))
        
        (let ((title (string-append
                       (present "cpu" cpu-duration)
                       (present "chrono" chronology-duration)
                       (present "evo" evolution-duration)
                       (present "highlight" highlight-duration)
                       (present "now" nowinfo-duration))))
          (let ((width (get-width self))
                (extent (get-text-extent surface title)))
            (draw-text surface (- width (get-width extent) 5) v title timeline-text-color))))))
  
  
  (method (plot-time self surface <Surface> from <fl> to <fl>)
    (let ((width (cast <fl> (get-width self)))
          (height (cast <fl> (get-height self))))
      (let ((v 110. @w (/ height 2.)))
        ;; time
        (set-color surface {Color Medium-Gray alpha: .7})
        (set-line-width surface 1)
        (move-to surface 0 v)
        (line-to surface width v)
        ;; units
        (let ((from (- from base-time))
              (to (- to base-time)))
          (let ((span (min (- to from) span)))
            (set-color surface {Color Medium-Gray alpha: .7})
            (set-line-width surface 1)
            (loop (for s from (fxceiling from) to (fxfloor to))
                  (let ((h (when->h self from to span (cast <fl> s))))
                    (move-to surface h (- v 3.))
                    (line-to surface h (+ v 4.))))))
        ;; log
        (when evolution
          (set-line-width surface 1)
          (loop (for n from (first-position evolution) to (last-position evolution))
                (when (= (evolutionary-udp-id evolution n) udp-id-log)
                  (let ((time (evolutionary-udp-time evolution n))
                        (level (evolutionary-udp-data2 evolution n)))
                    (let ((h (when->h self from to span time)))
                      (plot-log-entry self surface h (flonum->fixnum level)))))))
        ;; bookmarks
        (when evolution
          (set-color surface {Color White})
          (set-line-width surface 1)
          (loop (for n from (first-position evolution) to (last-position evolution))
                (when (= (evolutionary-udp-id evolution n) udp-id-bookmark)
                  (let ((time (evolutionary-udp-time evolution n)))
                    (let ((h (when->h self from to span time)))
                      (move-to surface (- h 3) (- v 3.))
                      (line-to surface (+ h 4) (+ v 4.))
                      (move-to surface (+ h 4) (- v 3.))
                      (line-to surface (- h 3) (+ v 4.)))))))
        ;; keyframes
        ;; not that important to see now that we do not hard reset
        @w
        (unless live?
          (set-color surface {Color Purple alpha: .85})
          (set-line-width surface 1)
          (loop (for n from (first-position evolution) to (last-position evolution))
                (when (= (flonum->fixnum (evolutionary-udp-kind evolution n)) udp-video)
                  (let ((id (evolutionary-udp-id evolution n)))
                    (when (or (= id udp-id-play-frame)
                              (= id udp-id-freeze-frame))
                      (when (= (evolutionary-udp-data3 evolution n) 123456.)
                        (let ((time (evolutionary-udp-time evolution n)))
                          (let ((h (cast <fl> (when->h self from to span time)))
                                (color {Color Purple}))
                            (ellipse$fl$ surface (new Rect$fl$ (- h 1.) (- v 1.) (+ h 2.) (+ v 2.)) color color))))))))))))
  
  
  (method (plot-log-entry self surface h level)
    (let ((v 110.)
          (color (vector-ref log-colors level)))
      (set-line-width surface 1)
      (set-color surface color)
      (move-to surface (- h 3) (- v 3.))
      (line-to surface (+ h 4) (+ v 4.))
      (move-to surface (+ h 4) (- v 3.))
      (line-to surface (- h 3) (+ v 4.))))
  
  
  ;;;
  ;;;; Evolution
  ;;;
  
  
  (method protected virtual (plot-evolution self surface <Surface> from <fl> to <fl>)
    (let ((start (timeline-start self))
          (end (timeline-end self)))
      (define (find-first) <fx+>
        (loop (for n from (first-position evolution) to (last-position evolution))
              (when (>= (evolutionary-udp-time evolution n) start)
                (return n))
              (finally #f)))
      
      (define (find-last first <fx>) <fx>
        (loop (for n from first to (last-position evolution))
              (when (> (evolutionary-udp-time evolution n) end)
                (return (- n 1)))
              (finally (last-position evolution))))
      
      (let ((width (cast <fl> (get-width self)))
            (height (cast <fl> (get-height self)))
            (span (min (- to from) span))
            (dark-purple {Color red: .464 green: .141 blue: .732})
            (previous-latency-h #f)
            (previous-latency-v #f)
            (previous-rtt-h #f)
            (previous-rtt-v #f)
            (previous-traffic-send-h #f)
            (previous-traffic-send-v #f)
            (previous-traffic-receive-h #f)
            (previous-traffic-receive-v #f)
            (previous-missing-h #f)
            (previous-missing-v #f)
            (graphs (map new graphs))
            (now-h (and now (when->h self from to span now)))
            (first (find-first)))
        (when first
          (let ((last (find-last first)))
            (define (find-head) <fx>
              (loop (for n from first to last)
                    (when (>= (evolutionary-udp-time evolution n) from)
                      (return n))
                    (finally first)))
            
            (define (find-tail head <fx>) <fx>
              (loop (for n from head to last)
                    (when (> (evolutionary-udp-time evolution n) to)
                      (return (- n 1)))
                    (finally last)))
            
            (define (find-previous head <fx> id <fl>) <fx+>
              (loop (for n from (- head 1) downto first)
                    (when (= (evolutionary-udp-id evolution n) id)
                      (return n))
                    (finally #f)))
            
            (define (find-next tail <fx> id <fl>) <fx+>
              (loop (for n from (+ tail 1) to last)
                    (when (= (evolutionary-udp-id evolution n) id)
                      (return n))
                    (finally #f)))
            
            (let ((head (find-head)))
              (let ((tail (find-tail head))
                    (sampling (cond ((<= span 1.) 1)
                                    ((>= span 60.) 100)
                                    (else (fxround (interpolate span 1. 60. 1. 100.)))))
                    (last-state-sequence #f))
                (define (find-lowest-latency)
                  (let ((lowest-latency #f))
                    (loop (for n from head to tail)
                          (let ((id (evolutionary-udp-id evolution n)))
                            (when (and (= id udp-id-insert-packet)
                                       (eqv? (flonum->fixnum (evolutionary-udp-origin evolution n)) origin)
                                       (eqv? (flonum->fixnum (evolutionary-udp-kind evolution n)) udp-audio))
                              (let ((latency (evolutionary-udp-insert-packet-last-latency evolution n)))
                                (when (or (not lowest-latency)
                                          (< latency lowest-latency))
                                  (set! lowest-latency latency))))))
                    (or lowest-latency 0.)))
                
                (when (not lowest-latency)
                  (set! lowest-latency (find-lowest-latency)))
                (set-line-width surface 1.)
                (for-each (lambda (graph)
                            (draw-context graph self surface from to span sampling evolution))
                          graphs)
                (loop (for n from head to tail)
                      (let ((time (evolutionary-udp-time evolution n))
                            (id (evolutionary-udp-id evolution n)))
                        (let ((h (fxround (* (/ (- time from) span) width))))
                          (ecase id
                            ((udp-id-insert-packet)
                             (when (and graph-latency?
                                        (eqv? (flonum->fixnum (evolutionary-udp-origin evolution n)) origin)
                                        (eqv? (flonum->fixnum (evolutionary-udp-kind evolution n)) udp-audio))
                               (set-line-width surface 1.)
                               (set-color surface {Color Blue})
                               (let ((latency (evolutionary-udp-insert-packet-last-latency evolution n)))
                                 (let ((v (fxround (latency->v self latency))))
                                   (when (not previous-latency-h)
                                     (let ((n (find-previous head id)))
                                       (when n
                                         (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                               (v (fxround (latency->v self (evolutionary-udp-insert-packet-last-latency evolution n)))))
                                           (set! previous-latency-h h)
                                           (set! previous-latency-v v)))))
                                   (when previous-latency-h
                                     (move-to surface previous-latency-h previous-latency-v)
                                     (line-to surface h v)
                                     (when show-knees?
                                       (ellipse surface (new Rect (- h 1) (- v 1) (+ h 2) (+ v 2)) {Color Blue} {Color Blue})))
                                   (set! previous-latency-h h)
                                   (set! previous-latency-v v)))))
                            ((udp-id-receive-ack)
                             (let ((state-sequence (flonum->fixnum (evolutionary-udp-receive-ack-state-sequence evolution n)))
                                   (rtt (evolutionary-udp-receive-ack-round-trip evolution n)))
                               (let ((v (fxround (rtt->v self rtt)))
                                     (color (if (or (not last-state-sequence)
                                                    (= state-sequence (+ last-state-sequence 1)))
                                                {Color Green}
                                              {Color Red})))
                                 (set! last-state-sequence state-sequence)
                                 (set-line-width surface .8)
                                 (set-color surface color)
                                 (when (not previous-rtt-h)
                                   (let ((n (find-previous head id)))
                                     (when n
                                       (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                             (v (fxround (rtt->v self (evolutionary-udp-receive-ack-round-trip evolution n)))))
                                         (set! previous-rtt-h h)
                                         (set! previous-rtt-v v)))))
                                 (when previous-rtt-h
                                   (move-to surface previous-rtt-h previous-rtt-v)
                                   (line-to surface h v)
                                   (when show-knees?
                                     (ellipse surface (new Rect (- h 1) (- v 1) (+ h 2) (+ v 2)) {Color Green} {Color Green})))
                                 (set! previous-rtt-h h)
                                 (set! previous-rtt-v v)
                                 (set-line-width surface 1.))))
                            ((udp-id-traffic-rate)
                             (let ((color {Color Purple}))
                               (set-line-width surface 1.)
                               (set-color surface color)
                               (let ((traffic (evolutionary-udp-traffic-rate-last-send-rate evolution n)))
                                 (let ((v (fxround (traffic->v self traffic))))
                                   (when (not previous-traffic-send-h)
                                     (let ((n (find-previous head id)))
                                       (when n
                                         (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                               (v (fxround (traffic->v self (evolutionary-udp-traffic-rate-last-send-rate evolution n)))))
                                           (set! previous-traffic-send-h h)
                                           (set! previous-traffic-send-v v)))))
                                   (when previous-traffic-send-h
                                     (move-to surface previous-traffic-send-h previous-traffic-send-v)
                                     (line-to surface h v)
                                     (when show-knees?
                                       (ellipse surface (new Rect (- h 1) (- v 1) (+ h 2) (+ v 2)) color color)))
                                   (set! previous-traffic-send-h h)
                                   (set! previous-traffic-send-v v))))
                             (let ((color {Color Dark-Purple}))
                               (set-line-width surface 1.)
                               (set-color surface color)
                               (let ((traffic (evolutionary-udp-traffic-rate-last-receive-rate evolution n)))
                                 (unless (= traffic -1.)
                                   (let ((v (fxround (traffic->v self traffic))))
                                     (when (not previous-traffic-receive-h)
                                       (let ((n (find-previous head id)))
                                         (when n
                                           (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                                 (v (fxround (traffic->v self (evolutionary-udp-traffic-rate-last-receive-rate evolution n)))))
                                             (set! previous-traffic-receive-h h)
                                             (set! previous-traffic-receive-v v)))))
                                     (when previous-traffic-receive-h
                                       (move-to surface previous-traffic-receive-h previous-traffic-receive-v)
                                       (line-to surface h v)
                                       (when show-knees?
                                         (ellipse surface (new Rect (- h 1) (- v 1) (+ h 2) (+ v 2)) color color)))
                                     (set! previous-traffic-receive-h h)
                                     (set! previous-traffic-receive-v v))))))
                            @wait
                            ((udp-id-resend-packet)
                             (let ((found (evolutionary-udp-sequence evolution n)))
                               (let ((color (if (= found 1.)
                                                {Color Orange}
                                              {Color Red}))
                                     (v 29))
                                 (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color))))
                            ((udp-id-discard-packet udp-id-lost-packet)
                             (let ((kind (flonum->fixnum (evolutionary-udp-kind evolution n))))
                               (plot-discard/lost self surface h id kind)
                               (let ((left (- h 2))
                                     (right (+ h 3)))
                                 (when (and now-h (between? now-h left right))
                                   (let ((sequence (evolutionary-udp-sequence evolution n)))
                                     (if (= id udp-id-discard-packet)
                                         (unless (memv? sequence discards)
                                           (set! discards (cons sequence discards)))
                                       (unless (memv? sequence missings)
                                         (set! missings (cons sequence missings)))))))))
                            ((udp-id-purge-ring)
                             (let ((kind (flonum->fixnum (evolutionary-udp-kind evolution n))))
                               (plot-purge-ring self surface h kind)))
                            ((udp-id-rebase-time)
                             (let ((direction (if (>= (evolutionary-udp-data1 evolution n) 0.) 'up 'down)))
                               (plot-rebase-time self surface h direction)))
                            ((udp-id-throttle-rate)
                             (let ((direction (if (>= (evolutionary-udp-data1 evolution n) 0.) 'up 'down)))
                               (plot-throttle-rate self surface h direction)))
                            ((udp-id-garbage-collect)
                             (plot-garbage-collect self surface h)))
                          (for-each (lambda (graph)
                                      (draw-graph graph self surface from to span sampling evolution n time id h now-h))
                                    graphs))))
                (set-line-width surface 1.)
                (when (and graph-latency? previous-latency-h)
                  (let ((n (find-next tail udp-id-receive-ack)))
                    (set-color surface {Color Blue})
                    (move-to surface previous-latency-h previous-latency-v)
                    (if (not n)
                        (line-to surface width previous-latency-v)
                      (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                            (v (fxround (latency->v self (evolutionary-udp-insert-packet-last-latency evolution n)))))
                        (line-to surface h v)))))
                (when previous-rtt-h
                  (let ((n (find-next tail udp-id-receive-ack)))
                    (set-color surface {Color Green})
                    (move-to surface previous-rtt-h previous-rtt-v)
                    (if (not n)
                        (line-to surface width previous-rtt-v)
                      (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                            (v (fxround (rtt->v self (evolutionary-udp-receive-ack-round-trip evolution n)))))
                        (line-to surface h v)))))
                (when previous-traffic-send-h
                  (let ((n (find-next tail udp-id-traffic-rate)))
                    (set-color surface {Color Purple})
                    (move-to surface previous-traffic-send-h previous-traffic-send-v)
                    (if (not n)
                        (line-to surface width previous-traffic-send-v)
                      (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                            (v (fxround (traffic->v self (evolutionary-udp-traffic-rate-last-send-rate evolution n)))))
                        (line-to surface h v)))))
                (when previous-traffic-receive-h
                  (let ((n (find-next tail udp-id-traffic-rate)))
                    (set-color surface {Color Dark-Purple})
                    (move-to surface previous-traffic-receive-h previous-traffic-receive-v)
                    (if (not n)
                        (line-to surface width previous-traffic-receive-v)
                      (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                            (v (fxround (traffic->v self (evolutionary-udp-traffic-rate-last-receive-rate evolution n)))))
                        (line-to surface h v))))))))))))
  
  
  (method (plot-discard/lost self surface h id kind)
    (let ((color (if (= kind udp-audio) {Color Yellow} {Color World-Darker-Green}))
          (left (- h 2))
          (right (+ h 3))
          (v (if (= kind udp-audio) 36 44)))
      (let ((rect (new Rect left (- v 2) right (+ v 3))))
        (if (= id udp-id-discard-packet)
            (fill-rect surface rect color)
          (frame-rect surface rect color)))))
  
  
  (method (plot-purge-ring self surface h kind)
    (let ((color (if (= kind udp-audio) {Color Yellow} {Color World-Darker-Green}))
          (v (if (= kind udp-audio) 36 44)))
      (set-color surface color)
      (move-to surface (- h 3) (- v 3.))
      (line-to surface (+ h 4) (+ v 4.))
      (move-to surface (+ h 4) (- v 3.))
      (line-to surface (- h 3) (+ v 4.))))
  
  
  (method (plot-rebase-time self surface h direction)
    (let ((color {Color Orange})
          (v 18))
      (set-color surface color)
      (draw-arrow-tip surface (- h 2) (- v 2) 5 direction)))
  
  
  (method (plot-throttle-rate self surface h direction)
    (let ((color (case direction ((up) {Color Green}) ((down) {Color Red})))
          (v 102))
      (set-color surface color)
      (draw-arrow-tip surface (- h 2) (- v 2) 5 direction)))
  
  
  (method (plot-garbage-collect self surface h)
    (let ((color {Color Red})
          (v 18))
      (set-color surface color)
      (draw-arrow-tip surface (- h 2) (- v 2) 5 'down)))
  
  
  (method protected virtual (plot-highlight self surface <Surface> from <fl> to <fl>)
    )
  
  
  ;;;
  ;;;; History
  ;;;
  
  
  (method protected virtual (plot-history? self)
    (not live?))
  
  
  (method (plot-history self surface <Surface> from <fl> to <fl>)
    (let ((start (timeline-start self))
          (end (timeline-end self)))
      (define (find-first)
        (loop (for n from (history-first history) to (history-last history))
              (when (>= (historical-time history n) start)
                (return n))
              (finally #f)))
      
      (define (find-last first)
        (loop (for n from first to (history-last history))
              (when (> (historical-time history n) end)
                (return (- n 1)))
              (finally (history-last history))))
      
      (let ((width (cast <fl> (get-width self)))
            (height (cast <fl> (get-height self)))
            (now (get-now history))
            (changes (get-changes history))
            (span (min (- to from) span))
            (v (- (get-height self) 87))
            (first (find-first)))
        (when (and first @convert (<= first tail))
          (let ((last (find-last first)))
            (define (plot-change n)
              (let ((time (historical-time history n)))
                (when (between? time from to)
                  (let ((change (id->change (historical-change-id history n))))
                    (let ((h (fxround (* (/ (- time from) span) width)))
                          (color (case (get-name change)
                                   ((move) {Color Blue})
                                   ((lookat) {Color Purple})
                                   ((animate) {Color Purple})
                                   ((edit-script update-script) {Color Ochre})
                                   ((fire) {Color Green})
                                   ((spawn) {Color Green})
                                   ((die) {Color Red})
                                   ((add-block delete-block add-entity remove-entity) {Color Green})
                                   ((action interact) {Color Green})
                                   (else {Color Light-Gray}))))
                      (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color))))))
            
            (loop (for n from first to last)
                  (unless (= n now)
                    (plot-change n)))
            (plot-change now))))))
  
  
  ;;;
  ;;;; Chronology
  ;;;
  
  
  (method protected virtual (plot-chronology? self)
    (not live?))
  
  
  (method protected virtual (plot-chronology self surface <Surface> from <fl> to <fl>)
    (let ((width (cast <fl> (get-width self)))
          (height (cast <fl> (get-height self)))
          (span (min (- to from) span))
          (first (first-position chronology))
          (last (last-position chronology))
          (starts (make-vector sites-count #f)))
      (define (find-head/starts!) <fx>
        (continuation-capture
          (lambda (return)
            (loop (for n from first to last)
                  (let ((id (flonum->fixnum (chronological-id chronology n)))
                        (time (chronological-time chronology n)))
                    (if (>= time from)
                        (continuation-return return n)
                      (let ((marker (chronological-marker chronology n)))
                        (if (even? (flonum->fixnum marker))
                            (vector-set! starts id time)
                          (vector-set! starts id #f))))))
            first)))
      
      (define (find-tail head) <fx>
        (continuation-capture
          (lambda (return)
            (loop (for n from head to last)
                  (when (> (chronological-time chronology n) to)
                    (continuation-return return (- n 1))))
            last)))
      
      (set-font surface {Font Label})
      (draw-text surface 5 117 "Chronology" timeline-text-color)
      (when (world-setting 'world.timeline-colors? #f)
        (fill-rect surface (new Rect   0   0  20 110) chronology-orange)
        (fill-rect surface (new Rect  20  11  40 110) chronology-yellow)
        (fill-rect surface (new Rect  40  22  60 110) chronology-green)
        (fill-rect surface (new Rect  60  33  80 110) chronology-cyan)
        (fill-rect surface (new Rect  80  44 100 110) chronology-blue)
        (fill-rect surface (new Rect 100  55 120 110) chronology-purple)
        (fill-rect surface (new Rect 120  66 140 110) chronology-magenta)
        (fill-rect surface (new Rect   0  77  30 110) {Color Yellow})
        (fill-rect surface (new Rect  30  77  60 110) {Color Yellow})
        (fill-rect surface (new Rect  60  77  90 110) {Color Green})
        (fill-rect surface (new Rect  90  77 140 110) {Color Blue})
        (fill-rect surface (new Rect   0  88 140 110) {Color Orange})
        (fill-rect surface (new Rect   0  99 140 110) {Color Red})
        @wait
        (fill-rect surface (new Rect  30   0  40 110) {Color Dark-Gray})
        (let ((text-color {Color Light-Gray}))
          (set-font surface {Font Label})
          (draw-text surface   3 -3 "audio" text-color)
          (draw-text surface  23  8 "video" text-color)
          (draw-text surface  43 19 "udp-release" text-color)
          (draw-text surface  63 30 "udp-state" text-color)
          (draw-text surface  83 41 "udp-receive" text-color)
          (draw-text surface 103 52 "udp-process" text-color)
          (draw-text surface 123 63 "video-output" text-color)
          (draw-text surface   7 74 "network" text-color)
          (draw-text surface  65 74 "tick" text-color)
          (draw-text surface  97 74 "render" text-color)
          (draw-text surface  32 85 "message/event" text-color)
          (draw-text surface  53 96 "memory" text-color)))
      
      (let ((head (find-head/starts!)))
        (let ((tail (find-tail head))
              (profiler-start #f)
              (profiler-end #f))
          (define (plot-call identifier rank <fx> color <Color> start <fl> end <fl>)
            (let ((bar-height (* (cast <fl> rank) 7.)))
              (let ((f (* (/ (- start from) span) width))
                    (t (* (/ (- end from) span) width))
                    (bottom height)
                    (top (- height bar-height)))
                (when (or (between? f 0. width)
                          (between? t 0. width)
                          (and (< f 0.)
                               (> t width)))
                  (let ((left (fxfloor f))
                        (top (fxfloor top))
                        (right (fxceiling t))
                        (bottom (fxceiling bottom)))
                    (let ((rect (new Rect left top right bottom)))
                      (fill-rect surface rect color)
                      (when (and now (between? now start end))
                        (set! boxes (cons rect boxes))
                        (let ((duration (- end start)))
                          (let ((text (format "{a} ({a})" identifier (present-seconds duration))))
                            (when (or (not profiler-start)
                                      (< start profiler-start))
                              (set! profiler-start start))
                            (when (or (not profiler-end)
                                      (> end profiler-end))
                              (set! profiler-end end))
                            (set! labels (cons (list 'right (- top 16) text) labels)))))))))))
          
          (loop (for layer from 10 downto 1)
                (loop (for n from head to tail)
                      (let ((id (flonum->fixnum (chronological-id chronology n)))
                            (marker (chronological-marker chronology n))
                            (time (chronological-time chronology n)))
                        (let ((look (id->site-look self id)))
                          (let ((rank (get-rank look)))
                            (when (and (= rank layer) (or all-chronology? (not (get-default? look))))
                              (if (even? (flonum->fixnum marker))
                                  (vector-set! starts id time)
                                (let ((start (or (vector-ref starts id) from)))
                                  (let ((end time))
                                    (proclaim (not check types))
                                    (plot-call (get-identifier look) rank (get-color look) (->flonum start) end)))
                                (vector-set! starts id #f)))))))
                (loop (for id from 0 below sites-count)
                      (let ((look (id->site-look self id)))
                        (let ((rank (get-rank look)))
                          (when (and (= rank layer) (or all-chronology? (not (get-default? look))))
                            (let ((start (vector-ref starts id)))
                              (when start
                                (let ()
                                  (proclaim (not check types))
                                  (plot-call (get-identifier look) rank (get-color look) (->flonum start) to)))))))))
          (when (not live?)
            (set-profiler-range (and profiler-start (new Range profiler-start profiler-end))))))))
  
  
  ;;;
  ;;;; Events
  ;;;
  
  
  (method protected virtual (plot-events self surface from to)
    )
  
  
  ;;;
  ;;;; Now
  ;;;
  
  
  (method (plot-now self surface <Surface> from <fl> to <fl>)
    (when (and now (not live?))
      (let ((h (when->h self from to span now))
            (height (cast <fl> (get-height self)))
            (text-color {Color Light-Gray}))
        ;; line
        (set-color surface {Color White})
        (set-line-width surface 1.5)
        (move-to surface h 1)
        (line-to surface h (- height 1))
        ;; text
        (let ((height (cast <fl> (get-height self))))
          (let ((s (format "{r precision: 3}" (- now base-time)))
                (v (/ height 2.)))
            (let ((width (get-text-width surface s)))
              (let ((h (if (< h 60) (+ (fxround h) 4) (- (fxround h) width 4)))
                    (v (- (+ (fxround v) 1) 9)))
                (set-font surface {Font Label})
                (draw-text surface h v s text-color))))))))
  
  
  (method virtual (plot-nowinfo self surface <Surface> from <fl> to <fl>)
    (when (and now (not live?))
      (let ((h (when->h self from to span now))
            (height (cast <fl> (get-height self)))
            (text-color {Color Light-Gray}))
        ;; evolution
        (unless (or full-mode? visualize? (not evolution))
          (when evolution-left
            (let ((h (when->h self from to span evolution-left)))
              (set-color surface {Color Gray alpha: .4})
              (set-line-width surface 1.)
              (move-to surface h 0)
              (line-to surface h height)))
          (when evolution-right
            (let ((h (when->h self from to span evolution-right)))
              (set-color surface {Color Gray alpha: .4})
              (set-line-width surface 1.)
              (move-to surface h 0)
              (line-to surface h height))))
        ;; boxes
        (for-each (lambda (box)
                    (frame-rect surface box {Color White}))
                  boxes)
        ;; labels
        (for-each (lambda (info)
                    (bind (side . labels) info
                      (for-each (lambda (info)
                                  (bind (v . labels) info
                                    (let ((texts (map third labels)))
                                      (let ((title (format "{l detail: :human}" texts)))
                                        (let ((width (get-text-width surface title)))
                                          (let ((h (case side
                                                     ((left) (- (fxround h) width 4))
                                                     ((right) (+ (fxround h) 4))))
                                                (v (+ (fxround v) 1)))
                                            (draw-text surface h v title text-color)))))))
                                (partition labels key: second))))
                  (partition (remove-duplicates labels test: equal?) key: first))
        ;; highlighted
        (when (not-null? highlighted)
          (let ((v 100))
            (let ((h (+ (fxround h) 4))
                  (v (- (+ (fxround v) 1) 9))
                  (text (format "{l}" (map evolution-id->abbrev highlighted))))
              (draw-text surface h v text text-color))))
        (let ((labels '()))
          (define (add-label side vert str)
            (set! labels (cons (list side vert str) labels)))
          
          ;; giveup
          (when (or (not-null? discards)
                    (not-null? missings))
            (let ((vert 53))
              (let ((discard-text (and (not-null? discards)
                                       (let ((count (length discards)))
                                         (if (> count 5)
                                             (format "discard ({a} total)" count)
                                           (format "discard {l}" (sort < discards))))))
                    (missing-text (and (not-null? missings)
                                       (let ((count (length missings)))
                                         (if (> count 5)
                                             (format "missing ({a} total)" count)
                                           (format "missing {l}" (sort < missings)))))))
                (let ((text (if (and discard-text missing-text)
                                (format "{a} {a}" discard-text missing-text)
                              (or discard-text
                                  missing-text))))
                  (add-label 'right vert text)))))
          ;; latency
          (unless (or full-mode? visualize? (not graph-latency?) (not evolution))
            (let ()
              (define (find-before time id)
                (loop (for n from (last-position evolution) downto (first-position evolution))
                      (when (and (= (evolutionary-udp-id evolution n) id)
                                 (< (evolutionary-udp-time evolution n) time)
                                 (eqv? (flonum->fixnum (evolutionary-udp-origin evolution n)) origin)
                                 (eqv? (flonum->fixnum (evolutionary-udp-kind evolution n)) udp-audio))
                        (return n))
                      (finally #f)))
              
              (define (find-after time id)
                (loop (for n from (first-position evolution) to (last-position evolution))
                      (when (and (= (evolutionary-udp-id evolution n) id)
                                 (> (evolutionary-udp-time evolution n) time)
                                 (eqv? (flonum->fixnum (evolutionary-udp-origin evolution n)) origin)
                                 (eqv? (flonum->fixnum (evolutionary-udp-kind evolution n)) udp-audio))
                        (return n))
                      (finally #f)))
              
              (let ((before (find-before now udp-id-insert-packet)))
                (when before
                  (let ((actual-after (find-after now udp-id-insert-packet)))
                    (let ((after (or actual-after before)))
                      (let ((b (evolutionary-udp-insert-packet-last-latency evolution before))
                            (a (evolutionary-udp-insert-packet-last-latency evolution after)))
                        (let ((bv (fxround (latency->v self b)))
                              (av (fxround (latency->v self a))))
                          (let ((vert (if actual-after
                                          (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) bv av)
                                        bv))
                                (latency (if actual-after
                                             (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) b a)
                                           b)))
                            (let ((str (present-seconds latency)))
                              (add-label 'left vert str)))))))))))
          ;; rtt
          (unless (or full-mode? visualize? (not evolution))
            (let ()
              (define (find-before time id)
                (loop (for n from (last-position evolution) downto (first-position evolution))
                      (when (and (= (evolutionary-udp-id evolution n) id)
                                 (< (evolutionary-udp-time evolution n) time))
                        (return n))
                      (finally #f)))
              
              (define (find-after time id)
                (loop (for n from (first-position evolution) to (last-position evolution))
                      (when (and (= (evolutionary-udp-id evolution n) id)
                                 (> (evolutionary-udp-time evolution n) time))
                        (return n))
                      (finally #f)))
              
              (let ((before (find-before now udp-id-receive-ack)))
                (when before
                  (let ((actual-after (find-after now udp-id-receive-ack)))
                    (let ((after (or actual-after before)))
                      (let ((b (evolutionary-udp-receive-ack-round-trip evolution before))
                            (a (evolutionary-udp-receive-ack-round-trip evolution after)))
                        (let ((bv (fxround (rtt->v self b)))
                              (av (fxround (rtt->v self a))))
                          (let ((vert (if actual-after
                                          (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) bv av)
                                        bv))
                                (rtt (if actual-after
                                         (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) b a)
                                       b)))
                            (let ((str (present-seconds rtt)))
                              (add-label 'right vert str)))))))))))
          ;; traffic
          (unless (or full-mode? visualize? (not evolution))
            (let ()
              (define (find-before time id)
                (loop (for n from (last-position evolution) downto (first-position evolution))
                      (when (and (= (evolutionary-udp-id evolution n) id)
                                 (< (evolutionary-udp-time evolution n) time))
                        (return n))
                      (finally #f)))
              
              (define (find-after time id)
                (loop (for n from (first-position evolution) to (last-position evolution))
                      (when (and (= (evolutionary-udp-id evolution n) id)
                                 (> (evolutionary-udp-time evolution n) time))
                        (return n))
                      (finally #f)))
              
              (let ((before (find-before now udp-id-traffic-rate)))
                (when before
                  (let ((actual-after (find-after now udp-id-traffic-rate)))
                    (let ((after (or actual-after before)))
                      ;; send
                      (let ((b (evolutionary-udp-traffic-rate-last-send-rate evolution before))
                            (a (evolutionary-udp-traffic-rate-last-send-rate evolution after)))
                        (let ((bv (fxround (traffic->v self b)))
                              (av (fxround (traffic->v self a))))
                          (let ((vert (if actual-after
                                          (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) bv av)
                                        bv))
                                (traffic (if actual-after
                                             (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) b a)
                                           b)))
                            (let ((str (format "{r precision: 1}Mbps" (bytes->mbps traffic))))
                              (add-label 'left vert str)))))
                      ;; receive
                      (let ((b (evolutionary-udp-traffic-rate-last-receive-rate evolution before))
                            (a (evolutionary-udp-traffic-rate-last-receive-rate evolution after)))
                        (let ((bv (fxround (traffic->v self b)))
                              (av (fxround (traffic->v self a))))
                          (let ((vert (if actual-after
                                          (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) bv av)
                                        bv))
                                (traffic (if actual-after
                                             (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) b a)
                                           b)))
                            (let ((str (format "{r precision: 1}Mbps" (bytes->mbps traffic))))
                              (add-label 'right vert str)))))))))))
          ;; labels
          (plot-labels self surface h text-color labels)))))
  
  
  (method protected (plot-labels self surface <Surface> h text-color labels)
    (for-each (lambda (partition)
                (bind (side . labels) partition
                  (define (preprocess sorted)
                    (map (lambda (info)
                           (bind (side vert str) info
                             (let ((extent (get-text-extent surface str)))
                               (let ((width (get-width extent))
                                     (height (get-height extent)))
                                 (let ((top (max (min (fxround (- vert (/ height 2.))) 86) 0)))
                                   (let ((bottom (+ top height)))
                                     (list width height top bottom str)))))))
                         sorted))
                  
                  (let ((sorted (preprocess (sort < labels key: second))))
                    (let (loop (scan sorted))
                      (define (overlapping)
                        (let (collect (ceiling #f) (overlap '()) (rest scan))
                          (if (null? rest)
                              (values overlap rest)
                            (let ((info (car rest)))
                              (bind (width height top bottom str) info
                                (if (and ceiling (>= top ceiling))
                                    (values overlap rest)
                                  (collect bottom (append overlap (list info)) (cdr rest))))))))
                      
                      (define (spread overlap)
                        (let ((first (first overlap))
                              (last (last overlap))
                              (height (apply + (map second overlap))))
                          (let ((mid (/ (cast <fl> (+ (third first) (fourth last))) 2.)))
                            (fxround (- mid (/ (cast <fl> height) 2.))))))
                      
                      (when (not-null? scan)
                        (receive (overlap rest) (overlapping)
                          (let (iter (v (spread overlap)) (lst overlap))
                            (when (not-null? lst)
                              (bind (width height top bottom str) (car lst)
                                (let ((h (case side
                                           ((left) (- (fxround h) width 4))
                                           ((right) (+ (fxround h) 4)))))
                                  (draw-text surface h v str text-color))
                                (iter (+ v height) (cdr lst)))))
                          (loop rest)))))))
              (partition labels key: first)))
  
  
  ;;;
  ;;;; Play
  ;;;
  
  
  (method protected (set-playing? self flag)
    (unless (eq? flag playing?)
      (if flag
          (start-playing self)
        (stop-playing self))))
  
  
  (method protected virtual (start-playing self)
    (let ((thread
            (new-thread
              (lambda ()
                (play-loop self))
              'play)))
      (when (not now)
        (set! now from))
      (thread-start! thread)
      (set! visualize? #t)
      (set! play-thread thread)
      (set! playing? #t)))
  
  
  (method protected virtual (stop-playing self)
    ;; quicky to test
    (thread-terminate! play-thread)
    (set! visualize? #f)
    (set! play-thread #f)
    (set! playing? #f)
    (redraw self)
    (now-update self))
  
  
  (method protected virtual (play-loop self)
    )
  
  
  (method protected (step-forward self elapse (reset-proc #f))
    (increase! now elapse)
    (let ((over (- now visualizer-end)))
      (if (> over 0.)
          (begin
            (when reset-proc
              (reset-proc))
            (set! now (+ visualizer-start over))
            (set-bounds self visualizer-start (+ visualizer-start span)))
        (let ((over (- now to)))
          (when (> over 0.)
            (set-bounds self to (+ to span))))))
    (redraw self)
    (now-update self))
  
  
  (method protected (step-backward self elapse)
    (decrease! now elapse)
    (let ((over (- visualizer-start now)))
      (if (> over 0.)
          (begin
            (set! now (- visualizer-end over))
            (set-bounds self (- visualizer-end span) visualizer-end))
        (let ((over (- from now)))
          (when (> over 0.)
            (set-bounds self (- from span) from)))))
    (redraw self)
    (now-update self))
  
  
  (method protected (play-faster self)
    (set! visualizer-speed (/ visualizer-speed .75))
    @not-sure
    (let ((speed (next-element speed-factors visualizer-speed cycle?: #f)))
      (if (not speed)
          (bell)
        (set! visualizer-speed speed))))
  
  
  (method protected (play-slower self)
    (set! visualizer-speed (* visualizer-speed .75))
    @not-sure
    (let ((speed (previous-element speed-factors visualizer-speed cycle?: #f)))
      (if (not speed)
          (bell)
        (set! visualizer-speed speed)))))


;;;
;;;; Graph
;;;


(class Graph extends Object
  
  
  (method protected virtual (draw-context self timeline surface from to span sampling evolution)
    )
  
  
  (method protected virtual (draw-graph self timeline surface from to span sampling evolution n time id h now-h)
    )))
