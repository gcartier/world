;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Evolution Panel
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.interface.evolution jazz


(import (jazz.component)
        (jazz.graphic)
        (jazz.io)
        (jazz.markup)
        (jazz.outline)
        (jazz.resource)
        (jazz.tree)
        (jazz.ui)
        (jazz.window)
        (world)
        (world.context)
        (world.evolution)
        (world.geometry)
        (world.interface.panel)
        (world.settings)
        (world.udp))


(definition protected (show-evolutions dir)
  (let ((interface (current-interface))
        (world (current-world)))
    (let ((panel (child interface 'evolution)))
      (if (get-visible? panel)
          (set-visible? panel #f)
        (let ((file {File Home ".together" "1.0.0" "work" "requests" "Guillaume_2018-09-18_09-43-17_24553554.evolution"}))
          (if (not (exists? file))
              (display-error world (format "File not found {a}" (get-name file)))
            (bind (metadata . evolution) (read-evolution file)
              (terminal metadata (class-of evolution))
              @w
              (let ((effective-entries (let ((max-entries 34))
                                         (if (> (length entries) max-entries)
                                             (subseq entries 0 max-entries)
                                           entries))))
                (view-entries panel effective-entries)))
            (set-visible? panel #t)
            (bring-to-front panel))))
      (update-parameter world 'evolution))))


(class Evolution-Panel extends World-Panel
  
  
  (form
    (<install>                                       size: {Dimension 420 639} background: {Color red: .000 green: .000 blue: .000 alpha: .450} layout-type: fill
      (<Border-View>                                 border-type: edge style: entry layout-type: fill
        (<Scroller-View>                             style: document hscroll?: #t vscroll?: #t
          (<content~>                                layout-type: fill
            (<Tree-Header>                           style: document selectable?: #f empty-background: none
              (<content~>
                (<Evolution-Tree>      name: entries portfolio: :images filled-column: site selection-mode: cell show-unfocused-selection?: #f background: #f
                  (<Tree-Node-Column>  name: time    title: "Time" width: 140 controls?: #f display-images?: #f display-levels?: #f)
                  (<Tree-Label-Column> name: event   title: "Event" width: 100)
                  (<Tree-Label-Column> name: origin  title: "Origin" width: 100)
                  (<Tree-Label-Column> name: kind    title: "Kind" width: 75)
                  (<Tree-Label-Column> name: data1   title: "Data1" width: 65)
                  (<Tree-Label-Column> name: data2   title: "Data2" width: 65)
                  (<Tree-Label-Column> name: data3   title: "Data3" width: 65)
                  (<Tree-Label-Column> name: data4   title: "Data4" width: 65)))))))))
  
  
  (method package (view-entries self entries)
    (let ((world (current-world))
          (tree (locate self 'entries))
          (color {Color World-Red})
          (data-color {Color White}))
      (remove-every-row tree)
      (with-update-locked self
        (lambda ()
          (define (present-origin origin)
            "Guillaume"
            @w
            (if (= origin -1.)
                origin
              ;; client-no
              (or (table-ref names (flonum->fixnum origin) #f)
                  origin)))
          
          (define (present-kind media-kind)
            (cond ((= media-kind -1.)
                   "")
                  ((= media-kind 5.)
                   "audio")
                  ((= media-kind 6.)
                   "video")
                  (else
                   media-kind)))
          
          (define (present-data data)
            (if (= data -1.)
                ""
              (->string data)))
          
          #f
          @convert
          (for-each (lambda (entry)
                      (let ((time (->string (get-time entry)))
                            (event (evolution-id->name (get-id entry)))
                            (origin (present-origin (get-origin entry)))
                            (kind (present-kind (get-media-kind entry)))
                            (data1 (present-data (get-data1 entry)))
                            (data2 (present-data (get-data2 entry)))
                            (data3 (present-data (get-data3 entry)))
                            (data4 (present-data (get-data4 entry))))
                        (add-row tree
                                 state: 'expanded
                                 children: (list (new Tree-Node title: time font: {Font Label-User} color: color)
                                                 (new Tree-Label title: event font: {Font Label-User} color: {Color World-Green})
                                                 (new Tree-Label title: origin font: {Font Label-User} color: {Color World-Blue})
                                                 (new Tree-Label title: kind font: {Font Label-User} color: {Color World-Blue})
                                                 (new Tree-Label title: data1 font: {Font Label-User} color: data-color)
                                                 (new Tree-Label title: data2 font: {Font Label-User} color: data-color)
                                                 (new Tree-Label title: data3 font: {Font Label-User} color: data-color)
                                                 (new Tree-Label title: data4 font: {Font Label-User} color: data-color))
                                 @waituser-data: site)))
                    entries))))))


;;;
;;;; Evolution-Tree
;;;


(class Evolution-Tree extends Tree-View))
