;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Evolution Panel
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.interface.evolution jazz


(import (jazz.component)
        (jazz.graphic)
        (jazz.io)
        (jazz.markup)
        (jazz.outline)
        (jazz.resource)
        (jazz.tree)
        (jazz.ui)
        (jazz.window)
        (world)
        (world.context)
        (world.evolution)
        (world.geometry)
        (world.interface.panel)
        (world.settings)
        (world.udp))


(definition (default-view-replay dir)
  (let ((interface (current-interface)))
    (let ((panel (child interface 'evolution)))
      (view-evolutions panel dir))))


(definition protected view-replay
  default-view-replay)

(definition protected (set-view-replay proc)
  (set! view-replay proc))

(definition protected (reset-view-replay)
  (set! view-replay default-view-replay))


(class Evolution-Panel extends World-Panel
  
  
  (form
    (<install>                                       size: {Dimension 520 639} background: {Color red: .000 green: .000 blue: .000 alpha: .450} layout-type: fill
      (<Border-View>                                 border-type: edge style: entry layout-type: fill
        (<Scroller-View>                             style: document hscroll?: #t vscroll?: #t
          (<content~>                                layout-type: fill
            (<Tree-Header>                           style: document selectable?: #f empty-background: none
              (<content~>
                (<Evolution-Tree>      name: entries portfolio: :images filled-column: site selection-mode: cell show-unfocused-selection?: #f background: #f
                  (<Tree-Node-Column>  name: time    title: "Time" width: 140 controls?: #f display-images?: #f display-levels?: #f)
                  (<Tree-Label-Column> name: tier    title: "Tier" width: 100)
                  (<Tree-Label-Column> name: event   title: "Event" width: 100)
                  (<Tree-Label-Column> name: origin  title: "Origin" width: 100)
                  (<Tree-Label-Column> name: kind    title: "Kind" width: 75)
                  (<Tree-Label-Column> name: data1   title: "Data1" width: 75)
                  (<Tree-Label-Column> name: data2   title: "Data2" width: 75)
                  (<Tree-Label-Column> name: data3   title: "Data3" width: 75)
                  (<Tree-Label-Column> name: data4   title: "Data4" width: 75)))))))))
  
  
  (method package (view-evolutions self dir)
    (receive (names metadatas chronologies evolutions) (collect-replays dir)
      (view-names/evolutions self names evolutions)))
  
  
  (method package (view-names/evolutions self names evolutions (base-time 0.) (from #f) (to #f) (highlight #f))
    (let ((world (current-world))
          (tree (locate self 'entries))
          (color {Color World-Red})
          (data-color {Color White})
          (highlight-row #f))
      (parameterize ((inhibit-updates? #t))
        (remove-every-row tree)
        (with-update-locked self
          (lambda ()
            (define (present-tier id)
              (if (not id)
                  "<server>"
                (or (table-ref names id #f)
                    "<unknown>")))
            
            (define (present-time time)
              (format "{r precision: 6}" (- time base-time)))
            
            (define (present-origin origin)
              (if (= origin -1.)
                  ""
                ;; client-no
                (or (table-ref names (flonum->fixnum origin) #f)
                    origin)))
            
            (define (present-kind media-kind)
              (cond ((= media-kind -1.)
                     "")
                    ((= media-kind 5.)
                     "audio")
                    ((= media-kind 6.)
                     "video")
                    (else
                     media-kind)))
            
            (define (present-data data)
              (if (= data -1.)
                  ""
                (->string data)))
            
            (define (present-data1 event data)
              (present-data data))
            
            (define (present-data2 event data)
              (cond ((= event udp-id-update-time)
                     (format "{r precision: 3}" data))
                    (else
                     (present-data data))))
            
            (define (present-data3 event data)
              (cond ((= event udp-id-update-time)
                     (format "{r precision: 6}" (- data base-time)))
                    ((= event udp-id-discard-packet)
                     (format "{r precision: 6}" (- data base-time)))
                    ((= event udp-id-duplicate-packet)
                     (format "{r precision: 6}" (- data base-time)))
                    ((= event udp-id-add-process)
                     (format "{r precision: 6}" (- data base-time)))
                    ((= event udp-id-invalid-smaller)
                     (format "{r precision: 6}" (- data base-time)))
                    ((= event udp-id-invalid-greater)
                     (format "{r precision: 6}" (- data base-time)))
                    ((= event udp-id-receive-ack)
                     (format "{r precision: 6}" data))
                    (else
                     (present-data data))))
            
            (define (present-data4 event data)
              (cond ((= data -1.)
                     "")
                    ((= event udp-id-invalid-smaller)
                     (format "{r precision: 6}" (- data base-time)))
                    ((= event udp-id-invalid-greater)
                     (format "{r precision: 6}" (- data base-time)))
                    (else
                     (format "{r precision: 3}" data))))
            
            (let ((unified (new-queue)))
              (iterate-table evolutions
                (lambda (id evolution)
                  (loop (for n from (first-position evolution) to (last-position evolution))
                        (let ((time (evolutionary-time evolution n)))
                          (when (and (or (not from) (>= time from))
                                     (or (not to) (<= time to)))
                            (let ((tier id)
                                  (event (evolutionary-id evolution n))
                                  (origin (evolutionary-data1 evolution n))
                                  (kind (evolutionary-data2 evolution n))
                                  (data1 (evolutionary-data3 evolution n))
                                  (data2 (evolutionary-data4 evolution n))
                                  (data3 (evolutionary-data5 evolution n))
                                  (data4 (evolutionary-data6 evolution n)))
                              (let ((user-data (vector time tier event origin kind data1 data2 data3 data4)))
                                (enqueue unified user-data))))))))
              (for-each (lambda (user-data)
                          (bind-vector (time tier event origin kind data1 data2 data3 data4) user-data
                            (let ((tier (present-tier tier))
                                  (time (present-time time))
                                  (event (evolution-id->name event))
                                  (origin (present-origin origin))
                                  (kind (present-kind kind))
                                  (data1 (present-data1 event data1))
                                  (data2 (present-data2 event data2))
                                  (data3 (present-data3 event data3))
                                  (data4 (present-data4 event data4))
                                  (highlight? (and highlight (> time highlight))))
                              (let ((row (add-row tree
                                                  state: 'expanded
                                                  children: (list (new Tree-Node title: time font: {Font Label-User} color: color)
                                                                  (new Tree-Label title: tier font: {Font Label-User} color: {Color World-Orange})
                                                                  (new Tree-Label title: event font: {Font Label-User} color: {Color World-Darker-Green})
                                                                  (new Tree-Label title: origin font: {Font Label-User} color: {Color World-Blue})
                                                                  (new Tree-Label title: kind font: {Font Label-User} color: {Color World-Blue})
                                                                  (new Tree-Label title: data1 font: {Font Label-User} color: data-color)
                                                                  (new Tree-Label title: data2 font: {Font Label-User} color: data-color)
                                                                  (new Tree-Label title: data3 font: {Font Label-User} color: data-color)
                                                                  (new Tree-Label title: data4 font: {Font Label-User} color: data-color))
                                                  user-data: user-data)))
                                (when (and highlight? (not highlight-row))
                                  (set! highlight-row row))
                                row))))
                        (sort < (queue-list unified) key: (lambda (user-data) (vector-ref user-data 0)))))
            (when highlight-row
              (let ((line (row->line tree highlight-row)))
                (let ((line (if (> line 0) (- line 1) line)))
                  (ensure-row-displayed tree line center?: #t)
                  (let ((data (get-cell-data tree (new Cell line 0))))
                    (set-color data {Color Light-Gray})))))))))))


;;;
;;;; Evolution-Tree
;;;


(class Evolution-Tree extends Tree-View))
