;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Evolution Panel
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.interface.evolution jazz


(import (jazz.component)
        (jazz.graphic)
        (jazz.io)
        (jazz.markup)
        (jazz.outline)
        (jazz.resource)
        (jazz.tree)
        (jazz.ui)
        (jazz.window)
        (world)
        (world.context)
        (world.evolution)
        (world.geometry)
        (world.interface.panel)
        (world.settings)
        (world.udp))


(definition (default-view-replay dir)
  (let ((interface (current-interface)))
    (let ((panel (child interface 'evolution)))
      (view-evolutions panel dir))))


(definition protected view-replay
  default-view-replay)

(definition protected (set-view-replay proc)
  (set! view-replay proc))

(definition protected (reset-view-replay)
  (set! view-replay default-view-replay))


(class Evolution-Panel extends World-Panel
  
  
  (form
    (<install>                                       size: {Dimension 520 639} background: {Color red: .000 green: .000 blue: .000 alpha: .450} layout-type: fill
      (<Border-View>                                 border-type: edge style: entry layout-type: fill
        (<Scroller-View>                             style: document hscroll?: #t vscroll?: #t
          (<content~>                                layout-type: fill
            (<Tree-Header>                           style: document selectable?: #f empty-background: none
              (<content~>
                (<Evolution-Tree>      name: entries portfolio: :images filled-column: site selection-mode: cell show-unfocused-selection?: #f background: #f
                  (<Tree-Node-Column>  name: time    title: "Time" width: 140 controls?: #f display-images?: #f display-levels?: #f)
                  (<Tree-Label-Column> name: tier    title: "Tier" width: 100)
                  (<Tree-Label-Column> name: event   title: "Event" width: 100)
                  (<Tree-Label-Column> name: origin  title: "Origin" width: 100)
                  (<Tree-Label-Column> name: kind    title: "Kind" width: 75)
                  (<Tree-Label-Column> name: data1   title: "Data1" width: 65)
                  (<Tree-Label-Column> name: data2   title: "Data2" width: 65)
                  (<Tree-Label-Column> name: data3   title: "Data3" width: 65)
                  (<Tree-Label-Column> name: data4   title: "Data4" width: 65)))))))))
  
  
  (method package (view-evolutions self dir)
    (receive (names chronologies evolutions) (collect-replays dir)
      (view-names/evolutions self names evolutions)))
  
  
  (method package (view-names/evolutions self names evolutions (from #f) (to #f))
    (let ((world (current-world))
          (tree (locate self 'entries))
          (color {Color World-Red})
          (data-color {Color White}))
      (remove-every-row tree)
      (with-update-locked self
        (lambda ()
          (define (present-tier id)
            (if (not id)
                "<server>"
              (or (table-ref names id #f)
                  "<unknown>")))
          
          (define (present-origin origin)
            (if (= origin -1.)
                origin
              ;; client-no
              (or (table-ref names (flonum->fixnum origin) #f)
                  origin)))
          
          (define (present-kind media-kind)
            (cond ((= media-kind -1.)
                   "")
                  ((= media-kind 5.)
                   "audio")
                  ((= media-kind 6.)
                   "video")
                  (else
                   media-kind)))
          
          (define (present-data data)
            (if (= data -1.)
                ""
              (->string data)))
          
          (let ((unified (new-queue)))
            (iterate-table evolutions
              (lambda (id evolution)
                (loop (for n from (first-position evolution) to (last-position evolution))
                      (let ((time (evolutionary-time evolution n)))
                        (when (and (or (not from) (>= time from))
                                   (or (not to) (<= time to)))
                          (let ((tier id)
                                (event (evolutionary-id evolution n))
                                (origin (evolutionary-data1 evolution n))
                                (kind (evolutionary-data2 evolution n))
                                (data1 (evolutionary-data3 evolution n))
                                (data2 (evolutionary-data4 evolution n))
                                (data3 (evolutionary-data5 evolution n))
                                (data4 (evolutionary-data6 evolution n)))
                            (let ((user-data (vector time tier event origin kind data1 data2 data3 data4)))
                              (enqueue unified user-data))))))))
            (for-each (lambda (user-data)
                        (bind-vector (time tier event origin kind data1 data2 data3 data4) user-data
                          (let ((tier (present-tier tier))
                                (time (->string time))
                                (event (evolution-id->name event))
                                (origin (present-origin origin))
                                (kind (present-kind kind))
                                (data1 (present-data data1))
                                (data2 (present-data data2))
                                (data3 (present-data data3))
                                (data4 (present-data data4)))
                            (add-row tree
                                     state: 'expanded
                                     children: (list (new Tree-Node title: time font: {Font Label-User} color: color)
                                                     (new Tree-Label title: tier font: {Font Label-User} color: {Color World-Orange})
                                                     (new Tree-Label title: event font: {Font Label-User} color: {Color World-Darker-Green})
                                                     (new Tree-Label title: origin font: {Font Label-User} color: {Color World-Blue})
                                                     (new Tree-Label title: kind font: {Font Label-User} color: {Color World-Blue})
                                                     (new Tree-Label title: data1 font: {Font Label-User} color: data-color)
                                                     (new Tree-Label title: data2 font: {Font Label-User} color: data-color)
                                                     (new Tree-Label title: data3 font: {Font Label-User} color: data-color)
                                                     (new Tree-Label title: data4 font: {Font Label-User} color: data-color))
                                     user-data: user-data))))
                      (sort < (queue-list unified) key: (lambda (user-data) (vector-ref user-data 0))))))))))


;;;
;;;; Evolution-Tree
;;;


(class Evolution-Tree extends Tree-View))
