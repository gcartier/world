;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Evolution Panel
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.interface.evolution jazz


(import (jazz.component)
        (jazz.graphic)
        (jazz.io)
        (jazz.markup)
        (jazz.outline)
        (jazz.resource)
        (jazz.tree)
        (jazz.ui)
        (jazz.window)
        (world)
        (world.context)
        (world.event)
        (world.evolution)
        (world.geometry)
        (world.interface.panel)
        (world.settings)
        (world.udp))


(definition (default-view-replay dir)
  (let ((interface (current-interface)))
    (let ((panel (child interface 'evolution)))
      (view-evolutions panel dir))))


(definition protected view-replay
  default-view-replay)

(definition protected (set-view-replay proc)
  (set! view-replay proc))

(definition protected (reset-view-replay)
  (set! view-replay default-view-replay))


(definition protected evolutions-max
  30)

(definition protected (set-evolutions-max max)
  (set! evolutions-max max))


(class Evolution-Panel extends World-Panel
  
  
  (slot names      initialize #f accessors generate)
  (slot evolutions initialize #f accessors generate)
  (slot base-time  initialize 0. accessors generate)
  (slot from       initialize #f accessors generate)
  (slot to         initialize #f accessors generate)
  (slot now        initialize #f accessors generate)
  
  
  (form
    (<install>                                       size: {Dimension 520 639} background: {Color red: .000 green: .000 blue: .000 alpha: .450} layout-type: fill
      (<Border-View>                   name: border  border-type: edge style: entry layout-type: fill
        (<Scroller-View>                             style: document hscroll?: #t vscroll?: #t
          (<content~>                                layout-type: fill
            (<Tree-Header>             name: header  style: document empty-background: none
              (<content~>
                (<Evolution-Tree>      name: entries portfolio: :images filled-column: site multiple-selection?: #t selection-mode: cell show-unfocused-selection?: #f background: #f
                  (<Tree-Node-Column>  name: time    title: "Time" width: 140 controls?: #f display-images?: #f display-levels?: #f)
                  (<Tree-Label-Column> name: tier    title: "Tier" width: 100)
                  (<Tree-Label-Column> name: event   title: "Event" width: 100)
                  (<Tree-Label-Column> name: origin  title: "Origin" width: 100)
                  (<Tree-Label-Column> name: kind    title: "Kind" width: 75)
                  (<Tree-Label-Column> name: data1   title: "Data1" width: 75)
                  (<Tree-Label-Column> name: data2   title: "Data2" width: 75)
                  (<Tree-Label-Column> name: data3   title: "Data3" width: 75)
                  (<Tree-Label-Column> name: data4   title: "Data4" width: 75)))))))))
  
  
  (method package (view-evolutions self dir)
    (receive (names metadatas chronologies evolutions) (collect-replays dir)
      (set! self.names names)
      (set! self.evolutions evolutions)
      (view-evolutions-at self)))
  
  
  (proclaim (not check bounds zero)
            (warn optimizations))

  
  (method package (view-evolutions-at self (from #f) (to #f) (now #f))
    (set! self.from from)
    (set! self.to to)
    (set! self.now now)
    (let ((world (current-world))
          (tree (locate self 'entries))
          (color {Color World-Red})
          (data-color {Color White})
          (highlight-row #f)
          (numerical-test
            (lambda (value value/range)
              (if (pair? value/range)
                  (bind (start end) value/range
                    (between? value start end))
                (= value value/range)))))
      (let ((filtered (get-filtered-columns tree))
            (entries (new-queue))
            (total 0))
        (iterate-table evolutions
          (lambda (id <fx> evolution <Evolution>)
            (define filters
              (map (lambda (pair)
                     (bind (column type . values) pair
                       (case (get-rank column)
                         ((0) (lambda (n) (member? (- (evolutionary-udp-time evolution n) base-time) values test: numerical-test)))
                         ((1) (lambda (n) (memv? id values)))
                         ((2) (lambda (n) (memv? (evolutionary-udp-id evolution n) values)))
                         ((3) (lambda (n) (memv? (evolutionary-udp-origin evolution n) values)))
                         ((4) (lambda (n) (memv? (evolutionary-udp-kind evolution n) values)))
                         ((5) (lambda (n) (member? (evolutionary-udp-data1 evolution n) values test: numerical-test)))
                         ((6) (lambda (n) (member? (evolutionary-udp-data2 evolution n) values test: numerical-test)))
                         ((7) (lambda (n) (member? (evolutionary-udp-data3 evolution n) values test: numerical-test)))
                         ((8) (lambda (n) (member? (evolutionary-udp-data4 evolution n) values test: numerical-test))))))
                   filtered))
            
            (let ((first (first-position evolution))
                  (last (last-position evolution)))
              (define (find-now)
                (if (not now)
                    first
                  (loop (for n from first to last)
                        (for time = (evolutionary-udp-time evolution n))
                        (when (> time now)
                          (return n))
                        (finally last))))
              
              (let ((now-index (find-now)))
                ;; gather entries
                (loop (for n from (max first (- now-index evolutions-max)) to (min last (+ now-index evolutions-max)))
                      (let ((time (evolutionary-udp-time evolution n)))
                        (when (and (or (not from) (>= time from))
                                   (or (not to) (<= time to))
                                   (loop (for filter in filters)
                                         (every (filter n))))
                          (let ((user-data (vector time
                                                   id
                                                   (evolutionary-udp-id evolution n)
                                                   (evolutionary-udp-origin evolution n)
                                                   (evolutionary-udp-kind evolution n)
                                                   (evolutionary-udp-data1 evolution n)
                                                   (evolutionary-udp-data2 evolution n)
                                                   (evolutionary-udp-data3 evolution n)
                                                   (evolutionary-udp-data4 evolution n))))
                            (enqueue entries user-data)))))
                ;; calculate total
                (loop (for n from first to last)
                      (let ((time (evolutionary-udp-time evolution n)))
                        (when (and (or (not from) (>= time from))
                                   (or (not to) (<= time to))
                                   (loop (for filter in filters)
                                         (every (filter n))))
                          (increase! total))))))))
        (let ((entries (queue-list entries)))
          (define (now-neighborhood)
            (let ((closest (sort < entries key: (lambda (entry)
                                                  (let ((time (vector-ref entry 0)))
                                                    (abs (- time now)))))))
              (let ((count (length closest)))
                (let ((neighborhood (sort < (if (<= count evolutions-max)
                                                closest
                                              (subseq closest 0 evolutions-max))
                                      key: (lambda (entry)
                                             (vector-ref entry 0))))
                      (highlight (and (not-null? closest) (car closest))))
                  (values neighborhood highlight)))))
          
          (define (present-data data)
            (if (= data -1.)
                ""
              (->string data)))
          
          (define (present-data1 event data)
            (present-data data))
          
          (define (present-data2 event data)
            (cond ((= event udp-id-update-time)
                   (format "{r precision: 3}" data))
                  (else
                   (present-data data))))
          
          (define (present-data3 event data)
            (cond ((= event udp-id-update-time)
                   (format "{r precision: 6}" (- data base-time)))
                  ((= event udp-id-duplicate-packet)
                   (format "{r precision: 6}" (- data base-time)))
                  ((= event udp-id-insert-packet)
                   (format "{r precision: 6}" (- data base-time)))
                  ((= event udp-id-invalid-smaller)
                   (format "{r precision: 6}" (- data base-time)))
                  ((= event udp-id-invalid-greater)
                   (format "{r precision: 6}" (- data base-time)))
                  ((= event udp-id-receive-ack)
                   (format "{r precision: 6}" data))
                  (else
                   (present-data data))))
          
          (define (present-data4 event data)
            (cond ((= data -1.)
                   "")
                  ((= event udp-id-invalid-smaller)
                   (format "{r precision: 6}" (- data base-time)))
                  ((= event udp-id-invalid-greater)
                   (format "{r precision: 6}" (- data base-time)))
                  ((= event udp-id-read-data)
                   (format "{r precision: 0}" data))
                  ((= event udp-id-write-data)
                   (format "{r precision: 0}" data))
                  (else
                   (format "{r precision: 3}" data))))
          
          (receive (neighborhood highlight) (now-neighborhood)
            (parameterize ((inhibit-updates? #t)
                           (inhibit-scrollee-layouts? #t))
              (remove-every-row tree)
              (with-update-locked self
                (lambda ()
                  (for-each (lambda (user-data)
                              (bind-vector (time tier event origin kind data1 data2 data3 data4) user-data
                                (let ((tier (present-tier self tier))
                                      (time (present-time self time))
                                      (event (present-event self event))
                                      (origin (present-origin self origin))
                                      (kind (present-kind self kind))
                                      (data1 (present-data1 event data1))
                                      (data2 (present-data2 event data2))
                                      (data3 (present-data3 event data3))
                                      (data4 (present-data4 event data4)))
                                  (let ((row (add-row tree
                                                      state: 'expanded
                                                      children: (list (new Tree-Node title: time font: {Font Label-User} color: color)
                                                                      (new Tree-Label title: tier font: {Font Label-User} color: {Color World-Orange})
                                                                      (new Tree-Label title: event font: {Font Label-User} color: {Color World-Darker-Green})
                                                                      (new Tree-Label title: origin font: {Font Label-User} color: {Color World-Blue})
                                                                      (new Tree-Label title: kind font: {Font Label-User} color: {Color World-Blue})
                                                                      (new Tree-Label title: data1 font: {Font Label-User} color: data-color)
                                                                      (new Tree-Label title: data2 font: {Font Label-User} color: data-color)
                                                                      (new Tree-Label title: data3 font: {Font Label-User} color: data-color)
                                                                      (new Tree-Label title: data4 font: {Font Label-User} color: data-color))
                                                      user-data: user-data)))
                                    (when (eq? user-data highlight)
                                      (set! highlight-row row))
                                    row))))
                            neighborhood)
                  (when highlight-row
                    (let ((line (row->line tree highlight-row)))
                      (let ((line (if (> line 0) (- line 1) line)))
                        (ensure-row-displayed tree line center?: #t)
                        (let ((data (get-cell-data tree (new Cell line 0))))
                          (set-color data {Color Light-Gray}))))))))
            (layout-scrollee tree)
            (values (length neighborhood) total))))))
  
  
  (proclaim (default check bounds zero)
            (default warn optimizations))
  
  
  (method package (redisplay-evolutions self)
    (view-evolutions-at self from to now))
  
  
  (method package (clear-evolutions self)
    (let ((tree (locate self 'entries)))
      (remove-every-row tree)))
  
  
  (method package (present-tier self id)
    (or (table-ref names id #f)
        "<unknown>"))
  
  
  (method package (present-time self time)
    (format "{r precision: 6}" (- time base-time)))
  
  
  (method package (present-event self event)
    (symbol->string (evolution-id->name event)))
  
  
  (method package (present-origin self origin)
    (if (= origin -1.)
        ""
      ;; client-no
      (or (table-ref names (flonum->fixnum origin) #f)
          (->string origin))))
  
  
  (method package (present-kind self kind)
    (if (= kind -1.)
        ""
      (symbol->string (udp-name (flonum->fixnum kind))))))


;;;
;;;; Evolution-Tree
;;;


(class Evolution-Tree extends Tree-View))
