;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Evolution Panel
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.interface.evolution jazz


(import (jazz.component)
        (jazz.graphic)
        (jazz.io)
        (jazz.markup)
        (jazz.outline)
        (jazz.resource)
        (jazz.tree)
        (jazz.ui)
        (jazz.window)
        (world)
        (world.context)
        (world.event)
        (world.evolution)
        (world.geometry)
        (world.interface.panel)
        (world.settings)
        (world.udp))


(definition (default-view-replay dir)
  (let ((interface (current-interface)))
    (let ((panel (child interface 'evolution)))
      (view-evolutions panel dir))))


(definition protected view-replay
  default-view-replay)

(definition protected (set-view-replay proc)
  (set! view-replay proc))

(definition protected (reset-view-replay)
  (set! view-replay default-view-replay))


(definition protected evolutions-max
  50)

(definition protected (set-evolutions-max max)
  (set! evolutions-max max))


(class Evolution-Panel extends World-Panel
  
  
  (slot names      initialize #f accessors generate)
  (slot evolutions initialize #f accessors generate)
  (slot base-time  initialize 0. accessors generate)
  (slot from       initialize #f accessors generate)
  (slot to         initialize #f accessors generate)
  (slot now        initialize #f accessors generate)
  
  
  (form
    (<install>                                       size: {Dimension 520 639} background: {Color red: .000 green: .000 blue: .000 alpha: .450} layout-type: fill
      (<Border-View>                   name: border  border-type: edge style: entry layout-type: fill
        (<Scroller-View>                             style: document hscroll?: #t vscroll?: #t
          (<content~>                                layout-type: fill
            (<Tree-Header>             name: header  style: document empty-background: none
              (<content~>
                (<Evolution-Tree>      name: entries portfolio: :images filled-column: site multiple-selection?: #t selection-mode: cell show-unfocused-selection?: #f background: #f
                  (<Tree-Node-Column>  name: time    title: "Time" width: 140 controls?: #f display-images?: #f display-levels?: #f)
                  (<Tree-Label-Column> name: tier    title: "Tier" width: 100)
                  (<Tree-Label-Column> name: event   title: "Event" width: 100)
                  (<Tree-Label-Column> name: origin  title: "Origin" width: 100)
                  (<Tree-Label-Column> name: kind    title: "Kind" width: 75)
                  (<Tree-Label-Column> name: data1   title: "Data1" width: 75)
                  (<Tree-Label-Column> name: data2   title: "Data2" width: 75)
                  (<Tree-Label-Column> name: data3   title: "Data3" width: 75)
                  (<Tree-Label-Column> name: data4   title: "Data4" width: 75)))))))))
  
  
  (method package (view-evolutions self dir)
    (receive (names metadatas chronologies evolutions) (collect-replays dir)
      (set! self.names names)
      (set! self.evolutions evolutions)
      (view-evolutions-at self)))
  
  
  (method package (view-evolutions-at self (from #f) (to #f) (now #f))
    (set! self.from from)
    (set! self.to to)
    (set! self.now now)
    (let ((world (current-world))
          (tree (locate self 'entries))
          (color {Color World-Red})
          (data-color {Color White})
          (highlight-row #f))
      (parameterize ((inhibit-updates? #t))
        (remove-every-row tree)
        (with-update-locked self
          (lambda ()
            (define (present-data data)
              (if (= data -1.)
                  ""
                (->string data)))
            
            (define (present-data1 event data)
              (present-data data))
            
            (define (present-data2 event data)
              (cond ((= event udp-id-update-time)
                     (format "{r precision: 3}" data))
                    (else
                     (present-data data))))
            
            (define (present-data3 event data)
              (cond ((= event udp-id-update-time)
                     (format "{r precision: 6}" (- data base-time)))
                    ((= event udp-id-duplicate-packet)
                     (format "{r precision: 6}" (- data base-time)))
                    ((= event udp-id-insert-packet)
                     (format "{r precision: 6}" (- data base-time)))
                    ((= event udp-id-invalid-smaller)
                     (format "{r precision: 6}" (- data base-time)))
                    ((= event udp-id-invalid-greater)
                     (format "{r precision: 6}" (- data base-time)))
                    ((= event udp-id-receive-ack)
                     (format "{r precision: 6}" data))
                    (else
                     (present-data data))))
            
            (define (present-data4 event data)
              (cond ((= data -1.)
                     "")
                    ((= event udp-id-invalid-smaller)
                     (format "{r precision: 6}" (- data base-time)))
                    ((= event udp-id-invalid-greater)
                     (format "{r precision: 6}" (- data base-time)))
                    (else
                     (format "{r precision: 3}" data))))
            
            (let ((unified (new-queue))
                  (filtered (get-filtered-columns tree)))
              (iterate-table evolutions
                (lambda (id evolution)
                  (loop (for n from (first-position evolution) to (last-position evolution))
                        (let ((time (evolutionary-udp-time evolution n)))
                          (when (and (or (not from) (>= time from))
                                     (or (not to) (<= time to)))
                            (let ((tier id)
                                  (event (evolutionary-udp-id evolution n))
                                  (origin (evolutionary-udp-origin evolution n))
                                  (kind (evolutionary-udp-kind evolution n))
                                  (data1 (evolutionary-udp-data1 evolution n))
                                  (data2 (evolutionary-udp-data2 evolution n))
                                  (data3 (evolutionary-udp-data3 evolution n))
                                  (data4 (evolutionary-udp-data4 evolution n))
                                  (test (lambda (value value/range)
                                          (if (pair? value/range)
                                              (bind (start end) value/range
                                                (between? value start end))
                                            (= value value/range)))))
                              (when (every? (lambda (pair)
                                              (bind (column type . values) pair
                                                ;; quick test
                                                (case (get-rank column)
                                                  ((0) (member? (- time base-time) values test: test))
                                                  ((1) (member? (present-tier self tier) values))
                                                  ((2) (member? (present-event self event) values))
                                                  ((3) (member? (present-origin self origin) values))
                                                  ((4) (member? (present-kind self kind) values))
                                                  ((5) (member? data1 values test: test))
                                                  ((6) (member? data2 values test: test))
                                                  ((7) (member? data3 values test: test))
                                                  ((8) (member? data4 values test: test))
                                                  (else #f))))
                                            filtered)
                                (let ((user-data (vector time tier event origin kind data1 data2 data3 data4)))
                                  (enqueue unified user-data)))))))))
              (let ((entries (queue-list unified)))
                (define (now-neighborhood)
                  (let ((closest (sort < entries key: (lambda (entry)
                                                        (let ((time (vector-ref entry 0)))
                                                          (abs (- time now)))))))
                    (let ((count (length closest)))
                      (let ((neighborhood (sort < (if (<= count evolutions-max)
                                                      closest
                                                    (subseq closest 0 evolutions-max))
                                            key: (lambda (entry)
                                                   (vector-ref entry 0))))
                            (highlight (and (not-null? closest) (car closest))))
                        (values neighborhood highlight)))))
                
                (receive (neighborhood highlight) (now-neighborhood)
                  (for-each (lambda (user-data)
                              (bind-vector (time tier event origin kind data1 data2 data3 data4) user-data
                                (let ((tier (present-tier self tier))
                                      (time (present-time self time))
                                      (event (present-event self event))
                                      (origin (present-origin self origin))
                                      (kind (present-kind self kind))
                                      (data1 (present-data1 event data1))
                                      (data2 (present-data2 event data2))
                                      (data3 (present-data3 event data3))
                                      (data4 (present-data4 event data4)))
                                  (let ((row (add-row tree
                                                      state: 'expanded
                                                      children: (list (new Tree-Node title: time font: {Font Label-User} color: color)
                                                                      (new Tree-Label title: tier font: {Font Label-User} color: {Color World-Orange})
                                                                      (new Tree-Label title: event font: {Font Label-User} color: {Color World-Darker-Green})
                                                                      (new Tree-Label title: origin font: {Font Label-User} color: {Color World-Blue})
                                                                      (new Tree-Label title: kind font: {Font Label-User} color: {Color World-Blue})
                                                                      (new Tree-Label title: data1 font: {Font Label-User} color: data-color)
                                                                      (new Tree-Label title: data2 font: {Font Label-User} color: data-color)
                                                                      (new Tree-Label title: data3 font: {Font Label-User} color: data-color)
                                                                      (new Tree-Label title: data4 font: {Font Label-User} color: data-color))
                                                      user-data: user-data)))
                                    (when (eq? user-data highlight)
                                      (set! highlight-row row))
                                    row))))
                            neighborhood)
                  (when highlight-row
                    (let ((line (row->line tree highlight-row)))
                      (let ((line (if (> line 0) (- line 1) line)))
                        (ensure-row-displayed tree line center?: #t)
                        (let ((data (get-cell-data tree (new Cell line 0))))
                          (set-color data {Color Light-Gray})))))
                  (values (length neighborhood) (length entries))))))))))
  
  
  (method package (redisplay-evolutions self)
    (view-evolutions-at self from to now))
  
  
  (method package (clear-evolutions self)
    (let ((tree (locate self 'entries)))
      (remove-every-row tree)))
  
  
  (method package (present-tier self id)
    (if (not id)
        "<server>"
      (or (table-ref names id #f)
          "<unknown>")))
  
  
  (method package (present-time self time)
    (format "{r precision: 6}" (- time base-time)))
  
  
  (method package (present-event self event)
    (symbol->string (evolution-id->name event)))
  
  
  (method package (present-origin self origin)
    (if (= origin -1.)
        ""
      ;; client-no
      (or (table-ref names (flonum->fixnum origin) #f)
          origin)))
  
  
  (method package (present-kind self media-kind)
    (cond ((= media-kind -1.)
           "")
          ((= media-kind 5.)
           "audio")
          ((= media-kind 6.)
           "video")
          (else
           media-kind))))


;;;
;;;; Evolution-Tree
;;;


(class Evolution-Tree extends Tree-View))
