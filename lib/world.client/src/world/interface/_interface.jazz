;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Interface
;;;


(module world.interface jazz


(import (jazz.jml)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.library)
        (jazz.literals)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.ui)
        (jazz.ui.window)
        (world)
        (world.texture))


(class World-Interface extends Layout-View
  
  
  (form
    (<install> layout-type: justify))
  
  
  (slot texture initialize #f getter generate)
  
  
  ;;;
  ;;;; Events
  ;;;
  
  
  (method override (size-change size)
    (nextmethod size)
    (when texture
      (close~ texture))
    (set! texture (make-cairo-texture (get-width~ size) (get-height~ size))))
  
  
  (method override (cursor-update evt)
    )
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  ;; for testing
  (slot target-polygons initialize '() accessors generate)
  
  
  (method (draw-interface)
    (let ((surface (get-surface~ texture))
          (handle (get-handle~ player)))
      (when (offscreen-region-invalid? handle)
        (set-operator~ surface CAIRO_OPERATOR_CLEAR)
        (paint~ surface)
        (set-operator~ surface CAIRO_OPERATOR_OVER)
        (set-clipper~ surface (new Rect 0 0 (get-width) (get-height)))
        (paint-drawing surface '())
        (for-each (lambda (polygon)
                    (set-color~ surface {Color Red})
                    (let ((points (map (lambda (vertex) (world->screen~ world vertex)) (get-vertices~ polygon))))
                      (let ((first (car points)))
                        (move-to~ surface (get-h~ first) (get-v~ first))
                        (for-each (lambda (point)
                                    (line-path~ surface (get-h~ point) (get-v~ point)))
                                  (cdr points))
                        (line-to~ surface (get-h~ first) (get-v~ first)))))
                  target-polygons)
        @test-world->screen
        (let ((face (get-target-face~ world)))
          (when face
            (set-color~ surface {Color Orange})
            (for-each (lambda (triangle)
                        (let ((t1 (world->screen~ world (get-v1~ triangle)))
                              (t2 (world->screen~ world (get-v2~ triangle)))
                              (t3 (world->screen~ world (get-v3~ triangle))))
                          (move-to~ surface (get-h~ t1) (get-v~ t1))
                          (line-path~ surface (get-h~ t2) (get-v~ t2))
                          (line-path~ surface (get-h~ t3) (get-v~ t3))
                          (line-to~ surface (get-h~ t1) (get-v~ t1))))
                      (get-triangles~ face))))
        (map-texture~ texture)
        (validate-offscreen handle))
      (let ((width (cast <fl> (get-width)))
            (height (cast <fl> (get-height))))
        (textured-quad~ texture
          (lambda () (glVertex3f 0.0 0.0 0.0))
          (lambda () (glVertex3f width 0.0 0.0))
          (lambda () (glVertex3f width height 0.0))
          (lambda () (glVertex3f 0.0 height 0.0))))))))
