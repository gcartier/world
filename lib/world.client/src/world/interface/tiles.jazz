;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Tiles
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.interface.tiles jazz


(import (jazz.graphic.opengl.glew)
        (world)
        (world.autoload)
        (world.block)
        (world.camera)
        (world.draw)
        (world.dye)
        (world.dyes)
        (world.entity)
        (world.face)
        (world.generate)
        (world.geometry)
        (world.interface)
        (world.interface.showcase)
        (world.material)
        (world.model)
        (world.object)
        (world.opengl)
        (world.quad)
        (world.syntax (phase syntax))
        (world.texture)
        (world.tile))


(definition spacing
  1.)


;; quicky for tests
(definition showing-zone
  #f)


(class Tiles-Showcase extends Showcase
  
  
  (slot tiles  initialize #f getter generate)
  (slot camera initialize #f getter generate)
  (slot target initialize #f getter generate)
  (slot point  initialize #f getter generate)
  (slot moved? initialize #f getter generate)
  
  
  (method (showcased-tiles)
    (let ((zone (current-zone)))
      (if (and tiles (eq? zone showing-zone))
          tiles
        (set! showing-zone zone)
        (set! tiles (if (minecraft?~ zone)
                        (showcased-minecraft)
                      (showcased-blocks)))
        tiles)))
  
  
  (method (showcased-blocks)
    (let ((world (current-world)))
      (let ((y -2.8)
            (z 0.))
        (let ((all (map (lambda (name)
                          (let ((model (make-block-model name name name name name name))
                                (scale .4))
                            (let ((entity (new Entity position: (vertex 0. y z) scale: (vertex scale scale scale))))
                              (set-radiuses~ entity (vertex .4 .4 .4))
                              (set-model~ entity model)
                              (decrease! z spacing)
                              entity)))
                        (image-names~ (get-tile-atlas~ world)))))
          (list->vector all)))))
  
  
  (method (showcased-minecraft)
    (let ((world (current-world))
          (zone (current-zone)))
      (let ((blocks (minecraft-blocks~ zone))
            (y -2.8)
            (z 0.))
        (let ((all (map (lambda (block)
                          (let ((model (make-faces-model (minecraft-block-model~ zone block 0. 0. 0.)))
                                (scale .8))
                            (let ((entity (new Entity position: (vertex 0. y z) scale: (vertex scale scale scale))))
                              (set-radiuses~ entity (vertex .4 .4 .4))
                              (set-model~ entity model)
                              (decrease! z spacing)
                              entity)))
                        (table-values blocks))))
          (list->vector all)))))
  
  
  (method (cache-camera)
    (or camera
        (let ((world (current-world))
              (cam (new Camera)))
          (set-width~ cam (get-width~ world))
          (set-height~ cam (get-height~ world))
          (vertex-copy! (get-position~ cam) (vertex 10. 0. 0.))
          (let ((lookat (get-lookat~ cam))
                (sight (vertex -1. 0. 0.))
                (up (vertex 0. 1. 0.)))
            (set-sight~ lookat sight)
            (set-up~ lookat up)
            (set-right~ lookat (cross-normal sight up)))
          (update-target~ cam)
          (setup-camera~ cam)
          (set! camera cam)
          camera)))
  
  
  (method (ray-closest-entity orig <f64vector> dir <f64vector>)
    (let ((closest #f)
          (distance #f))
      (let ((tiles (showcased-tiles)))
        (loop (for n from 0 below (vector-length tiles))
              (let ((entity (vector-ref tiles n)))
                (when (ray-intersects-sphere? orig dir (get-center~ entity) (get-radius~ entity))
                  (for-each-bounding-quad~ entity #f #f
                    (lambda (poly)
                      (let ((cls (ray-closest-triangle~ poly orig dir #f)))
                        (when cls
                          (bind (poly dist) cls
                            (when (or (not distance)
                                      (< dist distance))
                              (set! closest (list poly dist))
                              (set! distance dist)))))))))))
      closest))
  
  
  (method override (size-change size)
    (size-change~ (cache-camera) size))
  
  
  (method override (showcase-mouse-down h v)
    (set! point h))
  
  
  (method override (showcase-mouse-move h v)
    (when (and point (not (near? h point 2)))
      (let ((delta (/ (cast <fl> (- h point)) 100.)))
        (let ((camera (cache-camera)))
          (let ((position (get-position~ camera)))
            (vertex+! position position (vertex 0. 0. delta))
            (update-target~ camera))))
      (set! point h)
      (set! moved? #t)))

  
  (method override (showcase-mouse-up h v)
    (when (not moved?)
      (receive (position direction) (screen->ray~ camera h v)
        (let ((closest (ray-closest-entity position direction)))
          (when closest
            (bind (poly dist) closest
              (set! target (get-element~ poly)))))))
    (set! point h)
    (set! moved? #f))
  
  
  (method override (showcase-wheel reversed?)
    (let ((camera (cache-camera)))
      (let ((position (get-position~ camera)))
        (vertex+! position position (vertex 0. 0. (if reversed? spacing (- spacing))))
        (update-target~ camera))))


  (method override (draw-showcase)
    ;; Preserve
    (glPushMatrix)
    (glDisable GL_LIGHTING)
    
    ;; Reset and transform the matrix
    (glMatrixMode GL_MODELVIEW)
    (glLoadIdentity)
    (setup-camera~ (cache-camera))
    
    ;; Clear depth buffer
    (glClear GL_DEPTH_BUFFER_BIT)
    
    ;; Tiles
    (let ((tiles (showcased-tiles)))
      (loop (for n from 0 below (vector-length tiles))
            (let ((rank n))
              (let ((entity (vector-ref tiles rank)))
                (draw-entity~ entity)))))
    
    ;; Target
    (when target
      (draw-target~ target red-dye))
    
    ;; Restore
    (glEnable GL_LIGHTING)
    (glPopMatrix))))
