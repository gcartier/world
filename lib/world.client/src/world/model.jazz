;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Models
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.model jazz


(import (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (world)
        (world.autoload)
        (world.draw)
        (world.element)
        (world.generate)
        (world.geometry)
        (world.material)
        (world.mesh)
        (world.polygon)
        (world.renderers)
        (world.serialization)
        (world.shader)
        (world.syntax (phase syntax)))


;;;
;;;; Metadata
;;;


(definition public (load-model-metadata name file)
  (when (exists?~ file)
    (let ((metadata (call-with-input-file (path-settings file) read)))
      (assert (and (pair? metadata)
                   (pair? (cdr metadata))
                   (let ((symbol (cadr metadata)))
                     (and (symbol? symbol)
                          (equal? (symbol->string symbol) name)))))
      (cddr metadata))))


(definition public (model-metadata-render metadata)
  (and metadata
       (let ((pair (assq 'render metadata)))
         (and pair
              (cadr pair)))))


(definition public (model-metadata-mask metadata)
  (and metadata
       (let ((pair (assq 'mask metadata)))
         (and pair
              (cadr pair)))))


;;;
;;;; Models
;;;


(definition models <table>
  (make-table test: eq?))

(definition model-id <fx>
  0)


(definition public (registered-models)
  models)

(definition public (registered-model name)
  (let ((info/model (table-ref models name)))
    (if (is? info/model Model)
        info/model
      (bind (id kind generate) info/model
        (let ((model (generate)))
          (set-name~ model name)
          (set-id~ model id)
          (table-set! models name model)
          model)))))

(definition public (register-model name generate showcase? (kind #f))
  (if (not showcase?)
      (table-set! models name (list #f kind generate))
    (table-set! models name (list model-id kind generate))
    (increase! model-id)))


(definition public (registered-non-block-models)
  (let ((queue (new-queue)))
    (iterate-table-safe models
      (lambda (name info/model)
        (if (is? info/model Model)
            (when (and (get-id~ info/model)
                       (not (block?~ info/model)))
              (enqueue queue info/model))
          (bind (id kind generate) info/model
            (when (and id (not kind))
              (enqueue queue (registered-model name)))))))
    (queue-list queue)))


(definition public (registered-block-models)
  (let ((queue (new-queue)))
    (iterate-table-safe models
      (lambda (name info/model)
        (if (is? info/model Model)
            (when (and (get-id~ info/model)
                       (block?~ info/model))
              (enqueue queue info/model))
          (bind (id kind generate) info/model
            (when (and id (eq? kind 'block))
              (enqueue queue (registered-model name)))))))
    (queue-list queue)))


;;;
;;;; Model
;;;


(class Model extends Component
  
  
  (property position    <f64vector> initialize (vertex 0. 0. 0.) getter generate setter explicit)
  (property rotation    <f64vector> initialize (vertex 0. 0. 0.) getter generate setter explicit)
  (property scale       <f64vector> initialize (vertex 1. 1. 1.) getter generate setter explicit)
  (property faces       <object>    initialize #f                getter generate setter explicit)
  (property meshes      <vector+>   initialize #f                accessors generate)
  (property pumps       <object>    initialize #f                accessors generate)
  
  
  (slot file          <object>    initialize #f                     accessors generate)
  (slot path          <object>    initialize #f                     accessors generate)
  (slot path-time     <object>    initialize #f                     accessors generate)
  (slot metadata      <object>    initialize #f                     accessors generate)
  (slot matrix        <f64vector> initialize (make-identity-matrix) accessors generate)
  (slot global-matrix <f64vector> initialize (make-identity-matrix) accessors generate)
  (slot polygons      <vector+>   initialize #f                     accessors generate)
  (slot bounds        <object>    initialize #f                     getter generate setter explicit)
  (slot anchor        <object>    initialize 'center                accessors generate)
  (slot center        <object>    initialize #f                     getter generate)
  (slot animation     <object>    initialize #f                     accessors generate)
  (slot animations    <object>    initialize #f                     accessors generate)
  (slot entity-class  <object>    initialize #f                     accessors generate)
  (slot id            <fx+>       initialize #f                     accessors generate)
  
  ;; debug
  (slot native        <object>    initialize #f                     accessors generate)
  (slot atlas         <object>    initialize #f                     accessors generate)
  
  
  (method override (install-in-parent)
    (nextmethod)
    (update-matrix))
  
  
  (method meta override (marshall-object obj)
    (serialize-object (class-of obj)
                      (vector
                        (serialize (get-model~ obj)))))
  
  
  (method meta override (unmarshall-object content)
    (let ((world (current-world)))
      (bind-vector (path) content
        (find-model~ world (deserialize path)))))
  
  
  (method public (set-position pos <f64vector>) <void>
    (vertex-copy! position pos)
    (update-matrix))
  
  
  (method public (set-rotation rot <f64vector>) <void>
    (vertex-copy! rotation rot)
    (update-matrix))
  
  
  (method public (set-scale s <f64vector>) <void>
    (vertex-copy! scale s)
    (update-matrix))
  
  (method public (set-scaling s <fl>) <void>
    (vertex-init! scale s s s)
    (update-matrix))
  
  
  (method (update-matrix)
    (matrix-multiply! matrix (make-translation-matrix& position)
                             (matrix-multiply& (make-rotation-matrix& rotation)
                                               (make-scaling-matrix& scale)))
    (if (not parent)
        (matrix-copy! global-matrix matrix)
      (matrix-multiply! global-matrix (get-global-matrix~ parent) matrix))
    (for-each update-matrix~ children))
  
  
  ;;;
  ;;;; Faces
  ;;;
  
  
  (method public (set-faces lst)
    (let ((world (current-world)))
      (set! faces lst)
      (set! polygons (faces-polygons faces))
      (set! meshes (list->vector (map (lambda (partition)
                                        (bind (material . faces) partition
                                          (generate-mesh (faces-generator faces) matrix: matrix neighbors?: #t material: material)))
                                      (partition faces key: get-material~))))))
  
  
  (method (faces-polygons faces)
    (let ((count (length faces)))
      (let ((vect (make-f64vector (* count polygon-float-size)))
            (offset 0))
        (for-each (lambda (face)
                    (let ((poly (get-polygon~ face)))
                      (polygon-move!~ poly vect offset matrix)
                      (increase! offset polygon-float-size)))
                  faces)
        vect)))
  
  
  (method protected virtual (block?)
    #f)
  
  
  (method protected virtual (opaque-cube?)
    #f)
  
  
  ;;;
  ;;;; Bounds
  ;;;
  
  
  (method public (set-bounds bnd)
    (set! bounds bnd)
    (set! center (cuboid-center bnd)))
  
  
  (method public (determine-bounds)
    (vertices-bounds
      (lambda (process)
        (for-each (lambda (face)
                    (let ((vertices (get-vertices~ (get-polygon~ face))))
                      (loop (for n from 0 below (vector-length vertices))
                            (let ((vert (vector-ref vertices n)))
                              (process vert)))))
                  faces))))
  
  
  (method public (bounds-radius)
    (vertex-norm (cuboid-radiuses bounds)))
  
  
  ;;;
  ;;;; Anchor
  ;;;
  
  
  (method (position->anchor pos (entity-scale #f))
    (vertex- pos (anchor-point entity-scale)))
  
  
  (method (anchor->position anchor (entity-scale #f))
    (vertex+ anchor (anchor-point entity-scale)))
  
  
  (method (anchor-point (entity-scale #f))
    (case anchor
      ((center)
       (vertex 0.
               (* (vertex-y (cuboid-radiuses (get-bounds))) (vertex-y scale) (if entity-scale (vertex-y entity-scale) 1.))
               0.))
      ((origin)
       (vertex 0.
               0.
               0.))))
  
  
  ;;;
  ;;;; Render
  ;;;
  
  
  (method protected virtual (model-renderer)
    (get-transparent-renderer))
  
  
  (method protected virtual (model-bind-uniforms entity program mesh matrix)
    (bind-uniforms~ program mesh matrix #f))
  
  
  (method protected virtual (model-unbind-uniforms entity program)
    (unbind-uniforms~ program))
  
  
  ;;;
  ;;;; Animation
  ;;;
  
  
  (method public (all-animations)
    (let ((animations (if animations (table-values animations) '())))
      (if (not animation)
          animations
        (cons animation animations))))
  
  
  (method public (all-animation-names)
    (let ((animations (if animations (table-keys animations) '())))
      (if (not animation)
          animations
        (cons #f animations))))
  
  
  (method public (add-animation name anim)
    (when (not animations)
      (set! animations (make-table test: equal?)))
    (table-set! animations name anim))
  
  
  (method public (find-animation name)
    (if (not name)
        animation
      (and animations (table-ref animations name #f))))
  
  
  (method public (require-animation name)
    (or (find-animation name)
        (error "Unknown animation: {a}" name)))))
