;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Texture Atlas
;;;


(module world.atlas jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (world)
        (world.foreign)
        (world.texture)
        (time))


;;;
;;;; Atlas
;;;


(definition default-padding
  100)

(definition width-threshold
  2000)


(class Atlas extends Object
  
  
  (slot min-filter                                      getter generate)
  (slot mag-filter                                      getter generate)
  (slot parameters                                      getter generate)
  (slot mipmap?                                         getter generate)
  (slot pad?                                            getter generate)
  (slot padding    initialize 0                         getter generate)
  (slot files      initialize (make-table test: equal?) getter generate)
  (slot images     initialize (make-table test: equal?) getter generate)
  (slot uniform?   initialize #t                        getter generate)
  (slot depth      initialize 0                         getter generate)
  (slot h          initialize 0                         getter generate)
  (slot v          initialize 0                         getter generate)
  (slot width      initialize 0                         getter generate)
  (slot height     initialize 0                         getter generate)
  (slot texture    initialize #f                        getter generate)
  
  
  (method override (initialize (min-filter: min-filter #f) (mag-filter: mag-filter #f) (parameters: parameters #f) (mipmap?: mipmap? #t) (pad?: pad? #t))
    (set! min-filter~self min-filter)
    (set! mag-filter~self mag-filter)
    (set! parameters~self parameters)
    (set! mipmap?~self mipmap?)
    (if (get-texture-arrays?)
        (set! pad?~self #f)
      (set! pad?~self pad?)
      (set! padding~self (if pad? default-padding 0))
      (set! h~self padding)
      (set! v~self padding)))
  
  
  (method public (image-names)
    (sort di<? (table-keys images)))
  
  
  (method public (image-rect name)
    (or (table-ref images name #f)
        (error "Unable to find image: {s}" name)))
  
  
  (method public (image-file name)
    (or (table-ref files name #f)
        (error "Unable to find image: {s}" name)))
  
  
  (method public (add-surface surface image-width image-height depth)
    (table-set! images depth (list surface image-width image-height depth))
    (when (> image-width width)
      (set! width image-width))
    (when (> image-height height)
      (set! height image-height)))
  
  
  (method public (add-file file)
    (let ((name (get-base~ file)))
      (receive (image-width image-height surf) (cairo-surface-from-file file)
        (cond ((get-texture-arrays?)
               (table-set! files name file)
               (table-set! images name (list (new Surface surf) image-width image-height depth))
               (when (> image-width width)
                 (set! width image-width))
               (when (> image-height height)
                 (set! height image-height))
               (increase! depth))
              (else
               (let ((right (+ h image-width))
                     (bottom (+ v image-height)))
                 (table-set! files name file)
                 (table-set! images name (cons (new Surface surf) (new Rect h v right bottom)))
                 (let ((right (+ right padding))
                       (bottom (+ bottom padding)))
                   (when (> right width)
                     (set! width right))
                   (when (> bottom height)
                     (set! height bottom))
                   (if (< right width-threshold)
                       (set! h (+ right padding))
                     (set! h padding)
                     (set! v (+ height padding))))))))))
  
  
  (method public (add-directory dir)
    (iterate-directory~ dir
      (lambda (file)
        (when (extension=? (get-extension~ file) "png")
          (add-file file))
        files?: #t
        directories?: #f)))
  
  
  (method public (add-directory-if-exists dir)
    (when (exists?~ dir)
      (add-directory dir)))
  
  
  (method public (complete)
    (let ((count (table-length images)))
      (if (= count 0)
          (error "Empty atlas")
        (if (get-texture-arrays?)
            (let ((tex (new Image-Texture width height min-filter: min-filter mag-filter: mag-filter parameters: parameters mipmap?: mipmap?)))
              (map-textures~ tex width height (sort < (table-values images) key: fourth))
              (for-each (lambda (name)
                          (bind (surface width height depth) (table-ref images name #f)
                            (table-set! images name (uv 0.
                                                        0.
                                                        1.
                                                        1.
                                                        (cast <fl> depth)))))
                        (table-keys images))
              (set! texture tex))
          (if (= count 1)
              (let ((name (car (first (table->list images)))))
                (let ((image (car (table-ref images name))))
                  (table-set! images name (uv 0. 0. 1. 1. 0.))
                  (let ((surf (get-handle~ image)))
                    (let ((width (cairo_image_surface_get_width surf))
                          (height (cairo_image_surface_get_height surf))
                          (data (cairo_image_surface_get_data surf)))
                      ;; not sure if destroying the surface releases the data
                      ;; (close~ image)
                      (let ((tex (new Image-Texture width height data: data mipmap?: mipmap?)))
                        (map-texture~ tex)
                        (set! texture tex))))))
            (let ((surface (new Surface (cairo_image_surface_create CAIRO_FORMAT_ARGB32 width height))))
              (define (normalize-x x)
                (/ (cast <fl> x) (cast <fl> width)))
              
              (define (normalize-y y)
                (/ (cast <fl> y) (cast <fl> height)))
              
              (for-each (lambda (name)
                          (bind (image . rect) (table-ref images name #f)
                            ;; improve mipmapping by tiling a border around the image
                            (let ((pos (rect-position rect))
                                  (size (rect-size rect)))
                              (let ((h (get-h~ pos))
                                    (v (get-v~ pos))
                                    (width (get-width~ size))
                                    (height (get-height~ size)))
                                (if (not pad?)
                                    (blit-surface~ surface image destination: pos)
                                  (with-clip~ surface (inflate-rect rect padding padding)
                                    (lambda ()
                                      (blit-surface~ surface image destination: (new Point (- h width) (- v height)))
                                      (blit-surface~ surface image destination: (new Point h (- v height)))
                                      (blit-surface~ surface image destination: (new Point (+ h width) (- v height)))
                                      (blit-surface~ surface image destination: (new Point (- h width) v))
                                      (blit-surface~ surface image destination: (new Point (+ h width) v))
                                      (blit-surface~ surface image destination: (new Point (- h width) (+ v height)))
                                      (blit-surface~ surface image destination: (new Point h (+ v height)))
                                      (blit-surface~ surface image destination: (new Point (+ h width) (+ v height)))
                                      (blit-surface~ surface image destination: pos))))))
                            (table-set! images name (uv (normalize-x (get-left~ rect))
                                                        (normalize-y (get-top~ rect))
                                                        (normalize-x (get-right~ rect))
                                                        (normalize-y (get-bottom~ rect))
                                                        0.))))
                        (table-keys images))
              (let ((tex (new Cairo-Texture width height surface: surface mipmap?: mipmap?)))
                (map-texture~ tex)
                (set! texture tex))))))))))
