;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Texture Atlas
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is WorldScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2014
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See http://github.com/gcartier/world for details.


(module world.atlas jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.io)
        (jazz.platform.cairo)
        (world.support)
        (world.syntax (phase syntax))
        (world.texture))


(definition atlases
  (make-table test: eq?))


(definition public (register-atlas name atlas)
  (table-set! atlases name atlas))

(definition public (registered-atlas name)
  (table-ref atlases name #f))

(definition public (registered-atlases)
  atlases)


;;;
;;;; Atlas
;;;


(definition default-padding
  100)

(definition width-threshold
  3500)


(class Atlas extends Object
  
  
  (slot min-filter                                                   getter generate)
  (slot mag-filter                                                   getter generate)
  (slot wrap                                                         getter generate)
  (slot parameters                                                   getter generate)
  (slot mipmap?                                                      getter generate)
  (slot repeat?                                                      getter generate)
  (slot pad?                                                         getter generate)
  (slot padding                 initialize 0                         getter generate)
  (slot files                   initialize (make-table test: equal?) getter generate)
  (slot images                  initialize (make-table test: equal?) getter generate)
  (slot depth                   initialize 0                         getter generate)
  (slot h                       initialize 0                         getter generate)
  (slot v                       initialize 0                         getter generate)
  (slot width                   initialize 0                         getter generate)
  (slot height                  initialize 0                         getter generate)
  (slot texture                 initialize #f                        getter generate)
  (slot uniform?                initialize #f                        getter generate)
  (slot normalize?              initialize #t                        getter generate)
  (slot bounds     <f32vector+> initialize #f                        getter generate)
  
  
  (method override (initialize (min-filter: min-filter #f) (mag-filter: mag-filter #f) (wrap: wrap #f) (parameters: parameters #f) (mipmap?: mipmap? #t) (repeat?: repeat? #f) (pad?: pad? #t) (normalize?: normalize? #t))
    (let ((repeat? (and repeat? (get-texture-arrays?))))
      (let ((pad? (and pad? (not repeat?))))
        (set! min-filter~self min-filter)
        (set! mag-filter~self mag-filter)
        (set! wrap~self wrap)
        (set! parameters~self parameters)
        (set! mipmap?~self mipmap?)
        (set! repeat?~self repeat?)
        (set! pad?~self pad?)
        (set! padding~self (if pad? default-padding 0))
        (set! normalize?~self normalize?)
        (set! h~self padding)
        (set! v~self padding))))
  
  
  (method override (destroy)
    (when texture
      (destroy~ texture)
      (set! texture #f))
    (nextmethod))
  
  
  (method public (image-names)
    (sort di<? (table-keys images)))
  
  
  (method public (image-rect name)
    (or (table-ref images name #f)
        (error "Unable to find image: {s}" name)))
  
  
  (method public (image-file name)
    (or (table-ref files name #f)
        (error "Unable to find image: {s}" name)))
  
  
  (method public (add-surface surface image-width image-height depth)
    (table-set! images depth (list surface image-width image-height depth))
    (when (> image-width width)
      (set! width image-width))
    (when (> image-height height)
      (set! height image-height)))
  
  
  (method public (add-file file)
    (assert (exists?~ file))
    (let ((name (get-base~ file)))
      (unless (table-ref images name #f)
        (receive (image-width image-height surf) (cairo-surface-from-file file)
          (cond ((get-texture-arrays?)
                 (table-set! files name file)
                 (table-set! images name (list (new Surface surf) image-width image-height depth))
                 (increase! depth))
                (else
                 (let ((right (+ h image-width))
                       (bottom (+ v image-height)))
                   (table-set! files name file)
                   (table-set! images name (list (new Surface surf) (new Rect h v right bottom) depth))
                   (let ((right (+ right padding))
                         (bottom (+ bottom padding)))
                     (when (> right width)
                       (set! width right))
                     (when (> bottom height)
                       (set! height bottom))
                     (if (< right width-threshold)
                         (set! h (+ right padding))
                       (set! h padding)
                       (set! v (+ height padding))))
                   (increase! depth))))))))
  
  
  (method public (add-directory dir)
    (iterate-directory~ dir
      (lambda (file)
        (when (member? (get-extension~ file) '("png" "tga") test: extension=?)
          (add-file file))
        files?: #t
        directories?: #f)))
  
  
  (method public (add-directory-if-exists dir)
    (when (exists?~ dir)
      (add-directory dir)))
  
  
  (method public (complete)
    (define (analyse-images)
      (let ((width #f)
            (height #f)
            (unif? #t))
        (iterate-table images
          (lambda (name info)
            (bind (surface image-width image-height depth) info
              (cond ((not width)
                     (set! width image-width)
                     (set! height image-height))
                    (else
                     (when (or (/= image-width width)
                               (/= image-height height))
                       (set! unif? #f)
                       (when (> image-width width)
                         (set! width image-width))
                       (when (> image-height height)
                         (set! height image-height))))))))
        (values width height unif?)))
    
    ;; improves mipmapping by tiling a border around the image
    (define (pad-image surface image image-width image-height rect)
      (let ((pos (rect-position rect))
            (size (rect-size rect)))
        (let ((h (get-h~ pos))
              (v (get-v~ pos))
              (width (get-width~ size))
              (height (get-height~ size)))
          (with-clip~ surface (inflate-rect rect padding padding)
            (lambda ()
              (let ((radius (fxceiling (/ (cast <fl> padding) (min image-width image-height)))))
                (loop (for j from (- radius) to radius)
                      (loop (for i from (- radius) to radius)
                            (blit-surface~ surface image destination: (new Point (+ h (* i width)) (+ v (* j height))))))))))))
    
    (define (normalize-x x width)
      (/ (cast <fl> x) (cast <fl> width)))
    
    (define (normalize-y y height)
      (/ (cast <fl> y) (cast <fl> height)))
    
    (define (complete-texture)
      (let ((count (table-length images)))
        (if (= count 0)
            (error "Empty atlas")
          (if (get-texture-arrays?)
              (receive (width height unif?) (analyse-images)
                (if unif?
                    (let ((tex (new Image-Texture width height min-filter: min-filter mag-filter: mag-filter wrap: wrap parameters: parameters mipmap?: mipmap?)))
                      (map-texture-array~ tex (sort < (table-values images) key: fourth) repeat?: repeat?)
                      (for-each (lambda (name)
                                  (bind (surface width height depth) (table-ref images name #f)
                                    (table-set! images name (uv 0.
                                                                0.
                                                                1.
                                                                1.
                                                                (cast <fl> depth)))
                                    (close~ surface)))
                                (table-keys images))
                      (set! texture tex)
                      (set! uniform? #t))
                  (let ((width (+ padding width padding))
                        (height (+ padding height padding)))
                    (for-each (lambda (name)
                                (bind (image image-width image-height depth) (table-ref images name #f)
                                  (let ((padded-width (+ padding image-width padding))
                                        (padded-height (+ padding image-height padding)))
                                    (let ((surface (new Surface (cairo_image_surface_create CAIRO_FORMAT_ARGB32 (if repeat? width padded-width) (if repeat? height padded-height))))
                                          (rect (new Rect padding padding (+ image-width padding) (+ image-height padding))))
                                      (if (not pad?)
                                          (let ((pos (rect-position rect)))
                                            (if (not repeat?)
                                                (blit-surface~ surface image destination: pos)
                                              (let (loop-vert (v (get-v~ pos)))
                                                (let (loop-horz (h (get-h~ pos)))
                                                  (blit-surface~ surface image destination: (new Point h v))
                                                  (let ((next-h (+ h image-width)))
                                                    (when (< next-h width)
                                                      (loop-horz next-h))))
                                                (let ((next-v (+ v image-height)))
                                                  (when (< next-v height)
                                                    (loop-vert next-v))))))
                                        (pad-image surface image image-width image-height rect))
                                      (close~ image)
                                      (table-set! images name (list surface padded-width padded-height depth))))))
                              (table-keys images))
                    (let ((tex (new Image-Texture width height min-filter: min-filter mag-filter: mag-filter wrap: wrap parameters: parameters mipmap?: mipmap?)))
                      (map-texture-array~ tex (sort < (table-values images) key: fourth) repeat?: repeat?)
                      (for-each (lambda (name)
                                  (bind (surface image-width image-height depth) (table-ref images name #f)
                                    (table-set! images name (uv (normalize-x padding width)
                                                                (normalize-y padding height)
                                                                (normalize-x (- image-width padding) width)
                                                                (normalize-y (- image-height padding) height)
                                                                (cast <fl> depth)))
                                    (close~ surface)))
                                (table-keys images))
                      (set! texture tex)
                      (set! uniform? #f)))))
            (if (= count 1)
                (let ((name (car (table-keys images))))
                  (let ((image (car (table-ref images name))))
                    (table-set! images name (uv 0. 0. 1. 1. 0.))
                    (let ((surf (get-handle~ image)))
                      (let ((width (cairo_image_surface_get_width surf))
                            (height (cairo_image_surface_get_height surf))
                            (data (cairo_image_surface_get_data surf)))
                        (let ((tex (new Image-Texture width height data: data mipmap?: mipmap?)))
                          (map-texture~ tex repeat?: repeat?)
                          (set! texture tex)
                          (set! uniform? #t))))
                    (close~ image)))
              (let ((surface (new Surface (cairo_image_surface_create CAIRO_FORMAT_ARGB32 width height))))
                (for-each (lambda (name)
                            (bind (image rect depth) (table-ref images name #f)
                              (if (not pad?)
                                  (blit-surface~ surface image destination: (rect-position rect))
                                (pad-image surface image (rect-width rect) (rect-height rect) rect))
                              (close~ image)
                              (table-set! images name (uv (normalize-x (get-left~ rect) width)
                                                          (normalize-y (get-top~ rect) height)
                                                          (normalize-x (get-right~ rect) width)
                                                          (normalize-y (get-bottom~ rect) height)
                                                          (cast <fl> depth)))))
                          (table-keys images))
                
                (let ((tex (new Cairo-Texture width height surface: surface mipmap?: mipmap?)))
                  (map-texture~ tex repeat?: repeat?)
                  (set! texture tex)
                  (set! uniform? #f))))))))
    
    @wait-non-uniform-size-is-really-slow-on-mac
    (define (complete-bounds)
      (assert (<= depth 384))
      (let ((vec (make-f32vector (* depth 4))))
        (iterate-table images
          (lambda (name uv)
            (let ((offset (* (fxfloor (uv-depth uv)) 4)))
              (f32vector-set! vec offset (uv-left uv))
              (f32vector-set! vec (+ offset 1) (uv-top uv))
              (f32vector-set! vec (+ offset 2) (uv-right uv))
              (f32vector-set! vec (+ offset 3) (uv-bottom uv)))))
        (set! bounds vec)))
    
    (complete-texture)
    @wait-non-uniform-size-is-really-slow-on-mac
    (complete-bounds))))
