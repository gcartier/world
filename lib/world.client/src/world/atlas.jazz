;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Texture Atlas
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.atlas jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.io)
        (jazz.platform.cairo)
        (world.asset)
        (world.image)
        (world.settings)
        (world.support)
        (world.syntax (phase syntax))
        (world.texture))


;;;
;;;; Atlas
;;;


(definition default-padding
  100)

(definition width-threshold
  3500)


(definition warn-already-registered?
  #f)


(class Atlas extends Object
  
  
  (slot repeat?                                                      getter generate)
  (slot pad?                                                         getter generate)
  (slot padding                 initialize 0                         getter generate)
  (slot files                   initialize (make-table test: equal?) getter generate)
  (slot images                  initialize (make-table test: equal?) getter generate)
  (slot coordinates             initialize (make-table test: equal?) getter generate)
  (slot depth                   initialize 0                         getter generate)
  (slot h                       initialize 0                         getter generate)
  (slot v                       initialize 0                         getter generate)
  (slot width                   initialize 0                         getter generate)
  (slot height                  initialize 0                         getter generate)
  (slot texture                 initialize #f                        getter generate)
  (slot bounds     <f32vector+> initialize #f                        getter generate)
  
  
  (method override (initialize (repeat?: repeat? #f) (pad?: pad? #t))
    (let ((repeat? (and repeat? (get-texture-arrays?))))
      (let ((pad? (and pad? (not repeat?))))
        (set! repeat?~self repeat?)
        (set! pad?~self pad?)
        (set! padding~self (if (and pad? (not (get-texture-arrays?))) default-padding 0))
        (set! h~self padding)
        (set! v~self padding))))
  
  
  (method override (destroy)
    (when texture
      (destroy~ texture)
      (set! texture #f))
    (nextmethod))
  
  
  (method public (image-names)
    (sort di<? (table-keys coordinates)))
  
  
  (method public (image-rect name)
    (or (table-ref coordinates name #f)
        (error "Unable to find image: {s}" name)))
  
  
  (method public (image-file name)
    (or (table-ref files name #f)
        (error "Unable to find image: {s}" name)))
  
  
  (method public (get-image name)
    (table-ref images name))
  
  
  (method public (add-surface name surface image-width image-height)
    (if (table-ref images name #f)
        (when warn-already-registered?
          (debug 'name 'already 'registered name))
      (table-set! images name (list surface image-width image-height depth))
      (when (> image-width width)
        (set! width image-width))
      (when (> image-height height)
        (set! height image-height))
      (increase! depth)))
  
  
  (method public (add-file file)
    (assert (exists?~ file))
    (let ((name (get-base~ file)))
      (if (table-ref images name #f)
          (when warn-already-registered?
            (debug 'name 'already 'registered name))
        (receive (image-width image-height surf) (cairo-surface-from-file file)
          (cond ((get-texture-arrays?)
                 (table-set! files name file)
                 (table-set! images name (list (new Surface surf) image-width image-height depth))
                 (increase! depth))
                (else
                 (let ((right (+ h image-width))
                       (bottom (+ v image-height)))
                   (table-set! files name file)
                   (table-set! images name (list (new Surface surf) (new Rect h v right bottom) depth))
                   (let ((right (+ right padding))
                         (bottom (+ bottom padding)))
                     (when (> right width)
                       (set! width right))
                     (when (> bottom height)
                       (set! height bottom))
                     (if (< right width-threshold)
                         (set! h (+ right padding))
                       (set! h padding)
                       (set! v (+ height padding))))
                   (increase! depth))))))))
  
  
  (method public (add-asset asset)
    (let ((name (get-base~ asset)))
      (if (table-ref images name #f)
          (when warn-already-registered?
            (debug 'name 'already 'registered name))
        (receive (image-width image-height image) (read-image asset)
          (cond ((get-texture-arrays?)
                 (table-set! files name (make-brother~ asset "png"))
                 (table-set! images name (list (if (u8vector? image) image (new Surface image)) image-width image-height depth))
                 (increase! depth))
                (else
                 (let ((right (+ h image-width))
                       (bottom (+ v image-height)))
                   (table-set! files name (make-brother~ asset "png"))
                   (table-set! images name (list (if (u8vector? image) image (new Surface image)) (new Rect h v right bottom) depth))
                   (let ((right (+ right padding))
                         (bottom (+ bottom padding)))
                     (when (> right width)
                       (set! width right))
                     (when (> bottom height)
                       (set! height bottom))
                     (if (< right width-threshold)
                         (set! h (+ right padding))
                       (set! h padding)
                       (set! v (+ height padding))))
                   (increase! depth))))))))
  
  
  (method public (add-directory dir)
    (iterate-directory~ dir
      (lambda (file)
        (when (member? (get-extension~ file) '("png" "tga") test: extension=?)
          (add-file file))
        files?: #t
        directories?: #f)))
  
  
  (method public (add-assets-directory assets path)
    (iterate-directory~ (make-directory~ assets path)
      (lambda (subpath kind)
        (when (member? (extract-extension (last subpath)) '("png" "tga") test: extension=?)
          (let ((subpath (append (butlast subpath) (list (extract-base (last subpath))))))
            (let ((asset (new Asset assets (append path subpath))))
              (add-asset asset)))))
      full?: #f
      files?: #t
      directories?: #f))
  
  
  (method public (add-assets-directory-if-exists assets path)
    (when (exists?~ (make-directory~ assets path))
      (add-assets-directory assets path)))
  
  
  (method public (extract-texture (min-filter: min-filter #f) (mag-filter: mag-filter #f) (wrap: wrap #f) (mipmap?: mipmap? #t) (warn-non-uniform?: warn-non-uniform? #f))
    (define (analyse-images)
      (let ((width #f)
            (height #f)
            (unif? #t))
        (iterate-table images
          (lambda (name info)
            (bind (surface image-width image-height depth) info
              (cond ((not width)
                     (set! width image-width)
                     (set! height image-height))
                    (else
                     (when (or (/= image-width width)
                               (/= image-height height))
                       (set! unif? #f)
                       (when warn-non-uniform?
                         (debug 'non-uniform 'texture 'size name image-width image-height depth))
                       (when (> image-width width)
                         (set! width image-width))
                       (when (> image-height height)
                         (set! height image-height))))))))
        (values width height unif?)))
    
    ;; improves mipmapping by tiling a border around the image
    (define (pad-image surface image image-width image-height rect)
      (let ((pos (rect-position rect))
            (size (rect-size rect)))
        (let ((h (get-h~ pos))
              (v (get-v~ pos))
              (width (get-width~ size))
              (height (get-height~ size)))
          (with-clip~ surface (inflate-rect rect padding padding)
            (lambda ()
              (let ((radius (fxceiling (/ (cast <fl> padding) (min image-width image-height)))))
                (loop (for j from (- radius) to radius)
                      (loop (for i from (- radius) to radius)
                            (blit-surface~ surface image destination: (new Point (+ h (* i width)) (+ v (* j height))))))))))))
    
    (define (normalize-x x width)
      (/ (cast <fl> x) (cast <fl> width)))
    
    (define (normalize-y y height)
      (/ (cast <fl> y) (cast <fl> height)))
    
    (let ((count (table-length images)))
      (if (= count 0)
          (error "Empty atlas")
        (if (get-texture-arrays?)
            (receive (width height unif?) (analyse-images)
              (if unif?
                  (let ((tex (new Image-Texture width height min-filter: min-filter mag-filter: mag-filter wrap: wrap mipmap?: mipmap?)))
                    (map-texture-array~ tex (sort < (table-values images) key: fourth) repeat?: repeat?)
                    (for-each (lambda (name)
                                (bind (surface width height depth) (table-ref images name #f)
                                  (table-set! coordinates name (uv 0.
                                                                   0.
                                                                   1.
                                                                   1.
                                                                   (cast <fl> depth)))))
                              (table-keys images))
                    (set! texture tex))
                (let ((width (+ padding width padding))
                      (height (+ padding height padding)))
                  (for-each (lambda (name)
                              (bind (image image-width image-height depth) (table-ref images name #f)
                                (let ((padded-width (+ padding image-width padding))
                                      (padded-height (+ padding image-height padding)))
                                  (let ((surface (new Surface (cairo_image_surface_create CAIRO_FORMAT_ARGB32 (if repeat? width padded-width) (if repeat? height padded-height))))
                                        (rect (new Rect padding padding (+ image-width padding) (+ image-height padding))))
                                    (if (not pad?)
                                        (let ((pos (rect-position rect)))
                                          (if (not repeat?)
                                              (blit-surface~ surface image destination: pos)
                                            (let (loop-vert (v (get-v~ pos)))
                                              (let (loop-horz (h (get-h~ pos)))
                                                (blit-surface~ surface image destination: (new Point h v))
                                                (let ((next-h (+ h image-width)))
                                                  (when (< next-h width)
                                                    (loop-horz next-h))))
                                              (let ((next-v (+ v image-height)))
                                                (when (< next-v height)
                                                  (loop-vert next-v))))))
                                      (pad-image surface image image-width image-height rect))
                                    (close~ image)
                                    (table-set! images name (list surface padded-width padded-height depth))))))
                            (table-keys images))
                  (let ((tex (new Image-Texture width height min-filter: min-filter mag-filter: mag-filter wrap: wrap mipmap?: mipmap?)))
                    (map-texture-array~ tex (sort < (table-values images) key: fourth) repeat?: repeat?)
                    (for-each (lambda (name)
                                (bind (surface image-width image-height depth) (table-ref images name #f)
                                  (table-set! coordinates name (uv (normalize-x padding width)
                                                                   (normalize-y padding height)
                                                                   (normalize-x (- image-width padding) width)
                                                                   (normalize-y (- image-height padding) height)
                                                                   (cast <fl> depth)))))
                              (table-keys images))
                    (set! texture tex)))))
          (if (= count 1)
              (let ((name (car (table-keys images))))
                (let ((image (car (table-ref images name))))
                  (table-set! coordinates name (uv 0. 0. 1. 1. 0.))
                  (let ((surf (get-handle~ image)))
                    (let ((width (cairo_image_surface_get_width surf))
                          (height (cairo_image_surface_get_height surf))
                          (data (cairo_image_surface_get_data surf)))
                      (let ((tex (new Image-Texture width height data: data mipmap?: mipmap?)))
                        (map-texture~ tex repeat?: repeat?)
                        (set! texture tex))))))
            (let ((surface (new Surface (cairo_image_surface_create CAIRO_FORMAT_ARGB32 width height))))
              (for-each (lambda (name)
                          (bind (image rect depth) (table-ref images name #f)
                            (if (not pad?)
                                (blit-surface~ surface image destination: (rect-position rect))
                              (pad-image surface image (rect-width rect) (rect-height rect) rect))
                            (table-set! coordinates name (uv (normalize-x (get-left~ rect) width)
                                                             (normalize-y (get-top~ rect) height)
                                                             (normalize-x (get-right~ rect) width)
                                                             (normalize-y (get-bottom~ rect) height)
                                                             (cast <fl> depth)))))
                        (table-keys images))
              
              (let ((tex (new Cairo-Texture width height surface: surface mipmap?: mipmap?)))
                (map-texture~ tex repeat?: repeat?)
                (set! texture tex)))))))
    texture)
  
  
  (method public (update-coordinates name uv)
    (assert (= (uv-depth (image-rect name)) (uv-depth uv)))
    (table-set! coordinates name uv))
  
  
  (method public (complete)
    @wait-non-uniform-size-is-really-slow-on-mac
    (define (complete-bounds)
      (assert (<= depth 384))
      (let ((vec (make-f32vector (* depth 4))))
        (iterate-table coordinates
          (lambda (name uv)
            (let ((offset (* (fxfloor (uv-depth uv)) 4)))
              (f32vector-set! vec offset (uv-left uv))
              (f32vector-set! vec (+ offset 1) (uv-top uv))
              (f32vector-set! vec (+ offset 2) (uv-right uv))
              (f32vector-set! vec (+ offset 3) (uv-bottom uv)))))
        (set! bounds vec)))
    
    (define (close-images)
      (iterate-table images
        (lambda (name info)
          (bind (image image-width image-height depth) info
            (unless (u8vector? image)
              (close~ image)))))
      (set! images #f))
    
    ;; already completed
    (unless (not images)
      (close-images)
      @wait-non-uniform-size-is-really-slow-on-mac
      (complete-bounds)))))
