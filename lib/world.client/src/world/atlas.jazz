;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Texture Atlas
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.atlas jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (world)
        (world.autoload)
        (world.foreign)
        (world.support)
        (world.syntax (phase syntax))
        (world.texture)
        (time))


(definition atlases
  (make-table test: eq?))


(definition public (register-atlas name atlas)
  (table-set! atlases name atlas))

(definition public (registered-atlas name)
  (table-ref atlases name #f))


;;;
;;;; Atlas
;;;


(definition default-padding
  100)

(definition width-threshold
  3500)


(class Atlas extends Object
  
  
  (slot min-filter                                      getter generate)
  (slot mag-filter                                      getter generate)
  (slot wrap                                            getter generate)
  (slot parameters                                      getter generate)
  (slot mipmap?                                         getter generate)
  (slot repeat?                                         getter generate)
  (slot pad?                                            getter generate)
  (slot padding    initialize 0                         getter generate)
  (slot files      initialize (make-table test: equal?) getter generate)
  (slot images     initialize (make-table test: equal?) getter generate)
  (slot depth      initialize 0                         getter generate)
  (slot h          initialize 0                         getter generate)
  (slot v          initialize 0                         getter generate)
  (slot width      initialize 0                         getter generate)
  (slot height     initialize 0                         getter generate)
  (slot texture    initialize #f                        getter generate)
  (slot bounds     initialize #f                        getter generate)
  
  
  (method override (initialize (min-filter: min-filter #f) (mag-filter: mag-filter #f) (wrap: wrap #f) (parameters: parameters #f) (mipmap?: mipmap? #t) (repeat?: repeat? #f) (pad?: pad? #t))
    (let ((pad? (and pad? (not repeat?))))
      (set! min-filter~self min-filter)
      (set! mag-filter~self mag-filter)
      (set! wrap~self wrap)
      (set! parameters~self parameters)
      (set! mipmap?~self mipmap?)
      (set! repeat?~self (and repeat? (get-texture-arrays?)))
      (set! pad?~self pad?)
      (set! padding~self (if pad? default-padding 0))
      (set! h~self padding)
      (set! v~self padding)))
  
  
  (method override (destroy)
    (when texture
      (destroy~ texture)
      (set! texture #f))
    (nextmethod))
  
  
  (method public (image-names)
    (sort di<? (table-keys images)))
  
  
  (method public (image-rect name)
    (or (table-ref images name #f)
        (error "Unable to find image: {s}" name)))
  
  
  (method public (image-file name)
    (or (table-ref files name #f)
        (error "Unable to find image: {s}" name)))
  
  
  (method public (add-surface surface image-width image-height depth)
    (table-set! images depth (list surface image-width image-height depth))
    (when (> image-width width)
      (set! width image-width))
    (when (> image-height height)
      (set! height image-height)))
  
  
  (method public (add-file file)
    (let ((name (get-base~ file)))
      (unless (table-ref images name #f)
        (receive (image-width image-height surf) (cairo-surface-from-file file)
          (cond ((get-texture-arrays?)
                 (table-set! files name file)
                 (table-set! images name (list (new Surface surf) image-width image-height depth))
                 (increase! depth))
                (else
                 (let ((right (+ h image-width))
                       (bottom (+ v image-height)))
                   (table-set! files name file)
                   (table-set! images name (list (new Surface surf) (new Rect h v right bottom) depth))
                   (let ((right (+ right padding))
                         (bottom (+ bottom padding)))
                     (when (> right width)
                       (set! width right))
                     (when (> bottom height)
                       (set! height bottom))
                     (if (< right width-threshold)
                         (set! h (+ right padding))
                       (set! h padding)
                       (set! v (+ height padding))))
                   (increase! depth))))))))
  
  
  (method public (add-directory dir)
    (iterate-directory~ dir
      (lambda (file)
        (when (member? (get-extension~ file) '("png" "tga") test: extension=?)
          (add-file file))
        files?: #t
        directories?: #f)))
  
  
  (method public (add-directory-if-exists dir)
    (when (exists?~ dir)
      (add-directory dir)))
  
  
  (method public (complete)
    (define (analyse-images)
      (let ((width #f)
            (height #f)
            (uniform? #t))
        (iterate-table images
          (lambda (name info)
            (bind (surface image-width image-height depth) info
              (cond ((not width)
                     (set! width image-width)
                     (set! height image-height))
                    (else
                     (when (or (/= image-width width)
                               (/= image-height height))
                       (set! uniform? #f)
                       (when (> image-width width)
                         (set! width image-width))
                       (when (> image-height height)
                         (set! height image-height))))))))
        (values width height uniform?)))
    
    ;; improves mipmapping by tiling a border around the image
    (define (pad-image surface image image-width image-height rect)
      (let ((pos (rect-position rect))
            (size (rect-size rect)))
        (let ((h (get-h~ pos))
              (v (get-v~ pos))
              (width (get-width~ size))
              (height (get-height~ size)))
          (with-clip~ surface (inflate-rect rect padding padding)
            (lambda ()
              (let ((radius (fxceiling (/ (cast <fl> padding) (min image-width image-height)))))
                (loop (for j from (- radius) to radius)
                      (loop (for i from (- radius) to radius)
                            (blit-surface~ surface image destination: (new Point (+ h (* i width)) (+ v (* j height))))))))))))
    
    (define (normalize-x x width)
      (/ (cast <fl> x) (cast <fl> width)))
    
    (define (normalize-y y height)
      (/ (cast <fl> y) (cast <fl> height)))
    
    (define (complete-texture)
      (let ((count (table-length images)))
        (if (= count 0)
            (error "Empty atlas")
          (if (get-texture-arrays?)
              (receive (width height uniform?) (analyse-images)
                (if uniform?
                    (let ((tex (new Image-Texture width height min-filter: min-filter mag-filter: mag-filter wrap: wrap parameters: parameters mipmap?: mipmap?)))
                      (map-textures~ tex (sort < (table-values images) key: fourth) repeat?: repeat?)
                      (for-each (lambda (name)
                                  (bind (surface width height depth) (table-ref images name #f)
                                    (table-set! images name (uv 0.
                                                                0.
                                                                1.
                                                                1.
                                                                (cast <fl> depth)))
                                    (close~ surface)))
                                (table-keys images))
                      (set! texture tex))
                  (let ((width (+ padding width padding))
                        (height (+ padding height padding)))
                    (for-each (lambda (name)
                                (bind (image image-width image-height depth) (table-ref images name #f)
                                  (let ((padded-width (+ padding image-width padding))
                                        (padded-height (+ padding image-height padding)))
                                    (let ((surface (new Surface (cairo_image_surface_create CAIRO_FORMAT_ARGB32 (if repeat? width padded-width) (if repeat? height padded-height))))
                                          (rect (new Rect padding padding (+ image-width padding) (+ image-height padding))))
                                      (if (not pad?)
                                          (let ((pos (rect-position rect)))
                                            (if (not repeat?)
                                                (blit-surface~ surface image destination: pos)
                                              (let (loop-vert (v (get-v~ pos)))
                                                (let (loop-horz (h (get-h~ pos)))
                                                  (blit-surface~ surface image destination: (new Point h v))
                                                  (let ((next-h (+ h image-width)))
                                                    (when (< next-h width)
                                                      (loop-horz next-h))))
                                                (let ((next-v (+ v image-height)))
                                                  (when (< next-v height)
                                                    (loop-vert next-v))))))
                                        (pad-image surface image image-width image-height rect))
                                      (close~ image)
                                      (table-set! images name (list surface padded-width padded-height depth))))))
                              (table-keys images))
                    (let ((tex (new Image-Texture width height min-filter: min-filter mag-filter: mag-filter wrap: wrap parameters: parameters mipmap?: mipmap?)))
                      (map-textures~ tex (sort < (table-values images) key: fourth) repeat?: repeat?)
                      (for-each (lambda (name)
                                  (bind (surface image-width image-height depth) (table-ref images name #f)
                                    (table-set! images name (uv (normalize-x padding width)
                                                                (normalize-y padding height)
                                                                (normalize-x (- image-width padding) width)
                                                                (normalize-y (- image-height padding) height)
                                                                (cast <fl> depth)))
                                    (close~ surface)))
                                (table-keys images))
                      (set! texture tex)))))
            (if (= count 1)
                (let ((name (car (table-keys images))))
                  (let ((image (car (table-ref images name))))
                    (table-set! images name (uv 0. 0. 1. 1. 0.))
                    (let ((surf (get-handle~ image)))
                      (let ((width (cairo_image_surface_get_width surf))
                            (height (cairo_image_surface_get_height surf))
                            (data (cairo_image_surface_get_data surf)))
                        (let ((tex (new Image-Texture width height data: data mipmap?: mipmap?)))
                          (map-texture~ tex repeat?: repeat?)
                          (set! texture tex))))
                    (close~ image)))
              (let ((surface (new Surface (cairo_image_surface_create CAIRO_FORMAT_ARGB32 width height))))
                (for-each (lambda (name)
                            (bind (image rect depth) (table-ref images name #f)
                              (if (not pad?)
                                  (blit-surface~ surface image destination: (rect-position rect))
                                (pad-image surface image (rect-width rect) (rect-height rect) rect))
                              (close~ image)
                              (table-set! images name (uv (normalize-x (get-left~ rect) width)
                                                          (normalize-y (get-top~ rect) height)
                                                          (normalize-x (get-right~ rect) width)
                                                          (normalize-y (get-bottom~ rect) height)
                                                          (cast <fl> depth)))))
                          (table-keys images))
                
                (let ((tex (new Cairo-Texture width height surface: surface mipmap?: mipmap?)))
                  (map-texture~ tex repeat?: repeat?)
                  (set! texture tex))))))))
    
    (define (complete-bounds)
      (assert (<= depth 512))
      (let ((vec (make-f32vector (* depth 4))))
        (iterate-table images
          (lambda (name uv)
            (let ((offset (* (fxfloor (uv-depth uv)) 4)))
              (f32vector-set! vec offset (uv-left uv))
              (f32vector-set! vec (+ offset 1) (uv-top uv))
              (f32vector-set! vec (+ offset 2) (uv-right uv))
              (f32vector-set! vec (+ offset 3) (uv-bottom uv)))))
        (set! bounds vec)))
    
    (complete-texture)
    (complete-bounds))))
