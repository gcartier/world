;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Texture Atlas
;;;


(module world.atlas jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (world)
        (world.foreign)
        (world.texture)
        (time))


;;;
;;;; Atlas
;;;


(definition default-padding
  100)

(definition width-threshold
  2000)


(class Atlas extends Object
  
  
  (slot mipmap? initialize #t                        getter generate)
  (slot pad?    initialize #t                        getter generate)
  (slot padding initialize 0                         getter generate)
  (slot files   initialize (make-table test: equal?) getter generate)
  (slot images  initialize (make-table test: equal?) getter generate)
  (slot h       initialize 0                         getter generate)
  (slot v       initialize 0                         getter generate)
  (slot width   initialize 0                         getter generate)
  (slot height  initialize 0                         getter generate)
  (slot texture initialize #f                        getter generate)
  
  
  (method override (initialize (mipmap?: mipmap? #t) (pad?: pad? #t))
    (set! mipmap?~self mipmap?)
    (set! pad?~self pad?)
    (set! padding~self (if pad? default-padding 0))
    (set! h~self padding)
    (set! v~self padding))
  
  
  (method public (image-names)
    (sort di<? (table-keys images)))
  
  
  (method public (image-rect name)
    (or (table-ref images name #f)
        (error "Unable to find image: {s}" name)))
  
  
  (method public (image-file name)
    (or (table-ref files name #f)
        (error "Unable to find image: {s}" name)))
  
  
  (method public (add-file file)
    (let ((name (get-base~ file)))
      (receive (image-width image-height surf) (cairo-surface-from-file file)
        (let ((right (+ h image-width))
              (bottom (+ v image-height)))
          (table-set! files name file)
          (table-set! images name (cons (new Surface surf) (new Rect h v right bottom)))
          (let ((right (+ right padding))
                (bottom (+ bottom padding)))
            (when (> right width)
              (set! width right))
            (when (> bottom height)
              (set! height bottom))
            (if (< right width-threshold)
                (set! h (+ right padding))
              (set! h padding)
              (set! v (+ height padding))))))))
  
  
  (method public (add-directory dir)
    (iterate-directory~ dir
      (lambda (file)
        (when (extension=? (get-extension~ file) "png")
          (add-file file))
        files?: #t
        directories?: #f)))
  
  
  (method public (add-directory-if-exists dir)
    (when (exists?~ dir)
      (add-directory dir)))
  
  
  (method public (complete)
    (define (blit-images surface)
      (for-each (lambda (name)
                  (bind (image . rect) (table-ref images name #f)
                    ;; improve mipmapping by tiling a border around the image
                    (let ((pos (rect-position rect))
                          (size (rect-size rect)))
                      (let ((h (get-h~ pos))
                            (v (get-v~ pos))
                            (width (get-width~ size))
                            (height (get-height~ size)))
                        (if (not pad?)
                            (blit-surface~ surface image destination: pos)
                          (with-clip~ surface (inflate-rect rect padding padding)
                            (lambda ()
                              (blit-surface~ surface image destination: (new Point (- h width) (- v height)))
                              (blit-surface~ surface image destination: (new Point h (- v height)))
                              (blit-surface~ surface image destination: (new Point (+ h width) (- v height)))
                              (blit-surface~ surface image destination: (new Point (- h width) v))
                              (blit-surface~ surface image destination: (new Point (+ h width) v))
                              (blit-surface~ surface image destination: (new Point (- h width) (+ v height)))
                              (blit-surface~ surface image destination: (new Point h (+ v height)))
                              (blit-surface~ surface image destination: (new Point (+ h width) (+ v height)))
                              (blit-surface~ surface image destination: pos))))))
                    (table-set! images name (new Rect$fl$
                                              (normalize-x (get-left~ rect))
                                              (normalize-y (get-top~ rect))
                                              (normalize-x (get-right~ rect))
                                              (normalize-y (get-bottom~ rect))))))
                (table-keys images)))
    
    (define (normalize-x x)
      (/ (cast <fl> x) (cast <fl> width)))
    
    (define (normalize-y y)
      (/ (cast <fl> y) (cast <fl> height)))
    
    (case (table-length images)
      ((0) (error "Empty atlas"))
      ((1) (let ((name (car (first (table->list images)))))
             (let ((image (car (table-ref images name))))
               (table-set! images name (new Rect$fl$ 0. 0. 1. 1.))
               (let ((surf (get-handle~ image)))
                 (let ((width (cairo_image_surface_get_width surf))
                       (height (cairo_image_surface_get_height surf))
                       (data (cairo_image_surface_get_data surf)))
                   ;; not sure if destroying the surface releases the data
                   ;; (close~ image)
                   (let ((tex (new Image-Texture width height data: data mipmap?: mipmap?)))
                     (map-texture~ tex)
                     (set! texture tex)))))))
      (else (let ((surface (new Surface (cairo_image_surface_create CAIRO_FORMAT_ARGB32 width height))))
              (blit-images surface)
              (let ((tex (new Cairo-Texture width height surface: surface mipmap?: mipmap?)))
                (map-texture~ tex)
                (set! texture tex))))))))
