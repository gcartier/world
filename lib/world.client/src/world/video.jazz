;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Video
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.video jazz


(import (jazz.cairo)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.io)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (jazz.view)
        (jazz.window)
        (world)
        (world.autoload)
        (world.configure)
        (world.console)
        (world.context)
        (world.entity)
        (world.event)
        (world.foreign)
        (world.geometry)
        (world.hook)
        (world.id)
        (world.interface)
        (world.interface.sheet)
        (world.io)
        (world.layout)
        (world.pane)
        (world.quad-texture)
        (world.settings)
        (world.stream)
        (world.task)
        (world.texture)
        (world.time))


(definition protected self-resolution
  (world-setting 'world.self-resolution {Dimension 640 360}))


(definition protected video-resolution
  (world-setting 'world.video-resolution {Dimension 640 360}))

(definition protected video-framerate
  (world-setting 'world.video-framerate 15))

(definition protected video-bitrate
  (world-setting 'world.video-bitrate 1024))

(definition protected video-key-period
  (world-setting 'world.video-key-period #f))

(definition protected video-pass
  (world-setting 'world.video-pass #f))

(definition protected video-alpha
  (world-setting 'world.video-alpha 1.0 @wait 0.6))

(definition protected video-overlay?
  (world-setting 'world.video-overlay? #f))

(definition protected video-codec
  (world-setting 'world.video-codec 'h264))


(definition layouts
  '(;;overhead
    sidebar
    gallery
    fullscreen))

(definition public video-layout
  (world-setting 'world.video-layout 'sidebar @currently-buggy-when-we-cycle 'overhead))


(definition public video-mode
  'fit)

(definition public (set-video-mode mode)
  (let ((video (current-video)))
    (set! video-mode mode)
    (layout-outputs video)
    (invalidate-interface)))


(definition video-show
  (world-setting 'world.video-show #f))


(definition draw-refresh
  (world-setting 'world.draw-refresh 1.))


(definition slide-duration
  (world-setting 'world.slide-duration .2))


;;;
;;;; Kush
;;;


(definition public (kush-gauge width height rate motion)
  (/ (* width height rate motion 0.07) 1000.))


;;;
;;;; Access
;;;


(definition public (get-video-layout)
  video-layout)

(definition public (set-video-layout layout)
  (set! video-layout layout))


;; first four bytes are always 00 00 00 01
(definition protected (video-buffer-header? buffer)
  (let ((pos 5))
    (and (< pos (u8vector-length buffer))
         (= (u8vector-ref buffer pos) 16))))


;;;
;;;; Video
;;;


(class World-Video extends Object
  
  
  (slot outputs           getter generate)
  (slot ordered-outputs   getter generate)
  ;; quicky to test
  (slot extra-outputs     getter generate)
  (slot fullscreen-output accessors generate)
  (slot self-output       getter generate)
  (slot render-hook       accessors generate)
  
  
  (method override (initialize self)
    (nextmethod self)
    (set! self.outputs (make-table test: equal?))
    (set! ordered-outputs '())
    (set! extra-outputs '())
    (set! fullscreen-output #f)
    (set! self-output #f)
    (set! render-hook #f))
  
  
  (method package (resize self)
    (iterate-table outputs
      (lambda (id output)
        (resize output)))
    (layout-outputs self))
  
  
  ;; kind of hack because of an import conflict
  (method (video-layout-ref self)
    video-layout)
  
  
  ;;;
  ;;;; Outputs
  ;;;
  
  
  (method package (find-output self id)
    (table-ref outputs id #f))
  
  (method package (register-output self id output)
    (table-set! outputs id output))
  
  
  (method package (output-self? self output)
    (not (get-id output)))
  
  (method package (ordered-output self n)
    (element ordered-outputs n))
  
  (method package (ordered-output-self? self n)
    (output-self? self (ordered-output self n)))
  
  (method package (pane->output self pane)
    (find-if (lambda (output)
               (and (is? output Circle-Video-Sink)
                    (eq? (get-pane output) pane)))
             ordered-outputs))
  
  (method package (pane->output-rank self pane)
    (let ((output (pane->output self pane)))
      (and output
           (find-rank output ordered-outputs))))
  
  
  ;; quicky for tests
  (method package (register-extra-output self output)
    (set! extra-outputs (cons output extra-outputs)))
  ;; quicky for tests
  (method package (unregister-extra-output self output)
    (set! extra-outputs (remove output extra-outputs)))
  
  
  (method package (entity-output self id (position: position #f) (size: size #f) (resolution: resolution #f) (codec: codec #f))
    (or (table-ref outputs id #f)
        (let ((entity (find-entity id)))
          (let ((output (new Draw-Video-Sink entity
                             resolution: (or resolution {Dimension 1280 720})
                             framerate: video-framerate
                             bitrate: video-bitrate
                             codec: (or codec video-codec)
                             alpha-overlay: video-alpha
                             overlay?: video-overlay?)))
            (table-set! outputs id output)
            (play output)
            output))))
  
  
  (method package (player-output self id (player: player #f) (position: position #f) (size: size #f) (resolution: resolution #f) (codec: codec #f))
    (define (add-output output)
      (if #f @wait-for-circle-tests (and self-output (neq? output self-output))
          ;; reposition so self output is always last
          (set! ordered-outputs (append! (remove! self-output ordered-outputs) (list output self-output)))
        (set! ordered-outputs (append! ordered-outputs (list output)))))
    
    (or (table-ref outputs id #f)
        ;; the or is a quick hack to test self video
        (let ((player (or player (find-entity id))))
          (let ((output (case video-layout
                          ((overhead)
                           (new Overhead-Video-Sink
                             player
                             resolution: (or resolution video-resolution)
                             framerate: video-framerate
                             bitrate: video-bitrate
                             codec: (or codec video-codec)
                             alpha-overlay: video-alpha
                             overlay?: video-overlay?))
                          (else
                           (new Circle-Video-Sink
                             id
                             player
                             position: position
                             size: size
                             resolution: (if (not id) self-resolution (or resolution video-resolution))
                             framerate: video-framerate
                             bitrate: video-bitrate
                             codec: (or codec video-codec)
                             alpha-overlay: video-alpha
                             overlay?: video-overlay?
                             needs-layout?: #t
                             process?: (boolean id))))))
            (table-set! outputs id output)
            (when (not id)
              (set! self-output output))
            (add-output output)
            (play output)
            output))))
  
  
  (method package (visualizer-output self position size)
    (let ((output (new Sheet-Video-Sink
                    #f
                    #f
                    position: position
                    size: size
                    resolution: self-resolution
                    framerate: video-framerate
                    bitrate: video-bitrate
                    codec: video-codec
                    alpha-overlay: video-alpha
                    overlay?: video-overlay?
                    process?: #t)))
      (play output)
      output))
  
  
  (method package (close-output self id output (layout?: layout? #t))
    (table-clear outputs id)
    (set! ordered-outputs (remove! output ordered-outputs))
    (set! extra-outputs (remove! output extra-outputs))
    (when (eq? output self-output)
      (set! self-output #f))
    (when (eq? output fullscreen-output)
      (set! fullscreen-output #f))
    (release output)
    (when layout?
      (update-layouts self)))
  
  
  (method package (effective-fullscreen-output self)
    (or fullscreen-output
        (and (not-null? ordered-outputs)
             (car ordered-outputs))))
  
  
  (method package (receive-server-video self id buffer timestamp duration)
    (let ((output (find-output self id)))
      (when output
        (if (not buffer)
            (set-stream-state output 'off)
          (when (eq? (get-stream-state output) 'off)
            (set-stream-state output 'on))
          (consume output buffer timestamp duration)
          (record-event udp-id-sink-media
                        (fixnum->flonum client-no)
                        (fixnum->flonum world.udp:udp-video)
                        -1.
                        -1.
                        -1.
                        (timestamp->flonum timestamp))))))
  
  
  (method package (receive-visualizer-video self output buffer timestamp duration)
    (if (not buffer)
        (set-stream-state output 'off)
      (when (eq? (get-stream-state output) 'off)
        (set-stream-state output 'on))
      (consume output buffer timestamp duration)))
  
  
  (method package (receive-video self id/output buffer timestamp duration)
    (if (is? id/output Video-Sink)
        (receive-visualizer-video self id/output buffer timestamp duration)
      (receive-server-video self id/output buffer timestamp duration)))
  
  
  (method package (receive-processor-draw self id color alpha timestamp duration background slide?)
    (if (not color)
        (let ((output (find-output self id)))
          (when output
            (close-output self id output)))
      (let ((output (entity-output self id)))
        (set-background output background)
        (if (not slide?)
            (consume output color timestamp duration alpha)
          (let ((texture (get-texture (cache-quad-texture (get-pane output)))))
            (with-slide output texture
              (lambda ()
                (consume output color timestamp duration alpha))))))))
  
  
  (method package (render-outputs self)
    (unless (and render-hook
                 (render-hook self))
      (if (eq? video-layout 'fullscreen)
          (let ((fullscreen-output (effective-fullscreen-output self)))
            (when fullscreen-output
              (render fullscreen-output)))
        ;; use ordered-outputs so order is stable
        (for-each render ordered-outputs)
        (for-each render extra-outputs))))
  
  
  (method package (render-minis self)
    (unless (and render-hook
                 (render-hook self))
      (when (eq? video-layout 'fullscreen)
        (let ((fullscreen-output (effective-fullscreen-output self)))
          (for-each (lambda (output)
                      (unless (eq? output fullscreen-output)
                        (render output)))
                    ordered-outputs)))))
  
  
  ;;;
  ;;;; Layout
  ;;;
  
  
  (method (on-cycle-layouts self evt)
    (let ((world (current-world)))
      (cycle-layouts self)
      (display-message world (capitalize (symbol->string video-layout)))))
  
  
  (method (cycle-layouts self)
    (case video-layout
      ((overhead)
       (sidebar-layout self))
      ((sidebar)
       (gallery-layout self))
      ((gallery)
       (fullscreen-layout self))
      ((fullscreen)
       (overhead-layout self))
      ((circle)
       (circle-layout self))))
  
  
  (method protected (update-layouts self)
    (case video-layout
      ((overhead)
       (overhead-layout self))
      ((sidebar)
       (sidebar-layout self))
      ((gallery)
       (gallery-layout self))
      ((fullscreen)
       (fullscreen-layout self))
      ((circle)
       (circle-layout self))))
  
  
  (method (stop-renders self)
    (let ((zone (current-zone)))
      (for-each (lambda (player)
                  (let ((elem (get-camera-pane player)))
                    (when elem
                      (set-render? elem #f))))
                (get-players zone))))
  
  
  (method package (overhead-layout self)
    (stop-renders self)
    (set! video-layout 'overhead)
    (layout-outputs self))
  
  
  (method package (sidebar-layout self)
    (stop-renders self)
    (set! video-layout 'sidebar)
    (layout-outputs self))
  
  
  (method package (gallery-layout self)
    (set! video-layout 'gallery)
    (layout-outputs self))
  
  
  (method package (fullscreen-layout self)
    (set! video-layout 'fullscreen)
    (layout-outputs self))
  
  
  (method package (layout-outputs self)
    (when (not-null? ordered-outputs)
      (let ((rectangles (layout self (length ordered-outputs))))
        (when rectangles
          (for-each (lambda (output rect)
                      ;; quick hacks to test self video
                      (let ((player (or (get-player output) (current-me))))
                        (let ((elem (get-camera-pane player)))
                          (if (not rect)
                              (when elem
                                (set-render? elem #f))
                            (when elem
                              (set-render? elem #t))
                            (move output rect)))))
                    ordered-outputs
                    rectangles)))))
  
  
  (method package (layout self num-players)
    (let ((window (current-window)))
      (let ((bounds (get-bounds window)))
        (let ((l (get-left bounds))
              (t (get-top bounds))
              (r (get-right bounds))
              (b (get-bottom bounds)))
          (define (adjust-fullscreen rect)
            (if (eq? video-mode 'fit)
                rect
              ;; fill mode
              (let ((ratio (fit-rects rect bounds 'fill)))
                (let ((new-width (fxround (* (cast <fl> (rect-width rect)) ratio)))
                      (new-height (fxround (* (cast <fl> (rect-height rect)) ratio))))
                  (let ((pos (center (new Dimension new-width new-height) (rect-size bounds))))
                    (let ((h (get-h pos))
                          (v (get-v pos)))
                      (new Rect h v (+ h new-width) (+ v new-height))))))))
          
          (case video-layout
            ((sidebar)
             (layout-tiles num-players (new Rect 10 70 210 (- b 100))))
            ((gallery)
             (if (= num-players 1)
                 (list (adjust-fullscreen (car (layout-tiles 1 bounds))))
               (reverse (layout-tiles num-players bounds))))
            ((fullscreen)
             (let ((width (if (> num-players 2) 224 288))
                   (height (if (> num-players 2) 126 162)))
               (let ((full (car (layout-tiles 1 bounds)))
                     (border 0))
                 (let ((r (- r border))
                       (fullscreen-output (effective-fullscreen-output self)))
                   (map (lambda (output)
                          (if (eq? output fullscreen-output)
                              (adjust-fullscreen full)
                            (prog1 (new Rect (- r width) (- b height) r b)
                              (decrease! r (+ width border)))))
                        ordered-outputs)))))
            (else
             #f))))))
  
  
  (method package (circle-layout self)
    (set! video-layout 'circle)
    (let ((count (length ordered-outputs)))
      (define (layout-default)
        (for-each (lambda (output rank)
                    (set-matrix (get-pane output) (default-circle-matrix count rank)))
                  ordered-outputs
                  (naturals 0 count)))
      
      (if layout-circle-hook
          (with-safe-hook layout-circle-hook
            (lambda (procedure)
              (let ((matrices (procedure ordered-outputs)))
                (for-each (lambda (output matrix)
                            (set-matrix (get-pane output) matrix))
                          ordered-outputs
                          matrices)))
            (lambda ()
              (layout-default)))
        (layout-default)))))


;;;
;;;; Video-Src
;;;


(class Video-Src extends Stream-Src
  
  
  (slot appsink               initialize #f accessors generate)
  (slot appsinkself           initialize #f accessors generate)
  (slot data     <u8vector+>  initialize #f accessors generate)
  (slot info     <u64vector+> initialize #f accessors generate)
  (slot task                  initialize #f accessors generate)
  (slot fifo                  initialize #f accessors generate)
  (slot selffifo              initialize #f accessors generate)
  
  
  (method package virtual (release-fifos self)
    (when fifo
      (release-stream-fifo fifo))
    (when selffifo
      (release-stream-fifo selffifo)))
  
  
  (method (task-start self name)
    (let ((procedure
            (lambda (task)
              (video-loop self task))))
      (let ((task (new Task name procedure priority: video-priority)))
        (start-task task)
        (set! self.task task))))
  
  
  (method (task-stop self)
    (release-fifos self)
    (stop-task task)
    (set! task #f))
  
  
  (method protected virtual (video-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-seconds)))
          ;; not 100% correct if preempted before task-mutex
          (let ((time (current-seconds)))
            (when (running? task)
              (site (video on?: #t)
                (let ((elapse (- time previous))
                      (max-elapse 10.))
                  ;; ignore ridiculous elapses like
                  ;; coming back from computer sleep
                  (unless (> elapse max-elapse)
                    (let ((history (current-history)))
                      (unless (get-paused? history)
                        (process self task exit)))))))
            (task-halt task exit)
            (iter time))))))
  
  
  (method override (process self task exit)
    (let ((size (gst_app_sink_wait task exit fifo appsink data info)))
      (let ((buffer (subu8vector data 0 size))
            (timestamp (u64vector-ref info 0))
            (duration (u64vector-ref info 1)))
        (when (and video-show
                   (or (eq? video-show 'all)
                       (eq? video-show 'header)
                       (>= size video-show)))
          ;; h264 specific
          (let ((type (if (video-buffer-header? buffer)
                          '***header***
                        'delta)))
            (if (eq? video-show 'header)
                (when (eq? type '***header***)
                  (terminal size type))
              (terminal size type))))
        (consume sink buffer timestamp duration)
        (record-event udp-id-src-media
                      (fixnum->flonum client-no)
                      (fixnum->flonum world.udp:udp-video)
                      -1.
                      (if (video-buffer-header? buffer) 1. -1.)
                      (fixnum->flonum size)
                      (timestamp->flonum timestamp))))
    (when appsinkself
      (let ((size (gst_app_sink_wait task exit selffifo appsinkself data info)))
        (let ((buffer (subu8vector data 0 size))
              (timestamp (u64vector-ref info 0))
              (duration (u64vector-ref info 1)))
          (consume sinkself buffer timestamp duration)
          (record-event udp-id-src-self
                        (fixnum->flonum client-no)
                        (fixnum->flonum world.udp:udp-video)
                        -1.
                        -1.
                        (fixnum->flonum size)
                        (timestamp->flonum timestamp))))))
  
  
  (method protected virtual (reset-media self)
    ))


;;;
;;;; Camera-Video-Src
;;;


(class Camera-Video-Src extends Video-Src
  
  
  (slot resolution initialize #f accessors generate)
  (slot framerate  initialize #f accessors generate)
  (slot bitrate    initialize #f accessors generate)
  (slot codec      initialize #f accessors generate)
  (slot pipeline   initialize #f accessors generate)
  (slot mutex                    getter generate)
  
  
  (method override (initialize self (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f))
    (nextmethod self)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec)
    (set! self.mutex (make-mutex 'camera)))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (get-width resolution))
          (height (get-height resolution))
          (self-width (get-width self-resolution))
          (self-height (get-height self-resolution))
          (fifo (make-stream-fifo "camera"))
          (selffifo (make-stream-fifo "cameraself")))
      (let ((pipeline (gst-launch (cond-expand
                                    (mac "avfvideosrc")
                                    (windows "ksvideosrc")
                                    (else "v4l2src"))
                                  (tie "videorate max-rate={framerate}")
                                  "videoscale"
                                  "videoconvert"
                                  ;; this tie is there so the camera knows what resolution to use
                                  (tie "video/x-raw, width=1280, height=720, pixel-aspect-ratio=(fraction)1/1")
                                  "tee name=tee"
                                  (list
                                    "tee."
                                    "queue"
                                    "videoscale"
                                    "videoconvert"
                                    (tie "video/x-raw, format=I420, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                    "valve name=valve"
                                    (and (eq? codec 'h264)
                                         (let ((key-int-max (and video-key-period (fxround (* (cast <fl> framerate) video-key-period))))
                                               (pass video-pass)
                                               (psy-tune #f)
                                               (quantizer #f)
                                               (bitrate bitrate)
                                               (tune "zerolatency")
                                               (speed-preset "superfast"))
                                           (gst-element "x264enc"
                                                        key-int-max: key-int-max
                                                        pass: pass
                                                        psy-tune: psy-tune
                                                        quantizer: quantizer
                                                        bitrate: bitrate
                                                        tune: tune
                                                        speed-preset: speed-preset
                                                        name: "enc")))
                                    "appsink name=sink")
                                  (list
                                    "tee."
                                    "queue"
                                    "videoscale"
                                    "videoconvert"
                                    (tie "video/x-raw, format=BGRA, width={self-width}, height={self-height}, pixel-aspect-ratio=(fraction)1/1")
                                    "videoflip video-direction=horiz"
                                    "appsink name=sinkself"))))
        (gst_object_set_name pipeline "camera")
        (let ((appsink (gst_bin_get_by_name pipeline "sink"))
              (appsinkself (gst_bin_get_by_name pipeline "sinkself"))
              (data (make-u8vector (* (max width self-width) (max height self-height) 4)))
              (info (make-u64vector 2)))
          (gst_app_sink_signal_new_sample appsink fifo)
          (gst_app_sink_signal_new_sample appsinkself selffifo)
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.data data)
          (set! self.info info)
          (set! self.pipeline pipeline)
          (set! self.fifo fifo)
          (set! self.selffifo selffifo)
          (set! self.appsink appsink)
          (set! self.appsinkself appsinkself)))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'camera)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! info #f)
    (set! data #f)
    (set! pipeline #f)
    (set! appsink #f)
    (consume sink #f #f #f)
    (close-stream-fifo fifo)
    (set! fifo #f)
    (when selffifo
      (close selffifo)
      (set! selffifo #f)))
  
  
  (method (with-mutex self thunk)
    (mutex-lock! mutex)
    (prog1 (thunk)
      (mutex-unlock! mutex)))
  
  
  (method package (send-camera-video self buffer timestamp duration)
    (with-mutex self
      (lambda ()
        (let ((tier (current-client)))
          (let ((channel-no (get-no (get-camera-channel tier)))
                (header? (and buffer (video-buffer-header? buffer))))
            (send-client-video tier channel-no buffer header? timestamp duration))))))
  
  
  (method override (reset-media self)
    (with-mutex self
      (lambda ()
        (when pipeline
          (let ((valve (gst_bin_get_by_name pipeline "valve"))
                (encoder (gst_bin_get_by_name pipeline "enc")))
            (g_object_set valve "drop" (g_value_int 1))
            (gst_element_set_state encoder GST_STATE_READY)
            (gst_element_set_state encoder GST_STATE_PLAYING)
            (g_object_set valve "drop" (g_value_int 0))))))))


;;;
;;;; Screen-Video-Src
;;;


(class Screen-Video-Src extends Video-Src
  
  
  (slot resolution initialize #f accessors generate)
  (slot framerate  initialize #f accessors generate)
  (slot bitrate    initialize #f accessors generate)
  (slot codec      initialize #f accessors generate)
  (slot pipeline   initialize #f accessors generate)
  
  
  (method override (initialize self (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f))
    (nextmethod self)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (get-width resolution))
          (height (get-height resolution))
          (fifo (make-stream-fifo "screen")))
      (let ((pipeline (gst-launch (cond-expand
                                    (mac "avfvideosrc capture-screen=true")
                                    (windows "dx9screencapsrc")
                                    (else "v4l2src"))
                                  (tie "videorate max-rate={framerate}")
                                  "videoscale"
                                  "videoconvert"
                                  ;; this tie is there so the camera knows what resolution to use
                                  (tie "video/x-raw, width=1280, height=720, pixel-aspect-ratio=(fraction)1/1")
                                  "videoscale"
                                  "videoconvert"
                                  (tie "video/x-raw, format=I420, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                  "valve name=valve"
                                  (and (eq? codec 'h264)
                                       (let ((key-int-max (and video-key-period (fxround (* (cast <fl> framerate) video-key-period))))
                                             (pass video-pass)
                                             (psy-tune #f)
                                             (quantizer #f)
                                             (bitrate bitrate)
                                             (tune "zerolatency")
                                             (speed-preset "superfast"))
                                         (gst-element "x264enc"
                                                      key-int-max: key-int-max
                                                      pass: pass
                                                      psy-tune: psy-tune
                                                      quantizer: quantizer
                                                      bitrate: bitrate
                                                      tune: tune
                                                      speed-preset: speed-preset
                                                      name: "enc")))
                                  "appsink name=sink")))
        (gst_object_set_name pipeline "screen")
        (let ((appsink (gst_bin_get_by_name pipeline "sink"))
              (data (make-u8vector (* width height 4)))
              (info (make-u64vector 2)))
          (gst_app_sink_signal_new_sample appsink fifo)
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.data data)
          (set! self.info info)
          (set! self.pipeline pipeline)
          (set! self.fifo fifo)
          (set! self.appsink appsink)))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'screen)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! info #f)
    (set! data #f)
    (set! pipeline #f)
    (set! appsink #f)
    (consume sink #f #f #f)
    (close-stream-fifo fifo)
    (set! fifo #f))
  
  
  (method (reset self)
    (when pipeline
      (let ((valve (gst_bin_get_by_name pipeline "valve"))
            (encoder (gst_bin_get_by_name pipeline "enc")))
        (g_object_set valve "drop" (g_value_int 1))
        (gst_element_set_state encoder GST_STATE_READY)
        (gst_element_set_state encoder GST_STATE_PLAYING)
        (g_object_set valve "drop" (g_value_int 0))))))


;;;
;;;; Test-Video-Src
;;;


(class Test-Video-Src extends Video-Src
  
  
  (slot resolution initialize #f accessors generate)
  (slot framerate  initialize #f accessors generate)
  (slot bitrate    initialize #f accessors generate)
  (slot codec      initialize #f accessors generate)
  (slot pipeline   initialize #f accessors generate)
  
  
  (method override (initialize self (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f))
    (nextmethod self)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (get-width resolution))
          (height (get-height resolution))
          (fifo (make-stream-fifo "test")))
      (let ((pipeline (gst-launch "videotestsrc"
                                  "videoscale"
                                  "videoconvert"
                                  (tie "video/x-raw, format=I420, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                  (and (eq? codec 'h264) (tie "x264enc pass=qual quantizer=20 bitrate={bitrate} tune=zerolatency speed-preset=superfast"))
                                  "appsink name=sink")))
        (gst_object_set_name pipeline "test")
        (let ((appsink (gst_bin_get_by_name pipeline "sink"))
              (data (make-u8vector (* width height 4)))
              (info (make-u64vector 2)))
          (gst_app_sink_signal_new_sample appsink fifo)
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.data data)
          (set! self.info info)
          (set! self.pipeline pipeline)
          (set! self.appsink appsink)))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'test)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! info #f)
    (set! data #f)
    (set! pipeline #f)
    (set! appsink #f)
    (consume sink #f #f #f)
    (close-stream-fifo fifo)
    (set! fifo #f)))


;;;
;;;; File-Video-Src
;;;


(class File-Video-Src extends Video-Src
  
  
  (slot location                initialize #f accessors generate)
  (slot resolution              initialize #f accessors generate)
  (slot framerate               initialize #f accessors generate)
  (slot bitrate                 initialize #f accessors generate)
  (slot codec                   initialize #f accessors generate)
  (slot pipeline                initialize #f accessors generate)
  (slot audio?                  initialize #t accessors generate)
  (slot audio-sink              initialize #f accessors generate)
  (slot audio-appsink           initialize #f accessors generate)
  (slot audio-data <u8vector+>  initialize #f accessors generate)
  (slot audio-info <u64vector+> initialize #f accessors generate)
  (slot audio-fifo              initialize #f accessors generate)
  
  
  (method override (initialize self location (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f) (audio?: audio? #t))
    (nextmethod self)
    (set! self.location location)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec)
    (set! self.audio? audio?))
  
  
  (method override (release-fifos self)
    (nextmethod self)
    (when audio-fifo
      (release-stream-fifo audio-fifo)))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (get-width resolution))
          (height (get-height resolution))
          (fifo (make-stream-fifo "file"))
          (audio-fifo (make-stream-fifo "fileaudio")))
      (let ((pipeline (gst-launch (tie "filesrc name=filesrc")
                                  "decodebin name=decoder"
                                  (and audio?
                                       (list "decoder."
                                             "queue"
                                             "audioconvert"
                                             "audioresample"
                                             (cond-expand
                                               (windows "audio/x-raw, format=S16LE, layout=interleaved, rate=48000, channels=1")
                                               (else "audio/x-raw, format=F32LE, layout=interleaved, rate=48000, channels=1"))
                                             "appsink name=audioappsink"))
                                  (list "decoder."
                                        "videoscale"
                                        "videoconvert"
                                        (tie "video/x-raw, format=I420, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                        "appsink name=appsink sync=false"))))
        (gst_object_set_name pipeline "file")
        (let ((filesrc (gst_bin_get_by_name pipeline "filesrc"))
              (appsink (gst_bin_get_by_name pipeline "appsink"))
              (data (make-u8vector (* width height 4)))
              (info (make-u64vector 2))
              (audio-appsink (and audio? (gst_bin_get_by_name pipeline "audioappsink")))
              (audio-data (and audio? (make-u8vector (* width height 4))))
              (audio-info (and audio? (make-u64vector 2))))
          (gst_app_sink_signal_new_sample appsink fifo)
          (gst_app_sink_signal_new_sample audio-appsink audio-fifo)
          (g_object_set_string filesrc "location" (path-normalize location))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.data data)
          (set! self.info info)
          (set! self.fifo fifo)
          (set! self.pipeline pipeline)
          (set! self.appsink appsink)
          (when audio?
            (set! self.audio-appsink audio-appsink)
            (set! self.audio-data audio-data)
            (set! self.audio-info audio-info)
            (set! self.audio-fifo audio-fifo))))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'file)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! info #f)
    (set! data #f)
    (set! pipeline #f)
    (set! appsink #f)
    (consume sink #f #f #f)
    (close-stream-fifo fifo)
    (set! fifo #f)
    (set! audio-info #f)
    (set! audio-data #f)
    (set! audio-appsink #f)
    (when audio-sink
      (consume audio-sink #f #f #f))
    (when audio-fifo
      (close-stream-fifo audio-fifo)
      (set! audio-fifo #f)))
  
  
  (method override (process self task exit)
    (nextmethod self task exit)
    (when audio-sink
      (let ((size (gst_app_sink_wait task exit audio-fifo audio-appsink audio-data audio-info)))
        (let ((buffer (subu8vector audio-data 0 size))
              (timestamp (u64vector-ref audio-info 0))
              (duration (u64vector-ref audio-info 1)))
          (consume audio-sink buffer timestamp duration))))))


;;;
;;;; File-Preprocess-Video-Src
;;;


(class File-Preprocess-Video-Src extends File-Video-Src
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (get-width resolution))
          (height (get-height resolution))
          (fifo (make-stream-fifo "preprocess")))
      (let ((pipeline (gst-launch (tie "filesrc name=filesrc")
                                  "decodebin"
                                  (and framerate (tie "videorate max-rate={framerate}"))
                                  "videoscale"
                                  "videoconvert"
                                  (tie "video/x-raw, format=I420, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                  (let ((bitrate bitrate)
                                        (tune "zerolatency")
                                        (speed-preset "superfast"))
                                    (gst-element "x264enc"
                                                 bitrate: bitrate
                                                 tune: tune
                                                 speed-preset: speed-preset
                                                 name: "enc"))
                                  "appsink name=appsink sync=false")))
        (gst_object_set_name pipeline "file")
        (let ((filesrc (gst_bin_get_by_name pipeline "filesrc"))
              (appsink (gst_bin_get_by_name pipeline "appsink"))
              (data (make-u8vector (* width height 4)))
              (info (make-u64vector 2)))
          (gst_app_sink_signal_new_sample appsink fifo)
          (g_object_set_string filesrc "location" (path-normalize location))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.data data)
          (set! self.info info)
          (set! self.pipeline pipeline)
          (set! self.appsink appsink)))))
  
  
  (method override (video-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (when (running? task)
            (site (preprocess on?: #t)
              (if (gst_app_sink_is_eos appsink)
                  (consume sink #f #f #f)
                (process self task exit))))
          (task-sleep task .001 exit)
          (iter))))))


;;;
;;;; File-Stream-Video-Src
;;;


(class File-Stream-Video-Src extends Video-Src
  
  
  (slot location  getter generate)
  (slot file      getter generate)
  (slot port      getter generate)
  (slot time-base getter generate)
  
  
  (method override (initialize self location)
    (nextmethod self)
    (set! self.location location)
    (set! self.file #f)
    (set! self.port #f)
    (set! self.time-base (new Time-Base)))
  
  
  (method override (start-element self)
    (nextmethod self)
    (set! file (new-file {Directory Settings} (list "streams" (add-extension location "streamvideo"))))
    (set! port (open-input-file (path-settings file)))
    (task-start self 'video-stream))
  
  
  (method override (play-element self)
    (nextmethod self))
  
  
  (method override (pause-element self)
    (nextmethod self))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (close port)
    (set! file #f)
    (set! port #f))
  
  
  (method override (video-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (when (running? task)
            (receive (buffer timestamp duration) (read-frame port)
              (if (not buffer)
                  ;; quicky
                  (task-sleep task +inf.0 exit)
                (let ((time (current-seconds))
                      (nanostamp (timestamp->flonum timestamp)))
                  (update-start time-base time nanostamp)
                  (let ((sendtime (remote->local time-base nanostamp)))
                    (task-sleep task (- sendtime time) exit)
                    (site (stream on?: #t)
                      (consume sink buffer timestamp duration)))))))
          (iter))))))


;;;
;;;; Draw-Video-Src
;;;


(class Draw-Video-Src extends Video-Src
  
  
  (slot draw-proc  initialize #f accessors generate)
  (slot start-time initialize #f accessors generate)
  (slot resolution initialize #f accessors generate)
  (slot context    initialize #f accessors generate)
  
  
  (method override (initialize self (draw-proc: draw-proc #f))
    (nextmethod self)
    (set! self.draw-proc draw-proc)
    (set! self.resolution video-resolution))
  
  
  (method override (start-element self)
    (nextmethod self)
    (set! context (new Draw-Context video-resolution video-framerate video-bitrate))
    (set! start-time (current-seconds))
    (task-start self 'draw))
  
  
  (method override (play-element self)
    (nextmethod self))
  
  
  (method override (pause-element self)
    (nextmethod self))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (close context)
    (set! context #f))
  
  
  (method override (video-loop self task)
    (declare (proper-tail-calls))
    (let ((tier (current-client)))
      (with-task task
        (lambda (exit)
          (let (iter)
            (when (running? task)
              (let ((surface (get-surface context)))
                (draw-stream self surface)
                (receive (color alpha timestamp duration) (extract context task exit)
                  (site (stream on?: #t)
                    (let ((effective-timestamp (flonum->timestamp (- (current-seconds) start-time))))
                      (consume sink color effective-timestamp duration))))))
            (task-sleep task .1 @too-slow-until-we-have-a-way-to-detect-changes-to-the-surface draw-refresh exit)
            (iter))))))
  
  
  (method protected virtual (draw-stream self surface)
    (clear surface)
    (when draw-proc
      (draw-proc surface resolution))))


;;;
;;;; Image-Stream-Video-Src
;;;


(class Image-Stream-Video-Src extends Draw-Video-Src
  
  
  (slot location  getter generate)
  (slot live?     getter generate)
  (slot file      getter generate)
  (slot color     getter generate)
  (slot alpha     getter generate)
  (slot timestamp getter generate)
  (slot duration  getter generate)
  
  
  (method override (initialize self location (live?: live? #t))
    (nextmethod self)
    (set! self.location location)
    (set! self.live? live?)
    (set! self.file (new-file {Directory Settings} (list "images" location)))
    (set! self.color #f)
    (set! self.alpha #f)
    (set! self.timestamp #f)
    (set! self.duration #f))
  
  
  (method (extract/cache self task exit)
    (if color
        (values color alpha timestamp duration)
      (let ((surface (get-surface context)))
        (draw-stream self surface)
        (receive (color alpha timestamp duration) (extract context task exit)
          (set! self.color color)
          (set! self.alpha alpha)
          (set! self.timestamp timestamp)
          (set! self.duration duration)
          (values color alpha timestamp duration)))))
  
  
  (method override (video-loop self task)
    (declare (proper-tail-calls))
    (let ((tier (current-client)))
      (with-task task
        (lambda (exit)
          (let (iter)
            (when (running? task)
              (receive (color alpha timestamp duration) (extract/cache self task exit)
                (site (stream on?: #t)
                  (let ((effective-timestamp (flonum->timestamp (- (current-seconds) start-time))))
                    (consume sink color effective-timestamp duration)))))
            (if (not live?)
                (begin
                  (consume sink #f #f #f)
                  (continuation-return exit #f))
              (task-sleep task draw-refresh exit)
              (iter)))))))
  
  
  (method override (draw-stream self surface)
    (fill-image surface
                (new Rect 0 0 (get-width resolution) (get-height resolution))
                (new Image moniker: file)
                mode: 'fill)))


;;;
;;;; Self-Sink
;;;


(class Self-Sink extends Stream-Sink
  
  
  (slot self-output initialize #f getter generate)
  
  
  (method override (start-element self)
    (nextmethod self)
    (let ((video (current-video))
          (me (current-me)))
      (set! self-output (player-output video #f player: me))))
  
  
  (method override (stop-element self)
    (let ((video (current-video)))
      (close-output video #f self-output)
      (set-stream-state self-output 'off))
    (nextmethod self))
  
  
  (method override (consume self buffer timestamp duration)
    (set-stream-state self-output 'drawn)
    (draw self-output buffer #f timestamp duration)))


;;;
;;;; Video-Sink
;;;


(class Video-Sink extends Stream-Sink
  
  
  (slot resolution                  initialize #f accessors generate)
  (slot framerate                   initialize #f accessors generate)
  (slot bitrate                     initialize #f accessors generate)
  (slot codec                       initialize #f accessors generate)
  (slot flip                        initialize #f accessors generate)
  (slot process?                    initialize #f accessors generate)
  (slot alpha-overlay               initialize #f accessors generate)
  (slot overlay?                    initialize #f accessors generate)
  (slot color-pipeline              initialize #f accessors generate)
  (slot color-appsrc                initialize #f accessors generate)
  (slot color-appsink               initialize #f accessors generate)
  (slot color-data     <u8vector+>  initialize #f accessors generate)
  (slot color-info     <u64vector+> initialize #f accessors generate)
  (slot color-fifo                  initialize #f accessors generate)
  (slot alpha?                      initialize #f accessors generate)
  (slot alpha-pipeline              initialize #f accessors generate)
  (slot alpha-appsrc                initialize #f accessors generate)
  (slot alpha-appsink               initialize #f accessors generate)
  (slot alpha-data     <u8vector+>  initialize #f accessors generate)
  (slot alpha-info     <u64vector+> initialize #f accessors generate)
  (slot alpha-fifo                  initialize #f accessors generate)
  (slot image-surface               initialize #f accessors generate)
  (slot image-inhibit?              initialize #f accessors generate)
  (slot task                        initialize #f accessors generate)
  (slot needs-layout?               initialize #f accessors generate)
  (slot stream-state                initialize 'off getter generate setter explicit)
  (slot frame-count                 initialize #f)
  (slot frame-start                 initialize #f)
  (slot total-size                  initialize #f)
  
  
  (method override (initialize self (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f) (flip: flip #f) (process?: process? #t) (alpha-overlay: alpha-overlay #f) (overlay?: overlay? #f) (alpha?: alpha? #f) (needs-layout?: needs-layout? #f))
    (nextmethod self)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec)
    (set! self.flip flip)
    (set! self.process? process?)
    (set! self.alpha-overlay alpha-overlay)
    (set! self.overlay? overlay?)
    (set! self.alpha? alpha?)
    (set! self.needs-layout? needs-layout?))
  
  
  (method package virtual (release-fifos self)
    (when color-fifo
      (release-stream-fifo color-fifo))
    (when alpha-fifo
      (release-stream-fifo alpha-fifo)))
  
  
  (method package virtual (resize self)
    )
  
  
  (method package (set-stream-state self state)
    (when (neq? state stream-state)
      (set! stream-state state)
      (invalidate-interface)))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (when process?
      (let ((width (get-width resolution))
            (height (get-height resolution)))
        (let ((fifo (make-stream-fifo "color"))
              (pipeline (gst-launch (tie "appsrc name=src")
                                    (and (eq? codec 'h264) (tie "avdec_h264"))
                                    "videoscale"
                                    "videoconvert"
                                    (and flip (tie "videoflip video-direction={flip}"))
                                    (and alpha-overlay (tie "alpha alpha={alpha-overlay}"))
                                    (tie "video/x-raw, format=BGRA, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                    (tie "appsink name=sink"))))
          (gst_object_set_name pipeline "output")
          (let ((appsrc (gst_bin_get_by_name pipeline "src"))
                (appsink (gst_bin_get_by_name pipeline "sink"))
                (data (make-u8vector (* width height 4)))
                (info (make-u64vector 2)))
            (gst_app_sink_signal_new_sample appsink fifo)
            (case codec
              ((h264)
               (gst_app_src_set_caps appsrc
                                     (gst_caps "video/x-h264"
                                               "width"         (g_value_int width)
                                               "height"        (g_value_int height)
                                               "framerate"     (g_value_fraction framerate 1)
                                               "stream-format" (g_value_string "avc")
                                               "alignment"     (g_value_string "au"))))
              (else
               (gst_app_src_set_caps appsrc
                                     (gst_caps "video/x-raw"
                                               "format"    (g_value_string "I420")
                                               "width"     (g_value_int width)
                                               "height"    (g_value_int height)
                                               "framerate" (g_value_fraction framerate 1)))))
            (g_object_set appsrc
                          "is-live"     (g_value_boolean #t)
                          "stream-type" (g_value_int GST_APP_STREAM_TYPE_STREAM)
                          "format"      (g_value_int GST_FORMAT_TIME))
            (gst_element_set_state pipeline GST_STATE_READY)
            (set! self.color-data data)
            (set! self.color-info info)
            (set! self.color-pipeline pipeline)
            (set! self.color-appsrc appsrc)
            (set! self.color-appsink appsink)
            (set! self.color-fifo fifo)))
        (when alpha?
          (let ((fifo (make-stream-fifo "alpha"))
                (pipeline (gst-launch "appsrc name=src"
                                      "avdec_h264 name=dec"
                                      "appsink name=sink")))
            (gst_object_set_name pipeline "output")
            (let ((appsrc (gst_bin_get_by_name pipeline "src"))
                  (appsink (gst_bin_get_by_name pipeline "sink"))
                  (data (make-u8vector (/ (* width height 12) 8)))
                  (info (make-u64vector 2)))
              (gst_app_sink_signal_new_sample appsink fifo)
              (gst_app_src_set_caps appsrc
                                    (gst_caps "video/x-h264"
                                              "width"         (g_value_int width)
                                              "height"        (g_value_int height)
                                              "framerate"     (g_value_fraction framerate 1)
                                              "stream-format" (g_value_string "avc")
                                              "alignment"     (g_value_string "au")))
              (g_object_set appsrc
                            "is-live"     (g_value_boolean #t)
                            "stream-type" (g_value_int GST_APP_STREAM_TYPE_STREAM)
                            "format"      (g_value_int GST_FORMAT_TIME))
              (gst_element_set_state pipeline GST_STATE_READY)
              (set! self.alpha-data data)
              (set! self.alpha-info info)
              (set! self.alpha-pipeline pipeline)
              (set! self.alpha-appsrc appsrc)
              (set! self.alpha-appsink appsink)
              (set! self.alpha-fifo fifo)
              (set! self.image-surface (new Image-Surface (new Dimension width height)))))))))
  
  
  (method (task-start self name)
    (let ((procedure
            (lambda (task)
              (video-loop self task))))
      (let ((task (new Task name procedure priority: video-priority)))
        (start-task task)
        (set! self.task task))))
  
  
  (method (task-stop self)
    (release-fifos self)
    (stop-task task)
    (set! task #f))
  
  
  (method override (start-element self)
    (nextmethod self)
    (when process?
      (task-start self 'video-output)
      (gst_element_set_state color-pipeline GST_STATE_PAUSED)
      (when alpha?
        (gst_element_set_state alpha-pipeline GST_STATE_PAUSED))))
  
  
  (method override (play-element self)
    (nextmethod self)
    (when process?
      (gst_element_set_state color-pipeline GST_STATE_PLAYING)
      (when alpha?
        (gst_element_set_state alpha-pipeline GST_STATE_PLAYING))))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (when process?
      (gst_element_set_state color-pipeline GST_STATE_PAUSED)
      (when alpha?
        (gst_element_set_state alpha-pipeline GST_STATE_PAUSED))))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (when process?
      (gst_element_set_state color-pipeline GST_STATE_READY)
      (when alpha?
        (gst_element_set_state alpha-pipeline GST_STATE_READY))
      (task-stop self)))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when process?
      (gst_element_release color-pipeline)
      (set! color-info #f)
      (set! color-data #f)
      (set! color-pipeline #f)
      (set! color-appsrc #f)
      (set! color-appsink #f)
      (close-stream-fifo color-fifo)
      (set! color-fifo #f)
      (when alpha?
        (gst_element_release alpha-pipeline)
        (close image-surface)
        (set! alpha-info #f)
        (set! alpha-data #f)
        (set! alpha-pipeline #f)
        (set! alpha-appsrc #f)
        (set! alpha-appsink #f)
        (set! image-surface #f)
        (close-stream-fifo alpha-fifo)
        (set! alpha-fifo #f))
      (set-stream-state self 'off)))
  
  
  (method override (consume self color timestamp duration (alpha #f))
    ;; QUICK TEST
    (when color-appsrc
    ;; QUICK TEST
      (when color
        (gst_app_src_write3 color-appsrc color (u8vector-length color) timestamp duration)))
    (when alpha?
      ;; QUICK TEST
      (when alpha-appsrc
        ;; QUICK TEST
        (when alpha
          (gst_app_src_write3 alpha-appsrc alpha (u8vector-length alpha) timestamp duration)))))
  
  
  (method (video-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-seconds)))
          ;; not 100% correct if preempted before task-mutex
          (let ((time (current-seconds)))
            (when (running? task)
              (site (video-output on?: #t)
                (let ((elapse (- time previous))
                      (max-elapse 10.))
                  ;; ignore ridiculous elapses like
                  ;; coming back from computer sleep
                  (unless (> elapse max-elapse)
                    (let ((history (current-history)))
                      (unless (get-paused? history)
                        (process self task exit)))))))
            (task-halt task exit)
            (iter time))))))
  
  
  (method override (process self task exit)
    (let ((color-bytes (gst_app_sink_wait task exit color-fifo color-appsink color-data color-info))
          (alpha-bytes (and alpha? (gst_app_sink_wait task exit alpha-fifo alpha-appsink alpha-data alpha-info))))
      (let ((timestamp (u64vector-ref color-info 0))
            (duration (u64vector-ref color-info 1)))
        (draw self color-data (and alpha? alpha-data) timestamp duration)
        (when (eq? stream-state 'on)
          (set-stream-state self 'drawn)))))
  
  
  (method package virtual (draw self color alpha timestamp duration)
    )
  
  
  (method package virtual (add-overlay self color alpha texture)
    (when overlay?
      (if (not frame-count)
          (begin
            (set! frame-count 1)
            (set! frame-start (current-seconds))
            (set! total-size (u8vector-length color)))
        (increase! frame-count)
        (increase! total-size (u8vector-length color))
        (let ((elapse (- (current-seconds) frame-start)))
          (let ((rate (/ (cast <fl> frame-count) elapse))
                (size (/ (cast <fl> total-size) frame-count))
                (surface (get-surface texture)))
            (set-font surface {Font font-name: tahoma point-size: 24 hint-style: slight hint-metrics: on})
            (draw-text surface 5 (- (get-height resolution) 30) (format "Rate: {r precision: 3}, Size: {a}" rate size) {Color World-Red}))))))
  
  
  (method package (update self color alpha texture (background: background #f))
    (if (not alpha?)
        (move-u8vector->pointer! color (get-data texture))
      (let ((width (get-width resolution))
            (height (get-height resolution))
            (data (cairo_image_surface_get_data (get-handle image-surface))))
        (cairo_surface_flush (get-handle image-surface))
        (combine-alpha color alpha data (* width height))
        (cairo_surface_mark_dirty (get-handle image-surface))
        (unless image-inhibit?
          (let ((surface (get-surface texture)))
            (clear-glass surface resolution background: background)
            (draw-surface surface image-surface 0 0)))))
    (add-overlay self color alpha texture)
    (unless image-inhibit?
      (map-texture texture)))
  
  
  (method package virtual (render self)
    )
  
  
  (method package (maybe-update-layouts self)
    (when needs-layout?
      (update-layouts (current-video))
      (set! needs-layout? #f)))
  
  
  (method (with-slide self texture thunk)
    (set! image-inhibit? #t)
    (thunk)
    (let ((height (cast <fl> (get-height resolution))))
      (let ((delta (/ height render-rate slide-duration))
            (surface (get-surface texture)))
        (thread-start!
          (new-thread
            (lambda ()
              (let (loop (slide (- height delta)))
                (let ((slide (max 0. slide)))
                  (let ((done? (<= slide 0.)))
                    (with-task-mutex
                      (lambda ()
                        (if (not image-surface)
                            (set! done? #t)
                          (translate surface 0 slide)
                          (clear-glass surface resolution)
                          (draw-surface surface image-surface 0 0)
                          (translate surface 0 (- slide))
                          (map-texture texture))
                        (when done?
                          (set! image-inhibit? #f))))
                    (when (not done?)
                      (sleep render-period)
                      (loop (- slide delta)))))))
            'slide))))))


;;;
;;;; Draw-Video-Sink
;;;


(class Draw-Video-Sink extends Video-Sink
  
  
  (slot entity     initialize #f accessors generate)
  (slot pane       initialize #f accessors generate)
  (slot background initialize #f accessors generate)
  
  
  (method override (initialize self ent . rest)
    (apply nextmethod self alpha?: #t rest)
    (let ((p (cache-draw-pane ent (list (eq? ent (current-me)) resolution))))
      (set! entity ent)
      (set! pane p)))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when entity
      (set-draw-pane entity #f)
      (set! entity #f)
      (set! pane #f)))
  
  
  (method override (draw self color alpha timestamp duration)
    ;; quicky
    (when pane
      (update self color alpha (get-texture (cache-quad-texture pane)) background: background)))
  
  
  (method override (render self)
    ;; nothing to do render done by player pane
    ))


;;;
;;;; Event-View
;;;


(class Event-View extends View)


(definition public (make-event-view)
  (let ((view (new Event-View)))
    (define (mouse-down event)
      (debug 'mouse-down))
    
    (define (mouse-up event)
      (debug 'mouse-up))
    
    (define (key-press event)
      (debug 'key-press))
    
    (set-mouse-down-handler view mouse-down)
    (set-mouse-up-handler view mouse-up)
    (set-key-press-handler view key-press)
    view))


(definition public (make-view . rest)
  (apply new View rest))


;;;
;;;; Draw-Pane
;;;


(definition public (make-draw-pane entity info)
  (let ((size {Dimension$fl$ 6. 3.375})
        (resolution {Dimension 1280 720}))
    (let ((pane (new Draw-Pane
                  title: "Draw"
                  size: size
                  resolution: resolution
                  billboard: info
                  entity: entity)))
      (cond ((is? info View)
             (set-root pane info)
             (set-position info {Point 0 0})
             (set-size info resolution)
             pane)
            (else
             pane)))))


@c4
(definition public (make-c4-pane entity billboard)
  (let ((size {Dimension$fl$ 3.6363636363636362 3.})
        (resolution {Dimension 660 600}))
    (let ((pane (new Script-Pane
                  size: size
                  resolution: resolution
                  billboard: billboard
                  entity: entity))
          (view (new jazz.sample.c4:C4-Board position: {Point 0 0} size: resolution background: #f)))
      (set-root pane view)
      (let ((pos (center (get-size view) resolution)))
        (set-position view pos))
      pane)))
  
  
  @c4
  (method override (draw self surface)
    (let ((width (get-width resolution))
          (height (get-height resolution)))
      (let ((rect (new Rect 0 0 width height))
            (color {Color red: .000 green: .000 blue: .200 alpha: .3}))
        (clear surface)
        (fill-rect surface rect color)
        (frame-rect surface rect color)
        (paint-drawing root surface '())))
    (when quad-texture
      (map-texture (get-texture quad-texture))))


(class Draw-Pane extends Entity-Pane)


;;;
;;;; Overhead-Video-Sink
;;;


(class Overhead-Video-Sink extends Video-Sink
  
  
  (slot player initialize #f accessors generate)
  (slot pane   initialize #f accessors generate)
  
  
  (method override (initialize self entity . rest)
    (apply nextmethod self rest)
    (let ((p (cache-camera-pane entity (list (eq? entity (current-me)) resolution))))
      (set! player entity)
      (set! pane p)))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when player
      (set-camera-pane player #f)
      (set! player #f)
      (set! pane #f)))
  
  
  (method override (draw self color alpha timestamp duration)
    (update self color alpha (get-texture (cache-quad-texture pane))))
  
  
  (method override (render self)
    ;; nothing to do render done by player pane
    ))


;;;
;;;; Camera-Pane
;;;


(definition public (make-camera-pane billboard)
  (bind (me? resolution) billboard
    (new Camera-Pane
      title: "Camera"
      size: (new Dimension$fl$ 1. .5625)
      resolution: resolution
      billboard: billboard)))


(class Camera-Pane extends World-Pane
  
  
  (method override (draw self surface)
    (clear surface)))


;;;
;;;; Sheet-Video-Sink
;;;


(class Sheet-Video-Sink extends Video-Sink
  
  
  (slot id         initialize #f accessors generate)
  (slot player     initialize #f accessors generate)
  (slot sheet      initialize #f accessors generate)
  (slot draw-mode  initialize #f accessors generate)
  (slot draw-mutex initialize #f accessors generate)
  (slot last-color initialize #f accessors generate)
  
  
  (method override (initialize self id entity . rest)
    (bind-keywords ((position #f) (size #f) . others) rest
      (apply nextmethod self others)
      (let ((world (current-world)))
        (let ((pos (or position {Point 0 0}))
              (size (or size {Dimension 320 180})))
          (let ((s (make-world-sheet 'video World-Sheet size resolution: resolution retina?: #f)))
            (make-orthographic-matrix! (get-projection-matrix s) 0. (get-width world) 0. (get-height world) 0. 10.)
            (set-position s pos)
            (set-size s size)
            (set! self.id id)
            (set! self.player entity)
            (set! self.sheet s)
            (set! self.draw-mode 'draw)
            (set! self.draw-mutex (make-mutex 'draw))
            (set! self.last-color #f))))))
  
  
  (method override (resize self)
    (let ((world (current-world)))
      (let ((width (get-width world))
            (height (get-height world)))
        (make-orthographic-matrix! (get-projection-matrix sheet) 0. width 0. height 0. 10.))))
  
  
  (method package (move self rect)
    (set-rect sheet rect))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when sheet
      (glDeleteTextures* (get-id (get-texture sheet)))
      (set! sheet #f)))
  
  
  (method package (change-draw-mode self mode)
    (unless (eq? mode draw-mode)
      (set! draw-mode mode)
      ;; super quick try
      (when last-color
        (parameterize ((testing? #t)) ;; oh boy fix me!
        (draw self last-color #f #f #f)))))
  
  
  (method override (draw self color alpha timestamp duration)
    (mutex-lock! draw-mutex)
    (when (or (eq? draw-mode 'draw) (testing?))
      (let ((texture (get-texture sheet)))
        (update self color alpha texture))
      (set! last-color color))
    (when id
      (record-event udp-id-draw-video
                    (fixnum->flonum client-no)
                    (fixnum->flonum world.udp:udp-video)
                    -1.
                    -1.
                    -1.
                    (if (not timestamp)
                        -1.
                      (timestamp->flonum timestamp))))
    (mutex-unlock! draw-mutex))
  
  
  (method override (add-overlay self color alpha texture)
    (when (and id (neq? draw-mode 'draw))
      (case draw-mode
        ((freeze)
         (when world.udp:udp-freeze-overlay
           (fill-rect (get-surface texture) (size-rect resolution) world.udp:udp-freeze-overlay)))
        ((wait)
         (when world.udp:udp-wait-overlay
           (fill-rect (get-surface texture) (size-rect resolution) world.udp:udp-wait-overlay))))))
  
  
  (method override (render self)
    (when (eq? stream-state 'drawn)
    ;; QUICKY
    (when sheet
    (maybe-update-layouts self)
    (let ((world (current-world)))
      (let ((x (cast <fl> (get-left sheet)))
            (y (cast <fl> (get-top sheet)))
            (h (cast <fl> (get-height sheet))))
        (let ((matrix (make-translation-matrix (vertex x (- (get-height world) y h) 0.))))
          (render-sheet sheet matrix))))))))


;;;
;;;; Circle-Video-Sink
;;;


(class Circle-Video-Sink extends Video-Sink
  
  
  (slot id         initialize #f accessors generate)
  (slot player     initialize #f accessors generate)
  (slot texture    initialize #f accessors generate)
  (slot sheet      initialize #f accessors generate)
  (slot pane       initialize #f accessors generate)
  (slot draw-mode  initialize #f accessors generate)
  (slot draw-mutex initialize #f accessors generate)
  (slot last-color initialize #f accessors generate)
  
  
  (method override (initialize self id entity . rest)
    (bind-keywords ((position #f) (size #f) . others) rest
      (apply nextmethod self others)
      (let ((world (current-world)))
        (set! self.id id)
        (set! self.player entity)
        (set! self.texture (make-cairo-texture (get-width resolution) (get-height resolution)))
        (set! self.draw-mode 'draw)
        (set! self.draw-mutex (make-mutex 'draw))
        (set! self.last-color #f)
        ;; sheet
        (let ((pos (or position {Point 0 0}))
              (size (or size {Dimension 320 180})))
          (let ((s (make-world-sheet 'video World-Sheet size resolution: resolution texture: texture)))
            (make-orthographic-matrix! (get-projection-matrix s) 0. (get-width world) 0. (get-height world) 0. 10.)
            (set-position s pos)
            (set-size s size)
            (set! self.sheet s)))
        ;; pane
        (let ((p (new World-Pane
                   title: "Player"
                   size: (new Dimension$fl$ 10. 5.625)
                   resolution: resolution
                   texture: texture)))
          (set! self.pane p)))))
  
  
  (method override (resize self)
    (let ((world (current-world)))
      (let ((width (get-width world))
            (height (get-height world)))
        (make-orthographic-matrix! (get-projection-matrix sheet) 0. width 0. height 0. 10.))))
  
  
  (method package (move self rect)
    (set-rect sheet rect))
  
  
  (method override (start-element self)
    (nextmethod self)
    (let ((zone (current-zone)))
      (register-pane zone pane)))
  
  
  (method override (stop-element self)
    (let ((zone (current-zone)))
      (unregister-pane zone pane))
    (nextmethod self))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when texture
      (glDeleteTextures* (get-id texture))
      (set! texture #f)))
  
  
  (method package (change-draw-mode self mode)
    (unless (eq? mode draw-mode)
      (set! draw-mode mode)
      ;; super quick try
      (when last-color
        (parameterize ((testing? #t)) ;; oh boy fix me!
        (draw self last-color #f #f #f)))))
  
  
  (method override (draw self color alpha timestamp duration)
    (mutex-lock! draw-mutex)
    (when (or (eq? draw-mode 'draw) (testing?))
      (update self color alpha texture)
      (set! last-color color))
    (when id
      (record-event udp-id-draw-video
                    (fixnum->flonum client-no)
                    (fixnum->flonum world.udp:udp-video)
                    -1.
                    -1.
                    -1.
                    (if (not timestamp)
                        -1.
                      (timestamp->flonum timestamp))))
    (mutex-unlock! draw-mutex))
  
  
  (method override (add-overlay self color alpha texture)
    (when (and id (neq? draw-mode 'draw))
      (case draw-mode
        ((freeze)
         (when world.udp:udp-freeze-overlay
           (fill-rect (get-surface texture) (size-rect resolution) world.udp:udp-freeze-overlay)))
        ((wait)
         (when world.udp:udp-wait-overlay
           (fill-rect (get-surface texture) (size-rect resolution) world.udp:udp-wait-overlay))))))
  
  
  (method override (render self)
    (when (eq? stream-state 'drawn)
      ;; QUICKY
      (case video-layout
        ((gallery fullscreen)
         (maybe-update-layouts self)
         (let ((world (current-world)))
           (let ((x (cast <fl> (get-left sheet)))
                 (y (cast <fl> (get-top sheet)))
                 (h (cast <fl> (get-height sheet))))
             (let ((matrix (make-translation-matrix (vertex x (- (get-height world) y h) 0.))))
               (render-sheet sheet matrix)))))
        (else
         (maybe-update-layouts self)
         (render-pane pane))))))


;;;
;;;; Layout Circle
;;;


(definition protected layout-circle-hook
  #f)

(definition protected (set-layout-circle-hook proc)
  (set! layout-circle-hook (and proc (new Hook proc))))


(definition (default-circle-matrix count n)
  (matrix-multiply&
    ;(make-translation-matrix (vertex 0. 7. 0.))
    (make-scaling-matrix (vertex 10. 10. 10.))
    (make-rotation-matrix (vertex 0. 1. 0.) (* (/ PI*2 (cast <fl> count)) (cast <fl> n)))
    (make-translation-matrix (vertex 0. 0. (circle-radius count)))))


(definition protected (circle-radius count)
  (/ (cast <fl> count) PI*2)))
