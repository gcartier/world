;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Video
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.video jazz


(import (jazz.cairo)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.gstreamer)
        (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.billboard)
        (world.configure)
        (world.foreign)
        (world.geometry)
        (world.id)
        (world.interface.sheet)
        (world.io)
        (world.quad-texture)
        (world.settings)
        (world.stream)
        (world.stream.foreign)
        (world.syntax (phase syntax))
        (world.task)
        (world.window))


(definition protected video-resolution
  (world-setting 'world.video-resolution {Dimension 640 360}))

(definition protected video-framerate
  (world-setting 'world.video-framerate 15))

(definition protected video-bitrate
  (world-setting 'world.video-bitrate 2048))

(definition protected video-alpha
  (world-setting 'world.video-alpha 0.6))

(definition protected video-overlay?
  (world-setting 'world.video-overlay? #f))

(definition protected video-codec
  (world-setting 'world.video-codec 'h264))


(definition layouts
  '(overhead
    sidebar
    gallery
    fullscreen))

(definition video-layout
  (world-setting 'world.video-layout 'overhead))


(definition video-debug?
  (world-setting 'world.video-debug? #f))


;;;
;;;; Kush
;;;


(definition public (kush-gauge width height rate motion)
  (/ (* width height rate motion 0.07) 1000.))


;;;
;;;; Video
;;;


(definition protected (new-world-video)
  (let ((camera-src (new Camera-Src
                      resolution: video-resolution
                      framerate: video-framerate
                      bitrate: video-bitrate
                      codec: video-codec))
        (server-sink (new Stream-Sink
                       consumer: (lambda (buffer timestamp duration)
                                   (send-client-video~ (client-tier) buffer timestamp duration)))))
    (new World-Video input: (pipeline camera-src server-sink))))


(class World-Video extends Object
  
  
  (slot input          getter generate)
  (slot inputs         getter generate)
  (slot outputs        getter generate)
  (slot player-outputs getter generate)
  
  
  (method override (initialize (input: input #f))
    (nextmethod)
    (set! input~self input)
    (set! inputs~self (make-table test: equal?))
    (set! outputs~self (make-table test: equal?))
    (set! player-outputs '()))
  
  
  (method (autostart)
    (when (world-setting 'world.video-autostart? #f)
      (start)))
  
  
  (method (start)
    (start~ input))
  
  
  (method (stop)
    (conclude~ input)
    (iterate-table inputs
      (lambda (id input)
        (conclude~ input)))
    (iterate-table outputs
      (lambda (id output)
        (conclude~ output))))
  
  
  (method (resize)
    (iterate-table outputs
      (lambda (id output)
        (when (interface?~ output)
          (resize~ output))))
    (layout-outputs))
  
  
  ;;;
  ;;;; Input
  ;;;
  
  
  (method (on-toggle-video evt)
    (toggle))
  
  
  (method (toggle)
    (when (client?)
      (let ((world (current-world)))
        (if (playing?~ input)
            (stop)
          (start))
        (update-parameter~ world 'video)
        (display-on/off~ world "Video" (playing?~ input)))))
  
  
  ;;;
  ;;;; Inputs
  ;;;
  
  
  (method (register-input id input)
    (table-set! inputs id input))
  
  
  (method (close-input id input)
    (table-clear inputs id)
    (conclude~ input))
  
  
  ;;;
  ;;;; Outputs
  ;;;
  
  
  (method (find-output id)
    (table-ref outputs id #f))
  
  (method (register-output id output)
    (table-set! outputs id output))
  
  
  (method (player-output id (position: position #f) (size: size #f) (resolution: resolution #f) (layout: layout #f) (codec: codec #f))
    (or (table-ref outputs id #f)
        (let ((output (new-output id position: position size: size resolution: resolution layout: layout codec: codec)))
          (table-set! outputs id output)
          (set! player-outputs (append! player-outputs (list output)))
          (layout-outputs)
          output)))
  
  
  (method (new-output id (position: position #f) (size: size #f) (resolution: resolution #f) (layout: layout #f) (codec: codec #f))
    (case (or layout video-layout)
      ((overhead)
       (new Billboard-Video-Sink id
         resolution: (or resolution video-resolution)
         framerate: video-framerate
         bitrate: video-bitrate
         codec: (or codec video-codec)
         alpha: video-alpha
         overlay?: video-overlay?))
      (else
       (new Sheet-Video-Sink
         position: position
         size: size
         resolution: (or resolution video-resolution)
         framerate: video-framerate
         bitrate: video-bitrate
         codec: (or codec video-codec)
         alpha: video-alpha
         overlay?: video-overlay?))))
  
  
  (method (close-output id output)
    (table-clear outputs id)
    (set! player-outputs (remove! output player-outputs))
    (conclude~ output))
  
  
  (method (receive-server-video id buffer timestamp duration)
    (if (not buffer)
        (let ((output (find-output id)))
          (when output
            (close-output id output)))
      (let ((output (player-output id)))
        (setup~ output)
        (start~ output)
        (consume~ output buffer timestamp duration))))
  
  
  (method (render-scene)
    (iterate-table outputs
      (lambda (id output)
        (unless (interface?~ output)
          (render~ output)))))
  
  
  (method (render-interface)
    (iterate-table outputs
      (lambda (id output)
        (when (interface?~ output)
          (render~ output)))))
  
  
  ;;;
  ;;;; Layout
  ;;;
  
  
  (method (on-cycle-layouts evt)
    (let ((world (current-world)))
      (cycle-layouts)
      (display-message~ world (capitalize (symbol->string video-layout)))))
  
  
  (method (cycle-layouts)
    (let ((zone (current-zone)))
      (case video-layout
        ((overhead)
         (for-each (lambda (player)
                     (let ((elem (get-billboard-camera~ player)))
                       (when elem
                         (set-render?~ elem #f))))
                   (get-players~ zone))
         (set! video-layout 'sidebar)
         (layout-outputs))
        ((sidebar)
         (set! video-layout 'gallery)
         (layout-outputs))
        ((gallery)
         (set! video-layout 'fullscreen)
         (layout-outputs))
        ((fullscreen)
         (set! video-layout 'sidebar @w 'overhead)
         (layout-outputs)))))
  
  
  (method (layout-outputs)
    (when (not-null? player-outputs)
      (let ((player-rectangles (layout (length player-outputs))))
        ;; patch until barbara boum fixed
        (when (= (length player-outputs) (length player-rectangles))
          (for-each (lambda (output rect)
                      (move~ output rect))
                    player-outputs
                    player-rectangles)))))
  
  
  (method (layout num-players)
    (let ((window (current-world-window)))
      (let ((bounds (get-bounds~ window)))
        (let ((l (get-left~ bounds))
              (t (get-top~ bounds))
              (r (get-right~ bounds))
              (b (get-bottom~ bounds)))
          (case video-layout
            ((overhead))
            ((sidebar)
             (fill num-players (new Rect 10 70 210 (- b 100))))
            ((gallery)
             (fill num-players bounds))
            ((fullscreen)
             (cons bounds (fill (- num-players 1) (new Rect (- r 200) 500 r b)))))))))
  
  
  ;; BOUM BARBARA
  ;; (length (fill 7 {Rect 0 0 1150 478})) -> 5 !!!
  (method (fill num-players outer)
    (if (= num-players 0)
        '()
      (let ((outer-left (get-left~ outer))
            (outer-top (get-top~ outer))
            (outer-width (cast <fl> (rect-width outer)))
            (outer-height (cast <fl> (rect-height outer))))
        (let ((outer-ratio (/ outer-width outer-height))
              (box-ratio (/ 1280. 720.)))
          (let ((max-box-area 0)
                (best-box-width 0)
                (best-box-height 0)
                (best-col 0)
                (best-row 0))
            (loop (for row from 1 to num-players)
                  (let ((col (fxceiling/ num-players row)))
                    (define (calculate-box)
                      (let ((actual-box-ratio (/ (* box-ratio col) (cast <fl> row))))
                        (if (< actual-box-ratio outer-ratio)
                            (let ((height (/ outer-height (cast <fl> row))))
                              (values (* height box-ratio) height))
                          (let ((width (/ outer-width col)))
                            (values width ( / width box-ratio))))))
                    
                    (receive (box-width box-height) (calculate-box)
                      (let ((box-area (* box-width box-height)))
                        (when (> box-area max-box-area)
                          (set! max-box-area box-area)
                          (set! best-box-width box-width)
                          (set! best-box-height box-height)
                          (set! best-col col)
                          (set! best-row row))))))
            (let ((box-origin-x 0)
                  (box-origin-y 0)
                  (box-width best-box-width)
                  (box-height best-box-height)
                  (column-iter best-col)
                  (last-row-cols (modulo num-players best-row))
                  (queue (new-queue)))
              (loop (for row from 1 to best-row)
                    (set! box-origin-x 0)
                    (when (and (= row best-row) (> last-row-cols 0))
                      (set! column-iter last-row-cols))
                    (let ((border (center (* box-width column-iter) outer-width)))
                      (loop (for col from 1 to column-iter)
                            (let ((rectangle
                                    (new Rect
                                      (fxceiling (exact->inexact (+ outer-left border box-origin-x)))
                                      (fxceiling (exact->inexact (+ outer-top box-origin-y)))
                                      (fxfloor (exact->inexact (+ outer-left border box-origin-x box-width)))
                                      (fxfloor (exact->inexact (+ outer-top box-origin-y box-height))))))
                              (enqueue queue rectangle))
                            (set! box-origin-x (+ box-origin-x box-width))))
                    (set! box-origin-y (+ box-origin-y box-height)))
              (queue-list queue))))))))


;;;
;;;; Video-Src
;;;


(class Video-Src extends Stream-Src
  
  
  (slot appsink              initialize #f accessors generate)
  (slot data     <u8vector>  initialize #f accessors generate)
  (slot info     <u64vector> initialize #f accessors generate)
  (slot task                 initialize #f accessors generate)
  
  
  (method (task-start name)
    (let ((procedure
            (lambda (task)
              (video-task task))))
      (let ((task (new Task name procedure)))
        (start-task task)
        (thread-base-priority-set! (get-thread~ task) video-priority)
        (set! task~self task))))
  
  
  (method (task-stop)
    (cease-task task)
    (set! task #f))
  
  
  (method protected virtual (video-task task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-seconds)))
          ;; not 100% correct if preempted before task-mutex
          (let ((time (current-seconds)))
            (with-task-mutex
              (lambda ()
                (unless (stopping?~ task)
                  (let ((elapse (- time previous))
                        (max-elapse 10.))
                    ;; ignore ridiculous elapses like
                    ;; coming back from computer sleep
                    (unless (> elapse max-elapse)
                      (let ((history (current-history)))
                        (unless (get-paused?~ history)
                          (process))))))))
            (let ((duration (- (current-seconds) time)))
              (task-sleep task video-period duration exit))
            (iter time))))))
  
  
  (method override (process)
    (let ((size (gst_app_sink_read appsink data info)))
      (when (/= size -1)
        (let ((buffer (subu8vector data 0 size))
              (timestamp (u64vector-ref info 0))
              (duration (u64vector-ref info 1)))
          (consume~ sink buffer timestamp duration))))))


;;;
;;;; Camera-Src
;;;


(class Camera-Src extends Video-Src
  
  
  (slot resolution initialize #f accessors generate)
  (slot framerate  initialize #f accessors generate)
  (slot bitrate    initialize #f accessors generate)
  (slot codec      initialize #f accessors generate)
  (slot pipeline   initialize #f accessors generate)
  
  
  (method override (initialize (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f))
    (nextmethod)
    (set! resolution~self resolution)
    (set! framerate~self framerate)
    (set! bitrate~self bitrate)
    (set! codec~self codec))
  
  
  (method override (setup-element)
    (nextmethod)
    (let ((width (get-width~ resolution))
          (height (get-height~ resolution)))
      (let ((pipeline (gst-launch "avfvideosrc"
                                  "videoscale"
                                  "videoconvert"
                                  "videoflip video-direction=horiz"
                                  (tie "video/x-raw, format=I420, width={width}, height={height}, framerate={framerate}/1")
                                  (and (eq? codec 'h264) (tie "x264enc pass=qual quantizer=20 bitrate={bitrate} tune=zerolatency speed-preset=ultrafast"))
                                  "appsink name=sink")))
        (gst_object_set_name pipeline "camera")
        (let ((appsink (gst_bin_get_by_name pipeline "sink"))
              (data (make-u8vector (* width height 4)))
              (info (make-u64vector 2)))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! data~self data)
          (set! info~self info)
          (set! pipeline~self pipeline)
          (set! appsink~self appsink)))))
  
  
  (method override (start-element)
    (nextmethod)
    (task-start 'camera)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (stop-element)
    (nextmethod)
    (task-stop)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (conclude-element)
    (nextmethod)
    (gst_element_set_state pipeline GST_STATE_NULL)
    (gst_object_unref pipeline)
    (set! info #f)
    (set! data #f)
    (set! pipeline #f)
    (set! appsink #f)
    (consume~ sink #f #f #f)))


;;;
;;;; Screen-Src
;;;


(class Screen-Src extends Video-Src)


;;;
;;;; Test-Video-Src
;;;


(class Test-Video-Src extends Video-Src
  
  
  (slot resolution initialize #f accessors generate)
  (slot framerate  initialize #f accessors generate)
  (slot bitrate    initialize #f accessors generate)
  (slot codec      initialize #f accessors generate)
  (slot pipeline   initialize #f accessors generate)
  
  
  (method override (initialize (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f))
    (nextmethod)
    (set! resolution~self resolution)
    (set! framerate~self framerate)
    (set! bitrate~self bitrate)
    (set! codec~self codec))
  
  
  (method override (setup-element)
    (nextmethod)
    (let ((width (get-width~ resolution))
          (height (get-height~ resolution)))
      (let ((pipeline (gst-launch "videotestsrc"
                                  "videoscale"
                                  "videoconvert"
                                  (tie "video/x-raw, format=I420, width={width}, height={height}, framerate={framerate}/1")
                                  (and (eq? codec 'h264) (tie "x264enc pass=qual quantizer=20 bitrate={bitrate} tune=zerolatency speed-preset=ultrafast"))
                                  "appsink name=sink")))
        (gst_object_set_name pipeline "test")
        (let ((appsink (gst_bin_get_by_name pipeline "sink"))
              (data (make-u8vector (* width height 4)))
              (info (make-u64vector 2)))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! data~self data)
          (set! info~self info)
          (set! pipeline~self pipeline)
          (set! appsink~self appsink)))))
  
  
  (method override (start-element)
    (nextmethod)
    (task-start 'test)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (stop-element)
    (nextmethod)
    (task-stop)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (conclude-element)
    (nextmethod)
    (gst_element_set_state pipeline GST_STATE_NULL)
    (gst_object_unref pipeline)
    (set! info #f)
    (set! data #f)
    (set! pipeline #f)
    (set! appsink #f)
    (consume~ sink #f #f #f)))


;;;
;;;; File-Video-Src
;;;


(class File-Video-Src extends Video-Src
  
  
  (slot location               initialize #f accessors generate)
  (slot resolution             initialize #f accessors generate)
  (slot framerate              initialize #f accessors generate)
  (slot bitrate                initialize #f accessors generate)
  (slot codec                  initialize #f accessors generate)
  (slot pipeline               initialize #f accessors generate)
  (slot audio-sink             initialize #f accessors generate)
  (slot audio-appsink          initialize #f accessors generate)
  (slot audio-data <u8vector>  initialize #f accessors generate)
  (slot audio-info <u64vector> initialize #f accessors generate)
  
  
  (method override (initialize location (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f))
    (nextmethod)
    (set! location~self location)
    (set! resolution~self resolution)
    (set! framerate~self framerate)
    (set! bitrate~self bitrate)
    (set! codec~self codec))
  
  
  (method override (setup-element)
    (nextmethod)
    (let ((width (get-width~ resolution))
          (height (get-height~ resolution)))
      (let ((pipeline @wait
                      (gst-launch (tie "filesrc location={location}")
                                  "matroskademux name=demux"
                                  (list "demux.audio_0"
                                        "queue"
                                        "decodebin"
                                        "audioconvert"
                                        "audioresample"
                                        "audio/x-raw, format=F32LE, layout=interleaved, rate=80000, channels=2"
                                        "appsink name=audioappsink")
                                  (list "demux.video_0"
                                        "queue"
                                        "vp8dec"
                                        "videoconvert"
                                        "videoscale"
                                        ;; video does not show up for some reason
                                        ;(tie "video/x-raw, format=I420, width={width}, height={height}, framerate={framerate}/1")
                                        "appsink name=appsink"))
                      (gst-launch (tie "filesrc location={location}")
                                  "decodebin name=decoder"
                                  (list "decoder."
                                        "queue"
                                        "audioconvert"
                                        "audioresample"
                                        "audio/x-raw, format=F32LE, layout=interleaved, rate=80000, channels=2"
                                        "appsink name=audioappsink")
                                  (list "decoder."
                                        "videoconvert"
                                        ;; video does not show up for some reason
                                        ;; (tie "video/x-raw, format=I420, width={width}, height={height}, framerate={framerate}/1")
                                        "appsink name=appsink"))))
        (gst_object_set_name pipeline "file")
        (let ((appsink (gst_bin_get_by_name pipeline "appsink"))
              (data (make-u8vector (* width height 4)))
              (info (make-u64vector 2))
              (audio-appsink (gst_bin_get_by_name pipeline "audioappsink"))
              (audio-data (make-u8vector (* width height 4)))
              (audio-info (make-u64vector 2)))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! data~self data)
          (set! info~self info)
          (set! pipeline~self pipeline)
          (set! appsink~self appsink)
          (set! audio-appsink~self audio-appsink)
          (set! audio-data~self audio-data)
          (set! audio-info~self audio-info)))))
  
  
  (method override (start-element)
    (nextmethod)
    (task-start 'file)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (stop-element)
    (nextmethod)
    (task-stop)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (conclude-element)
    (nextmethod)
    (gst_element_set_state pipeline GST_STATE_NULL)
    (gst_object_unref pipeline)
    (set! info #f)
    (set! data #f)
    (set! pipeline #f)
    (set! appsink #f)
    (consume~ sink #f #f #f)
    (set! audio-info #f)
    (set! audio-data #f)
    (set! audio-appsink #f)
    (when audio-sink
      (consume~ audio-sink #f #f #f)))
  
  
  (method override (process)
    (nextmethod)
    (let ((size (gst_app_sink_read audio-appsink audio-data audio-info)))
      (when (and (/= size -1) audio-sink)
        (let ((buffer (subu8vector audio-data 0 size))
              (timestamp (u64vector-ref audio-info 0))
              (duration (u64vector-ref audio-info 1)))
          (consume~ audio-sink buffer timestamp duration))))))


;;;
;;;; Video-Sink
;;;


(class Video-Sink extends Stream-Sink
  
  
  (slot resolution           initialize #f accessors generate)
  (slot framerate            initialize #f accessors generate)
  (slot bitrate              initialize #f accessors generate)
  (slot codec                initialize #f accessors generate)
  (slot flip                 initialize #f accessors generate)
  (slot alpha                initialize #f accessors generate)
  (slot overlay?             initialize #f accessors generate)
  (slot pipeline             initialize #f accessors generate)
  (slot appsrc               initialize #f accessors generate)
  (slot appsink              initialize #f accessors generate)
  (slot data     <u8vector>  initialize #f accessors generate)
  (slot info     <u64vector> initialize #f accessors generate)
  (slot task                 initialize #f accessors generate)
  (slot drawn?               initialize #f accessors generate)
  (slot frame-count          initialize #f)
  (slot frame-start          initialize #f)
  (slot total-size           initialize #f)
  
  
  (method override (initialize (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f) (flip: flip #f) (alpha: alpha #f) (overlay?: overlay? #f))
    (nextmethod)
    (set! resolution~self resolution)
    (set! framerate~self framerate)
    (set! bitrate~self bitrate)
    (set! codec~self codec)
    (set! flip~self flip)
    (set! alpha~self alpha)
    (set! overlay?~self overlay?))
  
  
  (method protected virtual (interface?)
    #f)
  
  
  (method override (setup-element)
    (nextmethod)
    (let ((width (get-width~ resolution))
          (height (get-height~ resolution)))
      (let ((pipeline (gst-launch (tie "appsrc name=src")
                                  (and (eq? codec 'h264) (tie "avdec_h264"))
                                  "videoscale"
                                  "videoconvert"
                                  (and flip (tie "videoflip video-direction={flip}"))
                                  (and alpha (tie "alpha alpha={alpha}"))
                                  (tie "video/x-raw, format=BGRA, width={width}, height={height}, framerate={framerate}/1")
                                  (tie "appsink name=sink"))))
        (gst_object_set_name pipeline "output")
        (let ((appsrc (gst_bin_get_by_name pipeline "src"))
              (appsink (gst_bin_get_by_name pipeline "sink"))
              (data (make-u8vector (* width height 4)))
              (info (make-u64vector 2)))
          (case codec
            ((h264)
             (gst_app_src_set_caps appsrc
               (gst_caps "video/x-h264"
                 "width"         (g_value_int width)
                 "height"        (g_value_int height)
                 "framerate"     (g_value_fraction framerate 1)
                 "stream-format" (g_value_string "avc")
                 "alignment"     (g_value_string "au"))))
            (else
             (gst_app_src_set_caps appsrc
               (gst_caps "video/x-raw"
                 "format"    (g_value_string "I420")
                 "width"     (g_value_int width)
                 "height"    (g_value_int height)
                 "framerate" (g_value_fraction framerate 1)))))
          (g_object_set appsrc
            "is-live"     (g_value_boolean #t)
            "stream-type" (g_value_int GST_APP_STREAM_TYPE_STREAM)
            "format"      (g_value_int GST_FORMAT_TIME))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! data~self data)
          (set! info~self info)
          (set! pipeline~self pipeline)
          (set! appsrc~self appsrc)
          (set! appsink~self appsink)))))
  
  
  (method override (start-element)
    (define (task-start name)
      (let ((procedure
              (lambda (task)
                (video-task task))))
        (let ((task (new Task name procedure)))
          (start-task task)
          (thread-base-priority-set! (get-thread~ task) video-priority)
          (set! task~self task))))
    
    (nextmethod)
    (task-start 'video)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (stop-element)
    (define (task-stop)
      (cease-task task)
      (set! task #f))
    
    (nextmethod)
    (task-stop)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (conclude-element)
    (nextmethod)
    (gst_element_set_state pipeline GST_STATE_NULL)
    (gst_object_unref pipeline)
    (set! info #f)
    (set! data #f)
    (set! pipeline #f)
    (set! appsrc #f)
    (set! appsink #f)
    (set! drawn? #f))
  
  
  (method override (consume buffer timestamp duration)
    ;; QUICK TEST
    (when appsrc
    ;; QUICK TEST
      (when buffer
    (gst_app_src_write3 appsrc buffer (u8vector-length buffer) timestamp duration))))
  
  
  (method (video-task task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-seconds)))
          ;; not 100% correct if preempted before task-mutex
          (let ((time (current-seconds)))
            (with-task-mutex
              (lambda ()
                (unless (stopping?~ task)
                  (let ((elapse (- time previous))
                        (max-elapse 10.))
                    ;; ignore ridiculous elapses like
                    ;; coming back from computer sleep
                    (unless (> elapse max-elapse)
                      (let ((history (current-history)))
                        (unless (get-paused?~ history)
                          (process))))))))
            (let ((duration (- (current-seconds) time)))
              (task-sleep task video-period duration exit))
            (iter time))))))
  
  
  (method override (process)
    (let ((size (gst_app_sink_read appsink data info)))
      (when (/= size -1)
        (let ((buffer (subu8vector data 0 size))
              (timestamp (u64vector-ref info 0))
              (duration (u64vector-ref info 1)))
          (draw buffer timestamp duration)
          (set! drawn? #t)))))
  
  
  (method protected virtual (draw buffer timestamp duration)
    )
  
  
  (method (update buffer texture)
    (define (add-overlay)
      (if (not frame-count)
          (begin
            (set! frame-count 1)
            (set! frame-start (current-seconds))
            (set! total-size (u8vector-length buffer)))
        (increase! frame-count)
        (increase! total-size (u8vector-length buffer))
        (let ((elapse (- (current-seconds) frame-start)))
          (let ((rate (/ (cast <fl> frame-count) elapse))
                (size (/ (cast <fl> total-size) frame-count)))
            (set-font~ (get-surface~ texture) {Font font-name: tahoma point-size: 24 hint-style: slight hint-metrics: on})
            (draw-text~ (get-surface~ texture) 5 (- (get-height~ resolution) 30) (format "Rate: {r precision: 3}, Size: {a}" rate size) {Color World-Red})))))
    
    (copy_to_texture buffer (u8vector-length buffer) (get-data~ texture))
    (when overlay?
      (add-overlay))
    (map-texture~ texture))
  
  
  (method protected virtual (render)
    ))


;;;
;;;; Billboard-Video-Sink
;;;


(class Billboard-Video-Sink extends Video-Sink
  
  
  (slot player    initialize #f accessors generate)
  (slot billboard initialize #f accessors generate)
  
  
  (method override (initialize id . rest)
    (apply nextmethod rest)
    (let ((p (find-entity id)))
      (let ((elem (cache-billboard-camera~ p (list (eq? p (current-me)) resolution))))
        (set! player p)
        (set! billboard elem))))
  
  
  (method override (conclude-element)
    (nextmethod)
    (when player
      (set-billboard-camera~ player #f)
      (set! player #f)
      (set! billboard #f)))
  
  
  (method override (draw buffer timestamp duration)
    (update buffer (get-texture~ (cache-quad-texture~ billboard))))
  
  
  (method override (render)
    ;; nothing to do render done by player billboard
    ))


;;;
;;;; Billboard-Camera
;;;


(definition public (make-billboard-camera billboard)
  (new Billboard-Camera
    billboard: billboard))


(class Billboard-Camera extends Billboard-Element
  
  
  (method override (make-billboard-texture)
    (bind (me? resolution) billboard
      (let ((width (get-width~ resolution))
            (height (get-height~ resolution)))
        (let ((w 1.)
              (h .5625))
          (let ((v1 (vertex (/ w -2.) (/ h  2.) 0.))
                (v2 (vertex (/ w -2.) (/ h -2.) 0.))
                (v3 (vertex (/ w  2.) (/ h -2.) 0.))
                (v4 (vertex (/ w  2.) (/ h  2.) 0.)))
            (let ((quad-texture <Quad-Texture> (make-quad-texture width height v1 v2 v3 v4)))
              (let ((texture (get-texture~ quad-texture)))
                (let ((surface (get-surface~ texture)))
                  (clear~ surface)
                  (map-texture~ texture)))
              quad-texture))))))
  
  
  (method override (billboard-top)
    2.6)
  
  
  (method override (billboard-center)
    .4))


;;;
;;;; Texture-Video-Sink
;;;


(class Texture-Video-Sink extends Video-Sink
  
  
  (slot quad-texture initialize #f getter generate)
  (slot matrix       initialize #f getter generate)
  
  
  (method override (initialize matrix . rest)
    (bind-keywords ((size #f) . others) rest
      (define (determine-size)
        (or size
            (let ((ratio (/ (cast <fl> (get-width~ resolution)) (cast <fl> (get-height~ resolution)))))
              (let ((w ratio)
                    (h 1.))
                (new Dimension$fl$ w h)))))
      
      (apply nextmethod others)
      (let ((size (determine-size)))
        (let ((w (get-width~ size))
              (h (get-height~ size)))
          (let ((v1 (vertex (/ w -2.) (/ h -2.) 0.))
                (v2 (vertex (/ w -2.) (/ h  2.) 0.))
                (v3 (vertex (/ w  2.) (/ h  2.) 0.))
                (v4 (vertex (/ w  2.) (/ h -2.) 0.)))
            (let ((quad-texture (make-quad-texture (get-width~ resolution) (get-height~ resolution) v1 v2 v3 v4)))
              (set! quad-texture~self quad-texture)
              (set! matrix~self matrix)))))))
  
  
  (method override (conclude-element)
    (nextmethod)
    (when quad-texture
      (glDeleteTextures* (get-id~ (get-texture~ quad-texture)))
      (set! quad-texture #f)))
  
  
  (method override (draw buffer timestamp duration)
    (update buffer (get-texture~ quad-texture)))
  
  
  (method override (render)
    (when drawn?
      (render-texture~ quad-texture matrix))))


;;;
;;;; Sheet-Video-Sink
;;;


(class Sheet-Video-Sink extends Video-Sink
  
  
  (slot size  initialize #f accessors generate)
  (slot sheet initialize #f accessors generate)
  
  
  (method override (initialize . rest)
    (bind-keywords ((position #f) (size #f) . others) rest
      (apply nextmethod others)
      (let ((world (current-world)))
        (let ((pos (or position {Point 0 0}))
              (size (or size {Dimension 320 180})))
          (let ((s (make-world-sheet 'video World-Sheet size resolution: resolution)))
            (make-orthographic-matrix! (get-projection-matrix~ s) 0. (get-width~ world) 0. (get-height~ world) 0. 10.)
            (set-position~ s pos)
            (set-size~ s size)
            (set! sheet s))))))
  
  
  (method override (interface?)
    #t)
  
  
  (method (resize)
    (let ((world (current-world)))
      (let ((width (get-width~ world))
            (height (get-height~ world)))
        (make-orthographic-matrix! (get-projection-matrix~ sheet) 0. width 0. height 0. 10.))))
  
  
  (method (move rect)
    (set-rect~ sheet rect))
  
  
  (method override (conclude-element)
    (nextmethod)
    (when sheet
      (glDeleteTextures* (get-id~ (get-texture~ sheet)))
      (set! sheet #f)))
  
  
  (method override (draw buffer timestamp duration)
    (update buffer (get-texture~ sheet)))
  
  
  (method override (render)
    (when drawn?
    ;; QUICKY
    (when sheet
    (let ((world (current-world)))
      (let ((x (cast <fl> (get-left~ sheet)))
            (y (cast <fl> (get-top~ sheet)))
            (h (cast <fl> (get-height~ sheet))))
        (let ((matrix (make-translation-matrix (vertex x (- (get-height~ world) y h) 0.))))
          (render-sheet~ sheet matrix))))))))


;;;
;;;; Test
;;;


(definition test-pipeline #f)
(definition file-pipeline #f)
(definition camera-pipeline #f)
(definition circle-pipelines #f)


(definition next-names
  common-names)

(definition next-src
  0)


(definition (make-texture-pipeline name size resolution framerate video-src matrix . extras)
  (let ((video (current-video)))
    (let ((bitrate video-bitrate)
          (codec 'none))
      (let ((video-sink (new Texture-Video-Sink
                          matrix
                          size: size
                          resolution: resolution
                          framerate: framerate
                          bitrate: bitrate
                          codec: codec
                          flip: 'vert)))
        (let ((pipeline (pipeline video-src video-sink)))
          ;; quick first solution
          (set-elements~ pipeline (append (get-elements~ pipeline) extras))
          (register-input~ video name video-src)
          (register-output~ video name video-sink)
          (start~ pipeline)
          pipeline)))))


(definition (make-test-video)
  (let ((size #f)
        (resolution {Dimension 300 200})
        (framerate 30)
        (bitrate video-bitrate)
        (codec 'none))
    (make-texture-pipeline 'test size resolution framerate
      (new Test-Video-Src
        resolution: resolution
        framerate: framerate
        bitrate: bitrate
        codec: codec)
      (copy-matrix (matrix-multiply& (make-translation-matrix (vertex -9.5 7. 4.5))
                                     (make-scaling-matrix (vertex 6. 6. 6.))
                                     (make-rotation-matrix (vertex 0. 1. 0.) PI/4))))))


(definition (make-file-video)
  (let ((size #f)
        (resolution {Dimension 854 480})
        (framerate 30)
        (bitrate video-bitrate)
        (codec 'none))
    (let ((file-src (new File-Video-Src
                      "/Users/cartier/Devel/gstreamer/media/sintel.webm"
                      resolution: resolution
                      framerate: framerate
                      bitrate: bitrate
                      codec: codec))
          (audio-sink (new world.audio:Audio-Sink
                        codec: 'none)))
      (set-audio-sink~ file-src audio-sink)
      (make-texture-pipeline 'file size resolution framerate
        file-src
        (copy-matrix (matrix-multiply& (make-translation-matrix (vertex 0. 7. 0.))
                                       (make-scaling-matrix (vertex 6. 6. 6.))))
        ;; quick first solution
        audio-sink))))


(definition (make-camera-video)
  (let ((size #f)
        (resolution {Dimension 1280 720})
        (framerate 30)
        (bitrate video-bitrate)
        (codec 'none))
    (make-texture-pipeline 'camera size resolution framerate
      (new Camera-Src
        resolution: resolution
        framerate: framerate
        bitrate: bitrate
        codec: codec)
      (copy-matrix (matrix-multiply& (make-translation-matrix (vertex 10. 7. 5.))
                                     (make-scaling-matrix (vertex 6. 6. 6.))
                                     (make-rotation-matrix (vertex 0. 1. 0.) (- PI/4)))))))


(definition (make-circle-videos)
  (let ((count 15))
    (loop (for n from 0 below count)
          (collect (let ((name (string->symbol (format "circle{a}" n)))
                         (size #f)
                         (resolution {Dimension 300 200})
                         (framerate 30)
                         (bitrate video-bitrate)
                         (codec 'none))
                     (make-texture-pipeline name size resolution framerate
                       (new Test-Video-Src
                         resolution: resolution
                         framerate: framerate
                         bitrate: bitrate
                         codec: codec)
                       (copy-matrix (matrix-multiply& (make-translation-matrix (vertex 0. 7. 0.))
                                                      (make-scaling-matrix (vertex 6. 6. 6.))
                                                      (make-rotation-matrix (vertex 0. 1. 0.) (* (/ PI*2 (cast <fl> count)) (cast <fl> n)))
                                                      (make-translation-matrix (vertex 0. 0. 4.))))))))))


(definition (random-name!)
  (let ((name (random-element next-names)))
    (set! next-names (remove! name next-names))
    name))


(definition (random-src!)
  (let ((n next-src))
    (set! next-src (modulo (+ next-src 1) 3))
    (element (list Test-Video-Src File-Video-Src Camera-Src) n)))


(definition (add-players count)
  (let ((world (current-world))
        (video (current-video)))
    (define (layout-players)
      (let ((current-count (length (get-player-outputs~ video))))
        (let ((new-count (+ current-count count)))
          (let ((rectangles (layout~ video new-count)))
            (subseq rectangles current-count new-count)))))
    
    (let ((outputs
            (loop (for n from 0 below count)
                  (for rect in (layout-players))
                  (collect (let ((name (random-name!))
                                 (src-class (random-src!)))
                             (let ((file? (eq? src-class File-Video-Src))
                                   (audio? #f))
                               (let ((resolution (if file? {Dimension 854 480} video-resolution))
                                     (framerate 30)
                                     (bitrate video-bitrate)
                                     (codec 'none))
                                 (let ((video-src (if file?
                                                      (new File-Video-Src
                                                        "/Users/cartier/Devel/gstreamer/media/sintel.webm"
                                                        resolution: resolution
                                                        framerate: framerate
                                                        bitrate: bitrate
                                                        codec: codec)
                                                    (new src-class
                                                      resolution: resolution
                                                      framerate: framerate
                                                      bitrate: bitrate
                                                      codec: codec)))
                                       (video-sink (player-output~ video name layout: 'gallery position: (rect-position rect) size: (rect-size rect) resolution: resolution codec: codec))
                                       (audio-sink (and (and file? audio?)
                                                        (new world.audio:Audio-Sink
                                                          codec: 'none))))
                                   (when audio-sink
                                     (set-audio-sink~ video-src audio-sink))
                                   (let ((pipeline (if audio-sink
                                                       (pipeline video-src video-sink audio-sink)
                                                     (pipeline video-src video-sink))))
                                     (register-input~ video name video-src)
                                     (display-message~ world (format "{a} joined" name))
                                     pipeline)))))))))
      (for-each setup~ outputs)
      (for-each start~ outputs)
      (sleep .25) ; flicker heuristic. should wait until every new output has drawn
      (layout-outputs~ video)
      outputs)))


(definition (remove-players count)
  )


(definition (close-pipelines pipelines)
  (let ((video (current-video)))
    (for-each stop~ pipelines)
    (for-each (lambda (pipeline)
                (bind (input output) (get-elements~ pipeline)
                  (let ((id (table-find (get-outputs~ video) output)))
                    (close-input~ video id input)
                    (close-output~ video id output))))
              pipelines)))


(definition protected (video-test7)
  (set! circle-pipelines (if (not circle-pipelines)
                             (make-circle-videos)
                           (close-pipelines circle-pipelines)
                           #f)))


(definition protected (video-test8)
  (add-players 1))


(definition protected (video-test9)
  (remove-players 1))


(definition protected (video-test0)
  (if (not test-pipeline)
      (set! test-pipeline (make-test-video))
    (if (not file-pipeline)
        (set! file-pipeline (make-file-video))
      (set! camera-pipeline (make-camera-video))))))
