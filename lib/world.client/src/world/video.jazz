;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Video
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.video jazz


(import (jazz.graphic)
        (jazz.gstreamer)
        (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.billboard)
        (world.configure)
        (world.foreign)
        (world.geometry)
        (world.id)
        (world.quad-texture)
        (world.settings)
        (world.stream)
        (world.stream.foreign)
        (world.syntax (phase syntax))
        (world.task))


(definition protected video-resolution
  (world-setting 'world.video-resolution {Dimension 640 360}))

(definition protected video-framerate
  (world-setting 'world.video-framerate 10))

(definition protected video-bitrate
  (world-setting 'world.video-bitrate 2048))

(definition protected video-alpha
  (world-setting 'world.video-alpha 0.6))

(definition protected video-overlay?
  (world-setting 'world.video-overlay? #f))

(definition protected video-codec
  (world-setting 'world.video-codec 'h264))


(definition layouts
  '(none
    overhead
    sidebar
    fullscreen))

(definition video-layout
  (world-setting 'world.video-layout 'overhead))


(definition video-debug?
  (world-setting 'world.video-debug? #f))


;;;
;;;; Kush
;;;


(definition public (kush-gauge width height rate motion)
  (/ (* width height rate motion 0.07) 1000.))


;;;
;;;; Video
;;;


(definition protected (new-world-video)
  (let ((camera-src (new Camera-Src
                      resolution: video-resolution
                      framerate: video-framerate
                      bitrate: video-bitrate
                      codec: video-codec))
        (server-sink (new Stream-Sink
                       consumer: (lambda (buffer timestamp duration)
                                   (send-client-video~ (client-tier) buffer timestamp duration)))))
    (new World-Video input: (pipeline camera-src server-sink))))


(class World-Video extends Object
  
  
  (slot input   getter generate)
  (slot outputs getter generate)
  
  
  (method override (initialize (input: input #f))
    (nextmethod)
    (set! input~self input)
    (set! outputs~self (make-table test: equal?)))
  
  
  (method (autostart)
    (when (world-setting 'world.video-autostart? #f)
      (start)))
  
  
  (method (start)
    (start~ input))
  
  
  (method (stop)
    (stop~ input)
    (iterate-table outputs
      (lambda (id output)
        (stop~ output))))
  
  
  ;;;
  ;;;; Input
  ;;;
  
  
  (method (on-toggle-video evt)
    (toggle))
  
  
  (method (toggle)
    (when (client?)
      (let ((world (current-world)))
        (if (stopped?~ input)
            (start)
          (stop))
        (update-parameter~ world 'video)
        (display-on/off~ world "Video" (playing?~ input)))))
  
  
  ;;;
  ;;;; Output
  ;;;
  
  
  (method (cache-output id)
    (or (table-ref outputs id #f)
        (let ((output (new-output id)))
          (table-set! outputs id output)
          output)))
  
  (method (find-output id)
    (table-ref outputs id #f))
  
  
  (method (new-output id)
    (case video-layout
      ((overhead)
       (new Billboard-Video-Sink id
         resolution: video-resolution
         framerate: video-framerate
         bitrate: video-bitrate
         codec: video-codec
         alpha: video-alpha
         overlay?: video-overlay?))
      (else
       (new Sheet-Video-Sink
         resolution: video-resolution
         framerate: video-framerate
         bitrate: video-bitrate
         codec: video-codec
         alpha: video-alpha
         overlay?: video-overlay?))))
  
  
  (method (receive-server-video id buffer timestamp duration)
    (if (not buffer)
        (let ((output (find-output id)))
          (when output
            (table-clear outputs id)
            (stop~ output)))
      (let ((output (cache-output id)))
        (start~ output)
        (consume~ output buffer timestamp duration))))
  
  
  (method (render-outputs)
    (iterate-table outputs
      (lambda (id output)
        (render~ output))))
  
  
  ;;;
  ;;;; Layout
  ;;;
  
  
  (method (on-cycle-layouts evt)
    (cycle-layouts))
  
  
  (method (cycle-layouts)
    (let ((zone (current-zone)))
      (case video-layout
        ((none)
         (for-each (lambda (player)
                     (let ((elem (get-billboard-camera~ player)))
                       (when elem
                         (set-render?~ elem #t))))
                   (get-players~ zone))
         (set! video-layout 'overhead))
        ((overhead)
         (for-each (lambda (player)
                     (let ((elem (get-billboard-camera~ player)))
                       (when elem
                         (set-render?~ elem #f))))
                   (get-players~ zone))
         (set! video-layout 'sidebar))
        ((sidebar)
         (for-each (lambda (player)
                     (let ((elem (get-billboard-camera~ player)))
                       (when elem
                         (set-render?~ elem #f))))
                   (get-players~ zone))
         (set! video-layout 'fullscreen))
        ((fullscreen)
         (for-each (lambda (player)
                     (let ((elem (get-billboard-camera~ player)))
                       (when elem
                         (set-render?~ elem #f))))
                   (get-players~ zone))
         (set! video-layout 'none))))))


;;;
;;;; Camera-Src
;;;


(class Camera-Src extends Stream-Src
  
  
  (slot resolution           initialize #f accessors generate)
  (slot framerate            initialize #f accessors generate)
  (slot bitrate              initialize #f accessors generate)
  (slot codec                initialize #f accessors generate)
  (slot pipeline             initialize #f accessors generate)
  (slot appsink              initialize #f accessors generate)
  (slot data     <u8vector>  initialize #f accessors generate)
  (slot info     <u64vector> initialize #f accessors generate)
  (slot task                 initialize #f accessors generate)
  
  
  (method override (initialize (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f))
    (nextmethod)
    (set! resolution~self resolution)
    (set! framerate~self framerate)
    (set! bitrate~self bitrate)
    (set! codec~self codec))
  
  
  (method override (start)
    (define (task-start)
      (let ((procedure
              (lambda (task)
                (camera-task task))))
        (let ((task (new Task 'camera procedure)))
          (start-task task)
          (thread-base-priority-set! (get-thread~ task) video-priority)
          task)))
    
    (unless (eq? state 'playing)
      (init-gstreamer)
      (let ((width (get-width~ resolution))
            (height (get-height~ resolution)))
        (let ((pipeline (gst-launch "avfvideosrc"
                                    "videoscale"
                                    "videoconvert"
                                    (tie "video/x-raw, format=I420, width={width}, height={height}, framerate={framerate}/1")
                                    (and (eq? codec 'h264) (tie "x264enc pass=qual quantizer=20 bitrate={bitrate} tune=zerolatency speed-preset=ultrafast"))
                                    "appsink name=sink")))
          (gst_object_set_name pipeline "camera")
          (let ((appsink (gst_bin_get_by_name pipeline "sink"))
                (data (make-u8vector (* width height 4)))
                (info (make-u64vector 2)))
            (gst_element_set_state pipeline GST_STATE_PLAYING)
            (set! data~self data)
            (set! info~self info)
            (set! pipeline~self pipeline)
            (set! appsink~self appsink)
            (set! task~self (task-start))
            (set! state 'playing))))))
  
  
  (method override (stop)
    (define (task-stop)
      (cease-task task))
    
    (when (eq? state 'playing)
      (task-stop)
      (gst_element_set_state pipeline GST_STATE_NULL)
      (gst_object_unref pipeline)
      (set! info #f)
      (set! data #f)
      (set! pipeline #f)
      (set! appsink #f)
      (set! task #f)
      (set! state #f)))
  
  
  (method (camera-task task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-seconds)))
          ;; not 100% correct if preempted before task-mutex
          (let ((time (current-seconds)))
            (with-task-mutex
              (lambda ()
                (unless (stopping?~ task)
                  (let ((elapse (- time previous))
                        (max-elapse 10.))
                    ;; ignore ridiculous elapses like
                    ;; coming back from computer sleep
                    (unless (> elapse max-elapse)
                      (let ((history (current-history)))
                        (unless (get-paused?~ history)
                          (process))))))))
            (let ((duration (- (current-seconds) time)))
              (task-sleep task video-period duration exit))
            (iter time))))))
  
  
  (method override (process)
    (when (eq? state 'playing)
      (let ((size (gst_app_sink_read appsink data info)))
        (when (/= size -1)
          (let ((buffer (subu8vector data 0 size))
                (timestamp (u64vector-ref info 0))
                (duration (u64vector-ref info 1)))
            (consume~ sink buffer timestamp duration)))))))


;;;
;;;; Video-Sink
;;;


(class Video-Sink extends Stream-Sink
  
  
  (slot resolution           initialize #f accessors generate)
  (slot framerate            initialize #f accessors generate)
  (slot bitrate              initialize #f accessors generate)
  (slot codec                initialize #f accessors generate)
  (slot alpha                initialize #f accessors generate)
  (slot overlay?             initialize #f accessors generate)
  (slot pipeline             initialize #f accessors generate)
  (slot appsrc               initialize #f accessors generate)
  (slot appsink              initialize #f accessors generate)
  (slot data     <u8vector>  initialize #f accessors generate)
  (slot info     <u64vector> initialize #f accessors generate)
  (slot task                 initialize #f accessors generate)
  (slot frame-count          initialize #f)
  (slot frame-start          initialize #f)
  (slot total-size           initialize #f)
  
  
  (method override (initialize (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f) (alpha: alpha #f) (overlay?: overlay? #f))
    (nextmethod)
    (set! resolution~self resolution)
    (set! framerate~self framerate)
    (set! bitrate~self bitrate)
    (set! codec~self codec)
    (set! alpha~self alpha)
    (set! overlay?~self overlay?))
  
  
  (method override (start)
    (define (task-start)
      (let ((procedure
              (lambda (task)
                (video-task task))))
        (let ((task (new Task 'video procedure)))
          (start-task task)
          (thread-base-priority-set! (get-thread~ task) video-priority)
          task)))
    
    (unless (eq? state 'playing)
      (init-gstreamer)
      (let ((width (get-width~ resolution))
            (height (get-height~ resolution)))
        (let ((pipeline (gst-launch (tie "appsrc name=src")
                                    (and (eq? codec 'h264) (tie "avdec_h264"))
                                    "videoconvert"
                                    "videoflip video-direction=horiz"
                                    (tie "alpha alpha={alpha}")
                                    (tie "video/x-raw, format=BGRA, width={width}, height={height}, framerate={framerate}/1")
                                    (tie "appsink name=sink"))))
          (gst_object_set_name pipeline "output")
          (let ((appsrc (gst_bin_get_by_name pipeline "src"))
                (appsink (gst_bin_get_by_name pipeline "sink"))
                (data (make-u8vector (* width height 4)))
                (info (make-u64vector 2)))
            (case codec
              ((h264)
               (gst_app_src_set_caps appsrc
                 (gst_caps "video/x-h264"
                   "width"         (g_value_int width)
                   "height"        (g_value_int height)
                   "framerate"     (g_value_fraction framerate 1)
                   "stream-format" (g_value_string "avc")
                   "alignment"     (g_value_string "au"))))
              (else
               (gst_app_src_set_caps src
                 (gst_caps "video/x-raw"
                   "format"    (g_value_string "I420")
                   "width"     (g_value_int width)
                   "height"    (g_value_int height)
                   "framerate" (g_value_fraction framerate 1)))))
            (g_object_set appsrc
              "is-live"     (g_value_boolean #t)
              "stream-type" (g_value_int GST_APP_STREAM_TYPE_STREAM)
              "format"      (g_value_int GST_FORMAT_TIME))
            (gst_element_set_state pipeline GST_STATE_PLAYING)
            (set! data~self data)
            (set! info~self info)
            (set! pipeline~self pipeline)
            (set! appsrc~self appsrc)
            (set! appsink~self appsink)
            (set! task~self (task-start))
            (set! state 'playing))))))
  
  
  (method override (stop)
    (define (task-stop)
      (cease-task task))
    
    (when (eq? state 'playing)
      (gst_element_set_state pipeline GST_STATE_NULL)
      (gst_object_unref pipeline)
      (set! info #f)
      (set! data #f)
      (set! pipeline #f)
      (set! appsrc #f)
      (set! appsink #f)
      (set! task #f)
      (set! state #f)))
  
  
  (method override (consume buffer timestamp duration)
    (gst_app_src_write3 appsrc buffer (u8vector-length buffer) timestamp duration))
  
  
  (method (video-task task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-seconds)))
          ;; not 100% correct if preempted before task-mutex
          (let ((time (current-seconds)))
            (with-task-mutex
              (lambda ()
                (unless (stopping?~ task)
                  (let ((elapse (- time previous))
                        (max-elapse 10.))
                    ;; ignore ridiculous elapses like
                    ;; coming back from computer sleep
                    (unless (> elapse max-elapse)
                      (let ((history (current-history)))
                        (unless (get-paused?~ history)
                          (process))))))))
            (let ((duration (- (current-seconds) time)))
              (task-sleep task video-period duration exit))
            (iter time))))))
  
  
  (method override (process)
    (let ((size (gst_app_sink_read appsink data info)))
      (when (/= size -1)
        (let ((buffer (subu8vector data 0 size))
              (timestamp (u64vector-ref info 0))
              (duration (u64vector-ref info 1)))
          (draw buffer timestamp duration)))))
  
  
  (method protected virtual (draw buffer timestamp duration)
    )
  
  
  (method (update buffer texture)
    (define (add-overlay)
      (if (not frame-count)
          (begin
            (set! frame-count 1)
            (set! frame-start (current-seconds))
            (set! total-size (u8vector-length buffer)))
        (increase! frame-count)
        (increase! total-size (u8vector-length buffer))
        (let ((elapse (- (current-seconds) frame-start)))
          (let ((rate (/ (cast <fl> frame-count) elapse))
                (size (/ (cast <fl> total-size) frame-count)))
            (set-font~ (get-surface~ texture) {Font font-name: tahoma point-size: 24 hint-style: slight hint-metrics: on})
            (draw-text~ (get-surface~ texture) 5 (- (get-height~ resolution) 30) (format "Rate: {r precision: 3}, Size: {a}" rate size) {Color World-Red})))))
    
    (copy_to_texture buffer (u8vector-length buffer) (get-data~ texture))
    (when overlay?
      (add-overlay))
    (map-texture~ texture))
  
  
  (method protected virtual (render)
    ))


;;;
;;;; Billboard-Video-Sink
;;;


(class Billboard-Video-Sink extends Video-Sink
  
  
  (slot player    initialize #f accessors generate)
  (slot billboard initialize #f accessors generate)
  
  
  (method override (initialize id . rest)
    (apply nextmethod rest)
    (let ((p (find-entity id)))
      (let ((elem (cache-billboard-camera~ p (list (eq? p (current-me))))))
        (set! player p)
        (set! billboard elem))))
  
  
  (method override (stop)
    (nextmethod)
    (when player
      (set-billboard-camera~ player #f)
      (set! player #f)
      (set! billboard #f)))
  
  
  (method override (draw buffer timestamp duration)
    (update buffer (get-texture~ (cache-quad-texture~ billboard))))
  
  
  (method override (render)
    ;; nothing to do render done by player billboard
    ))


;;;
;;;; Billboard-Camera
;;;


(definition public (make-billboard-camera billboard)
  (new Billboard-Camera
    billboard: billboard))


(class Billboard-Camera extends Billboard-Element
  
  
  (method override (make-billboard-texture)
    (bind (me?) billboard
      (let ((width (get-width~ video-resolution))
            (height (get-height~ video-resolution)))
        (let ((w 1.)
              (h .5625))
          (let ((v1 (vertex (/ w -2.) (/ h  2.) 0.))
                (v2 (vertex (/ w -2.) (/ h -2.) 0.))
                (v3 (vertex (/ w  2.) (/ h -2.) 0.))
                (v4 (vertex (/ w  2.) (/ h  2.) 0.)))
            (let ((quad-texture <Quad-Texture> (make-quad-texture width height v1 v2 v3 v4)))
              (let ((texture (get-texture~ quad-texture)))
                (let ((surface (get-surface~ texture)))
                  (clear~ surface)
                  (map-texture~ texture)))
              quad-texture))))))
  
  
  (method override (billboard-top)
    2.6)
  
  
  (method override (billboard-center)
    .4))


;;;
;;;; Texture-Video-Sink
;;;


(class Texture-Video-Sink extends Video-Sink)


;;;
;;;; Sheet-Video-Sink
;;;


(class Sheet-Video-Sink extends Video-Sink
  
  
  (slot sheet initialize #f accessors generate)
  
  
  (method override (initialize . rest)
    (apply nextmethod rest)
    (let ((world (current-world)))
      (let ((s (world.interface.sheet:make-world-sheet 'video world.interface.sheet:World-Sheet (get-width~ resolution) (get-height~ resolution))))
        (make-orthographic-matrix! (get-projection-matrix~ s) 0. (get-width~ world) 0. (get-height~ world) 0. 10.)
        (set! sheet s))))
  
  
  (method override (stop)
    (nextmethod)
    (when sheet
      (glDeleteTextures* (get-id~ (get-texture~ sheet)))
      (set! sheet #f)))
  
  
  (method override (draw buffer timestamp duration)
    (update buffer (get-texture~ sheet)))
  
  
  (method override (render)
    (let ((world (current-world)))
      (let ((x 0.)
            (y 0.)
            (h (cast <fl> (get-height~ resolution))))
        (let ((matrix (make-translation-matrix (vertex x (- (get-height~ world) y h) 0.))))
          (render-sheet~ sheet matrix))))))


;;;
;;;; Test
;;;


@w
(definition public (test-video resolution framerate bitrate codec)
  (let ((camera (new Camera-Src resolution: resolution framerate: framerate bitrate: bitrate codec: codec))
        (debug (new Debug-Sink)))
    (let ((pipeline (pipeline camera debug)))
      (start~ camera resolution framerate bitrate codec)
      (start~ debug)
      pipeline)))


(definition protected (start-test)
  (debug 'start-test)
  )


(definition protected (stop-test)
  (debug 'stop-test)
  ))
