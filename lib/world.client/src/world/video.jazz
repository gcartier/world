;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Video
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.video jazz


(import (jazz.graphic)
        (jazz.gstreamer)
        (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.billboard)
        (world.configure)
        (world.foreign.gstreamer)
        (world.geometry)
        (world.id)
        (world.quad-texture)
        (world.settings)
        (world.stream)
        (world.syntax (phase syntax))
        (world.task))


(definition protected video-resolution
  (world-setting 'world.video-resolution {Dimension 640 360}))

(definition video-framerate
  (world-setting 'world.video-framerate 20))

(definition video-bitrate
  (world-setting 'world.video-bitrate 2048))

(definition video-alpha
  (world-setting 'world.video-alpha 0.6))

(definition video-overlay?
  (world-setting 'world.video-overlay? #f))

(definition video-codec
  (world-setting 'world.video-codec 'h264))


(definition layouts
  '(none
    overhead
    sidebar
    fullscreen))

(definition video-layout
  (world-setting 'world.video-layout 'overhead))


(definition video-debug?
  (world-setting 'world.video-debug? #f))


;;;
;;;; Kush
;;;


(definition public (kush-gauge width height rate motion)
  (/ (* width height rate motion 0.07) 1000.))


;;;
;;;; Start
;;;


(definition protected (start-video)
  (when (and (client?) (world-setting 'world.video-input? #f))
    (start-input~ (current-video))))


;;;
;;;; Task
;;;


(definition public (video-task task <Task>)
  (declare (proper-tail-calls))
  (with-task task
    (lambda (exit)
      (let (iter (previous (current-seconds)))
        (let ((time (current-seconds)))
          (let ((elapse (- time previous)))
            (unless (stopping?~ task)
              (site (video on?: #t)
                (process-video)))
            (let ((duration (- (current-seconds) time)))
              (task-sleep task video-period duration exit))
            (iter time)))))))


(definition (process-video)
  (when (client?)
    (process-input~ (current-video))
    (iterate-table video-outputs
      (lambda (id output)
        (extract-output~ output)))))


;;;
;;;; Input
;;;


(class World-Video extends Object
  
  
  (slot input?   <bool>      initialize #f accessors generate)
  (slot pipeline             initialize #f accessors generate)
  (slot sink                 initialize #f accessors generate)
  (slot buffer   <u8vector>  initialize #f accessors generate)
  (slot info     <u64vector> initialize #f accessors generate)
  
  
  (method (on-toggle-video evt)
    (toggle-input))
  
  
  (method (toggle-input)
    (when (client?)
      (let ((world (current-world)))
        (if (not input?)
            (start-input)
          (stop-input))
        (update-parameter~ world 'video)
        (display-on/off~ world "Video" input?))))
  
  
  (method (start-input)
    (unless input?
      (init-gstreamer)
      (let ((width (get-width~ video-resolution))
            (height (get-height~ video-resolution))
            (framerate video-framerate)
            (bitrate video-bitrate)
            (codec video-codec))
        (when video-debug?
          (terminal 'input 'start))
        (let ((pipeline (gst-launch "avfvideosrc"
                                    "videoscale"
                                    "videoconvert"
                                    (tie "video/x-raw, format=I420, width={width}, height={height}, framerate={framerate}/1")
                                    (and (eq? codec 'h264) (tie "x264enc pass=qual quantizer=20 bitrate={bitrate} tune=zerolatency speed-preset=ultrafast"))
                                    "appsink name=sink")))
          (gst_object_set_name pipeline "input")
          (let ((sink (gst_bin_get_by_name pipeline "sink"))
                (buffer (make-u8vector (* width height 4)))
                (info (make-u64vector 2)))
            (gst_element_set_state pipeline GST_STATE_PLAYING)
            (set! buffer~self buffer)
            (set! info~self info)
            (set! pipeline~self pipeline)
            (set! sink~self sink)
            (set! input? #t))))))
  
  
  (method (stop-input)
    (when input?
      (when video-debug?
        (terminal 'input 'stop))
      (gst_element_set_state pipeline GST_STATE_NULL)
      (gst_object_unref pipeline)
      (set! info #f)
      (set! buffer #f)
      (set! pipeline #f)
      (set! sink #f)
      (set! input? #f)))
  
  
  (method (process-input)
    (when input?
      (let ((size (gst_app_sink_read sink buffer info)))
        (when (/= size -1)
          (let ((timestamp (u64vector-ref info 0))
                (duration (u64vector-ref info 1)))
            (when video-debug?
              (terminal 'input 'send size))
            (send-client-video~ (client-tier) (subu8vector buffer 0 size) timestamp duration)))))))


;;;
;;;; Output
;;;


(class World-Video-Output extends Object
  
  
  (slot id                      initialize #f accessors generate)
  (slot output?     <bool>      initialize #f accessors generate)
  (slot billboard               initialize #f accessors generate)
  (slot player                  initialize #f accessors generate)
  (slot pipeline                initialize #f accessors generate)
  (slot src                     initialize #f accessors generate)
  (slot sink                    initialize #f accessors generate)
  (slot buffer      <u8vector>  initialize #f accessors generate)
  (slot info        <u64vector> initialize #f accessors generate)
  (slot frame-count             initialize #f)
  (slot frame-start             initialize #f)
  (slot total-size              initialize #f)
  
  
  (method override (initialize id)
    (nextmethod)
    (set! id~self id))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" id))))
  
  
  (method (on-cycle-layouts evt)
    (cycle-layouts))
  
  
  (method (start-output)
    (unless output?
      (init-gstreamer)
      (let ((width (get-width~ video-resolution))
            (height (get-height~ video-resolution))
            (framerate video-framerate)
            (alpha video-alpha)
            (codec video-codec))
        (when video-debug?
          (terminal 'output 'start id))
        (let ((pipeline (gst-launch (tie "appsrc name=src")
                                    (and (eq? codec 'h264) (tie "avdec_h264"))
                                    "videoconvert"
                                    "videoflip video-direction=horiz"
                                    (tie "alpha alpha={alpha}")
                                    (tie "video/x-raw, format=BGRA, width={width}, height={height}, framerate={framerate}/1")
                                    (tie "appsink name=sink"))))
          (gst_object_set_name pipeline "output")
          (let ((src (gst_bin_get_by_name pipeline "src"))
                (sink (gst_bin_get_by_name pipeline "sink"))
                (buffer (make-u8vector (* width height 4)))
                (info (make-u64vector 2)))
            (case codec
              ((h264)
               (gst_app_src_set_caps src
                 (gst_caps "video/x-h264"
                   "width"         (g_value_int width)
                   "height"        (g_value_int height)
                   "framerate"     (g_value_fraction framerate 1)
                   "stream-format" (g_value_string "avc")
                   "alignment"     (g_value_string "au"))))
              ((vp8)
               (gst_app_src_set_caps src
                 (gst_caps "video/x-vp8"
                   "width"         (g_value_int width)
                   "height"        (g_value_int height)
                   "framerate"     (g_value_fraction framerate 1)
                   "stream-format" (g_value_string "avc")
                   "alignment"     (g_value_string "au"))))
              (else
               (gst_app_src_set_caps src
                 (gst_caps "video/x-raw"
                   "format"    (g_value_string "I420")
                   "width"     (g_value_int width)
                   "height"    (g_value_int height)
                   "framerate" (g_value_fraction framerate 1)))))
            (g_object_set src
              "is-live"     (g_value_boolean #t)
              "stream-type" (g_value_int GST_APP_STREAM_TYPE_STREAM)
              "format"      (g_value_int GST_FORMAT_TIME))
            (gst_element_set_state pipeline GST_STATE_PLAYING)
            (set! buffer~self buffer)
            (set! info~self info)
            (set! pipeline~self pipeline)
            (set! src~self src)
            (set! sink~self sink)
            (set! output? #t))))))
  
  
  (method (stop-output)
    (when output?
      (when video-debug?
        (terminal 'output 'stop id))
      (gst_element_set_state pipeline GST_STATE_NULL)
      (gst_object_unref pipeline)
      (set! info #f)
      (set! buffer #f)
      (set! pipeline #f)
      (set! src #f)
      (set! sink #f)
      (set! output? #f)))
  
  
  (method (receive-output bytes timestamp duration)
    (when video-debug?
      (terminal 'output 'receive (u8vector-length bytes)))
    (gst_app_src_write3 src bytes (u8vector-length bytes) timestamp duration))
  
  
  (method (extract-output)
    (let ((size (gst_app_sink_read sink buffer info)))
      (when (/= size -1)
        (let ((timestamp (u64vector-ref info 0))
              (duration (u64vector-ref info 1)))
          (when video-debug?
            (terminal 'output 'extract size))
          (display-output buffer timestamp duration)))))
  
  
  (method (display-output bytes timestamp duration)
    (define (update-texture texture)
      (define (add-overlay)
        (if (not frame-count)
            (begin
              (set! frame-count 1)
              (set! frame-start (current-seconds))
              (set! total-size (u8vector-length bytes)))
          (increase! frame-count)
          (increase! total-size (u8vector-length bytes))
          (let ((elapse (- (current-seconds) frame-start)))
            (let ((rate (/ (cast <fl> frame-count) elapse))
                  (size (/ (cast <fl> total-size) frame-count)))
              (set-font~ (get-surface~ texture) {Font font-name: tahoma point-size: 24 hint-style: slight hint-metrics: on})
              (draw-text~ (get-surface~ texture) 5 (- (get-height~ video-resolution) 30) (format "Rate: {r precision: 3}, Size: {a}" rate size) {Color World-Red})))))
      
      (copy_to_texture bytes (u8vector-length bytes) (get-data~ texture))
      (when video-overlay?
        (add-overlay))
      (map-texture~ texture))
    
    (define (find-texture)
      (case video-layout
        ((overhead)
         (get-texture~ (cache-quad-texture~ (cache-billboard))))
        ((sidebar fullscreen)
         (get-texture~ (cache-player {Dimension 320 180})))))
    
    (update-texture (find-texture)))
  
  
  (method (render-output)
    (let ((world (current-world)))
      (case video-layout
        ((overhead)
         )
        ((sidebar fullscreen)
         (when billboard
           (let ((x 0.)
                 (y 0.)
                 (h (cast <fl> (get-height~ world.video:video-resolution)) @w 720.))
             (let ((matrix (make-translation-matrix (vertex x (- (get-height~ world) y h) 0.))))
               (render-player~ billboard matrix))))))))
  
  
  (method (cache-billboard)
    (or billboard
        (let ((player (find-entity id)))
          (let ((elem (cache-billboard-camera~ player (list (eq? player (current-me))))))
            (set! billboard elem)
            elem))))
  
  
  (method (cache-player size)
    (or player
        (let ((world (current-world)))
          (let ((play (world.interface.player:make-world-player 'video world.interface.player:World-Player (get-width~ size) (get-height~ size))))
            (make-orthographic-matrix! (get-projection-matrix~ player) 0. (get-width~ world) 0. (get-height~ world) 0. 10.)
            (set! player play)
            play)))))


;;;
;;;; Outputs
;;;


(definition video-outputs
  (make-table test: equal?))


(definition (cache-video-output id)
  (or (table-ref video-outputs id #f)
      (let ((output (create-video-output id)))
        (table-set! video-outputs id output)
        output)))


(definition (create-video-output id)
  (new World-Video-Output id))


(definition public (receive-server-video id bytes timestamp duration)
  (let ((output (cache-video-output id)))
    (start-output~ output)
    (receive-output~ output bytes timestamp duration)))


(definition public (render-video-outputs)
  (iterate-table video-outputs
    (lambda (id output)
      (render-output~ output))))


;;;
;;;; Layouts
;;;


(definition (cycle-layouts)
  (let ((zone (current-zone)))
    (case video-layout
      ((none)
       (for-each (lambda (player)
                   (let ((elem (get-billboard-camera~ player)))
                     (when elem
                       (set-render?~ elem #t))))
                 (get-players~ zone))
       (set! video-layout 'overhead))
      ((overhead)
       (for-each (lambda (player)
                   (let ((elem (get-billboard-camera~ player)))
                     (when elem
                       (set-render?~ elem #f))))
                 (get-players~ zone))
       (set! video-layout 'sidebar))
      ((sidebar)
       (for-each (lambda (player)
                   (let ((elem (get-billboard-camera~ player)))
                     (when elem
                       (set-render?~ elem #f))))
                 (get-players~ zone))
       (set! video-layout 'fullscreen))
      ((fullscreen)
       (for-each (lambda (player)
                   (let ((elem (get-billboard-camera~ player)))
                     (when elem
                       (set-render?~ elem #f))))
                 (get-players~ zone))
       (set! video-layout 'none)))))


;;;
;;;; Billboard
;;;


(definition public (make-billboard-camera billboard)
  (new Billboard-Camera
    billboard: billboard))


(class Billboard-Camera extends Billboard-Element
  
  
  (method override (make-billboard-texture)
    (bind (me?) billboard
      (let ((width (get-width~ video-resolution))
            (height (get-height~ video-resolution)))
        (let ((w 1.)
              (h .5625))
          (let ((v1 (vertex (/ w -2.) (/ h  2.) 0.))
                (v2 (vertex (/ w -2.) (/ h -2.) 0.))
                (v3 (vertex (/ w  2.) (/ h -2.) 0.))
                (v4 (vertex (/ w  2.) (/ h  2.) 0.)))
            (let ((quad-texture <Quad-Texture> (make-quad-texture width height v1 v2 v3 v4)))
              (let ((texture (get-texture~ quad-texture)))
                (let ((surface (get-surface~ texture)))
                  (clear~ surface)
                  (map-texture~ texture)))
              quad-texture))))))
  
  
  (method override (billboard-top)
    2.6)
  
  
  (method override (billboard-center)
    .4)))
