;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Video
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.video jazz


(import (jazz.cairo)
        (jazz.component)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.io)
        (jazz.presence)
        (jazz.settings)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (jazz.time)
        (jazz.view)
        (jazz.window)
        (world)
        (world.autoload)
        (world.billboard)
        (world.configure)
        (world.console)
        (world.context)
        (world.entity)
        (world.event)
        (world.foreign)
        (world.geometry)
        (world.hook)
        (world.id)
        (world.interface)
        (world.interface.sheet)
        (world.io)
        (world.layout)
        (world.media)
        (world.pane)
        (world.plane)
        (world.profile)
        (world.quad-texture)
        (world.settings)
        (world.stream)
        (world.task)
        (world.texture)
        (world.time)
        (world.udp)
        (world.window))


(definition protected video-resolution
  (world-setting 'world.video-resolution {Dimension 640 360}))

(definition protected video-framerate
  (world-setting 'world.video-framerate 15))

(definition protected video-bitrate
  (world-setting 'world.video-bitrate 1024))

(definition protected video-codec
  (world-setting 'world.video-codec 'h264))

(definition protected video-profile
  (world-setting 'world.video-profile (find-setting 'caps.profile.video)))

(definition protected video-hardware?
  (world-setting 'world.video-hardware? #f))


(definition protected camera-profile
  (world-setting 'world.camera-profile (find-setting 'caps.profile.camera)))

(definition protected camera-keyframes
  (world-setting 'world.camera-keyframes 2))


(definition protected screen-share-resolution
  (world-setting 'world.screen-share-resolution {Dimension 1280 720}))

(definition protected screen-share-framerate
  (world-setting 'world.screen-share-framerate 5))

(definition protected screen-share-bitrate
  (world-setting 'world.screen-share-bitrate 1024))

(definition protected screen-share-codec
  (world-setting 'world.screen-share-codec 'h264))

(definition protected screen-share-keyframes
  (world-setting 'world.screen-share-keyframes 2))


(definition layouts
  '(;;overhead
    sidebar
    gallery))

(definition public video-layout
  (world-setting 'world.video-layout 'sidebar @currently-buggy-when-we-cycle 'overhead))


(definition public video-mode
  'fit)

(definition public (set-video-mode mode)
  (let ((video (current-video)))
    (set! video-mode mode)
    (if (eq? video-layout 'focus)
        (let ((focused-output (effective-focused-output video)))
          (when focused-output
            (move-focused focused-output)))
      (layout-outputs video))))


(definition protected video-interface?
  #t)

(definition protected (set-video-interface? flag)
  (set! video-interface? flag))


(definition protected video-alpha
  (world-setting 'world.video-alpha #f @wait 0.6))


(definition protected video-show
  (world-setting 'world.video-show #f))


(definition protected speakers-xp?
  (world-setting 'world.speakers-xp? #f))


(definition protected slide-duration
  (world-setting 'world.slide-duration .2))


;;;
;;;; Kush
;;;


(definition public (kush-gauge width height rate motion)
  (/ (* width height rate motion 0.07) 1000.))


;;;
;;;; Codec
;;;


(class H264-Codec extends Codec
  
  
  (method override (buffer-header? self buffer)
    (let ((pos 5))
      (and (< pos (u8vector-length buffer))
           (= (u8vector-ref buffer pos) 16)))))


(register-codec (new H264-Codec 'h264 'video))


;;;
;;;; Header
;;;


;; first four bytes are always 00 00 00 01
(definition protected (video-buffer-header? buffer)
  (let ((pos 5))
    (and (< pos (u8vector-length buffer))
         (= (u8vector-ref buffer pos) 16))))


;;;
;;;; Profile
;;;


(class Video-Profile extends Object
  
  
  (slot name       getter generate)
  (slot level      getter generate)
  (slot extension  getter generate)
  (slot resolution getter generate)
  (slot framerate  getter generate)
  (slot bitrate    getter generate)
  (slot codec      getter generate)
  
  
  (method override (initialize self name level resolution framerate bitrate codec)
    (nextmethod self)
    (set! self.name name)
    (set! self.level level)
    (set! self.extension (format "streamvideo{a}" level))
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name)))))


;;;
;;;; Profiles
;;;


(definition protected video-profile-names
  (make-table test: eq?))

(definition protected video-profile-levels
  (make-table test: eqv?))


(definition protected (register-video-profile profile)
  (table-set! video-profile-names (get-name profile) profile)
  (table-set! video-profile-levels (get-level profile) profile))

(definition protected (name->video-profile name)
  (table-ref video-profile-names name))

(definition protected (level->video-profile level)
  (table-ref video-profile-levels level))


(definition public (active-video-profile)
  (name->video-profile video-profile))


(definition public (video-profile-level)
  (get-level (active-video-profile)))


(definition public (video-profile-extension)
  (get-extension (active-video-profile)))


(definition public (streaming-video-profiles)
  (streaming-profiles (active-video-profile)))


(definition public (streaming-profiles profile)
  (let ((level (get-level profile)))
    (loop (for l from level downto 0)
          (collect (level->video-profile l)))))


(definition protected (locate-stream-video-channel stream)
  (let ((receive-level (stream-receive-video-level stream)))
    (table-search (lambda (no channel)
                    (and (= (get-media-kind channel) udp-video)
                         (or (not receive-level)
                             (= (get-level channel) receive-level))
                         channel))
                  (get-channels stream))))


(definition protected (stream-receive-video-level stream)
  (let ((stream-level (get-video-level stream)))
    (and stream-level
         (min stream-level (video-profile-level)))))


(register-video-profile (new Video-Profile 'high   4 {Dimension 1920 1080} 30 4096 'h264))
(register-video-profile (new Video-Profile 'good   3 {Dimension 1280  720} 20 2048 'h264))
(register-video-profile (new Video-Profile 'medium 2 {Dimension  640  360} 15 1024 'h264))
(register-video-profile (new Video-Profile 'low    1 {Dimension  320  180} 12  768 'h264))
(register-video-profile (new Video-Profile 'poor   0 {Dimension  224 	126}  8  512 'h264))


;;;
;;;; Focused
;;;


(definition (adjust-focused bounds rect)
  (if (eq? video-mode 'fit)
      rect
    ;; fill mode
    (let ((ratio (fit-rects rect bounds 'fill)))
      (let ((new-width (fxround (* (cast <fl> (rect-width rect)) ratio)))
            (new-height (fxround (* (cast <fl> (rect-height rect)) ratio))))
        (let ((pos (center (new Dimension new-width new-height) (rect-size bounds))))
          (let ((h (get-h pos))
                (v (get-v pos)))
            (new Rect h v (+ h new-width) (+ v new-height))))))))


(definition (focused-rect bounds)
  (car (layout-tiles 1 bounds)))


;;;
;;;; Circle
;;;


(definition protected layout-circle-hook
  #f)

(definition protected (set-layout-circle-hook proc)
  (set! layout-circle-hook (and proc (new Hook proc))))


;;;
;;;; Video
;;;


(class World-Video extends Object
  
  
  (slot outputs         getter generate)
  (slot ordered-outputs getter generate)
  (slot self-output     getter generate)
  (slot focused-output  accessors generate)
  (slot render-hook     accessors generate)
  
  
  (method override (initialize self)
    (nextmethod self)
    (set! self.outputs (make-table test: equal?))
    (set! ordered-outputs '())
    (set! self-output #f)
    (set! focused-output #f)
    (set! render-hook #f))
  
  
  (method package (resize self)
    (iterate-table outputs
      (lambda (id output)
        (resize output)))
    (when focused-output
      (resize focused-output))
    (layout-outputs self)
    (when (eq? video-layout 'focus)
      (let ((focused-output (effective-focused-output self)))
        (when focused-output
          (move-focused focused-output)))))
  
  
  ;;;
  ;;;; Outputs
  ;;;
  
  
  (method package (find-output self id)
    (table-ref outputs id #f))
  
  (method package (register-output self id output)
    (table-set! outputs id output))
  
  
  (method package (entity-output self id (position: position #f) (size: size #f) (resolution: resolution #f) (codec: codec #f))
    (or (table-ref outputs id #f)
        (let ((entity (find-entity id)))
          (let ((output (new Draw-Video-Sink entity
                             resolution: (or resolution {Dimension 1280 720})
                             framerate: video-framerate
                             bitrate: video-bitrate
                             codec: (or codec video-codec)
                             alpha-overlay: video-alpha)))
            (table-set! outputs id output)
            (play output)
            output))))
  
  
  (method package (player-output self id (channel: channel #f) (player: player #f) (position: position #f) (size: size #f) (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f) (caps: caps #f))
    (define (add-output output)
      (if #f @wait-for-circle-tests (and self-output (neq? output self-output))
          ;; reposition so self output is always last
          (set! ordered-outputs (append! (remove! self-output ordered-outputs) (list output self-output)))
        (set! ordered-outputs (append! ordered-outputs (list output)))))
    
    (or (table-ref outputs id #f)
        ;; the or is a quick hack to test self video
        (let ((player (or player (find-entity id))))
          (let ((output (case video-layout
                          ((overhead)
                           (new Overhead-Video-Sink
                             player
                             resolution: (or resolution video-resolution)
                             framerate: (or framerate video-framerate)
                             bitrate: (or bitrate video-bitrate)
                             codec: (or codec video-codec)
                             caps: caps
                             alpha-overlay: video-alpha))
                          (else
                           (new Circle-Video-Sink
                             id
                             channel
                             player
                             position: position
                             size: size
                             resolution: (or resolution video-resolution)
                             framerate: (or framerate video-framerate)
                             bitrate: (or bitrate video-bitrate)
                             codec: (or codec video-codec)
                             caps: caps
                             alpha-overlay: video-alpha
                             process?: (boolean id))))))
            (table-set! outputs id output)
            (when (not id)
              (set! self-output output))
            (add-output output)
            (play output)
            output))))
  
  
  (method package (channel-output self channel (player: player #f) (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f) (caps: caps #f))
    (assert resolution
      (let ((output (player-output self (get-no channel)
                      channel: channel
                      player: player
                      resolution: resolution
                      framerate: framerate
                      bitrate: bitrate
                      codec: codec
                      caps: caps)))
        (invalidate-state output)
        (update-layouts self)
        output)))
  
  
  (method package (visualizer-output self position size)
    (let ((output (new Sheet-Video-Sink
                    #f
                    position: position
                    size: size
                    resolution: video-resolution
                    framerate: video-framerate
                    bitrate: video-bitrate
                    codec: video-codec
                    alpha-overlay: video-alpha
                    process?: #t)))
      (play output)
      output))
  
  
  (method package (close-output self id output (layout?: layout? #t))
    (table-clear outputs id)
    (set! ordered-outputs (remove! output ordered-outputs))
    (when (eq? output self-output)
      (set! self-output #f))
    (when (eq? output focused-output)
      (set! focused-output #f))
    (release output)
    (close output)
    (when layout?
      (update-layouts self)))
  
  
  (method package (effective-focused-output self)
    (or focused-output
        (and (not-null? ordered-outputs)
             (car ordered-outputs))))
  
  
  (method package (change-focused-output self output)
    (when focused-output
      (unfocus focused-output))
    (set! focused-output output)
    (when output
      (focus output)))
  
  
  (method package (receive-server-video self id buffer timestamp duration)
    (let ((output (find-output self id)))
      (when output
        (if (not buffer)
            (set-stream-state output 'off)
          (when (eq? (get-stream-state output) 'off)
            (set-stream-state output 'on))
          (consume output buffer timestamp duration)
          (record-event udp-id-sink-media
                        (fixnum->flonum id)
                        (fixnum->flonum client-no)
                        (fixnum->flonum udp-video)
                        -1.
                        -1.
                        -1.
                        (timestamp->flonum timestamp))))))
  
  
  (method package (receive-visualizer-video self output buffer timestamp duration)
    (if (not buffer)
        (set-stream-state output 'off)
      (when (eq? (get-stream-state output) 'off)
        (set-stream-state output 'on))
      (consume output buffer timestamp duration)))
  
  
  (method package (receive-video self id/output buffer timestamp duration)
    (if (is? id/output Video-Sink)
        (receive-visualizer-video self id/output buffer timestamp duration)
      (receive-server-video self id/output buffer timestamp duration)))
  
  
  (method package (receive-processor-draw self id color alpha timestamp duration background slide?)
    (if (not color)
        (let ((output (find-output self id)))
          (when output
            (close-output self id output)))
      (let ((output (entity-output self id)))
        (set-background output background)
        (if (not slide?)
            (consume output color timestamp duration alpha)
          (let ((texture (get-texture (cache-quad-texture (get-pane output)))))
            (with-slide output texture
              (lambda ()
                (consume output color timestamp duration alpha))))))))
  
  
  (method package (render-outputs self)
    (unless (and render-hook
                 (render-hook self))
      (if (eq? video-layout 'focus)
          (let ((focused-output (effective-focused-output self)))
            (when focused-output
              (render focused-output)))
        (for-each render ordered-outputs))
      (when (and (eq? video-layout 'focus) @wait-mini-self-in-focus-layoutvideo-interface? video-interface?)
        (let ((focused-output (effective-focused-output self)))
          (for-each (lambda (output)
                      (unless (eq? output focused-output)
                        (render output)))
                    ordered-outputs)))))
  
  
  (method package (redraw-outputs self)
    (for-each (lambda (output)
                (redraw-texture (get-interface-pane output)))
              ordered-outputs))
  
  
  ;;;
  ;;;; Layout
  ;;;
  
  
  (method (on-cycle-layouts self evt)
    (let ((world (current-world)))
      (cycle-layouts self)
      (display-message world (capitalize (symbol->string video-layout)))))
  
  
  (method (cycle-layouts self)
    (case video-layout
      ((overhead)
       (sidebar-layout self))
      ((sidebar)
       (gallery-layout self))
      ((gallery)
       (circle-layout self))
      ((circle)
       (focus-layout self))
      ((circle)
       (gallery-layout self))))
  
  
  (method protected (update-layouts self)
    (case video-layout
      ((overhead)
       (overhead-layout self))
      ((sidebar)
       (sidebar-layout self))
      ((gallery)
       (gallery-layout self))
      ((circle)
       (circle-layout self))
      ((focus)
       (focus-layout self))))
  
  
  (method (stop-renders self)
    (let ((zone (current-zone)))
      (for-each (lambda (player)
                  (let ((elem (get-camera-pane player)))
                    (when elem
                      (set-render? elem #f))))
                (get-players zone))))
  
  
  (method public (goto-layout self layout)
    (case layout
      ((circle)
       (circle-layout self))
      ((focus)
       (focus-layout self))
      ((gallery)
       (gallery-layout self))))
  
  
  (method package (overhead-layout self)
    (stop-renders self)
    (set! video-layout 'overhead)
    (layout-outputs self))
  
  
  (method package (sidebar-layout self)
    (stop-renders self)
    (set! video-layout 'sidebar)
    (layout-outputs self))
  
  
  (method package (gallery-layout self)
    (set! video-layout 'gallery)
    (layout-outputs self))
  
  
  (method package (layout-outputs self)
    (when (not-null? ordered-outputs)
      (let ((rectangles (layout self (length ordered-outputs))))
        (when rectangles
          (for-each (lambda (output rect)
                      ;; quick hacks to test self video
                      (let ((player (or (get-player output) (current-me))))
                        (let ((elem (get-camera-pane player)))
                          (if (not rect)
                              (when elem
                                (set-render? elem #f))
                            (when elem
                              (set-render? elem #t))
                            (move output rect)
                            (update-panes output)))))
                    ordered-outputs
                    rectangles)))))
  
  
  (method package (layout self num-players)
    (let ((window (current-window)))
      (let ((bounds (get-bounds window)))
        (let ((l (get-left bounds))
              (t (get-top bounds))
              (r (get-right bounds))
              (b (get-bottom bounds)))
          (case video-layout
            ((sidebar)
             (layout-tiles num-players (new Rect 10 70 210 (- b 100))))
            ((gallery)
             (let ((focused (focused-rect bounds)))
               (if (= num-players 1)
                   (list (adjust-focused bounds focused))
                 (reverse (layout-tiles num-players bounds)))))
            (else
             #f))))))
  
  
  (method package (circle-layout self)
    (set! video-layout 'circle)
    (update-circle-layout self))
  
  
  (method package (focus-layout self)
    (set! video-layout 'focus)
    (update-circle-layout self)
    (let ((focused-output (effective-focused-output self)))
      (when focused-output
        (move-focused focused-output))))
  
  
  (method (update-circle-layout self)
    (let ((count (length ordered-outputs)))
      (assert layout-circle-hook
        (with-safe-hook layout-circle-hook
          (lambda (procedure)
            (let ((matrices (procedure ordered-outputs)))
              (for-each (lambda (output placement)
                          (bind (translation . rotation) placement
                            (set-translation output translation)
                            (set-rotation output rotation)
                            (update-matrices output count)
                            (update-panes output)))
                        ordered-outputs
                        matrices)))))))
  
  
  (method protected (update-interface-matrices self)
    (let ((count (length ordered-outputs)))
      (for-each (lambda (output)
                  (update-interface-matrix output count))
                ordered-outputs))))


;;;
;;;; Video-Src
;;;


(class Video-Src extends Stream-Src
  
  
  (slot task initialize #f accessors generate)
  
  
  (method (start-listeners self)
    (for-each start-listener sinks))
  
  
  (method (stop-listeners self)
    (for-each stop-listener sinks))
  
  
  (method (task-start self name)
    (let ((procedure
            (lambda (task)
              (video-loop self task))))
      (let ((task (new Task name procedure priority: video-priority)))
        (start-listeners self)
        (start-task task)
        (set! self.task task))))
  
  
  (method (task-stop self)
    (stop-listeners self)
    (stop-task task)
    (set! task #f))
  
  
  (method protected virtual (video-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (if (stopping? task)
              (task-done task exit)
            (process self task exit)
            (task-halt task exit)
            (iter))))))
  
  
  (method override (process self task exit)
    (for-each (lambda (consumer)
                (gst_app_sink_process task exit consumer))
              sinks)))


;;;
;;;; Camera-Video-Src
;;;


(class Camera-Video-Src extends Video-Src
  
  
  (slot resolution initialize #f accessors generate)
  (slot framerate  initialize #f accessors generate)
  (slot bitrate    initialize #f accessors generate)
  (slot codec      initialize #f accessors generate)
  (slot pipeline   initialize #f accessors generate)
  
  
  (method override (initialize self (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f))
    (nextmethod self)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (get-width resolution))
          (height (get-height resolution)))
      (let ((pipeline (apply gst-launch
                             (cond-expand
                                    (mac "avfvideosrc")
                                    (windows "ksvideosrc")
                                    (else "v4l2src"))
                                  (tie "videorate max-rate={framerate}")
                                  ;; inform the camera to use high resolution
                                  (tie "video/x-raw, width=1280, height=720, pixel-aspect-ratio=(fraction)1/1")
                                  "videoscale method=sinc"
                                  (tie "video/x-raw, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                  "tee name=tee"
                                  (list
                                    "tee."
                                    "queue"
                                    "videoconvert"
                                    (tie "video/x-raw, format=BGRA, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                    "videoflip video-direction=horiz"
                                    "appsink name=sinkself")
                                  (collect (lambda (consumer)
                                             (and (is? consumer Camera-Video-Consumer)
                                                  (let ((profile (get-profile consumer)))
                                                    (let ((consumer-name (get-name profile))
                                                          (consumer-resolution (get-resolution profile)))
                                                      (let ((consumer-width (get-width consumer-resolution))
                                                            (consumer-height (get-height consumer-resolution))
                                                            (needs-scaling? (nu/=? consumer-resolution resolution)))
                                                        `("tee."
                                                          "queue"
                                                          ,(and needs-scaling? "videoscale method=sinc")
                                                          "videoconvert"
                                                          ,(tie "video/x-raw, format=I420, width={consumer-width}, height={consumer-height}, pixel-aspect-ratio=(fraction)1/1")
                                                          @replaced-by-frequent-keyframes
                                                          "valve name=valve"
                                                          ,(and (eq? codec 'h264)
                                                                (let ((key-int-max (and camera-keyframes (fxround (* (cast <fl> framerate) camera-keyframes))))
                                                                      (bitrate bitrate)
                                                                      (tune "zerolatency")
                                                                      (speed-preset "ultrafast")
                                                                      (threads #f @wait-threads (and needs-scaling? "1")))
                                                                  (gst-element "x264enc"
                                                                               key-int-max: key-int-max
                                                                               bitrate: bitrate
                                                                               tune: tune
                                                                               speed-preset: speed-preset
                                                                               threads: threads)))
                                                          ,(format "appsink name=sink{a}" consumer-name)))))))
                                           sinks))))
        (gst_object_set_name pipeline "camera")
        (for-each (lambda (consumer)
                    (if (eq? (get-caps consumer) 'self)
                        (let ((listener (open-stream-listener "cameraself"))
                              (appsink (gst_bin_get_by_name pipeline "sinkself")))
                          (gst_app_sink_connect_signals appsink listener)
                          (setup-consumer consumer listener appsink (* width height 4)))
                      (let ((profile (get-profile consumer)))
                        (let ((name (get-name profile))
                              (resolution (get-resolution profile)))
                          (let ((listener (open-stream-listener (format "camera{a}" name)))
                                (appsink (gst_bin_get_by_name pipeline (format "sink{a}" name))))
                            (gst_app_sink_connect_signals appsink listener)
                            (setup-consumer consumer listener appsink (* width height 4)))))))
                  sinks)
        (set! self.pipeline pipeline)
        (gst_element_set_state pipeline GST_STATE_READY))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'camera)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (release-consumers self))
  
  
  @replaced-by-frequent-keyframes
  (method override (reset-cooldown self)
    1.)
  
  
  @replaced-by-frequent-keyframes
  (method override (reset-media self channel)
    (cond-expand
      (windows)
      (else
       (gst_listener_reset (get-write-file listener))))))


;;;
;;;; Camera-Video-Consumer
;;;


(class Camera-Video-Consumer extends Stream-Consumer
  
  
  (slot channel-no getter generate)
  (slot profile    getter generate)
  
  
  (method override (initialize self channel-no profile . rest)
    (apply nextmethod self rest)
    (set! self.channel-no channel-no)
    (set! self.profile profile))


  (method override (consume self buffer timestamp duration)
    (let ((header? (and buffer (video-buffer-header? buffer))))
      (send-client-media (current-client) channel-no buffer header? timestamp duration)
      (when buffer
        (let ((size (u8vector-length buffer)))
          (when (and video-show
                     (or (eq? video-show 'all)
                         (eq? video-show 'header)
                         (>= size video-show)))
            ;; h264 specific
            (let ((type (if header?
                            '***header***
                          'delta)))
              (if (eq? video-show 'header)
                  (when (eq? type '***header***)
                    (terminal size type))
                (terminal size type))))
          (record-event udp-id-src-media
                        -1.
                        (fixnum->flonum client-no)
                        (fixnum->flonum udp-video)
                        -1.
                        (if header? 1. -1.)
                        (fixnum->flonum size)
                        (timestamp->flonum timestamp))))))
  
  
  @replaced-by-frequent-keyframes
  (method override (reset-action self)
    (lambda ()
      (when pipeline
        (let ((valve (gst_bin_get_by_name pipeline "valve"))
              (encoder (gst_bin_get_by_name pipeline "enc")))
          (g_object_set valve "drop" (g_value_int 1))
          (gst_element_set_state encoder GST_STATE_READY)
          (gst_element_set_state encoder GST_STATE_PLAYING)
          (g_object_set valve "drop" (g_value_int 0)))))))


;;;
;;;; Screen-Video-Src
;;;


(class Screen-Video-Src extends Video-Src
  
  
  (slot resolution initialize #f accessors generate)
  (slot framerate  initialize #f accessors generate)
  (slot bitrate    initialize #f accessors generate)
  (slot codec      initialize #f accessors generate)
  (slot pipeline   initialize #f accessors generate)
  
  
  (method override (initialize self (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f))
    (nextmethod self)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (get-width resolution))
          (height (get-height resolution))
          (listener (open-stream-listener "screen")))
      (let ((pipeline (gst-launch (cond-expand
                                    (mac "avfvideosrc capture-screen=true")
                                    (windows "dx9screencapsrc")
                                    (else "v4l2src"))
                                  (tie "videorate max-rate={framerate}")
                                  "videoscale"
                                  "videoconvert"
                                  ;; inform the camera to use high resolution
                                  (tie "video/x-raw, width=1280, height=720, pixel-aspect-ratio=(fraction)1/1")
                                  "videoscale"
                                  "videoconvert"
                                  (tie "video/x-raw, format=I420, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                  @replaced-by-frequent-keyframes
                                  "valve name=valve"
                                  (and (eq? codec 'h264)
                                       (let ((key-int-max (and screen-share-keyframes (fxround (* (cast <fl> framerate) screen-share-keyframes))))
                                             (bitrate bitrate)
                                             (tune "zerolatency")
                                             (speed-preset "ultrafast"))
                                         (gst-element "x264enc"
                                                      key-int-max: key-int-max
                                                      bitrate: bitrate
                                                      tune: tune
                                                      speed-preset: speed-preset
                                                      name: "enc")))
                                  "appsink name=sink")))
        (gst_object_set_name pipeline "screen")
        (let ((appsink (gst_bin_get_by_name pipeline "sink")))
          (gst_app_sink_connect_signals appsink listener)
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.pipeline pipeline)
          (setup-consumer (find-consumer self #f) listener appsink (* width height 4))))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'screen)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (release-consumers self))
  
  
  @replaced-by-frequent-keyframes
  (method override (reset-cooldown self)
    1.)
  
  
  @replaced-by-frequent-keyframes
  (method override (reset-media self channel)
    (cond-expand
      (windows)
      (else
       (gst_listener_reset (get-write-file listener))))))


;;;
;;;; Screen-Video-Consumer
;;;


(class Screen-Video-Consumer extends Stream-Consumer
  
  
  (slot channel-no getter generate)
  
  
  (method override (initialize self channel-no . rest)
    (apply nextmethod self rest)
    (set! self.channel-no channel-no))


  (method override (consume self buffer timestamp duration)
    (let ((header? (and buffer (video-buffer-header? buffer))))
      (send-client-media (current-client) channel-no buffer header? timestamp duration)))
  
  
  @replaced-by-frequent-keyframes
  (method override (reset-action self)
    (lambda ()
      (when pipeline
        (let ((valve (gst_bin_get_by_name pipeline "valve"))
              (encoder (gst_bin_get_by_name pipeline "enc")))
          (g_object_set valve "drop" (g_value_int 1))
          (gst_element_set_state encoder GST_STATE_READY)
          (gst_element_set_state encoder GST_STATE_PLAYING)
          (g_object_set valve "drop" (g_value_int 0)))))))


;;;
;;;; File-Video-Src
;;;


(class File-Video-Src extends Video-Src
  
  
  (slot location   initialize #f accessors generate)
  (slot resolution initialize #f accessors generate)
  (slot pipeline   initialize #f accessors generate)
  
  
  (method override (initialize self location (resolution: resolution #f))
    (nextmethod self)
    (set! self.location location)
    (set! self.resolution resolution))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (get-width resolution))
          (height (get-height resolution))
          (listener (open-stream-listener "file")))
      (let ((pipeline (gst-launch (tie "filesrc name=filesrc")
                                  "qtdemux"
                                  "appsink name=appsink")))
        (gst_object_set_name pipeline "file")
        (let ((filesrc (gst_bin_get_by_name pipeline "filesrc"))
              (appsink (gst_bin_get_by_name pipeline "appsink")))
          (gst_monitor pipeline 'events "appsink")
          (gst_app_sink_connect_signals appsink listener)
          (g_object_set_string filesrc "location" (path-normalize (parse (new-file {Directory Settings} (list "streams" (add-extension location "mp4"))))))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.pipeline pipeline)
          (setup-consumer (find-consumer self #f) listener appsink (* width height 4))))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'file)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (release-consumers self)))


;;;
;;;; File-Preprocess-Video-Src
;;;


(definition protected stream-keyframes
  (world-setting 'world.stream-keyframes #f))


(class File-Preprocess-Video-Src extends Video-Src
  
  
  (slot location   initialize #f accessors generate)
  (slot resolution initialize #f accessors generate)
  (slot framerate  initialize #f accessors generate)
  (slot bitrate    initialize #f accessors generate)
  (slot codec      initialize #f accessors generate)
  (slot pipeline   initialize #f accessors generate)
  
  
  (method override (initialize self location (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f))
    (nextmethod self)
    (set! self.location location)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (get-width resolution))
          (height (get-height resolution))
          (listener (open-stream-listener "preprocessvideo")))
      (let ((pipeline (gst-launch (tie "filesrc name=filesrc")
                                  ;; calls vtdec which generates errors in some files
                                  ;; "decodebin"
                                  "qtdemux"
                                  "avdec_h264"
                                  (and framerate (tie "videorate max-rate={framerate}"))
                                  "videoscale method=sinc"
                                  "videoconvert"
                                  (tie "video/x-raw, format=I420, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                  (let ((key-int-max (and stream-keyframes (fxround (* (cast <fl> framerate) stream-keyframes))))
                                        (bitrate bitrate)
                                        (tune "zerolatency")
                                        (speed-preset "superfast"))
                                    ;; no point using a slower speed until
                                    ;; we can encode without tune=zerolatency
                                    (gst-element "x264enc"
                                                 key-int-max: key-int-max
                                                 bitrate: bitrate
                                                 tune: tune
                                                 speed-preset: speed-preset
                                                 name: "enc"))
                                  "appsink name=appsink sync=false")))
        (gst_object_set_name pipeline "file")
        (let ((filesrc (gst_bin_get_by_name pipeline "filesrc"))
              (appsink (gst_bin_get_by_name pipeline "appsink")))
          (gst_app_sink_connect_signals appsink listener)
          (g_object_set_string filesrc "location" (path-normalize location))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.pipeline pipeline)
          (setup-consumer (find-consumer self #f) listener appsink (* width height 4))))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'file)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (release-consumers self))
  
  
  (method override (video-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (if (stopping? task)
              (task-done task exit)
            (site (preprocess on?: #t)
              (process self task exit))
            (task-sleep task .001 exit)
            (iter)))))))


;;;
;;;; File-Stream-Video-Src
;;;


(class File-Stream-Video-Src extends Video-Src implements Media-Stream
  
  
  (slot profile        getter generate)
  (slot location       getter generate)
  (slot stream?        getter generate)
  (slot file           getter generate)
  (slot reader         getter generate)
  (slot time-base      getter generate)
  (slot last-timestamp getter generate)
  (slot consumer       getter generate)
  
  
  (method override (initialize self profile location (stream?: stream? #t))
    (nextmethod self)
    (set! self.profile profile)
    (set! self.location location)
    (set! self.stream? stream?)
    (set! self.file #f)
    (set! self.reader #f)
    (set! self.time-base (new Time-Base))
    (set! self.last-timestamp #f)
    (set! self.consumer #f))
  
  
  (method override (set-stream? self flag)
    (set! stream? flag))
  
  
  (method override (start-element self)
    (nextmethod self)
    (set! file (new-file {Directory Settings} (list "streams" (add-extension location (get-extension profile)))))
    (set! reader (new Stream-Reader file))
    (set! consumer (car sinks))
    (task-start self 'video-stream))
  
  
  (method override (play-element self)
    (nextmethod self)
    (task-wakeup (get-thread task)
      (lambda (exit)
        (reset time-base))))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (task-wakeup (get-thread task)
      (lambda (exit)
        (task-sleep task +inf.0 exit))))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (close reader)
    (set! file #f)
    (set! reader #f))
  
  
  (method override (seek self pos)
    (task-wakeup (get-thread task)
      (lambda (exit)
        (seek reader pos)
        (reset time-base))))
  
  
  (method override (video-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (if (stopping? task)
              (task-done task exit)
            ;; protect against stream? threaded change
            (let ((stream? stream?))
              (receive (buffer timestamp duration) (read-frame reader stream?)
                (if (not buffer)
                    (if stream-loop?
                        (begin
                          (close reader)
                          (set! reader (new Stream-Reader file last-timestamp))
                          (set! time-base (new Time-Base))
                          (iter))
                      (task-done task exit))
                  (set! last-timestamp timestamp)
                  (let ((time (current-seconds))
                        (nanostamp (timestamp->flonum timestamp)))
                    (update-start time-base time nanostamp)
                    (let ((sendtime (remote->local time-base nanostamp)))
                      (task-sleep task (- sendtime time) exit)
                      (when stream?
                        (site (stream on?: #t)
                          (consume consumer buffer timestamp duration)))))))))
          (iter))))))


;;;
;;;; Draw-Video-Src
;;;


(definition protected draw-resolution
  (world-setting 'world.draw-resolution {Dimension 1280 720}))

(definition protected draw-framerate
  (world-setting 'world.draw-framerate 5))

(definition protected draw-bitrate
  (world-setting 'world.draw-bitrate 1024))

(definition protected draw-codec
  (world-setting 'world.draw-codec 'h264))


(class Draw-Video-Src extends Video-Src
  
  
  (slot draw-proc  initialize #f accessors generate)
  (slot start-time initialize #f accessors generate)
  (slot resolution initialize #f accessors generate)
  (slot context    initialize #f accessors generate)
  (slot consumer   initialize #f getter generate)
  
  
  (method override (initialize self (draw-proc: draw-proc #f))
    (nextmethod self)
    (set! self.draw-proc draw-proc)
    (set! self.resolution draw-resolution))
  
  
  (method protected virtual (new-draw-context self)
    (new Draw-Context draw-resolution draw-framerate draw-bitrate))
  
  
  (method override (start-element self)
    (nextmethod self)
    (set! context (new-draw-context self))
    (set! start-time (current-seconds))
    (set! consumer (car sinks))
    (task-start self 'draw))
  
  
  (method override (play-element self)
    (nextmethod self))
  
  
  (method override (pause-element self)
    (nextmethod self))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (free-context self))
  
  
  (method (free-context self)
    (when context
      (close context)
      (set! context #f)))
  
  
  (method override (video-loop self task)
    (declare (proper-tail-calls))
    (let ((tier (current-client)))
      (with-task task
        (lambda (exit)
          (let (iter)
          (if (stopping? task)
              (task-done task exit)
            (let ((surface (get-surface context)))
              (draw-stream self surface)
              (receive (color alpha timestamp duration) (extract context task exit)
                (site (stream on?: #t)
                  (let ((effective-timestamp (flonum->timestamp (- (current-seconds) start-time))))
                    (consume consumer color effective-timestamp duration)))))
            (task-sleep task .1 exit)
            (iter)))))))
  
  
  (method protected virtual (draw-stream self surface)
    (clear surface)
    (when draw-proc
      (draw-proc surface resolution))))


;;;
;;;; Image-Stream-Video-Src
;;;


(class Image-Stream-Video-Src extends Draw-Video-Src
  
  
  (slot location      getter generate)
  (slot file          getter generate)
  (slot color         getter generate)
  (slot alpha         getter generate)
  (slot timestamp     getter generate)
  (slot duration      getter generate)
  (slot extract-mutex getter generate)
  
  
  (method override (initialize self location)
    (nextmethod self)
    (set! self.location location)
    (set! self.file (new-file {Directory Settings} (list "streams" location)))
    (set! self.color #f)
    (set! self.alpha #f)
    (set! self.timestamp #f)
    (set! self.duration #f)
    (set! self.extract-mutex (make-mutex 'extract)))
  
  
  (method override (new-draw-context self)
    (new Draw-Context draw-resolution draw-framerate draw-bitrate tune: (bitwise-ior stillimage zerolatency)))
  
  
  (method (extract/cache self task exit)
    (mutex-lock! extract-mutex)
    (prog1
        (if color
            (values color alpha timestamp duration)
          (let ((surface (get-surface context)))
            (draw-stream self surface)
            (receive (color alpha timestamp duration) (extract context task exit)
              (set! self.color color)
              (set! self.alpha alpha)
              (set! self.timestamp timestamp)
              (set! self.duration duration)
              (values color alpha timestamp duration))))
      (mutex-unlock! extract-mutex)))
  
  
  (method override (video-loop self task)
    (declare (proper-tail-calls))
    (let ((tier (current-client)))
      (with-task task
        (lambda (exit)
          (receive (color alpha timestamp duration) (extract/cache self task exit)
            (site (stream on?: #t)
              (let ((effective-timestamp (flonum->timestamp (- (current-seconds) start-time))))
                (consume consumer color effective-timestamp duration))))
          (free-context self)
          (continuation-return exit #f)))))
  
  
  (method override (draw-stream self surface)
    (fill-image surface
                (new Rect 0 0 (get-width resolution) (get-height resolution))
                (new Image moniker: file)
                mode: 'fill))
  
  
  (method override (reset-media self channel)
    (receive (color alpha timestamp duration) (extract/cache self task exit)
      (let ((effective-timestamp (flonum->timestamp (- (current-seconds) start-time))))
        (consume consumer color effective-timestamp duration)))))


;;;
;;;; Self-Consumer
;;;


(class Self-Consumer extends Stream-Consumer
  
  
  (slot resolution  initialize #f getter generate)
  (slot self-output initialize #f getter generate)
  
  
  (method override (initialize self . rest)
    (bind-keywords ((resolution #f) . others) rest
      (apply nextmethod self others)
      (assert resolution)
      (set! self.resolution resolution)
      (let ((video (current-video))
            (me (current-me)))
        (set! self-output (player-output video #f
                            player: me
                            resolution: resolution))
        (invalidate-state self-output))))
  
  
  (method override (destroy self)
    (let ((video (current-video)))
      (close-output video #f self-output)
      (set-stream-state self-output 'off))
    (nextmethod self))
  
  
  (method override (consume self buffer timestamp duration)
    (if (not buffer)
        (set-stream-state self-output 'off)
      (set-stream-state self-output 'drawn)
      (draw self-output buffer #f timestamp duration))))


;;;
;;;; Video-Sink
;;;


(class Video-Sink extends Stream-Sink
  
  
  (slot resolution                  initialize #f accessors generate)
  (slot framerate                   initialize #f accessors generate)
  (slot bitrate                     initialize #f accessors generate)
  (slot codec                       initialize #f accessors generate)
  (slot caps                        initialize #f accessors generate)
  (slot process?                    initialize #f accessors generate)
  (slot alpha-overlay               initialize #f accessors generate)
  (slot color-pipeline              initialize #f accessors generate)
  (slot color-appsrc                initialize #f accessors generate)
  (slot color-appsink               initialize #f accessors generate)
  (slot color-data     <u8vector+>  initialize #f accessors generate)
  (slot color-info     <u64vector+> initialize #f accessors generate)
  (slot color-listener              initialize #f accessors generate)
  (slot alpha?                      initialize #f accessors generate)
  (slot alpha-pipeline              initialize #f accessors generate)
  (slot alpha-appsrc                initialize #f accessors generate)
  (slot alpha-appsink               initialize #f accessors generate)
  (slot alpha-data     <u8vector+>  initialize #f accessors generate)
  (slot alpha-info     <u64vector+> initialize #f accessors generate)
  (slot alpha-listener              initialize #f accessors generate)
  (slot image-surface               initialize #f accessors generate)
  (slot image-inhibit?              initialize #f accessors generate)
  (slot task                        initialize #f accessors generate)
  (slot stream-state                initialize 'off getter generate setter explicit)
  
  
  (method override (initialize self (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f) (caps: caps #f) (process?: process? #t) (alpha-overlay: alpha-overlay #f) (alpha?: alpha? #f))
    (nextmethod self)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec)
    (set! self.caps caps)
    (set! self.process? process?)
    (set! self.alpha-overlay alpha-overlay)
    (set! self.alpha? alpha?))
  
  
  (method package virtual (start-listeners self)
    (when color-listener
      (start-stream-listener color-listener))
    (when alpha-listener
      (start-stream-listener alpha-listener)))
  
  
  (method package virtual (stop-listeners self)
    (when color-listener
      (stop-stream-listener color-listener))
    (when alpha-listener
      (stop-stream-listener alpha-listener)))
  
  
  (method package virtual (resize self)
    )
  
  
  (method package virtual (move self rect)
    )
  
  
  (method package virtual (focus self)
    )
  
  
  (method package virtual (unfocus self)
    )
  
  
  (method package (set-stream-state self state)
    (when (neq? state stream-state)
      (set! stream-state state)
      (invalidate-state self)))
  
  
  (method package virtual (invalidate-state self)
    )
  
  
  (method package virtual (setup-pipeline self)
    (when process?
      (let ((width (get-width resolution))
            (height (get-height resolution)))
        (let ((listener (open-stream-listener "videocolor"))
              (pipeline (gst-launch (tie "appsrc name=src")
                                    (and (not video-hardware?) (eq? codec 'h264) (tie "avdec_h264"))
                                    ;; try
                                    (and video-hardware? "h264parse")
                                    (and video-hardware? "vtdec_hw")
                                    "videoscale"
                                    "videoconvert"
                                    (and alpha-overlay (tie "alpha alpha={alpha-overlay}"))
                                    (tie "video/x-raw, format=BGRA, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                    (tie "appsink name=sink"))))
          (gst_object_set_name pipeline "output")
          (let ((appsrc (gst_bin_get_by_name pipeline "src"))
                (appsink (gst_bin_get_by_name pipeline "sink"))
                (data (make-u8vector (* width height 4)))
                (info (make-u64vector 2)))
            (gst_app_sink_connect_signals appsink listener)
            (case codec
              ((h264)
               (gst_app_src_set_caps appsrc
                                     (gst_caps "video/x-h264"
                                               "width"         (g_value_int width)
                                               "height"        (g_value_int height)
                                               "framerate"     (g_value_fraction framerate 1)
                                               "stream-format" (g_value_string (if video-hardware?
                                                                                   ;; try
                                                                                   "byte-stream"
                                                                                 "avc"))
                                               "alignment"     (g_value_string "au"))))
              (else
               (gst_app_src_set_caps appsrc
                                     (gst_caps "video/x-raw"
                                               "format"    (g_value_string "I420")
                                               "width"     (g_value_int width)
                                               "height"    (g_value_int height)
                                               "framerate" (g_value_fraction framerate 1)))))
            (g_object_set appsrc
                          "is-live"     (g_value_boolean #t)
                          "stream-type" (g_value_int GST_APP_STREAM_TYPE_STREAM)
                          "format"      (g_value_int GST_FORMAT_TIME))
            (gst_element_set_state pipeline GST_STATE_READY)
            (set! self.color-data data)
            (set! self.color-info info)
            (set! self.color-pipeline pipeline)
            (set! self.color-appsrc appsrc)
            (set! self.color-appsink appsink)
            (set! self.color-listener listener)))
        (when alpha?
          (let ((listener (open-stream-listener "videoalpha"))
                (pipeline (gst-launch "appsrc name=src"
                                      "avdec_h264 name=dec"
                                      "appsink name=sink")))
            (gst_object_set_name pipeline "output")
            (let ((appsrc (gst_bin_get_by_name pipeline "src"))
                  (appsink (gst_bin_get_by_name pipeline "sink"))
                  (data (make-u8vector (/ (* width height 12) 8)))
                  (info (make-u64vector 2)))
              (gst_app_sink_connect_signals appsink listener)
              (gst_app_src_set_caps appsrc
                                    (gst_caps "video/x-h264"
                                              "width"         (g_value_int width)
                                              "height"        (g_value_int height)
                                              "framerate"     (g_value_fraction framerate 1)
                                              "stream-format" (g_value_string "avc")
                                              "alignment"     (g_value_string "au")))
              (g_object_set appsrc
                            "is-live"     (g_value_boolean #t)
                            "stream-type" (g_value_int GST_APP_STREAM_TYPE_STREAM)
                            "format"      (g_value_int GST_FORMAT_TIME))
              (gst_element_set_state pipeline GST_STATE_READY)
              (set! self.alpha-data data)
              (set! self.alpha-info info)
              (set! self.alpha-pipeline pipeline)
              (set! self.alpha-appsrc appsrc)
              (set! self.alpha-appsink appsink)
              (set! self.alpha-listener listener)
              (set! self.image-surface (new Image-Surface (new Dimension width height)))))))))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (setup-pipeline self))
  
  
  (method (task-start self name)
    (let ((procedure
            (lambda (task)
              (video-loop self task))))
      (let ((task (new Task name procedure priority: video-priority)))
        (start-listeners self)
        (start-task task)
        (set! self.task task))))
  
  
  (method (task-stop self)
    (stop-listeners self)
    (stop-task task)
    (set! task #f))
  
  
  (method override (start-element self)
    (nextmethod self)
    (when process?
      (task-start self 'video-output)
      (gst_element_set_state color-pipeline GST_STATE_PAUSED)
      (when alpha?
        (gst_element_set_state alpha-pipeline GST_STATE_PAUSED))))
  
  
  (method override (play-element self)
    (nextmethod self)
    (when process?
      (gst_element_set_state color-pipeline GST_STATE_PLAYING)
      (when alpha?
        (gst_element_set_state alpha-pipeline GST_STATE_PLAYING))))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (when process?
      (gst_element_set_state color-pipeline GST_STATE_PAUSED)
      (when alpha?
        (gst_element_set_state alpha-pipeline GST_STATE_PAUSED))))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (when process?
      (gst_element_set_state color-pipeline GST_STATE_READY)
      (when alpha?
        (gst_element_set_state alpha-pipeline GST_STATE_READY))
      (task-stop self)))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when process?
      (gst_element_release color-pipeline)
      (set! color-info #f)
      (set! color-data #f)
      (set! color-pipeline #f)
      (set! color-appsrc #f)
      (set! color-appsink #f)
      (close-stream-listener color-listener)
      (set! color-listener #f)
      (when alpha?
        (gst_element_release alpha-pipeline)
        (close image-surface)
        (set! alpha-info #f)
        (set! alpha-data #f)
        (set! alpha-pipeline #f)
        (set! alpha-appsrc #f)
        (set! alpha-appsink #f)
        (set! image-surface #f)
        (close-stream-listener alpha-listener)
        (set! alpha-listener #f))
      (set-stream-state self 'off)))
  
  
  (method override (consume self color timestamp duration (alpha #f))
    ;; QUICK TEST
    (when color-appsrc
    ;; QUICK TEST
      (when color
        (gst_app_src_write color-appsrc color (u8vector-length color) timestamp duration)))
    (when alpha?
      ;; QUICK TEST
      (when alpha-appsrc
        ;; QUICK TEST
        (when alpha
          (gst_app_src_write alpha-appsrc alpha (u8vector-length alpha) timestamp duration)))))
  
  
  (method (video-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (if (stopping? task)
              (task-done task exit)
            (process self task exit)
            (task-halt task exit)
            (iter))))))
  
  
  (method override (process self task exit)
    (let ((color-bytes (gst_app_sink_wait task exit color-listener color-appsink color-data color-info #f #f))
          (alpha-bytes (and alpha? (gst_app_sink_wait task exit alpha-listener alpha-appsink alpha-data alpha-info #f #f))))
      (site (video-output on?: #t)
        (let ((timestamp (u64vector-ref color-info 0))
              (duration (u64vector-ref color-info 1)))
          (draw self color-data (and alpha? alpha-data) timestamp duration)
          (when (eq? stream-state 'on)
            (set-stream-state self 'drawn))))))
  
  
  (method package virtual (draw self color alpha timestamp duration)
    )
  
  
  (method package (update self color alpha texture (background: background #f))
    (if (not alpha?)
        (if speakers-xp?
            (if (eq? (effective-focused-output (current-video)) self)
                (move-u8vector->pointer! color (get-data texture))
              (let ((width (get-width resolution))
                    (height (get-height resolution)))
                (add-alpha color .6 (get-data texture) (* width height))))
          (move-u8vector->pointer! color (get-data texture)))
      (let ((width (get-width resolution))
            (height (get-height resolution))
            (data (cairo_image_surface_get_data (get-handle image-surface))))
        (cairo_surface_flush (get-handle image-surface))
        (combine-alpha color alpha data (* width height))
        (cairo_surface_mark_dirty (get-handle image-surface))
        (unless image-inhibit?
          (let ((surface (get-surface texture)))
            (clear-glass surface resolution background: background)
            (draw-surface surface image-surface 0 0)))))
    (unless image-inhibit?
      (map-texture texture)))
  
  
  (method package virtual (render self)
    )
  
  
  (method (with-slide self texture thunk)
    (set! image-inhibit? #t)
    (thunk)
    (let ((height (cast <fl> (get-height resolution))))
      (let ((delta (/ height render-rate slide-duration))
            (surface (get-surface texture)))
        (thread-start!
          (new-thread
            (lambda ()
              (let (loop (slide (- height delta)))
                (let ((slide (max 0. slide)))
                  (let ((done? (<= slide 0.)))
                    (with-task-mutex
                      (lambda ()
                        (if (not image-surface)
                            (set! done? #t)
                          (translate surface 0 slide)
                          (clear-glass surface resolution)
                          (draw-surface surface image-surface 0 0)
                          (translate surface 0 (- slide))
                          (map-texture texture))
                        (when done?
                          (set! image-inhibit? #f))))
                    (when (not done?)
                      (sleep render-period)
                      (loop (- slide delta)))))))
            'slide))))))


;;;
;;;; Draw-Video-Sink
;;;


(class Draw-Video-Sink extends Video-Sink
  
  
  (slot entity     initialize #f accessors generate)
  (slot pane       initialize #f accessors generate)
  (slot background initialize #f accessors generate)
  
  
  (method override (initialize self ent . rest)
    (apply nextmethod self alpha?: #t rest)
    (let ((p (cache-draw-pane ent (list (eq? ent (current-me)) resolution))))
      (set! entity ent)
      (set! pane p)))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when entity
      (set-draw-pane entity #f)
      (set! entity #f)
      (set! pane #f)))
  
  
  (method override (draw self color alpha timestamp duration)
    ;; quicky
    (when pane
      (update self color alpha (get-texture (cache-quad-texture pane)) background: background)))
  
  
  (method override (render self)
    ;; nothing to do render done by player pane
    ))


;;;
;;;; Event-View
;;;


(class Event-View extends View)


(definition public (make-event-view)
  (let ((view (new Event-View)))
    (define (mouse-down event)
      (debug 'mouse-down))
    
    (define (mouse-up event)
      (debug 'mouse-up))
    
    (define (key-press event)
      (debug 'key-press))
    
    (set-mouse-down-handler view mouse-down)
    (set-mouse-up-handler view mouse-up)
    (set-key-press-handler view key-press)
    view))


(definition public (make-view . rest)
  (apply new View rest))


;;;
;;;; Draw-Pane
;;;


(definition public (make-draw-pane entity info)
  (let ((expanse {Dimension$fl$ 6. 3.375})
        (resolution {Dimension 1280 720}))
    (let ((pane (new Draw-Pane
                  title: "Draw"
                  expanse: expanse
                  resolution: resolution
                  billboard: info
                  entity: entity)))
      (cond ((is? info View)
             (set-root pane info)
             (set-position info {Point 0 0})
             (set-size info resolution)
             pane)
            (else
             pane)))))


@c4
(definition public (make-c4-pane entity billboard)
  (let ((size {Dimension$fl$ 3.6363636363636362 3.})
        (resolution {Dimension 660 600}))
    (let ((pane (new Script-Pane
                  size: size
                  resolution: resolution
                  billboard: billboard
                  entity: entity))
          (view (new jazz.sample.c4:C4-Board position: {Point 0 0} size: resolution background: #f)))
      (set-root pane view)
      (let ((pos (center (get-size view) resolution)))
        (set-position view pos))
      pane)))
  
  
  @c4
  (method override (draw self surface)
    (let ((width (get-width resolution))
          (height (get-height resolution)))
      (let ((rect (new Rect 0 0 width height))
            (color {Color red: .000 green: .000 blue: .200 alpha: .3}))
        (clear surface)
        (fill-rect surface rect color)
        (frame-rect surface rect color)
        (paint-drawing root surface '())))
    (when quad-texture
      (map-texture (get-texture quad-texture))))


(class Draw-Pane extends Entity-Pane)


;;;
;;;; Overhead-Video-Sink
;;;


(class Overhead-Video-Sink extends Video-Sink
  
  
  (slot player initialize #f accessors generate)
  (slot pane   initialize #f accessors generate)
  
  
  (method override (initialize self entity . rest)
    (apply nextmethod self rest)
    (let ((p (cache-camera-pane entity (list (eq? entity (current-me)) resolution))))
      (set! player entity)
      (set! pane p)))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when player
      (set-camera-pane player #f)
      (set! player #f)
      (set! pane #f)))
  
  
  (method override (draw self color alpha timestamp duration)
    (update self color alpha (get-texture (cache-quad-texture pane))))
  
  
  (method override (render self)
    ;; nothing to do render done by player pane
    ))


;;;
;;;; Camera-Pane
;;;


(definition public (make-camera-pane billboard)
  (bind (me? resolution) billboard
    (new Camera-Pane
      title: "Camera"
      expanse: (new Dimension$fl$ 1. .5625)
      resolution: resolution
      billboard: billboard)))


(class Camera-Pane extends World-Pane
  
  
  (method override (draw self surface)
    (clear surface)))


;;;
;;;; Sheet-Video-Sink
;;;


(class Sheet-Video-Sink extends Video-Sink
  
  
  (slot player initialize #f accessors generate)
  (slot sheet  initialize #f accessors generate)
  
  
  (method override (initialize self entity . rest)
    (bind-keywords ((position #f) (size #f) . others) rest
      (apply nextmethod self others)
      (let ((world (current-world)))
        (let ((pos (or position {Point 0 0}))
              (size (or size {Dimension 320 180})))
          (let ((s (make-world-sheet 'video World-Sheet size resolution: resolution retina?: #f)))
            (make-orthographic-matrix! (get-projection-matrix s) 0. (get-width world) 0. (get-height world) 0. 10.)
            (set-position s pos)
            (set-size s size)
            (set! self.player entity)
            (set! self.sheet s))))))
  
  
  (method override (resize self)
    (let ((world (current-world)))
      (let ((width (get-width world))
            (height (get-height world)))
        (make-orthographic-matrix! (get-projection-matrix sheet) 0. width 0. height 0. 10.))))
  
  
  (method override (move self rect)
    (set-rect sheet rect))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when sheet
      (glDeleteTextures* (get-id (get-texture sheet)))
      (set! sheet #f)))
  
  
  (method override (draw self color alpha timestamp duration)
    (let ((texture (get-texture sheet)))
      (update self color alpha texture)))
  
  
  (method override (render self)
    (when (eq? stream-state 'drawn)
    ;; QUICKY
    (when sheet
    (let ((world (current-world)))
      (let ((x (cast <fl> (get-left sheet)))
            (y (cast <fl> (get-top sheet)))
            (height (cast <fl> (get-height sheet))))
        (let ((matrix (make-translation-matrix (vertex x (- (get-height world) y height) 0.))))
          (render-sheet sheet matrix))))))))


;;;
;;;; Circle-Video-Sink
;;;


(class Circle-Video-Sink extends Video-Sink
  
  
  (slot id              initialize #f accessors generate)
  (slot channel         initialize #f accessors generate)
  (slot player          initialize #f accessors generate)
  (slot texture         initialize #f accessors generate)
  (slot translation     initialize #f accessors generate)
  (slot rotation        initialize #f accessors generate)
  (slot plane           initialize #f accessors generate)
  (slot media-pane      initialize #f accessors generate)
  (slot media-sheet     initialize #f accessors generate)
  (slot interface-pane  initialize #f accessors generate)
  (slot interface-sheet initialize #f accessors generate)
  
  
  (method override (initialize self id channel entity . rest)
    (bind-keywords ((position #f) (size #f) . others) rest
      (apply nextmethod self others)
      (let ((window (current-window)))
        (set! self.id id)
        (set! self.channel channel)
        (set! self.player entity)
        (set! self.texture (make-cairo-texture (get-width resolution) (get-height resolution)))
        (let ((position (or position {Point 0 0}))
              (size (or size {Dimension 640 360})))
          ;; media
          (let ((pane (make-sheet-pane
                        name: 'media
                        title: "Media"
                        position: position
                        size: size
                        expanse: (new Dimension$fl$ 10. (/ 10. (/ 16. 9.)))
                        resolution: resolution
                        texture: texture)))
            (set! self.media-pane pane)
            (set! self.media-sheet (get-sheet pane)))
          ;; interface
          (let ((position {Point 0 0})
                (size {Dimension 1280 720})
                (expanse (new Dimension$fl$ 10. (/ 10. (/ 16. 9.))))
                (resolution {Dimension 1280 720}))
            (let ((texture (make-cairo-texture (get-width resolution) (get-height resolution)))
                  (root (new world.circle:Circle-View position: position size: size)))
              (let ((pane (make-sheet-pane
                            name: 'interface
                            title: "Interface"
                            position: position
                            size: size
                            expanse: expanse
                            resolution: resolution
                            texture: texture
                            root: root
                            root-mousable?: #t)))
                (set! self.interface-pane pane)
                (set! self.interface-sheet (get-sheet pane))
                (set-output root self)
                (update root))))
          ;; panes
          (update-panes self)))))
  
  
  (method override (destroy self)
    (let ((window (current-window)))
      (unregister-pane window media-pane)
      (unregister-sheet window media-sheet)
      (unregister-pane window interface-pane)
      (unregister-sheet window interface-sheet))
    (nextmethod self))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (let ((effective-name (if (not channel) "Me" (get-name (get-stream channel)))))
          (format output "{a}" effective-name)))))
  
  
  (method package (update-panes self)
    (let ((window (current-window))
          (video (current-video)))
      (case video-layout
        ((gallery)
         (unregister-pane window media-pane)
         (unregister-pane window interface-pane)
         (register-sheet window media-sheet)
         (register-sheet window interface-sheet)
         (when (eq? self (effective-focused-output video))
           (send-sheet-to-back window media-sheet)
           (send-sheet-to-back window interface-sheet)))
        ((circle focus)
         (register-pane window media-pane)
         (register-pane window interface-pane)
         (cond ((and (eq? video-layout 'focus)
                     (eq? self (effective-focused-output video)))
                (register-sheet window media-sheet)
                (register-sheet window interface-sheet))
               (else
                (unregister-sheet window media-sheet)
                (unregister-sheet window interface-sheet)))))))
  
  
  (method package (update-matrices self count)
    (update-media-matrix self count)
    (update-interface-matrix self count))
  
  
  (method package (update-media-matrix self count)
    (let ((matrix (circle-matrix self translation (<= count 3))))
      (set-matrix media-pane matrix)
      (set! plane (new Plane (matrix-translation matrix) (matrix-direction matrix)))))
  
  
  (method package (update-interface-matrix self count)
    (when translation
      (if (and speakers-xp? (eq? (effective-focused-output (current-video)) self))
          (let ((position (matrix-translation (get-matrix media-pane))))
            (let ((billboard-matrix (orthogonal-matrix& (get-position (current-camera)) position) @w (billboard-matrix& position)))
              (set-matrix media-pane billboard-matrix)
              (set-matrix interface-pane billboard-matrix)))
        (set-matrix media-pane (circle-matrix self translation (<= count 3)))
      (if (xor (>= (plane-to-point-distance& plane (get-position (current-camera))) 0.)
               (> count 3))
          (set-matrix interface-pane (circle-matrix self (+ translation .005) #f))
        (set-matrix interface-pane (circle-matrix self (+ translation -.005) #t))))))
  
  
  (method (circle-matrix self translation flip?)
    (matrix-multiply&
      (make-rotation-matrix& (vertex& 0. 1. 0.) rotation)
      (make-translation-matrix& (vertex& 0. 0. translation))
      (if flip?
          (make-rotation-matrix (vertex& 0. 1. 0.) PI)
        (make-identity-matrix&))))
  
  
  (method override (resize self)
    (let ((world (current-world)))
      (let ((width (get-width world))
            (height (get-height world)))
        (make-orthographic-matrix! (get-projection-matrix media-sheet) 0. width 0. height 0. 10.)
        (make-orthographic-matrix! (get-projection-matrix interface-sheet) 0. width 0. height 0. 10.))))
  
  
  (method override (move self rect)
    (set-rect media-sheet rect)
    (set-rect interface-sheet rect))
  
  
  (method package (focused? self)
    (and (eq? video-layout 'focus)
         (eq? (effective-focused-output (current-video)) self)))
  
  
  (method package (move-focused self)
    (let ((bounds (get-bounds (current-window))))
      (let ((focused (focused-rect bounds)))
        (let ((adjusted (adjust-focused bounds focused)))
          (move self adjusted)))))
  
  
  (method override (focus self)
    (let ((window (current-window)))
      (move-focused self)
      (register-sheet window media-sheet)
      (register-sheet window interface-sheet)
      (send-sheet-to-back window media-sheet)
      (send-sheet-to-back window interface-sheet)))
  
  
  (method override (unfocus self)
    (let ((window (current-window)))
      (unregister-sheet window media-sheet)
      (unregister-sheet window interface-sheet)))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when texture
      (glDeleteTextures* (get-id texture))
      (set! texture #f)))
  
  
  (method override (invalidate-state self)
    (redraw-texture interface-pane))
  
  
  (method override (draw self color alpha timestamp duration)
    (update self color alpha texture)
    (when channel
      (record-event udp-id-draw-video
                    -1.
                    (fixnum->flonum client-no)
                    (fixnum->flonum udp-video)
                    -1.
                    -1.
                    -1.
                    (if (not timestamp)
                        -1.
                      (timestamp->flonum timestamp)))))
  
  
  (method override (render self)
    (let ((world (current-world)))
      (define (render-sheets)
        (when (eq? stream-state 'drawn)
          (let ((sheet media-sheet))
            (let ((x (cast <fl> (get-left sheet)))
                  (y (cast <fl> (get-top sheet)))
                  (height (cast <fl> (get-height sheet))))
              (let ((matrix (make-translation-matrix (vertex x (- (get-height world) y height) 0.))))
                (render-sheet sheet matrix)))))
        (when (or video-interface?
                  (neq? stream-state 'drawn))
          (let ((sheet interface-sheet))
            (let ((x (cast <fl> (get-left sheet)))
                  (y (cast <fl> (get-top sheet)))
                  (height (cast <fl> (get-height sheet))))
              (let ((matrix (make-translation-matrix (vertex x (- (get-height world) y height) 0.))))
                (render-sheet sheet matrix))))))
      
      (case video-layout
        ((gallery)
         (render-sheets))
        (else
         (when (focused? self)
           (render-sheets))
         (when (and (eq? stream-state 'drawn)
                    (or #t @wait-mini-self-in-focus-layoutvideo-interface? video-interface?
                        (not (focused? self))))
           (render-pane media-pane))
         (when (and (or (neq? video-layout 'focus)
                        (neq? stream-state 'drawn))
                    (or video-interface?
                        (neq? stream-state 'drawn)))
           (render-pane interface-pane))))))))
