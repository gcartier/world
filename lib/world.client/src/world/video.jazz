;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Video
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.video jazz


(import (jazz.cairo)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.io)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (jazz.view)
        (jazz.window)
        (world)
        (world.autoload)
        (world.configure)
        (world.console)
        (world.context)
        (world.entity)
        (world.event)
        (world.foreign)
        (world.geometry)
        (world.id)
        (world.interface)
        (world.interface.sheet)
        (world.io)
        (world.layout)
        (world.pane)
        (world.quad-texture)
        (world.settings)
        (world.stream)
        (world.task)
        (world.texture)
        (world.time))


(definition protected self-resolution
  (world-setting 'world.self-resolution {Dimension 640 360}))


(definition protected video-resolution
  (world-setting 'world.video-resolution {Dimension 640 360}))

(definition protected video-framerate
  (world-setting 'world.video-framerate 15))

(definition protected video-bitrate
  (world-setting 'world.video-bitrate 1024 @wait 2048))

(definition protected video-key-period
  (world-setting 'world.video-key-period #f))

(definition protected video-pass
  (world-setting 'world.video-pass #f))

(definition protected video-alpha
  (world-setting 'world.video-alpha 1.0 @wait 0.6))

(definition protected video-overlay?
  (world-setting 'world.video-overlay? #f))

(definition protected video-codec
  (world-setting 'world.video-codec 'h264))


(definition layouts
  '(;;overhead
    sidebar
    gallery
    fullscreen))

(definition public video-layout
  (world-setting 'world.video-layout 'sidebar @currently-buggy-when-we-cycle 'overhead))


(definition public video-mode
  'fit)

(definition public (set-video-mode mode)
  (let ((video (current-video)))
    (set! video-mode mode)
    (layout-outputs video)
    (invalidate-interface)))


(definition video-show
  (world-setting 'world.video-show #f))


(definition public capture-screen?
  #f)

(definition public (set-capture-screen? flag)
  (set! capture-screen? flag))


(definition draw-refresh
  (world-setting 'world.draw-refresh 1.))


(definition slide-duration
  (world-setting 'world.slide-duration .2))


;;;
;;;; Kush
;;;


(definition public (kush-gauge width height rate motion)
  (/ (* width height rate motion 0.07) 1000.))


;;;
;;;; Access
;;;


(definition public (get-video-layout)
  video-layout)

(definition public (set-video-layout layout)
  (set! video-layout layout))


;;;
;;;; Video
;;;


(definition protected (new-world-video)
  (let ((input-src (cond (video-stream
                          (new File-Stream-Video-Src
                            video-stream))
                         (image-stream
                          (new Image-Stream-Video-Src
                            image-stream))
                         (else
                          (new Camera-Video-Src
                            resolution: video-resolution
                            framerate: video-framerate
                            bitrate: video-bitrate
                            codec: video-codec))))
        (server-sink (new Stream-Sink
                       consumer: (lambda (buffer timestamp duration)
                                   (let ((video (current-video)))
                                     (send-camera-video video buffer timestamp duration)))))
        (self-sink (and (not streaming?)
                        (new Stream-Sink
                          consumer: (lambda (buffer timestamp duration)
                                      (let ((video (current-video)))
                                        (let ((sink (find-output video #f)))
                                          (set-stream-state sink 'drawn)
                                          (draw sink buffer #f timestamp duration))))))))
    (new World-Video input: (pipeline input-src
                                      (if self-sink
                                          (list server-sink self-sink)
                                        server-sink)))))


;; first four bytes are always 00 00 00 01
(definition protected (video-buffer-header? buffer)
  (let ((pos 5))
    (and (< pos (u8vector-length buffer))
         (= (u8vector-ref buffer pos) 16))))


(class World-Video extends Object
  
  
  (slot input             getter generate)
  (slot inputs            getter generate)
  (slot outputs           getter generate)
  (slot ordered-outputs   getter generate)
  ;; quicky to test
  (slot extra-outputs     getter generate)
  (slot fullscreen-output accessors generate)
  (slot self-output       getter generate)
  (slot camera-mutex      getter generate)
  (slot render-hook       accessors generate)
  
  
  (method override (initialize self (input: input #f))
    (nextmethod self)
    (set! self.input input)
    (set! self.inputs (make-table test: equal?))
    (set! self.outputs (make-table test: equal?))
    (set! ordered-outputs '())
    (set! extra-outputs '())
    (set! fullscreen-output #f)
    (set! self-output #f)
    (set! camera-mutex (make-mutex 'camera))
    (set! render-hook #f))
  
  
  (method package (autostart self)
    (when (world-setting 'world.video-autostart? #f)
      (start self)))
  
  
  (method package (start self)
    (unless (and streaming?
                 audio-stream
                 (not video-stream)
                 (not image-stream))
      (start input)))
  
  
  (method package (stop self)
    (unless (and streaming?
                 audio-stream
                 (not video-stream)
                 (not image-stream))
      (release input)))
  
  
  (method (with-camera-mutex self thunk)
    (mutex-lock! camera-mutex)
    (prog1 (thunk)
      (mutex-unlock! camera-mutex)))
  
  
  (method package (send-camera-video self buffer timestamp duration)
    (with-camera-mutex self
      (lambda ()
        (let ((tier (current-client)))
          (let ((header? (and buffer (video-buffer-header? buffer))))
            (send-client-video tier -1 buffer header? timestamp duration))))))
  
  
  (method package (reset-camera self)
    (with-camera-mutex self
      (lambda ()
        (let ((camera (car (get-elements input))))
          ;; quicky for tests
          (when (is? camera Camera-Video-Src)
            (reset camera))))))
  
  
  (method package (resize self)
    (iterate-table outputs
      (lambda (id output)
        (when (sheet? output)
          (resize output))))
    (layout-outputs self))
  
  
  ;; kind of hack because of an import conflict
  (method (video-layout-ref self)
    video-layout)
  
  
  ;;;
  ;;;; Input
  ;;;
  
  
  (method (on-toggle-video self evt)
    (toggle-video self))
  
  
  (method package (toggle-video self)
    (when (client?)
      (if (video-playing? self)
          (stop-video self)
        (start-video self))))
  
  
  (method package (start-video self (feedback?: feedback? #t))
    (when (client?)
      (let ((world (current-world)))
        (start self)
        (update-parameter world 'video)
        (when feedback?
          (display-on/off world "Video" (playing? input))))))
  
  
  (method package (stop-video self (feedback?: feedback? #t))
    (when (client?)
      (let ((world (current-world)))
        (stop self)
        (when self-output
          (set-stream-state self-output 'off))
        (update-parameter world 'video)
        (when feedback?
          (display-on/off world "Video" (playing? input))))))
  
  
  (method package (video-playing? self)
    (playing? input))
  
  
  ;;;
  ;;;; Inputs
  ;;;
  
  
  (method package (find-input self id)
    (table-ref inputs id #f))
  
  (method package (register-input self id input)
    (table-set! inputs id input))
  
  
  (method package (close-input self id input)
    (table-clear inputs id)
    (release input))
  
  
  ;;;
  ;;;; Outputs
  ;;;
  
  
  (method package (find-output self id)
    (table-ref outputs id #f))
  
  (method package (register-output self id output)
    (table-set! outputs id output))
  
  
  (method package (output-self? self output)
    (not (get-id output)))
  
  (method package (ordered-output self n)
    (element ordered-outputs n))
  
  (method package (ordered-output-self? self n)
    (output-self? self (ordered-output self n)))
  
  
  ;; quicky for tests
  (method package (register-extra-output self output)
    (set! extra-outputs (cons output extra-outputs)))
  ;; quicky for tests
  (method package (unregister-extra-output self output)
    (set! extra-outputs (remove output extra-outputs)))
  
  
  (method package (entity-output self id (position: position #f) (size: size #f) (resolution: resolution #f) (codec: codec #f))
    (or (table-ref outputs id #f)
        (let ((entity (find-entity id)))
          (let ((output (new Draw-Video-Sink entity
                             resolution: (or resolution {Dimension 1280 720})
                             framerate: video-framerate
                             bitrate: video-bitrate
                             codec: (or codec video-codec)
                             alpha-overlay: video-alpha
                             overlay?: video-overlay?)))
            (table-set! outputs id output)
            (setup output)
            (start output)
            output))))
  
  
  (method package (player-output self id (player: player #f) (position: position #f) (size: size #f) (resolution: resolution #f) (codec: codec #f))
    (define (add-output output)
      (if #f @wait-for-circle-tests (and self-output (neq? output self-output))
          ;; reposition so self output is always last
          (set! ordered-outputs (append! (remove! self-output ordered-outputs) (list output self-output)))
        (set! ordered-outputs (append! ordered-outputs (list output)))))
    
    (or (table-ref outputs id #f)
        ;; the or is a quick hack to test self video
        (let ((player (or player (find-entity id))))
          (let ((output (case video-layout
                          ((overhead)
                           (new Camera-Video-Sink
                             player
                             resolution: (or resolution video-resolution)
                             framerate: video-framerate
                             bitrate: video-bitrate
                             codec: (or codec video-codec)
                             alpha-overlay: video-alpha
                             overlay?: video-overlay?))
                          (else
                           (new Circle-Video-Sink
                             id
                             player
                             position: position
                             size: size
                             resolution: (if (not id) self-resolution (or resolution video-resolution))
                             framerate: video-framerate
                             bitrate: video-bitrate
                             codec: (or codec video-codec)
                             alpha-overlay: video-alpha
                             overlay?: video-overlay?
                             needs-layout?: #t
                             process?: id)))))
            (table-set! outputs id output)
            (when (not id)
              (set! self-output output))
            (add-output output)
            (setup output)
            (start output)
            output))))
  
  
  (method package (visualizer-output self position size)
    (let ((output (new Sheet-Video-Sink
                    #f
                    #f
                    position: position
                    size: size
                    resolution: self-resolution
                    framerate: video-framerate
                    bitrate: video-bitrate
                    codec: video-codec
                    alpha-overlay: video-alpha
                    overlay?: video-overlay?
                    process?: #t)))
      (setup output)
      (start output)
      output))
  
  
  (method package (close-output self id output (layout?: layout? #t))
    (table-clear outputs id)
    (set! ordered-outputs (remove! output ordered-outputs))
    (set! extra-outputs (remove! output extra-outputs))
    (when (eq? output self-output)
      (set! self-output #f))
    (when (eq? output fullscreen-output)
      (set! fullscreen-output #f))
    (release output)
    (when layout?
      (update-layouts self)))
  
  
  (method package (close-outputs self)
    (iterate-table-safe outputs
      (lambda (id output)
        (close-output self id output layout?: #f))))
  
  
  (method package (effective-fullscreen-output self)
    (or fullscreen-output
        (and (not-null? ordered-outputs)
             (car ordered-outputs))))
  
  
  (method package (receive-server-video self id buffer timestamp duration)
    (let ((output (find-output self id)))
      (when output
        (if (not buffer)
            (set-stream-state output 'off)
          (when (eq? (get-stream-state output) 'off)
            (set-stream-state output 'on))
          (consume output buffer timestamp duration)
          (record-event udp-id-sink-media
                        (fixnum->flonum client-no)
                        (fixnum->flonum world.udp:udp-video)
                        -1.
                        -1.
                        -1.
                        (timestamp->flonum timestamp))))))
  
  
  (method package (receive-visualizer-video self output buffer timestamp duration)
    (if (not buffer)
        (set-stream-state output 'off)
      (when (eq? (get-stream-state output) 'off)
        (set-stream-state output 'on))
      (consume output buffer timestamp duration)))
  
  
  (method package (receive-video self id/output buffer timestamp duration)
    (if (is? id/output Video-Sink)
        (receive-visualizer-video self id/output buffer timestamp duration)
      (receive-server-video self id/output buffer timestamp duration)))
  
  
  (method package (receive-processor-draw self id color alpha timestamp duration background slide?)
    (if (not color)
        (let ((output (find-output self id)))
          (when output
            (close-output self id output)))
      (let ((output (entity-output self id)))
        (set-background output background)
        (if (not slide?)
            (consume output color timestamp duration alpha)
          (let ((texture (get-texture (cache-quad-texture (get-pane output)))))
            (with-slide output texture
              (lambda ()
                (consume output color timestamp duration alpha))))))))
  
  
  (method package (render-outputs self)
    (unless (and render-hook
                 (render-hook self))
      (if (eq? video-layout 'fullscreen)
          (let ((fullscreen-output (effective-fullscreen-output self)))
            (when fullscreen-output
              (render fullscreen-output)))
        ;; use ordered-outputs so order is stable
        (for-each render ordered-outputs)
        (for-each render extra-outputs))))
  
  
  (method package (render-minis self)
    (unless (and render-hook
                 (render-hook self))
      (when (eq? video-layout 'fullscreen)
        (let ((fullscreen-output (effective-fullscreen-output self)))
          (for-each (lambda (output)
                      (unless (eq? output fullscreen-output)
                        (render output)))
                    ordered-outputs)))))
  
  
  ;;;
  ;;;; Layout
  ;;;
  
  
  (method (on-cycle-layouts self evt)
    (let ((world (current-world)))
      (cycle-layouts self)
      (display-message world (capitalize (symbol->string video-layout)))))
  
  
  (method (cycle-layouts self)
    (case video-layout
      ((overhead)
       (sidebar-layout self))
      ((sidebar)
       (gallery-layout self))
      ((gallery)
       (fullscreen-layout self))
      ((fullscreen)
       (overhead-layout self))
      ((circle)
       (circle-layout self))))
  
  
  (method protected (update-layouts self)
    (case video-layout
      ((overhead)
       (overhead-layout self))
      ((sidebar)
       (sidebar-layout self))
      ((gallery)
       (gallery-layout self))
      ((fullscreen)
       (fullscreen-layout self))
      ((circle)
       (circle-layout self))))
  
  
  (method (stop-renders self)
    (let ((zone (current-zone)))
      (for-each (lambda (player)
                  (let ((elem (get-camera-pane player)))
                    (when elem
                      (set-render? elem #f))))
                (get-players zone))))
  
  
  (method package (overhead-layout self)
    (stop-renders self)
    (set! video-layout 'overhead)
    (layout-outputs self))
  
  
  (method package (sidebar-layout self)
    (stop-renders self)
    (set! video-layout 'sidebar)
    (layout-outputs self))
  
  
  (method package (gallery-layout self)
    (set! video-layout 'gallery)
    (layout-outputs self))
  
  
  (method package (fullscreen-layout self)
    (set! video-layout 'fullscreen)
    (layout-outputs self))
  
  
  (method package (layout-outputs self)
    (when (not-null? ordered-outputs)
      (let ((rectangles (layout self (length ordered-outputs))))
        (when rectangles
          (for-each (lambda (output rect)
                      ;; quick hacks to test self video
                      (let ((player (or (get-player output) (current-me))))
                        (let ((elem (get-camera-pane player)))
                          (if (not rect)
                              (when elem
                                (set-render? elem #f))
                            (when elem
                              (set-render? elem #t))
                            (move output rect)))))
                    ordered-outputs
                    rectangles)))))
  
  
  (method package (layout self num-players)
    (let ((window (current-window)))
      (let ((bounds (get-bounds window)))
        (let ((l (get-left bounds))
              (t (get-top bounds))
              (r (get-right bounds))
              (b (get-bottom bounds)))
          (define (adjust-fullscreen rect)
            (if (eq? video-mode 'fit)
                rect
              ;; fill mode
              (let ((ratio (fit-rects rect bounds 'fill)))
                (let ((new-width (fxround (* (cast <fl> (rect-width rect)) ratio)))
                      (new-height (fxround (* (cast <fl> (rect-height rect)) ratio))))
                  (let ((pos (center (new Dimension new-width new-height) (rect-size bounds))))
                    (let ((h (get-h pos))
                          (v (get-v pos)))
                      (new Rect h v (+ h new-width) (+ v new-height))))))))
          
          (case video-layout
            ((sidebar)
             (layout-tiles num-players (new Rect 10 70 210 (- b 100))))
            ((gallery)
             (if (= num-players 1)
                 (list (adjust-fullscreen (car (layout-tiles 1 bounds))))
               (reverse (layout-tiles num-players bounds))))
            ((fullscreen)
             (let ((width (if (> num-players 2) 224 288))
                   (height (if (> num-players 2) 126 162)))
               (let ((full (car (layout-tiles 1 bounds)))
                     (border 0))
                 (let ((r (- r border))
                       (fullscreen-output (effective-fullscreen-output self)))
                   (map (lambda (output)
                          (if (eq? output fullscreen-output)
                              (adjust-fullscreen full)
                            (prog1 (new Rect (- r width) (- b height) r b)
                              (decrease! r (+ width border)))))
                        ordered-outputs)))))
            (else
             #f))))))
  
  
  (method package (circle-layout self)
    (set! video-layout 'circle)
    (let ((count (length ordered-outputs)))
      (define (layout-default)
        (for-each (lambda (output rank)
                    (set-matrix output (copy-matrix (make-circle-matrix count rank))))
                  ordered-outputs
                  (naturals 0 count)))
      
      (if layout-circle
          (with-safe-trigger layout-circle
            (lambda ()
              (let ((matrices ((get-procedure layout-circle) ordered-outputs)))
                (for-each (lambda (output matrix)
                            (set-matrix output (copy-matrix matrix)))
                          ordered-outputs
                          matrices)))
            (lambda ()
              (layout-default)))
        (layout-default)))))


;; quicky for now to be replaced with safe script handlers
(definition protected (with-safe-trigger trigger thunk default)
  (if (get-in-error? trigger)
      (default)
    (with-exception-catcher
      (lambda (exc)
        (set-in-error? trigger #t)
        (delay-event
          (lambda ()
            (let ((world (current-world)))
              (let ((reason (exception-reason exc)))
                (display-message world (split-string reason #\newline) duration: 60.)))))
        (default))
      thunk)))


;;;
;;;; Video-Src
;;;


(class Video-Src extends Stream-Src
  
  
  (slot appsink               initialize #f accessors generate)
  (slot appsinkself           initialize #f accessors generate)
  (slot data     <u8vector+>  initialize #f accessors generate)
  (slot info     <u64vector+> initialize #f accessors generate)
  (slot task                  initialize #f accessors generate)
  
  
  (method (task-start self name)
    (let ((procedure
            (lambda (task)
              (video-loop self task))))
      (let ((task (new Task name procedure priority: video-priority)))
        (start-task task)
        (set! self.task task))))
  
  
  (method (task-stop self)
    (halt-task task)
    (set! task #f))
  
  
  (method protected virtual (video-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-seconds)))
          ;; not 100% correct if preempted before task-mutex
          (let ((time (current-seconds)))
            (when (running? task)
              (site (video on?: #t)
                (let ((elapse (- time previous))
                      (max-elapse 10.))
                  ;; ignore ridiculous elapses like
                  ;; coming back from computer sleep
                  (unless (> elapse max-elapse)
                    (let ((history (current-history)))
                      (unless (get-paused? history)
                        (process self)))))))
            (let ((duration (- (current-seconds) time)))
              (task-wait task video-period duration exit))
            (iter time))))))
  
  
  (method override (process self)
    (let ((size (gst_app_sink_read appsink data info)))
      (when (/= size -1)
        (let ((buffer (subu8vector data 0 size))
              (timestamp (u64vector-ref info 0))
              (duration (u64vector-ref info 1)))
          (when (and video-show
                     (or (eq? video-show 'all)
                         (eq? video-show 'header)
                         (>= size video-show)))
            ;; h264 specific
            (let ((type (if (video-buffer-header? buffer)
                            '***header***
                          'delta)))
              (if (eq? video-show 'header)
                  (when (eq? type '***header***)
                    (terminal size type))
                (terminal size type))))
          (consume sink buffer timestamp duration)
          (record-event udp-id-src-media
                        (fixnum->flonum client-no)
                        (fixnum->flonum world.udp:udp-video)
                        -1.
                        (if (video-buffer-header? buffer) 1. -1.)
                        (fixnum->flonum size)
                        (timestamp->flonum timestamp)))))
    (when appsinkself
      (let ((size (gst_app_sink_read appsinkself data info)))
        (when (/= size -1)
          (let ((buffer (subu8vector data 0 size))
                (timestamp (u64vector-ref info 0))
                (duration (u64vector-ref info 1)))
            (consume sinkself buffer timestamp duration)
            (record-event udp-id-src-self
                          (fixnum->flonum client-no)
                          (fixnum->flonum world.udp:udp-video)
                          -1.
                          -1.
                          (fixnum->flonum size)
                          (timestamp->flonum timestamp))))))))


;;;
;;;; Camera-Video-Src
;;;


(class Camera-Video-Src extends Video-Src
  
  
  (slot resolution initialize #f accessors generate)
  (slot framerate  initialize #f accessors generate)
  (slot bitrate    initialize #f accessors generate)
  (slot codec      initialize #f accessors generate)
  (slot pipeline   initialize #f accessors generate)
  
  
  (method override (initialize self (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f))
    (nextmethod self)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (get-width resolution))
          (height (get-height resolution))
          (self-width (get-width self-resolution))
          (self-height (get-height self-resolution)))
      (let ((pipeline (gst-launch (cond-expand
                                    (mac (if capture-screen?
                                             "avfvideosrc capture-screen=true"
                                           "avfvideosrc"))
                                    (windows (if capture-screen?
                                                 "dx9screencapsrc"
                                               "ksvideosrc"))
                                    (else "v4l2src"))
                                  (tie "videorate max-rate={framerate}")
                                  "videoscale"
                                  "videoconvert"
                                  ;; this tie is there so the camera knows what resolution to use
                                  (tie "video/x-raw, width=1280, height=720, pixel-aspect-ratio=(fraction)1/1")
                                  "tee name=tee"
                                  (list
                                    "tee."
                                    "queue"
                                    "videoscale"
                                    "videoconvert"
                                    (tie "video/x-raw, format=I420, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                    "valve name=valve"
                                    (and (eq? codec 'h264)
                                         (let ((key-int-max (and video-key-period (fxround (* (cast <fl> framerate) video-key-period))))
                                               (pass video-pass)
                                               (psy-tune #f)
                                               (quantizer #f)
                                               (bitrate bitrate)
                                               (tune "zerolatency")
                                               (speed-preset "superfast"))
                                           (let ((elem
                                                   (gst-element "x264enc"
                                                                key-int-max: key-int-max
                                                                pass: pass
                                                                psy-tune: psy-tune
                                                                quantizer: quantizer
                                                                bitrate: bitrate
                                                                tune: tune
                                                                speed-preset: speed-preset
                                                                name: "enc")))
                                             @w (format :terminal "size={a}x{a} framerate={a}{%}" width height framerate)
                                             @w (format :terminal "{a}{%}" elem)
                                             elem)))
                                    "appsink name=sink")
                                  (list
                                    "tee."
                                    "queue"
                                    "videoscale"
                                    "videoconvert"
                                    (tie "video/x-raw, format=BGRA, width={self-width}, height={self-height}, pixel-aspect-ratio=(fraction)1/1")
                                    "videoflip video-direction=horiz"
                                    "appsink name=sinkself"))))
        (gst_object_set_name pipeline "camera")
        (let ((appsink (gst_bin_get_by_name pipeline "sink"))
              (appsinkself (gst_bin_get_by_name pipeline "sinkself"))
              (data (make-u8vector (* (max width self-width) (max height self-height) 4)))
              (info (make-u64vector 2)))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.data data)
          (set! self.info info)
          (set! self.pipeline pipeline)
          (set! self.appsink appsink)
          (set! self.appsinkself appsinkself)))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'camera)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! info #f)
    (set! data #f)
    (set! pipeline #f)
    (set! appsink #f)
    (consume sink #f #f #f))
  
  
  (method (reset self)
    (when pipeline
      (let ((valve (gst_bin_get_by_name pipeline "valve"))
            (encoder (gst_bin_get_by_name pipeline "enc")))
        (g_object_set valve "drop" (g_value_int 1))
        (gst_element_set_state encoder GST_STATE_READY)
        (gst_element_set_state encoder GST_STATE_PLAYING)
        (g_object_set valve "drop" (g_value_int 0))))))


;;;
;;;; Screen-Video-Src
;;;


(class Screen-Video-Src extends Video-Src)


;;;
;;;; Test-Video-Src
;;;


(class Test-Video-Src extends Video-Src
  
  
  (slot resolution initialize #f accessors generate)
  (slot framerate  initialize #f accessors generate)
  (slot bitrate    initialize #f accessors generate)
  (slot codec      initialize #f accessors generate)
  (slot pipeline   initialize #f accessors generate)
  
  
  (method override (initialize self (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f))
    (nextmethod self)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (get-width resolution))
          (height (get-height resolution)))
      (let ((pipeline (gst-launch "videotestsrc"
                                  "videoscale"
                                  "videoconvert"
                                  (tie "video/x-raw, format=I420, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                  (and (eq? codec 'h264) (tie "x264enc pass=qual quantizer=20 bitrate={bitrate} tune=zerolatency speed-preset=superfast"))
                                  "appsink name=sink")))
        (gst_object_set_name pipeline "test")
        (let ((appsink (gst_bin_get_by_name pipeline "sink"))
              (data (make-u8vector (* width height 4)))
              (info (make-u64vector 2)))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.data data)
          (set! self.info info)
          (set! self.pipeline pipeline)
          (set! self.appsink appsink)))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'test)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! info #f)
    (set! data #f)
    (set! pipeline #f)
    (set! appsink #f)
    (consume sink #f #f #f)))


;;;
;;;; File-Video-Src
;;;


(class File-Video-Src extends Video-Src
  
  
  (slot location                initialize #f accessors generate)
  (slot resolution              initialize #f accessors generate)
  (slot framerate               initialize #f accessors generate)
  (slot bitrate                 initialize #f accessors generate)
  (slot codec                   initialize #f accessors generate)
  (slot pipeline                initialize #f accessors generate)
  (slot audio?                  initialize #t accessors generate)
  (slot audio-sink              initialize #f accessors generate)
  (slot audio-appsink           initialize #f accessors generate)
  (slot audio-data <u8vector+>  initialize #f accessors generate)
  (slot audio-info <u64vector+> initialize #f accessors generate)
  
  
  (method override (initialize self location (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f) (audio?: audio? #t))
    (nextmethod self)
    (set! self.location location)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec)
    (set! self.audio? audio?))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (get-width resolution))
          (height (get-height resolution)))
      (let ((pipeline (gst-launch (tie "filesrc name=filesrc")
                                  "decodebin name=decoder"
                                  (and audio?
                                       (list "decoder."
                                             "queue"
                                             "audioconvert"
                                             "audioresample"
                                             (cond-expand
                                               (windows "audio/x-raw, format=S16LE, layout=interleaved, rate=48000, channels=1")
                                               (else "audio/x-raw, format=F32LE, layout=interleaved, rate=48000, channels=1"))
                                             "appsink name=audioappsink"))
                                  (list "decoder."
                                        "videoscale"
                                        "videoconvert"
                                        (tie "video/x-raw, format=I420, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                        "appsink name=appsink sync=false"))))
        (gst_object_set_name pipeline "file")
        (let ((filesrc (gst_bin_get_by_name pipeline "filesrc"))
              (appsink (gst_bin_get_by_name pipeline "appsink"))
              (data (make-u8vector (* width height 4)))
              (info (make-u64vector 2))
              (audio-appsink (and audio? (gst_bin_get_by_name pipeline "audioappsink")))
              (audio-data (and audio? (make-u8vector (* width height 4))))
              (audio-info (and audio? (make-u64vector 2))))
          (g_object_set_string filesrc "location" (path-normalize location))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.data data)
          (set! self.info info)
          (set! self.pipeline pipeline)
          (set! self.appsink appsink)
          (when audio?
            (set! self.audio-appsink audio-appsink)
            (set! self.audio-data audio-data)
            (set! self.audio-info audio-info))))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'file)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! info #f)
    (set! data #f)
    (set! pipeline #f)
    (set! appsink #f)
    (consume sink #f #f #f)
    (set! audio-info #f)
    (set! audio-data #f)
    (set! audio-appsink #f)
    (when audio-sink
      (consume audio-sink #f #f #f)))
  
  
  (method override (process self)
    (nextmethod self)
    (when audio-sink
      (let ((size (gst_app_sink_read audio-appsink audio-data audio-info)))
        (when (/= size -1)
          (let ((buffer (subu8vector audio-data 0 size))
                (timestamp (u64vector-ref audio-info 0))
                (duration (u64vector-ref audio-info 1)))
            (consume audio-sink buffer timestamp duration)))))))


;;;
;;;; File-Preprocess-Video-Src
;;;


(class File-Preprocess-Video-Src extends File-Video-Src
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (get-width resolution))
          (height (get-height resolution)))
      (let ((pipeline (gst-launch (tie "filesrc name=filesrc")
                                  "decodebin"
                                  (and framerate (tie "videorate max-rate={framerate}"))
                                  "videoscale"
                                  "videoconvert"
                                  (tie "video/x-raw, format=I420, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                  (let ((bitrate bitrate)
                                        (tune "zerolatency")
                                        (speed-preset "superfast"))
                                    (gst-element "x264enc"
                                                 bitrate: bitrate
                                                 tune: tune
                                                 speed-preset: speed-preset
                                                 name: "enc"))
                                  "appsink name=appsink sync=false")))
        (gst_object_set_name pipeline "file")
        (let ((filesrc (gst_bin_get_by_name pipeline "filesrc"))
              (appsink (gst_bin_get_by_name pipeline "appsink"))
              (data (make-u8vector (* width height 4)))
              (info (make-u64vector 2)))
          (g_object_set_string filesrc "location" (path-normalize location))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.data data)
          (set! self.info info)
          (set! self.pipeline pipeline)
          (set! self.appsink appsink)))))
  
  
  (method override (video-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (when (running? task)
            (site (preprocess on?: #t)
              (if (gst_app_sink_is_eos appsink)
                  (consume sink #f #f #f)
                (process self))))
          (task-sleep task .001 exit)
          (iter))))))


;;;
;;;; File-Stream-Video-Src
;;;


(class File-Stream-Video-Src extends Video-Src
  
  
  (slot location  getter generate)
  (slot file      getter generate)
  (slot port      getter generate)
  (slot time-base getter generate)
  
  
  (method override (initialize self location)
    (nextmethod self)
    (set! self.location location)
    (set! self.file #f)
    (set! self.port #f)
    (set! self.time-base (new Time-Base)))
  
  
  (method override (start-element self)
    (nextmethod self)
    (set! file (new-file {Directory Settings} (list "streams" (add-extension location "streamvideo"))))
    (set! port (open-input-file (path-settings file)))
    (task-start self 'stream))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (close port)
    (set! file #f)
    (set! port #f))
  
  
  (method override (video-loop self task)
    (declare (proper-tail-calls))
    (let ((tier (current-client)))
      (with-task task
        (lambda (exit)
          (let (iter)
            (when (running? task)
              (receive (buffer timestamp duration) (read-frame port)
                (if (not buffer)
                    ;; quicky
                    (task-sleep task +inf.0 exit)
                  (let ((time (current-seconds))
                        (nanostamp (timestamp->flonum timestamp)))
                    (update-start time-base time nanostamp)
                    (let ((sendtime (remote->local time-base nanostamp)))
                      (task-sleep task (- sendtime time) exit)
                      (site (stream on?: #t)
                        (consume sink buffer timestamp duration)))))))
            (iter)))))))


;;;
;;;; Draw-Video-Src
;;;


(class Draw-Video-Src extends Video-Src
  
  
  (slot start-time initialize #f accessors generate)
  (slot resolution initialize #f accessors generate)
  (slot context    initialize #f accessors generate)
  
  
  (method override (initialize self)
    (nextmethod self)
    (set! self.resolution video-resolution))
  
  
  (method override (start-element self)
    (nextmethod self)
    (let ((width (get-width video-resolution))
          (height (get-height video-resolution)))
      (set! context (new Draw-Context width height video-framerate video-bitrate)))
    (set! start-time (current-seconds))
    (task-start self 'draw))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (close context)
    (set! context #f))
  
  
  (method override (video-loop self task)
    (declare (proper-tail-calls))
    (let ((tier (current-client)))
      (with-task task
        (lambda (exit)
          (let (iter)
            (when (running? task)
              (let ((surface (get-surface context)))
                (draw-stream self surface)
                (receive (color alpha timestamp duration) (extract context)
                  (site (stream on?: #t)
                    (let ((effective-timestamp (flonum->timestamp (- (current-seconds) start-time))))
                      (consume sink color effective-timestamp duration))))))
            (sleep draw-refresh)
            (iter))))))
  
  
  (method protected virtual (draw-stream self surface)
    (clear surface)))


;;;
;;;; Image-Stream-Video-Src
;;;


(class Image-Stream-Video-Src extends Draw-Video-Src
  
  
  (slot location  getter generate)
  (slot live?     getter generate)
  (slot file      getter generate)
  (slot color     getter generate)
  (slot alpha     getter generate)
  (slot timestamp getter generate)
  (slot duration  getter generate)
  
  
  (method override (initialize self location (live?: live? #t))
    (nextmethod self)
    (set! self.location location)
    (set! self.live? live?)
    (set! self.file (new-file {Directory Settings} (list "images" location)))
    (set! self.color #f)
    (set! self.alpha #f)
    (set! self.timestamp #f)
    (set! self.duration #f))
  
  
  (method (extract/cache self)
    (if color
        (values color alpha timestamp duration)
      (let ((surface (get-surface context)))
        (draw-stream self surface)
        (receive (color alpha timestamp duration) (extract context)
          (set! self.color color)
          (set! self.alpha alpha)
          (set! self.timestamp timestamp)
          (set! self.duration duration)
          (values color alpha timestamp duration)))))
  
  
  (method override (video-loop self task)
    (declare (proper-tail-calls))
    (let ((tier (current-client)))
      (with-task task
        (lambda (exit)
          (let (iter)
            (when (running? task)
              (receive (color alpha timestamp duration) (extract/cache self)
                (site (stream on?: #t)
                  (let ((effective-timestamp (flonum->timestamp (- (current-seconds) start-time))))
                    (consume sink color effective-timestamp duration)))))
            (if (not live?)
                (begin
                  (consume sink #f #f #f)
                  (continuation-return exit #f))
              (sleep draw-refresh)
              (iter)))))))
  
  
  (method override (draw-stream self surface)
    (fill-image surface
                (new Rect 0 0 (get-width resolution) (get-height resolution))
                (new Image moniker: file)
                mode: 'fill)))


;;;
;;;; Video-Sink
;;;


(class Video-Sink extends Stream-Sink
  
  
  (slot resolution                  initialize #f accessors generate)
  (slot framerate                   initialize #f accessors generate)
  (slot bitrate                     initialize #f accessors generate)
  (slot codec                       initialize #f accessors generate)
  (slot flip                        initialize #f accessors generate)
  (slot process?                    initialize #f accessors generate)
  (slot alpha-overlay               initialize #f accessors generate)
  (slot overlay?                    initialize #f accessors generate)
  (slot color-pipeline              initialize #f accessors generate)
  (slot color-appsrc                initialize #f accessors generate)
  (slot color-appsink               initialize #f accessors generate)
  (slot color-data     <u8vector+>  initialize #f accessors generate)
  (slot color-info     <u64vector+> initialize #f accessors generate)
  (slot color-bytes                 initialize #f accessors generate)
  (slot alpha?                      initialize #f accessors generate)
  (slot alpha-pipeline              initialize #f accessors generate)
  (slot alpha-appsrc                initialize #f accessors generate)
  (slot alpha-appsink               initialize #f accessors generate)
  (slot alpha-data     <u8vector+>  initialize #f accessors generate)
  (slot alpha-info     <u64vector+> initialize #f accessors generate)
  (slot alpha-bytes                 initialize #f accessors generate)
  (slot image-surface               initialize #f accessors generate)
  (slot image-inhibit?              initialize #f accessors generate)
  (slot task                        initialize #f accessors generate)
  (slot needs-layout?               initialize #f accessors generate)
  (slot stream-state                initialize 'off getter generate setter explicit)
  (slot frame-count                 initialize #f)
  (slot frame-start                 initialize #f)
  (slot total-size                  initialize #f)
  
  
  (method override (initialize self (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f) (flip: flip #f) (process?: process? #t) (alpha-overlay: alpha-overlay #f) (overlay?: overlay? #f) (alpha?: alpha? #f) (needs-layout?: needs-layout? #f))
    (nextmethod self)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec)
    (set! self.flip flip)
    (set! self.process? process?)
    (set! self.alpha-overlay alpha-overlay)
    (set! self.overlay? overlay?)
    (set! self.alpha? alpha?)
    (set! self.needs-layout? needs-layout?))
  
  
  (method package virtual (sheet? self)
    #f)
  
  
  (method package (set-stream-state self state)
    (when (neq? state stream-state)
      (set! stream-state state)
      (invalidate-interface)))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (when process?
      (let ((width (get-width resolution))
            (height (get-height resolution)))
        (let ((pipeline (gst-launch (tie "appsrc name=src")
                                    (and (eq? codec 'h264) (tie "avdec_h264"))
                                    "videoscale"
                                    "videoconvert"
                                    (and flip (tie "videoflip video-direction={flip}"))
                                    (and alpha-overlay (tie "alpha alpha={alpha-overlay}"))
                                    (tie "video/x-raw, format=BGRA, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                    (tie "appsink name=sink"))))
          (gst_object_set_name pipeline "output")
          (let ((appsrc (gst_bin_get_by_name pipeline "src"))
                (appsink (gst_bin_get_by_name pipeline "sink"))
                (data (make-u8vector (* width height 4)))
                (info (make-u64vector 2)))
            (case codec
              ((h264)
               (gst_app_src_set_caps appsrc
                                     (gst_caps "video/x-h264"
                                               "width"         (g_value_int width)
                                               "height"        (g_value_int height)
                                               "framerate"     (g_value_fraction framerate 1)
                                               "stream-format" (g_value_string "avc")
                                               "alignment"     (g_value_string "au"))))
              (else
               (gst_app_src_set_caps appsrc
                                     (gst_caps "video/x-raw"
                                               "format"    (g_value_string "I420")
                                               "width"     (g_value_int width)
                                               "height"    (g_value_int height)
                                               "framerate" (g_value_fraction framerate 1)))))
            (g_object_set appsrc
                          "is-live"     (g_value_boolean #t)
                          "stream-type" (g_value_int GST_APP_STREAM_TYPE_STREAM)
                          "format"      (g_value_int GST_FORMAT_TIME))
            (gst_element_set_state pipeline GST_STATE_READY)
            (set! self.color-data data)
            (set! self.color-info info)
            (set! self.color-bytes #f)
            (set! self.color-pipeline pipeline)
            (set! self.color-appsrc appsrc)
            (set! self.color-appsink appsink)))
        (when alpha?
          (let ((pipeline (gst-launch "appsrc name=src"
                                      "avdec_h264 name=dec"
                                      "appsink name=sink")))
            (gst_object_set_name pipeline "output")
            (let ((appsrc (gst_bin_get_by_name pipeline "src"))
                  (appsink (gst_bin_get_by_name pipeline "sink"))
                  (data (make-u8vector (/ (* width height 12) 8)))
                  (info (make-u64vector 2)))
              (gst_app_src_set_caps appsrc
                                    (gst_caps "video/x-h264"
                                              "width"         (g_value_int width)
                                              "height"        (g_value_int height)
                                              "framerate"     (g_value_fraction framerate 1)
                                              "stream-format" (g_value_string "avc")
                                              "alignment"     (g_value_string "au")))
              (g_object_set appsrc
                            "is-live"     (g_value_boolean #t)
                            "stream-type" (g_value_int GST_APP_STREAM_TYPE_STREAM)
                            "format"      (g_value_int GST_FORMAT_TIME))
              (gst_element_set_state pipeline GST_STATE_READY)
              (set! self.alpha-data data)
              (set! self.alpha-info info)
              (set! self.alpha-bytes #f)
              (set! self.alpha-pipeline pipeline)
              (set! self.alpha-appsrc appsrc)
              (set! self.alpha-appsink appsink)
              (set! self.image-surface (new Image-Surface (new Dimension width height)))))))))
  
  
  (method override (start-element self)
    (define (task-start name)
      (let ((procedure
              (lambda (task)
                (video-loop self task))))
        (let ((task (new Task name procedure priority: video-priority)))
          (start-task task)
          (set! self.task task))))
    
    (nextmethod self)
    (when process?
      (task-start 'video)
      (gst_element_set_state color-pipeline GST_STATE_PLAYING)
      (when alpha?
        (gst_element_set_state alpha-pipeline GST_STATE_PLAYING))))
  
  
  (method override (stop-element self)
    (define (task-stop)
      (halt-task task)
      (set! task #f))
    
    (nextmethod self)
    (when process?
      (task-stop)
      (gst_element_set_state color-pipeline GST_STATE_READY)
      (when alpha?
        (gst_element_set_state alpha-pipeline GST_STATE_READY))))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when process?
      (gst_element_release color-pipeline)
      (set! color-info #f)
      (set! color-data #f)
      (set! color-bytes #f)
      (set! color-pipeline #f)
      (set! color-appsrc #f)
      (set! color-appsink #f)
      (when alpha?
        (gst_element_release alpha-pipeline)
        (close image-surface)
        (set! alpha-info #f)
        (set! alpha-data #f)
        (set! alpha-bytes #f)
        (set! alpha-pipeline #f)
        (set! alpha-appsrc #f)
        (set! alpha-appsink #f)
        (set! image-surface #f))
      (set-stream-state self 'off)))
  
  
  (method override (consume self color timestamp duration (alpha #f))
    ;; QUICK TEST
    (when color-appsrc
    ;; QUICK TEST
      (when color
        (gst_app_src_write3 color-appsrc color (u8vector-length color) timestamp duration)))
    (when alpha?
      ;; QUICK TEST
      (when alpha-appsrc
        ;; QUICK TEST
        (when alpha
          (gst_app_src_write3 alpha-appsrc alpha (u8vector-length alpha) timestamp duration)))))
  
  
  (method (video-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-seconds)))
          ;; not 100% correct if preempted before task-mutex
          (let ((time (current-seconds)))
            (when (running? task)
              (site (video-output on?: #t)
                (let ((elapse (- time previous))
                      (max-elapse 10.))
                  ;; ignore ridiculous elapses like
                  ;; coming back from computer sleep
                  (unless (> elapse max-elapse)
                    (let ((history (current-history)))
                      (unless (get-paused? history)
                        (process self)))))))
            (let ((duration (- (current-seconds) time)))
              (task-wait task video-period duration exit))
            (iter time))))))
  
  
  (method override (process self)
    (when (not color-bytes)
      (let ((size (gst_app_sink_read color-appsink color-data color-info)))
        (when (/= size -1)
          (set! color-bytes size))))
    (when (and alpha? (not alpha-bytes))
      (let ((size (gst_app_sink_read alpha-appsink alpha-data alpha-info)))
        (when (/= size -1)
          (set! alpha-bytes size))))
    (when (and color-bytes (or (not alpha?) alpha-bytes))
      (let ((timestamp (u64vector-ref color-info 0))
            (duration (u64vector-ref color-info 1)))
        (draw self color-data (and alpha? alpha-data) timestamp duration)
        (set! color-bytes #f)
        (set! alpha-bytes #f)
        (when (eq? stream-state 'on)
          (set-stream-state self 'drawn)))))
  
  
  (method package virtual (draw self color alpha timestamp duration)
    )
  
  
  (method package virtual (add-overlay self color alpha texture)
    (when overlay?
      (if (not frame-count)
          (begin
            (set! frame-count 1)
            (set! frame-start (current-seconds))
            (set! total-size (u8vector-length color)))
        (increase! frame-count)
        (increase! total-size (u8vector-length color))
        (let ((elapse (- (current-seconds) frame-start)))
          (let ((rate (/ (cast <fl> frame-count) elapse))
                (size (/ (cast <fl> total-size) frame-count))
                (surface (get-surface texture)))
            (set-font surface {Font font-name: tahoma point-size: 24 hint-style: slight hint-metrics: on})
            (draw-text surface 5 (- (get-height resolution) 30) (format "Rate: {r precision: 3}, Size: {a}" rate size) {Color World-Red}))))))
  
  
  (method package (update self color alpha texture (background: background #f))
    (if (not alpha?)
        (move-u8vector->pointer! color (get-data texture))
      (let ((width (get-width resolution))
            (height (get-height resolution))
            (data (cairo_image_surface_get_data (get-handle image-surface))))
        (cairo_surface_flush (get-handle image-surface))
        (combine-alpha color alpha data (* width height))
        (cairo_surface_mark_dirty (get-handle image-surface))
        (unless image-inhibit?
          (let ((surface (get-surface texture)))
            (clear-glass surface resolution background: background)
            (draw-surface surface image-surface 0 0)))))
    (add-overlay self color alpha texture)
    (unless image-inhibit?
      (map-texture texture)))
  
  
  (method package virtual (render self)
    )
  
  
  (method package (maybe-update-layouts self)
    (when needs-layout?
      (update-layouts (current-video))
      (set! needs-layout? #f)))
  
  
  (method (with-slide self texture thunk)
    (set! image-inhibit? #t)
    (thunk)
    (let ((height (cast <fl> (get-height resolution))))
      (let ((delta (/ height render-rate slide-duration))
            (surface (get-surface texture)))
        (thread-start!
          (new-thread
            (lambda ()
              (let (loop (slide (- height delta)))
                (let ((slide (max 0. slide)))
                  (let ((done? (<= slide 0.)))
                    (with-task-mutex
                      (lambda ()
                        (if (not image-surface)
                            (set! done? #t)
                          (translate surface 0 slide)
                          (clear-glass surface resolution)
                          (draw-surface surface image-surface 0 0)
                          (translate surface 0 (- slide))
                          (map-texture texture))
                        (when done?
                          (set! image-inhibit? #f))))
                    (when (not done?)
                      (sleep render-period)
                      (loop (- slide delta)))))))
            'slide))))))


;;;
;;;; Draw-Video-Sink
;;;


(class Draw-Video-Sink extends Video-Sink
  
  
  (slot entity     initialize #f accessors generate)
  (slot pane       initialize #f accessors generate)
  (slot background initialize #f accessors generate)
  
  
  (method override (initialize self ent . rest)
    (apply nextmethod self alpha?: #t rest)
    (let ((p (cache-draw-pane ent (list (eq? ent (current-me)) resolution))))
      (set! entity ent)
      (set! pane p)))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when entity
      (set-draw-pane entity #f)
      (set! entity #f)
      (set! pane #f)))
  
  
  (method override (draw self color alpha timestamp duration)
    ;; quicky
    (when pane
      (update self color alpha (get-texture (cache-quad-texture pane)) background: background)))
  
  
  (method override (render self)
    ;; nothing to do render done by player pane
    ))


;;;
;;;; Event-View
;;;


(class Event-View extends View)


(definition public (make-event-view)
  (let ((view (new Event-View)))
    (define (mouse-down event)
      (debug 'mouse-down))
    
    (define (mouse-up event)
      (debug 'mouse-up))
    
    (define (key-press event)
      (debug 'key-press))
    
    (set-mouse-down-handler view mouse-down)
    (set-mouse-up-handler view mouse-up)
    (set-key-press-handler view key-press)
    view))


(definition public (make-view . rest)
  (apply new View rest))


;;;
;;;; Draw-Pane
;;;


(definition public (make-draw-pane entity info)
  (let ((size {Dimension$fl$ 6. 3.375})
        (resolution {Dimension 1280 720}))
    (let ((pane (new Draw-Pane
                  title: "Draw"
                  size: size
                  resolution: resolution
                  billboard: info
                  entity: entity)))
      (cond ((is? info View)
             (set-root pane info)
             (set-position info {Point 0 0})
             (set-size info resolution)
             pane)
            (else
             pane)))))


@c4
(definition public (make-c4-pane entity billboard)
  (let ((size {Dimension$fl$ 3.6363636363636362 3.})
        (resolution {Dimension 660 600}))
    (let ((pane (new Script-Pane
                  size: size
                  resolution: resolution
                  billboard: billboard
                  entity: entity))
          (view (new jazz.sample.c4:C4-Board position: {Point 0 0} size: resolution background: #f)))
      (set-root pane view)
      (let ((pos (center (get-size view) resolution)))
        (set-position view pos))
      pane)))
  
  
  @c4
  (method override (draw self surface)
    (let ((width (get-width resolution))
          (height (get-height resolution)))
      (let ((rect (new Rect 0 0 width height))
            (color {Color red: .000 green: .000 blue: .200 alpha: .3}))
        (clear surface)
        (fill-rect surface rect color)
        (frame-rect surface rect color)
        (paint-drawing root surface '())))
    (when quad-texture
      (map-texture (get-texture quad-texture))))


(class Draw-Pane extends Entity-Pane)


;;;
;;;; Camera-Video-Sink
;;;


(class Camera-Video-Sink extends Video-Sink
  
  
  (slot player initialize #f accessors generate)
  (slot pane   initialize #f accessors generate)
  
  
  (method override (initialize self entity . rest)
    (apply nextmethod self rest)
    (let ((p (cache-camera-pane entity (list (eq? entity (current-me)) resolution))))
      (set! player entity)
      (set! pane p)))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when player
      (set-camera-pane player #f)
      (set! player #f)
      (set! pane #f)))
  
  
  (method override (draw self color alpha timestamp duration)
    (update self color alpha (get-texture (cache-quad-texture pane))))
  
  
  (method override (render self)
    ;; nothing to do render done by player pane
    ))


;;;
;;;; Camera-Pane
;;;


(definition public (make-camera-pane billboard)
  (bind (me? resolution) billboard
    (new Camera-Pane
      title: "Camera"
      size: (new Dimension$fl$ 1. .5625)
      resolution: resolution
      billboard: billboard)))


(class Camera-Pane extends World-Pane
  
  
  (method override (draw self surface)
    (clear surface)))


;;;
;;;; Texture-Video-Sink
;;;


(class Texture-Video-Sink extends Video-Sink
  
  
  (slot quad-texture initialize #f getter generate)
  (slot matrix       initialize #f getter generate)
  
  
  (method override (initialize self matrix . rest)
    (bind-keywords ((size #f) . others) rest
      (define (determine-size)
        (or size
            (let ((ratio (/ (cast <fl> (get-width resolution)) (cast <fl> (get-height resolution)))))
              (let ((w ratio)
                    (h 1.))
                (new Dimension$fl$ w h)))))
      
      (apply nextmethod self others)
      (let ((size (determine-size)))
        (let ((w (get-width size))
              (h (get-height size)))
          (let ((v1 (vertex (/ w -2.) (/ h -2.) 0.))
                (v2 (vertex (/ w -2.) (/ h  2.) 0.))
                (v3 (vertex (/ w  2.) (/ h  2.) 0.))
                (v4 (vertex (/ w  2.) (/ h -2.) 0.)))
            (let ((quad-texture (make-quad-texture (get-width resolution) (get-height resolution) v1 v2 v3 v4)))
              (set! self.quad-texture quad-texture)
              (set! self.matrix matrix)))))))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when quad-texture
      (glDeleteTextures* (get-id (get-texture quad-texture)))
      (set! quad-texture #f)))
  
  
  (method override (draw self color alpha timestamp duration)
    (update self color alpha (get-texture quad-texture)))
  
  
  (method override (render self)
    (when (eq? stream-state 'drawn)
      (render-texture quad-texture matrix))))


;;;
;;;; Sheet-Video-Sink
;;;


(class Sheet-Video-Sink extends Video-Sink
  
  
  (slot id         initialize #f accessors generate)
  (slot player     initialize #f accessors generate)
  (slot sheet      initialize #f accessors generate)
  (slot draw-mode  initialize #f accessors generate)
  (slot draw-mutex initialize #f accessors generate)
  (slot last-color initialize #f accessors generate)
  
  
  (method override (initialize self id entity . rest)
    (bind-keywords ((position #f) (size #f) . others) rest
      (apply nextmethod self others)
      (let ((world (current-world)))
        (let ((pos (or position {Point 0 0}))
              (size (or size {Dimension 320 180})))
          (let ((s (make-world-sheet 'video World-Sheet size resolution: resolution retina?: #f)))
            (make-orthographic-matrix! (get-projection-matrix s) 0. (get-width world) 0. (get-height world) 0. 10.)
            (set-position s pos)
            (set-size s size)
            (set! self.id id)
            (set! self.player entity)
            (set! self.sheet s)
            (set! self.draw-mode 'draw)
            (set! self.draw-mutex (make-mutex 'draw))
            (set! self.last-color #f))))))
  
  
  (method override (sheet? self)
    #t)
  
  
  (method package (resize self)
    (let ((world (current-world)))
      (let ((width (get-width world))
            (height (get-height world)))
        (make-orthographic-matrix! (get-projection-matrix sheet) 0. width 0. height 0. 10.))))
  
  
  (method package (move self rect)
    (set-rect sheet rect))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when sheet
      (glDeleteTextures* (get-id (get-texture sheet)))
      (set! sheet #f)))
  
  
  (method package (change-draw-mode self mode)
    (unless (eq? mode draw-mode)
      (set! draw-mode mode)
      ;; super quick try
      (when last-color
        (parameterize ((testing? #t)) ;; oh boy fix me!
        (draw self last-color #f #f #f)))))
  
  
  (method override (draw self color alpha timestamp duration)
    (mutex-lock! draw-mutex)
    (when (or (eq? draw-mode 'draw) (testing?))
      (let ((texture (get-texture sheet)))
        (update self color alpha texture))
      (set! last-color color))
    (when id
      (record-event udp-id-draw-video
                    (fixnum->flonum client-no)
                    (fixnum->flonum world.udp:udp-video)
                    -1.
                    -1.
                    -1.
                    (if (not timestamp)
                        -1.
                      (timestamp->flonum timestamp))))
    (mutex-unlock! draw-mutex))
  
  
  (method override (add-overlay self color alpha texture)
    (when (and id (neq? draw-mode 'draw))
      (case draw-mode
        ((freeze)
         (when world.udp:udp-freeze-overlay
           (fill-rect (get-surface texture) (size-rect resolution) world.udp:udp-freeze-overlay)))
        ((wait)
         (when world.udp:udp-wait-overlay
           (fill-rect (get-surface texture) (size-rect resolution) world.udp:udp-wait-overlay))))))
  
  
  (method override (render self)
    (when (eq? stream-state 'drawn)
    ;; QUICKY
    (when sheet
    (maybe-update-layouts self)
    (let ((world (current-world)))
      (let ((x (cast <fl> (get-left sheet)))
            (y (cast <fl> (get-top sheet)))
            (h (cast <fl> (get-height sheet))))
        (let ((matrix (make-translation-matrix (vertex x (- (get-height world) y h) 0.))))
          (render-sheet sheet matrix))))))))


;;;
;;;; Circle-Video-Sink
;;;


(class Circle-Video-Sink extends Video-Sink
  
  
  (slot id         initialize #f accessors generate)
  (slot player     initialize #f accessors generate)
  (slot texture    initialize #f accessors generate)
  (slot sheet      initialize #f accessors generate)
  (slot pane       initialize #f accessors generate)
  (slot matrix     initialize #f accessors generate)
  (slot draw-mode  initialize #f accessors generate)
  (slot draw-mutex initialize #f accessors generate)
  (slot last-color initialize #f accessors generate)
  
  
  (method override (initialize self id entity . rest)
    (bind-keywords ((position #f) (size #f) . others) rest
      (apply nextmethod self others)
      (let ((world (current-world)))
        (set! self.id id)
        (set! self.player entity)
        (set! self.texture (make-cairo-texture (get-width resolution) (get-height resolution)))
        (set! self.draw-mode 'draw)
        (set! self.draw-mutex (make-mutex 'draw))
        (set! self.last-color #f)
        ;; sheet
        (let ((pos (or position {Point 0 0}))
              (size (or size {Dimension 320 180})))
          (let ((s (make-world-sheet 'video World-Sheet size resolution: resolution texture: texture)))
            (make-orthographic-matrix! (get-projection-matrix s) 0. (get-width world) 0. (get-height world) 0. 10.)
            (set-position s pos)
            (set-size s size)
            (set! self.sheet s)))
        ;; pane
        (let ((p (new World-Pane
                   title: "Player"
                   size: (new Dimension$fl$ 1. .5625)
                   resolution: resolution
                   texture: texture)))
          (set! self.pane p)
          (set! self.matrix (make-identity-matrix))))))
  
  
  (method override (sheet? self)
    (memq? video-layout '(gallery fullscreen)))
  
  
  (method package (resize self)
    (when sheet
      (let ((world (current-world)))
        (let ((width (get-width world))
              (height (get-height world)))
          (make-orthographic-matrix! (get-projection-matrix sheet) 0. width 0. height 0. 10.)))))
  
  
  (method package (move self rect)
    (when sheet
      (set-rect sheet rect)))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when texture
      (glDeleteTextures* (get-id texture))
      (set! texture #f)))
  
  
  (method package (change-draw-mode self mode)
    (unless (eq? mode draw-mode)
      (set! draw-mode mode)
      ;; super quick try
      (when last-color
        (parameterize ((testing? #t)) ;; oh boy fix me!
        (draw self last-color #f #f #f)))))
  
  
  (method override (draw self color alpha timestamp duration)
    (mutex-lock! draw-mutex)
    (when (or (eq? draw-mode 'draw) (testing?))
      (update self color alpha texture)
      (set! last-color color))
    (when id
      (record-event udp-id-draw-video
                    (fixnum->flonum client-no)
                    (fixnum->flonum world.udp:udp-video)
                    -1.
                    -1.
                    -1.
                    (if (not timestamp)
                        -1.
                      (timestamp->flonum timestamp))))
    (mutex-unlock! draw-mutex))
  
  
  (method override (add-overlay self color alpha texture)
    (when (and id (neq? draw-mode 'draw))
      (case draw-mode
        ((freeze)
         (when world.udp:udp-freeze-overlay
           (fill-rect (get-surface texture) (size-rect resolution) world.udp:udp-freeze-overlay)))
        ((wait)
         (when world.udp:udp-wait-overlay
           (fill-rect (get-surface texture) (size-rect resolution) world.udp:udp-wait-overlay))))))
  
  
  (method override (render self)
    (when (eq? stream-state 'drawn)
      ;; QUICKY
      (cond ((sheet? self)
             (maybe-update-layouts self)
             (let ((world (current-world)))
               (let ((x (cast <fl> (get-left sheet)))
                     (y (cast <fl> (get-top sheet)))
                     (h (cast <fl> (get-height sheet))))
                 (let ((matrix (make-translation-matrix (vertex x (- (get-height world) y h) 0.))))
                   (render-sheet sheet matrix)))))
            (else
             (maybe-update-layouts self)
             (render-texture (cache-quad-texture pane) matrix))))))


;;;
;;;; Test
;;;


(definition test-pipeline #f)
(definition file-pipeline #f)
(definition camera-pipeline #f)
(definition circle-pipelines #f)


(definition next-names
  (copy common-names))

(definition next-src
  0)


(definition (make-texture-pipeline name size resolution framerate codec video-src matrix (audio-sink #f))
  (let ((video (current-video)))
    (let ((bitrate video-bitrate))
      (let ((video-sink (new Texture-Video-Sink
                          matrix
                          size: size
                          resolution: resolution
                          framerate: framerate
                          bitrate: bitrate
                          codec: codec
                          flip: 'vert)))
        (let ((pipeline (pipeline video-src video-sink)))
          ;; quick first solution
          (when audio-sink
            (set-elements pipeline (append (get-elements pipeline) (list audio-sink))))
          (register-input video name video-src)
          (register-output video name video-sink)
          (register-extra-output video video-sink)
          (set-stream-state video-sink 'on)
          (start pipeline)
          pipeline)))))


(definition protected (make-test-video)
  (let ((size #f)
        (resolution {Dimension 300 200})
        (framerate (cond-expand (unix 25) (else 30)))
        (bitrate video-bitrate)
        (codec 'none))
    (make-texture-pipeline 'test size resolution framerate codec
      (new Test-Video-Src
        resolution: resolution
        framerate: framerate
        bitrate: bitrate
        codec: codec)
      (copy-matrix (matrix-multiply& (make-translation-matrix (vertex -9.5 7. 4.5))
                                     (make-scaling-matrix (vertex 6. 6. 6.))
                                     (make-rotation-matrix (vertex 0. 1. 0.) PI/4))))))


(definition protected (make-file-video (file: file #f) (resolution: resolution #f) (position: position #f) (audio?: audio? #t) (volume: volume #f))
  (let ((size #f)
        (resolution (or resolution {Dimension 1280 720}))
        (framerate (cond-expand (unix 25) (else 30)))
        (bitrate video-bitrate))
    (let ((file-src (new File-Video-Src
                      (parse (or file {File Home "Media" "sintel.webm"}))
                      resolution: resolution
                      framerate: framerate
                      bitrate: bitrate
                      codec: 'none
                      audio?: audio?))
          (audio-sink (and audio?
                           (new world.audio:Audio-Sink
                             codec: 'none
                             volume: volume))))
      (when audio?
        (set-audio-sink file-src audio-sink))
      (make-texture-pipeline 'file size resolution framerate 'none
        file-src
        (copy-matrix (matrix-multiply& (make-translation-matrix (or position (vertex 0. 7. 0.)))
                                       (make-scaling-matrix (vertex 6. 6. 6.))))
        ;; quick first solution
        audio-sink))))


(definition protected (make-camera-video)
  (let ((size #f)
        (resolution {Dimension 1280 720})
        (framerate (cond-expand (unix 25) (else 30)))
        (bitrate video-bitrate)
        (codec 'none))
    (make-texture-pipeline 'camera size resolution framerate codec
      (new Camera-Video-Src
        resolution: resolution
        framerate: framerate
        bitrate: bitrate
        codec: codec)
      (copy-matrix (matrix-multiply& (make-translation-matrix (vertex 10. 7. 5.))
                                     (make-scaling-matrix (vertex 6. 6. 6.))
                                     (make-rotation-matrix (vertex 0. 1. 0.) (- PI/4)))))))


(definition protected circle-count
  10)


(definition protected (make-circle-videos)
  (let ((count circle-count))
    (loop (for n from 4 below count)
          (collect (make-circle-video #f n)))))


(definition protected (make-circle-video location n)
  (let ((name (string->symbol (format "circle{a}" n)))
        (size @w #f (new Dimension$fl$ 1. .5625))
        (resolution {Dimension 640 360})
        (framerate (cond-expand (unix 25) (else 30)))
        (bitrate video-bitrate)
        (codec video-codec @w 'none))
    (make-texture-pipeline name size resolution framerate codec
      (if location
          (new Image-Stream-Video-Src
            location)
        (new Test-Video-Src
          resolution: resolution
          framerate: framerate
          bitrate: bitrate
          codec: codec))
      (copy-matrix (make-circle-matrix circle-count n)))))


(class Trigger extends Object
  
  
  (slot procedure getter generate)
  (slot in-error? accessors generate)
  
  
  (method override (initialize self procedure)
    (nextmethod self)
    (set! self.procedure procedure)
    (set! self.in-error? #f)))


(definition protected layout-circle
  #f)

(definition protected (set-layout-circle proc)
  (set! layout-circle (new Trigger proc)))


(definition (make-circle-matrix count n)
  (matrix-multiply&
    (make-translation-matrix (vertex 0. 7. 0.))
    (make-scaling-matrix (vertex 10. 10. 10.))
    (make-rotation-matrix (vertex 0. 1. 0.) (* (/ PI*2 (cast <fl> count)) (cast <fl> n)))
    (make-translation-matrix (vertex 0. 0. (circle-radius count)))))


(definition protected (circle-radius count)
  (/ (cast <fl> count) PI*2))


(definition (random-name!)
  (let ((name (random-element next-names)))
    (set! next-names (remove! name next-names))
    name))


(definition (random-src!)
  (let ((n next-src))
    (set! next-src (modulo (+ next-src 1) 3))
    (element (list Test-Video-Src File-Video-Src Camera-Video-Src) n)))


(definition protected (add-player)
  (let ((world (current-world))
        (video (current-video)))
    (define (layout-player)
      (let ((current-count (length (get-ordered-outputs video))))
        (let ((new-count (+ current-count 1)))
          (let ((rectangles (layout video new-count)))
            (and rectangles
                 (last rectangles))))))
    
    (let ((name (random-name!))
          (src-class (random-src!))
          (rect (layout-player)))
      (let ((file? (eq? src-class File-Video-Src))
            (audio? #f))
        (let ((position (and rect (rect-position rect)))
              (size (and rect (rect-size rect)))
              (resolution (if file? {Dimension 854 480} video-resolution))
              (framerate video-framerate)
              (bitrate video-bitrate)
              (codec 'none))
          (let ((video-src (if file?
                               (new File-Video-Src
                                 "~/Media/sintel.webm"
                                 resolution: resolution
                                 framerate: framerate
                                 bitrate: bitrate
                                 codec: codec)
                             (new src-class
                               resolution: resolution
                               framerate: framerate
                               bitrate: bitrate
                               codec: codec)))
                (video-sink (player-output video name position: position size: size resolution: resolution codec: codec))
                (audio-sink (and (and file? audio?)
                                 (new world.audio:Audio-Sink
                                   codec: 'none))))
            (when audio-sink
              (set-audio-sink video-src audio-sink))
            (let ((pipeline (if audio-sink
                                (pipeline video-src video-sink audio-sink)
                              (pipeline video-src video-sink))))
              (register-input video name video-src)
              (setup pipeline)
              (start pipeline)
              (sleep .25) ; flicker heuristic. should wait until every new output has drawn
              (update-layouts video)
              (display-message world (format "{a} joined" name))
              pipeline)))))))


(definition protected (remove-player)
  (let ((world (current-world))
        (video (current-video)))
    (let ((ordered-outputs (get-ordered-outputs video)))
      (if (null? ordered-outputs)
          (bell)
        (let ((output (random-element ordered-outputs)))
          (let ((name (table-find (get-outputs video) output)))
            (let ((input (find-input video name)))
              (stop input)
              (stop output)
              (close-input video name input)
              (close-output video name output)
              (update-layouts video)
              (display-message world (format "{a} left" name)))))))))


(definition protected (close-pipeline pipeline)
  (let ((video (current-video)))
    (stop pipeline)
    (bind (input output) (get-elements pipeline)
      (let ((id (table-find (get-outputs video) output)))
        (close-input video id input)
        (close-output video id output)))))


(definition protected (close-pipelines pipelines)
  (for-each close-pipeline pipelines))


(definition protected (video-test7)
  (set! circle-pipelines (if (not circle-pipelines)
                             (make-circle-videos)
                           (close-pipelines circle-pipelines)
                           #f)))


(definition protected (video-test8)
  (add-player))


(definition protected (video-test9)
  (remove-player))


(definition protected (video-test0)
  (if (not test-pipeline)
      (set! test-pipeline (make-test-video))
    (if (not file-pipeline)
        (set! file-pipeline (make-file-video))
      (set! camera-pipeline (make-camera-video))))))
