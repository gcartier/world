;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Video
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.video jazz


(import (jazz.cairo)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.io)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (jazz.view)
        (jazz.window)
        (world)
        (world.autoload)
        (world.configure)
        (world.console)
        (world.context)
        (world.entity)
        (world.foreign)
        (world.geometry)
        (world.id)
        (world.interface.sheet)
        (world.io)
        (world.layout)
        (world.pane)
        (world.quad-texture)
        (world.settings)
        (world.task))


(definition protected video-resolution
  (world-setting 'world.video-resolution {Dimension 1280 720}))

(definition protected video-framerate
  (world-setting 'world.video-framerate 15))

(definition protected video-bitrate
  (world-setting 'world.video-bitrate 1024 @wait 2048))

(definition protected video-key-period
  (world-setting 'world.video-key-period #f))

(definition protected video-pass
  (world-setting 'world.video-pass #f))

(definition protected video-alpha
  (world-setting 'world.video-alpha 1.0 @wait 0.6))

(definition protected video-overlay?
  (world-setting 'world.video-overlay? #f))

(definition protected video-codec
  (world-setting 'world.video-codec 'h264))


(definition layouts
  '(;;overhead
    sidebar
    gallery
    fullscreen))

(definition video-layout
  (world-setting 'world.video-layout 'sidebar @currently-buggy-when-we-cycle 'overhead))


(definition video-show
  (world-setting 'world.video-show #f))


(definition video-debug?
  (world-setting 'world.video-debug? #f))


(definition self-video?
  (world-setting 'together.self-video? #t))


(definition slide-duration
  (world-setting 'world.slide-duration .2))


;;;
;;;; Kush
;;;


(definition public (kush-gauge width height rate motion)
  (/ (* width height rate motion 0.07) 1000.))


;;;
;;;; Access
;;;


(definition public (get-video-layout)
  video-layout)

(definition public (set-video-layout layout)
  (set! video-layout layout))


;;;
;;;; Video
;;;


(definition protected (new-world-video)
  (let ((camera-src (new Camera-Video-Src
                      resolution: video-resolution
                      framerate: video-framerate
                      bitrate: video-bitrate
                      codec: video-codec))
        (server-sink (new Stream-Sink
                       consumer: (lambda (buffer timestamp duration)
                                 (let ((video (current-video)))
                                   (send-camera-video video buffer timestamp duration)))))
        (self-sink (and self-video?
                        (new Stream-Sink
                          consumer: (lambda (buffer timestamp duration)
                                      (let ((video (current-video)))
                                        ;; the player: is a quick hack to test self video
                                        (let ((sink (player-output video #f player: (current-me))))
                                          (draw sink buffer #f timestamp duration)
                                          (set-drawn? sink #t))))))))
    (new World-Video input: (pipeline camera-src (if self-sink
                                                     (list server-sink self-sink)
                                                   server-sink)))))


(definition protected (video-buffer-header? buffer)
  (and (>= (u8vector-length buffer) 5)
       (= (u8vector-ref buffer 5) 16)))


(class World-Video extends Object
  
  
  (slot input             getter generate)
  (slot inputs            getter generate)
  (slot outputs           getter generate)
  (slot ordered-outputs   getter generate)
  (slot fullscreen-output getter generate)
  (slot camera-mutex      getter generate)
  (slot receive-hook      accessors generate)
  (slot render-hook       accessors generate)
  
  
  (method override (initialize self (input: input #f))
    (nextmethod self)
    (set! self.input input)
    (set! self.inputs (make-table test: equal?))
    (set! self.outputs (make-table test: equal?))
    (set! ordered-outputs '())
    (set! fullscreen-output #f)
    (set! camera-mutex (make-mutex 'camera))
    (set! receive-hook #f)
    (set! render-hook #f))
  
  
  (method package (autostart self)
    (when (world-setting 'world.video-autostart? #f)
      (start self)))
  
  
  (method package (start self)
    (start input))
  
  
  (method package (stop self)
    (release input))
  
  
  (method (with-camera-mutex self thunk)
    (mutex-lock! camera-mutex)
    (prog1 (thunk)
      (mutex-unlock! camera-mutex)))
  
  
  (method package (send-camera-video self buffer timestamp duration)
    (with-camera-mutex self
      (lambda ()
        (let ((tier (current-client)))
          (send-client-video tier buffer timestamp duration)))))
  
  
  (method package (reset-camera self)
    (with-camera-mutex self
      (lambda ()
        (let ((tier (current-client)))
          (let ((next-data-sequence (read-video-data-sequence tier)))
            (let ((camera (car (get-elements input))))
              (let ((pipeline (get-pipeline camera)))
                (and pipeline
                     (let ((valve (gst_bin_get_by_name pipeline "valve"))
                           (encoder (gst_bin_get_by_name pipeline "enc")))
                       (g_object_set valve "drop" (g_value_int 1))
                       (gst_element_set_state encoder GST_STATE_READY)
                       (gst_element_set_state encoder GST_STATE_PLAYING)
                       (g_object_set valve "drop" (g_value_int 0))
                       next-data-sequence)))))))))
  
  
  (method package (resize self)
    (iterate-table outputs
      (lambda (id output)
        (when (sheet? output)
          (resize output))))
    (layout-outputs self))
  
  
  ;;;
  ;;;; Input
  ;;;
  
  
  (method (on-toggle-video self evt)
    (toggle-video self))
  
  
  (method package (toggle-video self)
    (when (client?)
      (if (video-playing? self)
          (stop-video self)
        (start-video self))))
  
  
  (method package (start-video self (feedback?: feedback? #t))
    (when (client?)
      (let ((world (current-world)))
        (start self)
        (update-parameter world 'video)
        (when feedback?
          (display-on/off world "Video" (playing? input))))))
  
  
  (method package (stop-video self (feedback?: feedback? #t))
    (when (client?)
      (let ((world (current-world)))
        (stop self)
        (let ((self-output (table-ref outputs #f #f)))
          (when self-output
            (close-output self #f self-output)))
        (update-parameter world 'video)
        (when feedback?
          (display-on/off world "Video" (playing? input))))))
  
  
  (method package (video-playing? self)
    (playing? input))
  
  
  ;;;
  ;;;; Inputs
  ;;;
  
  
  (method package (find-input self id)
    (table-ref inputs id #f))
  
  (method package (register-input self id input)
    (table-set! inputs id input))
  
  
  (method package (close-input self id input)
    (table-clear inputs id)
    (release input))
  
  
  ;;;
  ;;;; Outputs
  ;;;
  
  
  (method package (find-output self id)
    (table-ref outputs id #f))
  
  (method package (register-output self id output)
    (table-set! outputs id output))
  
  
  (method package (entity-output self id (position: position #f) (size: size #f) (resolution: resolution #f) (layout: layout #f) (codec: codec #f))
    (or (table-ref outputs id #f)
        (let ((entity (find-entity id)))
          (let ((output (new Draw-Video-Sink entity
                             resolution: (or resolution {Dimension 1280 720})
                             framerate: video-framerate
                             bitrate: video-bitrate
                             codec: (or codec video-codec)
                             alpha-overlay: video-alpha
                             overlay?: video-overlay?)))
            (table-set! outputs id output)
            (setup output)
            (start output)
            output))))
  
  
  (method package (player-output self id (player: player #f) (position: position #f) (size: size #f) (resolution: resolution #f) (layout: layout #f) (codec: codec #f))
    (or (table-ref outputs id #f)
        ;; the or is a quick hack to test self video
        (let ((player (or player (find-entity id))))
          (let ((output (case (or layout video-layout)
                          ((overhead)
                           (new Camera-Video-Sink
                             player
                             resolution: (or resolution video-resolution)
                             framerate: video-framerate
                             bitrate: video-bitrate
                             codec: (or codec video-codec)
                             alpha-overlay: video-alpha
                             overlay?: video-overlay?))
                          (else
                           (new Sheet-Video-Sink
                             player
                             position: position
                             size: size
                             resolution: (or resolution video-resolution)
                             framerate: video-framerate
                             bitrate: video-bitrate
                             codec: (or codec video-codec)
                             alpha-overlay: video-alpha
                             overlay?: video-overlay?)))))
            (table-set! outputs id output)
            (set! ordered-outputs (append! ordered-outputs (list output)))
            (update-layouts self)
            (setup output)
            (start output)
            output))))
  
  
  (method package (close-output self id output)
    (table-clear outputs id)
    (set! ordered-outputs (remove! output ordered-outputs))
    (release output)
    (update-layouts self))
  
  
  (method package (receive-server-video self id buffer timestamp duration)
    (unless (and receive-hook
                 (receive-hook self id buffer timestamp duration))
      (if (not buffer)
          (let ((output (find-output self id)))
            (when output
              (close-output self id output)))
        (let ((output (player-output self id)))
          (consume output buffer timestamp duration)))))
  
  
  (method package (receive-processor-draw self id color alpha timestamp duration background slide?)
    (if (not color)
        (let ((output (find-output self id)))
          (when output
            (close-output self id output)))
      (let ((output (entity-output self id)))
        (set-background output background)
        (if (not slide?)
            (consume output color timestamp duration alpha)
          (let ((texture (get-texture (cache-quad-texture (get-pane output)))))
            (with-slide output texture
              (lambda ()
                (consume output color timestamp duration alpha))))))))
  
  
  (method package (render-scene self)
    (unless (and render-hook
                 (render-hook self))
      (let ((self-output (table-ref outputs #f #f)))
        ;; use ordered-outputs so order is stable
        (for-each (lambda (output)
                    (unless (eq? output self-output)
                      (render output)))
                  ordered-outputs)
        ;; render self output last for fullscreen
        (when self-output
          (render self-output)))))
  
  
  ;;;
  ;;;; Layout
  ;;;
  
  
  (method (on-cycle-layouts self evt)
    (let ((world (current-world)))
      (cycle-layouts self)
      (display-message world (capitalize (symbol->string video-layout)))))
  
  
  (method (cycle-layouts self)
    (case video-layout
      ((overhead)
       (sidebar-layout self))
      ((sidebar)
       (gallery-layout self))
      ((gallery)
       (fullscreen-layout self))
      ((fullscreen)
       (overhead-layout self))))
  
  
  (method (update-layouts self)
    (case video-layout
      ((overhead)
       (overhead-layout self))
      ((sidebar)
       (sidebar-layout self))
      ((gallery)
       (gallery-layout self))
      ((fullscreen)
       (fullscreen-layout self))))
  
  
  (method (stop-renders self)
    (let ((zone (current-zone)))
      (for-each (lambda (player)
                  (let ((elem (get-camera-pane player)))
                    (when elem
                      (set-render? elem #f))))
                (get-players zone))))
  
  
  (method package (overhead-layout self)
    (stop-renders self)
    (set! video-layout 'overhead)
    (layout-outputs self))
  
  
  (method package (sidebar-layout self)
    (stop-renders self)
    (set! video-layout 'sidebar)
    (layout-outputs self))
  
  
  (method package (gallery-layout self)
    (set! video-layout 'gallery)
    (layout-outputs self))
  
  
  (method package (fullscreen-layout self)
    (unless (and fullscreen-output
                 (table-find outputs fullscreen-output))
      (let ((output (find-if (lambda (output)
                               (let ((id (table-find outputs output)))
                                 id))
                             ordered-outputs)))
        (set! fullscreen-output output)))
    (set! video-layout 'fullscreen)
    (layout-outputs self))
  
  
  (method package (layout-outputs self)
    (when (not-null? ordered-outputs)
      (let ((rectangles (layout self (length ordered-outputs))))
        (when rectangles
          (for-each (lambda (output rect)
                      ;; quick hacks to test self video
                      (let ((player (get-player output)))
                        (let ((elem (get-camera-pane player)))
                          (if (not rect)
                              (when elem
                                (set-render? elem #f))
                            (when elem
                              (set-render? elem #t))
                            (move output rect)))))
                    ordered-outputs
                    rectangles)))))
  
  
  (method package (layout self num-players)
    (let ((window (current-window)))
      (let ((bounds (get-bounds window)))
        (let ((l (get-left bounds))
              (t (get-top bounds))
              (r (get-right bounds))
              (b (get-bottom bounds)))
          (case video-layout
            ((sidebar)
             (layout-tiles num-players (new Rect 10 70 210 (- b 100))))
            ((gallery)
             ;; quicky to fix
             (if (= num-players 1)
                 (list bounds)
               ;; quicky so self is botton in a 2 call
               (if (= num-players 2)
                   (let ((self-output (find-output self #f)))
                     (if self-output
                         (let ((rectangles (layout-tiles num-players bounds)))
                           (if (eq? (car ordered-outputs) self-output)
                               rectangles
                             (reverse rectangles)))
                       (layout-tiles num-players bounds)))
                 (layout-tiles num-players bounds))))
            ((fullscreen)
             (let ((full bounds)
                   (mini (car (layout-tiles 1 (new Rect (- r 300) 500 r b) vertical-justification: 'tail))))
               (map (lambda (output)
                      (if (eq? output fullscreen-output)
                          full
                        (let ((id (table-find outputs output)))
                          (if (not id)
                              mini
                            #f))))
                    ordered-outputs))
             @display-everyone-that-is-not-fullscreen
             (cons bounds (layout-tiles (- num-players 1) (new Rect (- r 200) 500 r b) vertical-justification: 'tail)))
            (else
             #f)))))))


;;;
;;;; Video-Src
;;;


(class Video-Src extends Stream-Src
  
  
  (slot appsink               initialize #f accessors generate)
  (slot appsink2              initialize #f accessors generate)
  (slot data     <u8vector+>  initialize #f accessors generate)
  (slot info     <u64vector+> initialize #f accessors generate)
  (slot task                  initialize #f accessors generate)
  
  
  (method (task-start self name)
    (let ((procedure
            (lambda (task)
              (video-task self task))))
      (let ((task (new Task name procedure priority: video-priority)))
        (start-task task)
        (set! self.task task))))
  
  
  (method (task-stop self)
    (halt-task task)
    (set! task #f))
  
  
  (method protected virtual (video-task self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-seconds)))
          ;; not 100% correct if preempted before task-mutex
          (let ((time (current-seconds)))
            (unless (stopping? task)
              (site (video on?: #t)
                (let ((elapse (- time previous))
                      (max-elapse 10.))
                  ;; ignore ridiculous elapses like
                  ;; coming back from computer sleep
                  (unless (> elapse max-elapse)
                    (let ((history (current-history)))
                      (unless (get-paused? history)
                        (process self)))))))
            (let ((duration (- (current-seconds) time)))
              (task-sleep task video-period duration exit))
            (iter time))))))
  
  
  (method override (process self)
    (let ((size (gst_app_sink_read appsink data info)))
      (when (/= size -1)
        (let ((buffer (subu8vector data 0 size))
              (timestamp (u64vector-ref info 0))
              (duration (u64vector-ref info 1)))
          (when (and video-show
                     (or (eq? video-show 'all)
                         (eq? video-show 'header)
                         (>= size video-show)))
            ;; h264 specific
            (let ((type (if (video-buffer-header? buffer)
                            '***header***
                          'delta)))
              (if (eq? video-show 'header)
                  (when (eq? type '***header***)
                    (terminal size type))
                (terminal size type))))
          (consume sink buffer timestamp duration))))
    (when self-video?
      (let ((size (gst_app_sink_read appsink2 data info)))
        (when (/= size -1)
          (let ((buffer (subu8vector data 0 size))
                (timestamp (u64vector-ref info 0))
                (duration (u64vector-ref info 1)))
            (consume sink2 buffer timestamp duration)))))))


;;;
;;;; Camera-Video-Src
;;;


(class Camera-Video-Src extends Video-Src
  
  
  (slot resolution initialize #f accessors generate)
  (slot framerate  initialize #f accessors generate)
  (slot bitrate    initialize #f accessors generate)
  (slot codec      initialize #f accessors generate)
  (slot pipeline   initialize #f accessors generate)
  
  
  (method override (initialize self (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f))
    (nextmethod self)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (get-width resolution))
          (height (get-height resolution)))
      (let ((pipeline (if (not self-video?)
                          (gst-launch (cond-expand
                                        (mac "avfvideosrc")
                                        (windows "ksvideosrc")
                                        (else "v4l2src"))
                                      "videoscale"
                                      "videoconvert"
                                      (tie "video/x-raw, format=I420, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1, framerate={framerate}/1")
                                      "valve name=valve"
                                      (and (eq? codec 'h264)
                                           (let ((key-int-max (and video-key-period (fxround (* (cast <fl> framerate) video-key-period))))
                                                 (pass video-pass)
                                                 (psy-tune #f)
                                                 (quantizer #f)
                                                 (bitrate bitrate)
                                                 (tune "zerolatency")
                                                 (speed-preset "superfast"))
                                             (let ((elem
                                                     (gst-element "x264enc"
                                                                  key-int-max: key-int-max
                                                                  pass: pass
                                                                  psy-tune: psy-tune
                                                                  quantizer: quantizer
                                                                  bitrate: bitrate
                                                                  tune: tune
                                                                  speed-preset: speed-preset
                                                                  name: "enc")))
                                               @w (format :terminal "size={a}x{a} framerate={a}{%}" width height framerate)
                                               @w (format :terminal "{a}{%}" elem)
                                               elem)))
                                      "appsink name=sink")
                        (gst-launch (cond-expand
                                      (mac "avfvideosrc")
                                      (windows "ksvideosrc")
                                      (else "v4l2src"))
                                    "tee name=tee"
                                    (list
                                      "tee."
                                      "queue"
                                      "videoscale"
                                      "videoconvert"
                                      (tie "video/x-raw, format=I420, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1, framerate={framerate}/1")
                                      "valve name=valve"
                                      (and (eq? codec 'h264)
                                           (let ((key-int-max (and video-key-period (fxround (* (cast <fl> framerate) video-key-period))))
                                                 (pass video-pass)
                                                 (psy-tune #f)
                                                 (quantizer #f)
                                                 (bitrate bitrate)
                                                 (tune "zerolatency")
                                                 (speed-preset "superfast"))
                                             (let ((elem
                                                     (gst-element "x264enc"
                                                                  key-int-max: key-int-max
                                                                  pass: pass
                                                                  psy-tune: psy-tune
                                                                  quantizer: quantizer
                                                                  bitrate: bitrate
                                                                  tune: tune
                                                                  speed-preset: speed-preset
                                                                  name: "enc")))
                                               @w (format :terminal "size={a}x{a} framerate={a}{%}" width height framerate)
                                               @w (format :terminal "{a}{%}" elem)
                                               elem)))
                                      "appsink name=sink")
                                    (list
                                      "tee."
                                      "queue"
                                      (let ((drop (if self-video? "false" "true")))
                                        (tie "valve drop={drop} name=selfvalve"))
                                      "videoscale"
                                      "videoconvert"
                                      "videoflip video-direction=horiz"
                                      (tie "video/x-raw, format=BGRA, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1, framerate={framerate}/1")
                                      "appsink name=sink2")))))
        (gst_object_set_name pipeline "camera")
        (let ((appsink (gst_bin_get_by_name pipeline "sink"))
              (appsink2 (and self-video? (gst_bin_get_by_name pipeline "sink2")))
              (data (make-u8vector (* width height 4)))
              (info (make-u64vector 2)))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.data data)
          (set! self.info info)
          (set! self.pipeline pipeline)
          (set! self.appsink appsink)
          (set! self.appsink2 appsink2)))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'camera)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! info #f)
    (set! data #f)
    (set! pipeline #f)
    (set! appsink #f)
    (consume sink #f #f #f)))


;;;
;;;; Screen-Video-Src
;;;


(class Screen-Video-Src extends Video-Src)


;;;
;;;; Test-Video-Src
;;;


(class Test-Video-Src extends Video-Src
  
  
  (slot resolution initialize #f accessors generate)
  (slot framerate  initialize #f accessors generate)
  (slot bitrate    initialize #f accessors generate)
  (slot codec      initialize #f accessors generate)
  (slot pipeline   initialize #f accessors generate)
  
  
  (method override (initialize self (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f))
    (nextmethod self)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (get-width resolution))
          (height (get-height resolution)))
      (let ((pipeline (gst-launch "videotestsrc"
                                  "videoscale"
                                  "videoconvert"
                                  (tie "video/x-raw, format=I420, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1, framerate={framerate}/1")
                                  (and (eq? codec 'h264) (tie "x264enc pass=qual quantizer=20 bitrate={bitrate} tune=zerolatency speed-preset=superfast"))
                                  "appsink name=sink")))
        (gst_object_set_name pipeline "test")
        (let ((appsink (gst_bin_get_by_name pipeline "sink"))
              (data (make-u8vector (* width height 4)))
              (info (make-u64vector 2)))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.data data)
          (set! self.info info)
          (set! self.pipeline pipeline)
          (set! self.appsink appsink)))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'test)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! info #f)
    (set! data #f)
    (set! pipeline #f)
    (set! appsink #f)
    (consume sink #f #f #f)))


;;;
;;;; File-Video-Src
;;;


(class File-Video-Src extends Video-Src
  
  
  (slot location                initialize #f accessors generate)
  (slot resolution              initialize #f accessors generate)
  (slot framerate               initialize #f accessors generate)
  (slot bitrate                 initialize #f accessors generate)
  (slot codec                   initialize #f accessors generate)
  (slot pipeline                initialize #f accessors generate)
  (slot audio?                  initialize #t accessors generate)
  (slot audio-sink              initialize #f accessors generate)
  (slot audio-appsink           initialize #f accessors generate)
  (slot audio-data <u8vector+>  initialize #f accessors generate)
  (slot audio-info <u64vector+> initialize #f accessors generate)
  
  
  (method override (initialize self location (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f) (audio?: audio? #t))
    (nextmethod self)
    (set! self.location location)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec)
    (set! self.audio? audio?))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (get-width resolution))
          (height (get-height resolution)))
      (let ((pipeline (gst-launch (tie "filesrc name=filesrc")
                                  "decodebin name=decoder"
                                  (and audio?
                                       (list "decoder."
                                             "queue"
                                             "audioconvert"
                                             "audioresample"
                                             (cond-expand
                                               (windows "audio/x-raw, format=S16LE, layout=interleaved, rate=80000, channels=2")
                                               (else "audio/x-raw, format=F32LE, layout=interleaved, rate=80000, channels=2"))
                                             "appsink name=audioappsink"))
                                  (list "decoder."
                                        "videoscale"
                                        "videoconvert"
                                        (tie "video/x-raw, format=I420, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                        "appsink name=appsink"))))
        (gst_object_set_name pipeline "file")
        (let ((filesrc (gst_bin_get_by_name pipeline "filesrc"))
              (appsink (gst_bin_get_by_name pipeline "appsink"))
              (data (make-u8vector (* width height 4)))
              (info (make-u64vector 2))
              (audio-appsink (and audio? (gst_bin_get_by_name pipeline "audioappsink")))
              (audio-data (and audio? (make-u8vector (* width height 4))))
              (audio-info (and audio? (make-u64vector 2))))
          (g_object_set_string filesrc "location" (path-normalize location))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.data data)
          (set! self.info info)
          (set! self.pipeline pipeline)
          (set! self.appsink appsink)
          (when audio?
            (set! self.audio-appsink audio-appsink)
            (set! self.audio-data audio-data)
            (set! self.audio-info audio-info))))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'file)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! info #f)
    (set! data #f)
    (set! pipeline #f)
    (set! appsink #f)
    (consume sink #f #f #f)
    (set! audio-info #f)
    (set! audio-data #f)
    (set! audio-appsink #f)
    (when audio-sink
      (consume audio-sink #f #f #f)))
  
  
  (method override (process self)
    (nextmethod self)
    (when audio-sink
      (let ((size (gst_app_sink_read audio-appsink audio-data audio-info)))
        (when (/= size -1)
          (let ((buffer (subu8vector audio-data 0 size))
                (timestamp (u64vector-ref audio-info 0))
                (duration (u64vector-ref audio-info 1)))
            (consume audio-sink buffer timestamp duration)))))))


;;;
;;;; Video-Sink
;;;


(class Video-Sink extends Stream-Sink
  
  
  (slot resolution                  initialize #f accessors generate)
  (slot framerate                   initialize #f accessors generate)
  (slot bitrate                     initialize #f accessors generate)
  (slot codec                       initialize #f accessors generate)
  (slot flip                        initialize #f accessors generate)
  (slot alpha-overlay               initialize #f accessors generate)
  (slot overlay?                    initialize #f accessors generate)
  (slot color-pipeline              initialize #f accessors generate)
  (slot color-appsrc                initialize #f accessors generate)
  (slot color-appsink               initialize #f accessors generate)
  (slot color-data     <u8vector+>  initialize #f accessors generate)
  (slot color-info     <u64vector+> initialize #f accessors generate)
  (slot color-bytes                 initialize #f accessors generate)
  (slot alpha?                      initialize #f accessors generate)
  (slot alpha-pipeline              initialize #f accessors generate)
  (slot alpha-appsrc                initialize #f accessors generate)
  (slot alpha-appsink               initialize #f accessors generate)
  (slot alpha-data     <u8vector+>  initialize #f accessors generate)
  (slot alpha-info     <u64vector+> initialize #f accessors generate)
  (slot alpha-bytes                 initialize #f accessors generate)
  (slot image-surface               initialize #f accessors generate)
  (slot image-inhibit?              initialize #f accessors generate)
  (slot task                        initialize #f accessors generate)
  (slot drawn?                      initialize #f accessors generate)
  (slot frame-count                 initialize #f)
  (slot frame-start                 initialize #f)
  (slot total-size                  initialize #f)
  
  
  (method override (initialize self (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f) (flip: flip #f) (alpha-overlay: alpha-overlay #f) (overlay?: overlay? #f) (alpha?: alpha? #f))
    (nextmethod self)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec)
    (set! self.flip flip)
    (set! self.alpha-overlay alpha-overlay)
    (set! self.overlay? overlay?)
    (set! self.alpha? alpha?))
  
  
  (method package virtual (sheet? self)
    #f)
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (get-width resolution))
          (height (get-height resolution)))
      (let ((pipeline (gst-launch (tie "appsrc name=src")
                                  (and (eq? codec 'h264) (tie "avdec_h264"))
                                  "videoscale"
                                  "videoconvert"
                                  (and flip (tie "videoflip video-direction={flip}"))
                                  (and alpha-overlay (tie "alpha alpha={alpha-overlay}"))
                                  (tie "video/x-raw, format=BGRA, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1, framerate={framerate}/1")
                                  (tie "appsink name=sink"))))
        (gst_object_set_name pipeline "output")
        (let ((appsrc (gst_bin_get_by_name pipeline "src"))
              (appsink (gst_bin_get_by_name pipeline "sink"))
              (data (make-u8vector (* width height 4)))
              (info (make-u64vector 2)))
          (case codec
            ((h264)
             (gst_app_src_set_caps appsrc
               (gst_caps "video/x-h264"
                 "width"         (g_value_int width)
                 "height"        (g_value_int height)
                 "framerate"     (g_value_fraction framerate 1)
                 "stream-format" (g_value_string "avc")
                 "alignment"     (g_value_string "au"))))
            (else
             (gst_app_src_set_caps appsrc
               (gst_caps "video/x-raw"
                 "format"    (g_value_string "I420")
                 "width"     (g_value_int width)
                 "height"    (g_value_int height)
                 "framerate" (g_value_fraction framerate 1)))))
          (g_object_set appsrc
            "is-live"     (g_value_boolean #t)
            "stream-type" (g_value_int GST_APP_STREAM_TYPE_STREAM)
            "format"      (g_value_int GST_FORMAT_TIME))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.color-data data)
          (set! self.color-info info)
          (set! self.color-bytes #f)
          (set! self.color-pipeline pipeline)
          (set! self.color-appsrc appsrc)
          (set! self.color-appsink appsink)))
      (when alpha?
        (let ((pipeline (gst-launch "appsrc name=src"
                                    "avdec_h264 name=dec"
                                    "appsink name=sink")))
          (gst_object_set_name pipeline "output")
          (let ((appsrc (gst_bin_get_by_name pipeline "src"))
                (appsink (gst_bin_get_by_name pipeline "sink"))
                (data (make-u8vector (/ (* width height 12) 8)))
                (info (make-u64vector 2)))
            (gst_app_src_set_caps appsrc
              (gst_caps "video/x-h264"
                 "width"         (g_value_int width)
                 "height"        (g_value_int height)
                 "framerate"     (g_value_fraction framerate 1)
                 "stream-format" (g_value_string "avc")
                 "alignment"     (g_value_string "au")))
            (g_object_set appsrc
              "is-live"     (g_value_boolean #t)
              "stream-type" (g_value_int GST_APP_STREAM_TYPE_STREAM)
              "format"      (g_value_int GST_FORMAT_TIME))
            (gst_element_set_state pipeline GST_STATE_READY)
            (set! self.alpha-data data)
            (set! self.alpha-info info)
            (set! self.alpha-bytes #f)
            (set! self.alpha-pipeline pipeline)
            (set! self.alpha-appsrc appsrc)
            (set! self.alpha-appsink appsink)
            (set! self.image-surface (new Image-Surface (new Dimension width height))))))))
  
  
  (method override (start-element self)
    (define (task-start name)
      (let ((procedure
              (lambda (task)
                (video-task self task))))
        (let ((task (new Task name procedure priority: video-priority)))
          (start-task task)
          (set! self.task task))))
    
    (nextmethod self)
    (task-start 'video)
    (gst_element_set_state color-pipeline GST_STATE_PLAYING)
    (when alpha?
      (gst_element_set_state alpha-pipeline GST_STATE_PLAYING)))
  
  
  (method override (stop-element self)
    (define (task-stop)
      (halt-task task)
      (set! task #f))
    
    (nextmethod self)
    (task-stop)
    (gst_element_set_state color-pipeline GST_STATE_READY)
    (when alpha?
      (gst_element_set_state alpha-pipeline GST_STATE_READY)))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release color-pipeline)
    (set! color-info #f)
    (set! color-data #f)
    (set! color-bytes #f)
    (set! color-pipeline #f)
    (set! color-appsrc #f)
    (set! color-appsink #f)
    (when alpha?
      (gst_element_release alpha-pipeline)
      (close image-surface)
      (set! alpha-info #f)
      (set! alpha-data #f)
      (set! alpha-bytes #f)
      (set! alpha-pipeline #f)
      (set! alpha-appsrc #f)
      (set! alpha-appsink #f)
      (set! image-surface #f))
    (set! drawn? #f))
  
  
  (method override (consume self color timestamp duration (alpha #f))
    ;; QUICK TEST
    (when color-appsrc
    ;; QUICK TEST
      (when color
        (gst_app_src_write3 color-appsrc color (u8vector-length color) timestamp duration)))
    (when alpha?
      ;; QUICK TEST
      (when alpha-appsrc
        ;; QUICK TEST
        (when alpha
          (gst_app_src_write3 alpha-appsrc alpha (u8vector-length alpha) timestamp duration)))))
  
  
  (method (video-task self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-seconds)))
          ;; not 100% correct if preempted before task-mutex
          (let ((time (current-seconds)))
            (unless (stopping? task)
              (site (video-output on?: #t)
                (let ((elapse (- time previous))
                      (max-elapse 10.))
                  ;; ignore ridiculous elapses like
                  ;; coming back from computer sleep
                  (unless (> elapse max-elapse)
                    (let ((history (current-history)))
                      (unless (get-paused? history)
                        (process self)))))))
            (let ((duration (- (current-seconds) time)))
              (task-sleep task video-period duration exit))
            (iter time))))))
  
  
  (method override (process self)
    (when (not color-bytes)
      (let ((size (gst_app_sink_read color-appsink color-data color-info)))
        (when (/= size -1)
          (set! color-bytes size))))
    (when (and alpha? (not alpha-bytes))
      (let ((size (gst_app_sink_read alpha-appsink alpha-data alpha-info)))
        (when (/= size -1)
          (set! alpha-bytes size))))
    (when (and color-bytes (or (not alpha?) alpha-bytes))
      (let ((timestamp (u64vector-ref color-info 0))
            (duration (u64vector-ref color-info 1)))
        (draw self color-data (and alpha? alpha-data) timestamp duration)
        (set! color-bytes #f)
        (set! alpha-bytes #f)
        (set! drawn? #t))))
  
  
  (method package virtual (draw self color alpha timestamp duration)
    )
  
  
  (method package (update self color alpha texture (background: background #f))
    (define (add-overlay)
      (if (not frame-count)
          (begin
            (set! frame-count 1)
            (set! frame-start (current-seconds))
            (set! total-size (u8vector-length color)))
        (increase! frame-count)
        (increase! total-size (u8vector-length color))
        (let ((elapse (- (current-seconds) frame-start)))
          (let ((rate (/ (cast <fl> frame-count) elapse))
                (size (/ (cast <fl> total-size) frame-count)))
            (set-font (get-surface texture) {Font font-name: tahoma point-size: 24 hint-style: slight hint-metrics: on})
            (draw-text (get-surface texture) 5 (- (get-height resolution) 30) (format "Rate: {r precision: 3}, Size: {a}" rate size) {Color World-Red})))))
    
    (if (not alpha?)
        (move-u8vector->pointer! color (get-data texture))
      (let ((width (get-width resolution))
            (height (get-height resolution))
            (data (cairo_image_surface_get_data (get-handle image-surface))))
        (cairo_surface_flush (get-handle image-surface))
        (combine-alpha color alpha data (* width height))
        (cairo_surface_mark_dirty (get-handle image-surface))
        (unless image-inhibit?
          (let ((surface (get-surface texture)))
            (clear-glass surface resolution background: background)
            (draw-surface surface image-surface 0 0)))))
    (when overlay?
      (add-overlay))
    (unless image-inhibit?
      (map-texture texture)))
  
  
  (method package virtual (render self)
    )
  
  
  (method (with-slide self texture thunk)
    (set! image-inhibit? #t)
    (thunk)
    (let ((height (cast <fl> (get-height resolution))))
      (let ((delta (/ height render-rate slide-duration))
            (surface (get-surface texture)))
        (thread-start!
          (new-thread
            (lambda ()
              (let (loop (slide (- height delta)))
                (let ((slide (max 0. slide)))
                  (let ((done? (<= slide 0.)))
                    (with-task-mutex
                      (lambda ()
                        (if (not image-surface)
                            (set! done? #t)
                          (translate surface 0 slide)
                          (clear-glass surface resolution)
                          (draw-surface surface image-surface 0 0)
                          (translate surface 0 (- slide))
                          (map-texture texture))
                        (when done?
                          (set! image-inhibit? #f))))
                    (when (not done?)
                      (sleep render-period)
                      (loop (- slide delta)))))))
            'slide))))))


;;;
;;;; Draw-Video-Sink
;;;


(class Draw-Video-Sink extends Video-Sink
  
  
  (slot entity     initialize #f accessors generate)
  (slot pane       initialize #f accessors generate)
  (slot background initialize #f accessors generate)
  
  
  (method override (initialize self ent . rest)
    (apply nextmethod self alpha?: #t rest)
    (let ((p (cache-draw-pane ent (list (eq? ent (current-me)) resolution))))
      (set! entity ent)
      (set! pane p)))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when entity
      (set-draw-pane entity #f)
      (set! entity #f)
      (set! pane #f)))
  
  
  (method override (draw self color alpha timestamp duration)
    ;; quicky
    (when pane
      (update self color alpha (get-texture (cache-quad-texture pane)) background: background)))
  
  
  (method override (render self)
    ;; nothing to do render done by player pane
    ))


;;;
;;;; Event-View
;;;


(class Event-View extends View)


(definition public (make-event-view)
  (let ((view (new Event-View)))
    (define (mouse-down event)
      (debug 'mouse-down))
    
    (define (mouse-up event)
      (debug 'mouse-up))
    
    (define (key-press event)
      (debug 'key-press))
    
    (set-mouse-down-handler view mouse-down)
    (set-mouse-up-handler view mouse-up)
    (set-key-press-handler view key-press)
    view))


(definition public (make-view . rest)
  (apply new View rest))


;;;
;;;; Draw-Pane
;;;


(definition public (make-draw-pane entity info)
  (let ((size {Dimension$fl$ 6. 3.375})
        (resolution {Dimension 1280 720}))
    (let ((pane (new Draw-Pane
                  title: "Draw"
                  size: size
                  resolution: resolution
                  billboard: info
                  entity: entity)))
      (cond ((is? info View)
             (set-root pane info)
             (set-position info {Point 0 0})
             (set-size info resolution)
             pane)
            (else
             pane)))))


@c4
(definition public (make-c4-pane entity billboard)
  (let ((size {Dimension$fl$ 3.6363636363636362 3.})
        (resolution {Dimension 660 600}))
    (let ((pane (new Script-Pane
                  size: size
                  resolution: resolution
                  billboard: billboard
                  entity: entity))
          (view (new jazz.sample.c4:C4-Board position: {Point 0 0} size: resolution background: #f)))
      (set-root pane view)
      (let ((pos (center (get-size view) resolution)))
        (set-position view pos))
      pane)))
  
  
  @c4
  (method override (draw self surface)
    (let ((width (get-width resolution))
          (height (get-height resolution)))
      (let ((rect (new Rect 0 0 width height))
            (color {Color red: .000 green: .000 blue: .200 alpha: .3}))
        (clear surface)
        (fill-rect surface rect color)
        (frame-rect surface rect color)
        (paint-drawing root surface '())))
    (when quad-texture
      (map-texture (get-texture quad-texture))))


(class Draw-Pane extends Entity-Pane)


;;;
;;;; Camera-Video-Sink
;;;


(class Camera-Video-Sink extends Video-Sink
  
  
  (slot player initialize #f accessors generate)
  (slot pane   initialize #f accessors generate)
  
  
  (method override (initialize self entity . rest)
    (apply nextmethod self rest)
    (let ((p (cache-camera-pane entity (list (eq? entity (current-me)) resolution))))
      (set! player entity)
      (set! pane p)))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when player
      (set-camera-pane player #f)
      (set! player #f)
      (set! pane #f)))
  
  
  (method override (draw self color alpha timestamp duration)
    (update self color alpha (get-texture (cache-quad-texture pane))))
  
  
  (method override (render self)
    ;; nothing to do render done by player pane
    ))


;;;
;;;; Camera-Pane
;;;


(definition public (make-camera-pane billboard)
  (bind (me? resolution) billboard
    (new Camera-Pane
      title: "Camera"
      size: (new Dimension$fl$ 1. .5625)
      resolution: resolution
      billboard: billboard)))


(class Camera-Pane extends World-Pane
  
  
  (method override (draw self surface)
    (clear surface)))


;;;
;;;; Texture-Video-Sink
;;;


(class Texture-Video-Sink extends Video-Sink
  
  
  (slot quad-texture initialize #f getter generate)
  (slot matrix       initialize #f getter generate)
  
  
  (method override (initialize self matrix . rest)
    (bind-keywords ((size #f) . others) rest
      (define (determine-size)
        (or size
            (let ((ratio (/ (cast <fl> (get-width resolution)) (cast <fl> (get-height resolution)))))
              (let ((w ratio)
                    (h 1.))
                (new Dimension$fl$ w h)))))
      
      (apply nextmethod self others)
      (let ((size (determine-size)))
        (let ((w (get-width size))
              (h (get-height size)))
          (let ((v1 (vertex (/ w -2.) (/ h -2.) 0.))
                (v2 (vertex (/ w -2.) (/ h  2.) 0.))
                (v3 (vertex (/ w  2.) (/ h  2.) 0.))
                (v4 (vertex (/ w  2.) (/ h -2.) 0.)))
            (let ((quad-texture (make-quad-texture (get-width resolution) (get-height resolution) v1 v2 v3 v4)))
              (set! self.quad-texture quad-texture)
              (set! self.matrix matrix)))))))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when quad-texture
      (glDeleteTextures* (get-id (get-texture quad-texture)))
      (set! quad-texture #f)))
  
  
  (method override (draw self color alpha timestamp duration)
    (update self color alpha (get-texture quad-texture)))
  
  
  (method override (render self)
    (when drawn?
      (render-texture quad-texture matrix))))


;;;
;;;; Sheet-Video-Sink
;;;


(class Sheet-Video-Sink extends Video-Sink
  
  
  (slot player initialize #f accessors generate)
  (slot size   initialize #f accessors generate)
  (slot sheet  initialize #f accessors generate)
  
  
  (method override (initialize self entity . rest)
    (bind-keywords ((position #f) (size #f) . others) rest
      (apply nextmethod self others)
      (let ((world (current-world)))
        (let ((pos (or position {Point 0 0}))
              (size (or size {Dimension 320 180})))
          (let ((s (make-world-sheet 'video World-Sheet size resolution: resolution)))
            (make-orthographic-matrix! (get-projection-matrix s) 0. (get-width world) 0. (get-height world) 0. 10.)
            (set-position s pos)
            (set-size s size)
            (set! player entity)
            (set! sheet s))))))
  
  
  (method override (sheet? self)
    #t)
  
  
  (method package (resize self)
    (let ((world (current-world)))
      (let ((width (get-width world))
            (height (get-height world)))
        (make-orthographic-matrix! (get-projection-matrix sheet) 0. width 0. height 0. 10.))))
  
  
  (method package (move self rect)
    (set-rect sheet rect))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when sheet
      (glDeleteTextures* (get-id (get-texture sheet)))
      (set! sheet #f)))
  
  
  (method override (draw self color alpha timestamp duration)
    (update self color alpha (get-texture sheet)))
  
  
  (method override (render self)
    (when drawn?
    ;; QUICKY
    (when sheet
    (let ((world (current-world)))
      (let ((x (cast <fl> (get-left sheet)))
            (y (cast <fl> (get-top sheet)))
            (h (cast <fl> (get-height sheet))))
        (let ((matrix (make-translation-matrix (vertex x (- (get-height world) y h) 0.))))
          (render-sheet sheet matrix))))))))


;;;
;;;; Test
;;;


(definition test-pipeline #f)
(definition file-pipeline #f)
(definition camera-pipeline #f)
(definition circle-pipelines #f)


(definition next-names
  (copy common-names))

(definition next-src
  0)


(definition (make-texture-pipeline name size resolution framerate codec video-src matrix (audio-sink #f))
  (let ((video (current-video)))
    (let ((bitrate video-bitrate))
      (let ((video-sink (new Texture-Video-Sink
                          matrix
                          size: size
                          resolution: resolution
                          framerate: framerate
                          bitrate: bitrate
                          codec: codec
                          flip: 'vert)))
        (let ((pipeline (pipeline video-src video-sink)))
          ;; quick first solution
          (when audio-sink
            (set-elements pipeline (append (get-elements pipeline) (list audio-sink))))
          (register-input video name video-src)
          (register-output video name video-sink)
          (start pipeline)
          pipeline)))))


(definition protected (make-test-video)
  (let ((size #f)
        (resolution {Dimension 300 200})
        (framerate (cond-expand (unix 25) (else 30)))
        (bitrate video-bitrate)
        (codec 'none))
    (make-texture-pipeline 'test size resolution framerate codec
      (new Test-Video-Src
        resolution: resolution
        framerate: framerate
        bitrate: bitrate
        codec: codec)
      (copy-matrix (matrix-multiply& (make-translation-matrix (vertex -9.5 7. 4.5))
                                     (make-scaling-matrix (vertex 6. 6. 6.))
                                     (make-rotation-matrix (vertex 0. 1. 0.) PI/4))))))


(definition protected (make-file-video (file: file #f) (resolution: resolution #f) (position: position #f) (audio?: audio? #t) (volume: volume #f))
  (let ((size #f)
        (resolution (or resolution {Dimension 1280 720}))
        (framerate (cond-expand (unix 25) (else 30)))
        (bitrate video-bitrate))
    (let ((file-src (new File-Video-Src
                      (parse (or file {File Home "Media" "sintel.webm"}))
                      resolution: resolution
                      framerate: framerate
                      bitrate: bitrate
                      codec: 'none
                      audio?: audio?))
          (audio-sink (and audio?
                           (new world.audio:Audio-Sink
                             codec: 'none
                             volume: volume))))
      (when audio?
        (set-audio-sink file-src audio-sink))
      (make-texture-pipeline 'file size resolution framerate 'none
        file-src
        (copy-matrix (matrix-multiply& (make-translation-matrix (or position (vertex 0. 7. 0.)))
                                       (make-scaling-matrix (vertex 6. 6. 6.))))
        ;; quick first solution
        audio-sink))))


(definition protected (make-camera-video)
  (let ((size #f)
        (resolution {Dimension 1280 720})
        (framerate (cond-expand (unix 25) (else 30)))
        (bitrate video-bitrate)
        (codec 'none))
    (make-texture-pipeline 'camera size resolution framerate codec
      (new Camera-Video-Src
        resolution: resolution
        framerate: framerate
        bitrate: bitrate
        codec: codec)
      (copy-matrix (matrix-multiply& (make-translation-matrix (vertex 10. 7. 5.))
                                     (make-scaling-matrix (vertex 6. 6. 6.))
                                     (make-rotation-matrix (vertex 0. 1. 0.) (- PI/4)))))))


(definition protected (make-circle-videos)
  (let ((count 15))
    (loop (for n from 0 below count)
          (collect (let ((name (string->symbol (format "circle{a}" n)))
                         (size #f)
                         (resolution {Dimension 300 200})
                         (framerate (cond-expand (unix 25) (else 30)))
                         (bitrate video-bitrate)
                         (codec 'none))
                     (make-texture-pipeline name size resolution framerate codec
                       (new Test-Video-Src
                         resolution: resolution
                         framerate: framerate
                         bitrate: bitrate
                         codec: codec)
                       (copy-matrix (matrix-multiply& (make-translation-matrix (vertex 0. 7. 0.))
                                                      (make-scaling-matrix (vertex 6. 6. 6.))
                                                      (make-rotation-matrix (vertex 0. 1. 0.) (* (/ PI*2 (cast <fl> count)) (cast <fl> n)))
                                                      (make-translation-matrix (vertex 0. 0. 4.))))))))))


(definition (random-name!)
  (let ((name (random-element next-names)))
    (set! next-names (remove! name next-names))
    name))


(definition (random-src!)
  (let ((n next-src))
    (set! next-src (modulo (+ next-src 1) 3))
    (element (list Test-Video-Src File-Video-Src Camera-Video-Src) n)))


(definition protected (add-player)
  (let ((world (current-world))
        (video (current-video)))
    (define (layout-player)
      (let ((current-count (length (get-ordered-outputs video))))
        (let ((new-count (+ current-count 1)))
          (let ((rectangles (layout video new-count)))
            (and rectangles
                 (last rectangles))))))
    
    (let ((name (random-name!))
          (src-class (random-src!))
          (rect (layout-player)))
      (let ((file? (eq? src-class File-Video-Src))
            (audio? #f))
        (let ((position (and rect (rect-position rect)))
              (size (and rect (rect-size rect)))
              (resolution (if file? {Dimension 854 480} video-resolution))
              (framerate video-framerate)
              (bitrate video-bitrate)
              (codec 'none))
          (let ((video-src (if file?
                               (new File-Video-Src
                                 "~/Media/sintel.webm"
                                 resolution: resolution
                                 framerate: framerate
                                 bitrate: bitrate
                                 codec: codec)
                             (new src-class
                               resolution: resolution
                               framerate: framerate
                               bitrate: bitrate
                               codec: codec)))
                (video-sink (player-output video name position: position size: size resolution: resolution codec: codec))
                (audio-sink (and (and file? audio?)
                                 (new world.audio:Audio-Sink
                                   codec: 'none))))
            (when audio-sink
              (set-audio-sink video-src audio-sink))
            (let ((pipeline (if audio-sink
                                (pipeline video-src video-sink audio-sink)
                              (pipeline video-src video-sink))))
              (register-input video name video-src)
              (setup pipeline)
              (start pipeline)
              (sleep .25) ; flicker heuristic. should wait until every new output has drawn
              (update-layouts video)
              (display-message world (format "{a} joined" name))
              pipeline)))))))


(definition protected (remove-player)
  (let ((world (current-world))
        (video (current-video)))
    (let ((ordered-outputs (get-ordered-outputs video)))
      (if (null? ordered-outputs)
          (bell)
        (let ((output (random-element ordered-outputs)))
          (let ((name (table-find (get-outputs video) output)))
            (let ((input (find-input video name)))
              (stop input)
              (stop output)
              (close-input video name input)
              (close-output video name output)
              (update-layouts video)
              (display-message world (format "{a} left" name)))))))))


(definition (close-pipelines pipelines)
  (let ((video (current-video)))
    (for-each stop pipelines)
    (for-each (lambda (pipeline)
                (bind (input output) (get-elements pipeline)
                  (let ((id (table-find (get-outputs video) output)))
                    (close-input video id input)
                    (close-output video id output))))
              pipelines)))


(definition protected (video-test7)
  (set! circle-pipelines (if (not circle-pipelines)
                             (make-circle-videos)
                           (close-pipelines circle-pipelines)
                           #f)))


(definition protected (video-test8)
  (add-player))


(definition protected (video-test9)
  (remove-player))


(definition protected (video-test0)
  (if (not test-pipeline)
      (set! test-pipeline (make-test-video))
    (if (not file-pipeline)
        (set! file-pipeline (make-file-video))
      (set! camera-pipeline (make-camera-video))))))
