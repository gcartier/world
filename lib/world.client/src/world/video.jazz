;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Video
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.video jazz


(import (jazz.cairo)
        (jazz.component)
        (jazz.event)
        (jazz.flow)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.image)
        (jazz.io)
        (jazz.listener)
        (jazz.opengl.glew)
        (jazz.opengl.render)
        (jazz.opengl.texture)
        (jazz.platform)
        (jazz.presence)
        (jazz.screen)
        (jazz.settings)
        (jazz.stream)
        (jazz.stream.syntax (phase syntax))
        (jazz.syntax (phase syntax))
        (jazz.time)
        (jazz.version)
        (jazz.view)
        (jazz.window)
        (gaea.geometry)
        (gaea.homogeneous)
        (gaea.plane)
        (world)
        (world.autoload)
        (world.billboard)
        (world.buffers)
        (world.configure)
        (world.console)
        (world.context)
        (world.customize)
        (world.entity)
        (world.event)
        (world.foreign)
        (world.hardware (cond mac))
        (world.hook)
        (world.interface)
        (world.interface.sheet)
        (world.io)
        (world.layout)
        (world.media)
        (world.moment)
        (world.moment.syntax (phase syntax))
        (world.pane)
        (world.profile)
        (world.quad-texture)
        (world.render)
        (world.screenshot)
        (world.settings)
        (world.stream)
        (world.syntax (phase syntax))
        (world.task)
        (world.texture)
        (world.time)
        (world.udp)
        (world.window))


(definition protected video-resolution
  (world-setting 'world.video-resolution {Dimension 640 360}))

(definition protected video-framerate
  (world-setting 'world.video-framerate 15))

(definition protected video-bitrate
  (world-setting 'world.video-bitrate 1024))

(definition protected video-codec
  (world-setting 'world.video-codec 'h264))

(definition protected video-hardware?
  (world-setting 'world.video-hardware? #f))

(definition protected (set-video-hardware? hardware?)
  (set! video-hardware? hardware?))


(definition protected camera-keyframes
  (world-setting 'world.camera-keyframes 2))


(definition protected screen-share-framerate
  (world-setting 'world.screen-share-framerate 10))

(definition protected screen-share-min-bitrate
  (world-setting 'world.screen-share-min-bitrate 256))

(definition protected screen-share-bitrate
  (world-setting 'world.screen-share-bitrate 2048))

(definition protected screen-share-codec
  (world-setting 'world.screen-share-codec 'h264))

(definition protected screen-share-keyframes
  (world-setting 'world.screen-share-keyframes 2))


(definition protected window-share-framerate
  (world-setting 'world.window-share-framerate 10))

(definition protected window-share-min-bitrate
  (world-setting 'world.window-share-min-bitrate 256))

(definition protected window-share-bitrate
  (world-setting 'world.window-share-bitrate 2048))

(definition protected window-share-codec
  (world-setting 'world.window-share-codec 'h264))

(definition protected window-share-keyframes
  (world-setting 'world.window-share-keyframes 2))


(definition protected entity-resolution
  {Dimension 1280 720})

(definition protected entity-framerate
  30)

(definition protected entity-bitrate
  4096)


(definition layouts
  '(;;overhead
    sidebar
    gallery))

(definition public video-layout
  (world-setting 'world.video-layout 'sidebar @currently-buggy-when-we-cycle 'overhead))

(definition (change-video-layout layout)
  (when (neq? layout video-layout)
    (set! video-layout layout)
    (update-self-output (current-video))
    (set-setting options-settings 'world.video-layout layout)))


(definition public video-mode
  'fit)

(definition public (set-video-mode mode)
  (let ((video (current-video)))
    (set! video-mode mode)
    (if (eq? video-layout 'focus)
        (let ((focused-output (effective-focused-output video)))
          (when focused-output
            (move-focused focused-output)))
      (layout-outputs video))))


(definition protected video-interface?
  #t)

(definition protected (set-video-interface? flag)
  (set! video-interface? flag))


(definition protected video-alpha
  (world-setting 'world.video-alpha #f @wait 0.6))


(definition protected speakers-xp?
  (world-setting 'world.speakers-xp? #f))


(definition protected slide-duration
  (world-setting 'world.slide-duration .2))


(definition protected default-circle-position
  (vertex 0. 4. 0.))

(definition protected circle-position
  (copy-vertex default-circle-position))

(definition protected (set-circle-position position)
  (vertex-copy! circle-position position))


(definition protected default-circle-lookat
  (make-standard-lookat))

(definition protected circle-lookat
  (copy-lookat default-circle-lookat))

(definition protected (set-circle-lookat lookat)
  (lookat-copy! circle-lookat lookat))


(definition protected default-circle-scale
  (vertex 1. 1. 1.))

(definition protected circle-scale
  (copy-vertex default-circle-scale))

(definition protected (set-circle-scale scale)
  (vertex-copy! circle-scale scale))


(definition protected (circle-lookat-matrix! res <matrix>)
  (make-lookat-matrix! res circle-lookat))


(definition protected circle-vista
  #f)

(definition protected (set-circle-vista vista)
  (set! circle-vista vista))


;;;
;;;; Kush
;;;


(definition public (kush-gauge width height rate motion)
  (/ (* width height rate motion 0.07) 1000.))


;;;
;;;; Codec
;;;


(class H264-Codec extends Codec
  
  
  (method override (buffer-keyframe? self buffer)
    (h264-buffer-keyframe? buffer)))


(register-codec (new H264-Codec 'h264 'video))


;;;
;;;; Camera Profile
;;;


(definition protected (maximum-camera-profile)
  (max-upload-profile))


;;;
;;;; Render Rate
;;;


(definition protected (effective-render-rate profile)
  (or (world-setting 'world.render-rate #f)
      (case profile
        ((low medium) 20.)
        ((standard) 30.)
        (else 40.))))


(definition protected (has-rendering-output?)
  (continuation-capture
    (lambda (return)
      (let ((video (current-video)))
        (table-iterate (get-outputs video)
          (lambda (id output)
            (unless (eq? (get-stream-state output) 'off)
              (continuation-return return #t)))))
      #f)))


(definition protected (update-render-rate)
  (update-render-rate-video (has-rendering-output?)))


(definition protected (update-render-rate-video rendering-output?)
  (let ((zone (current-zone+)))
    (let ((render-rate (effective-render-rate graphic-profile)))
      (let ((render-rate-inactive (cond (rendering-output? render-rate)
                                        ((and zone (playable? zone)) 15.)
                                        (else .75))))
        (setup-render-rate render-rate render-rate-inactive)))))


(update-render-rate-video #f)


;;;
;;;; Focused
;;;


(definition (adjust-focused bounds rect)
  (if (eq? video-mode 'fit)
      rect
    ;; fill mode
    (let ((ratio (fit-rects rect bounds 'fill)))
      (let ((new-width (fxround (* (cast <fl> (rect-width rect)) ratio)))
            (new-height (fxround (* (cast <fl> (rect-height rect)) ratio))))
        (let ((pos (center (new Dimension new-width new-height) (rect-size bounds))))
          (let ((h (get-h pos))
                (v (get-v pos)))
            (new Rect h v (+ h new-width) (+ v new-height))))))))


(definition (focused-rect bounds)
  (car (layout-tiles 1 bounds)))


;;;
;;;; Circle
;;;


(definition protected circle-max-fixed
  2)


(definition protected layout-circle-hook
  #f)

(definition protected (set-layout-circle-hook proc)
  (set! layout-circle-hook (and proc (new Hook proc))))


;;;
;;;; Video
;;;


(class World-Video extends Object
  
  
  (slot outputs         getter generate)
  (slot ordered-outputs getter generate)
  (slot focused-output  getter generate)
  (slot self-level      accessors generate)
  (slot self-output     accessors generate)
  (slot self-consumer   accessors generate)
  (slot render-hook     accessors generate)
  
  
  (method override (initialize self)
    (nextmethod self)
    (set! self.outputs (make-table test: equal?))
    (set! self.ordered-outputs '())
    (set! self.focused-output #f)
    (set! self.self-level #f)
    (set! self.self-output #f)
    (set! self.self-consumer #f)
    (set! self.render-hook #f))
  
  
  (method package (resize self)
    (for-each resize ordered-outputs)
    (when focused-output
      (resize focused-output))
    (layout-outputs self)
    (when (eq? video-layout 'focus)
      (let ((focused-output (effective-focused-output self)))
        (when focused-output
          (move-focused focused-output)))))
  
  
  ;;;
  ;;;; Outputs
  ;;;
  
  
  (method package (find-output self id)
    (table-ref outputs id #f))
  
  
  (method package (install-output self id output (rank: rank #f))
    (setup output)
    (table-set! outputs id output)
    (set! ordered-outputs (if rank
                              (insert! ordered-outputs rank output)
                            (append! ordered-outputs (list output))))
    (update-render-rate)
    (start output)
    (update-layouts self)
    (invalidate-state output)
    (when (not focused-output)
      (change-focused-output self output)))
  
  
  (method package (entity-output self id (position: position #f) (size: size #f) (codec: codec #f) (caps: caps #f))
    (or (table-ref outputs id #f)
        (let ((entity (registered-entity-id (current-zone) id)))
          ;; quick
          (and entity
               (let ((output (new Draw-Video-Sink entity
                                  resolution: entity-resolution
                                  framerate: entity-framerate
                                  bitrate: entity-bitrate
                                  codec: (or codec video-codec)
                                  caps: caps
                                  alpha-overlay: video-alpha)))
                 (setup output)
                 (table-set! outputs id output)
                 (play output)
                 output)))))
  
  
  (method package (player-output self id (stream-no: stream-no #f) (channel: channel #f) (player: player #f) (rank: rank #f) (position: position #f) (size: size #f) (level: level #f) (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f) (caps: caps #f) (process?: process? (boolean id)) (sync-audio?: sync-audio? #f) (root-view: root-view #f))
    (or (table-ref outputs id #f)
        ;; the or is a quick hack to test self video
        (let ((player (or player (registered-entity-id (current-zone) id))))
          (let ((output (case video-layout
                          ((overhead)
                           (new Overhead-Video-Sink
                             player
                             level: level
                             resolution: (or resolution video-resolution)
                             framerate: (or framerate video-framerate)
                             bitrate: (or bitrate video-bitrate)
                             codec: (or codec video-codec)
                             caps: caps
                             alpha-overlay: video-alpha))
                          (else
                           (new Circle-Video-Sink
                             id
                             stream-no
                             channel
                             player
                             position: position
                             size: size
                             level: level
                             resolution: (or resolution video-resolution)
                             framerate: (or framerate video-framerate)
                             bitrate: (or bitrate video-bitrate)
                             codec: (or codec video-codec)
                             caps: caps
                             alpha-overlay: video-alpha
                             process?: process?
                             sync-audio?: sync-audio?
                             root-view: root-view)))))
            (install-output self id output rank: rank)
            output))))
  
  
  (method package (channel-output self channel (rank: rank #f) (resolution: resolution #f) (sync-audio?: sync-audio? #f) (root-view: root-view #f) (process?: process? #t))
    (let ((no (get-no channel))
          (stream-no (get-no (get-stream channel)))
          (level (get-level channel))
          (resolution (or resolution (get-resolution channel)))
          (framerate (get-framerate channel))
          (bitrate (get-bitrate channel))
          (codec (get-codec channel))
          (caps (get-caps channel))
          (player (current-me)))
      (assert (or resolution (not process?))
        (player-output self no
          stream-no: stream-no
          channel: channel
          player: player
          rank: rank
          level: level
          resolution: resolution
          framerate: framerate
          bitrate: bitrate
          codec: codec
          caps: caps
          process?: process?
          sync-audio?: sync-audio?
          root-view: root-view))))
  
  
  (method package (circle-output self channel)
    (let ((no (get-no channel))
          (stream-no (get-no (get-stream channel)))
          (level (get-level channel))
          (resolution (get-resolution channel))
          (framerate (get-framerate channel))
          (bitrate (get-bitrate channel))
          (codec (get-codec channel))
          (caps (get-caps channel))
          (player (current-me)))
      (assert resolution
        (new Circle-Video-Sink
          player
          stream-no
          channel
          player
          level: level
          resolution: resolution
          framerate: framerate
          bitrate: bitrate
          codec: codec
          caps: caps))))
  
  
  (method package (visualizer-output self position size (codec: codec #f) (caps: caps #f))
    (let ((output (new Sheet-Video-Sink
                    #f
                    position: position
                    size: size
                    resolution: video-resolution
                    framerate: video-framerate
                    bitrate: video-bitrate
                    codec: codec
                    caps: caps
                    alpha-overlay: video-alpha
                    process?: #t
                    visualizer?: #t)))
      (play output)
      output))
  
  
  (method package (replace-output self output new-channel (sync-audio?: sync-audio? #f))
    (let ((id (get-id output)))
      (let ((rank (find-output-rank self output))
            (focused? (eq? output focused-output)))
        (close-output self id output layout?: #f)
        (let ((new-output (channel-output self new-channel rank: rank sync-audio?: sync-audio?)))
          (when focused?
            (change-focused-output self new-output))
          new-output))))
  
  
  (method package (close-output self id output (layout?: layout? #t))
    (table-clear outputs id)
    (set! ordered-outputs (remove! output ordered-outputs))
    (when (eq? output focused-output)
      (set! focused-output #f))
    (release output)
    (close output)
    (update-render-rate)
    (when layout?
      (update-layouts self)))
  
  
  (method package (outputs-order self)
    (collect (lambda (output)
               (and (is? output Circle-Video-Sink)
                    (get-stream-no output)))
             ordered-outputs))
  
  
  (method package (reorder-outputs self order)
    (let ((queue (new-queue))
          (remaining (copy ordered-outputs)))
      (for-each (lambda (stream-no)
                  (let ((output (find-if (lambda (output)
                                           (and (is? output Circle-Video-Sink)
                                                (equal? (get-stream-no output) stream-no)))
                                         ordered-outputs)))
                    (when output
                      (enqueue queue output)
                      (set! remaining (remove! output remaining)))))
                order)
      (let ((ordered (append! (queue-list queue) remaining)))
        (set! ordered-outputs ordered))))
  
  
  (method package (find-output-rank self output)
    (find ordered-outputs output))
  
  
  (method package (effective-focused-output self)
    (or focused-output
        (and (not-null? ordered-outputs)
             (car ordered-outputs))))
  
  
  (method package (change-focused-output self output)
    (let ((focus-layout? (eq? video-layout 'focus)))
      (when (and focus-layout? focused-output)
        (unfocus focused-output))
      (set! focused-output output)
      (when (and focus-layout? output)
        (focus output))))
  
  
  (method package (receive-video self output buffer dts pts duration flags timestamp-offset)
    (define (receive)
      (when (eq? (get-stream-state output) 'off)
        (set-stream-state output 'on))
      (write-video output buffer dts pts duration timestamp-offset))
    
    (unless (get-stream-disconnected? output)
      (cond ((get-wait-keyframe? output)
             (when (frame-keyframe? flags)
               (set-wait-keyframe? output #f)
               (receive)))
            (else
             (receive)))))
  
  
  (method package (receive-visualizer-video self output buffer dts pts duration flags)
    (when (eq? (get-stream-state output) 'off)
      (set-stream-state output 'on))
    (write-video output buffer dts pts duration #f))
  
  
  (method package (receive-processor-draw self id color-caps alpha-caps color alpha dts pts duration background slide?)
    (if (not color)
        (let ((output (find-output self id)))
          (when output
            (close-output self id output)))
      (let ((output (entity-output self id caps: color-caps)))
        ;; quicky
        (when output
          (set-background output background)
          (if (not slide?)
              (write-video output color dts pts duration #f alpha)
            (let ((texture (get-texture (cache-quad-texture (get-pane output)))))
              (with-slide output texture
                (lambda ()
                  (write-video output color dts pts duration #f alpha)))))))))
  
  
  (method package (render-outputs self)
    (unless (and render-hook
                 (render-hook self))
      (if (eq? video-layout 'focus)
          (let ((focused-output (effective-focused-output self)))
            (when focused-output
              (render focused-output)))
        (for-each render ordered-outputs))
      (when (and (eq? video-layout 'focus) video-interface?)
        (let ((focused-output (effective-focused-output self)))
          (for-each (lambda (output)
                      (unless (eq? output focused-output)
                        (render output)))
                    ordered-outputs)))))
  
  
  (method package (invalidate-outputs self)
    (for-each (lambda (output)
                (invalidate-texture (get-interface-pane output)))
              ordered-outputs))
  
  
  ;;;
  ;;;; Layout
  ;;;
  
  
  (method (cycle-layouts self)
    (case video-layout
      ((overhead)
       (sidebar-layout self))
      ((sidebar)
       (gallery-layout self))
      ((gallery)
       (circle-layout self))
      ((circle)
       (focus-layout self))
      ((focus)
       (gallery-layout self))))
  
  
  (method (update-layout self)
    (case video-layout
      ((overhead)
       (overhead-layout self))
      ((sidebar)
       (sidebar-layout self))
      ((gallery)
       (gallery-layout self))
      ((circle)
       (circle-layout self))
      ((focus)
       (focus-layout self))))
  
  
  (method package (update-layouts self)
    (update-self-output self)
    (update-layout self))
  
  
  (method (stop-renders self)
    (let ((zone (current-zone)))
      (for-each (lambda (player)
                  (let ((elem (get-camera-pane player)))
                    (when elem
                      (set-render? elem #f))))
                (get-players zone))))
  
  
  (method public (goto-layout self layout)
    (case layout
      ((circle)
       (circle-layout self))
      ((focus)
       (focus-layout self))
      ((gallery)
       (gallery-layout self))))
  
  
  (method package (overhead-layout self)
    (stop-renders self)
    (change-video-layout 'overhead)
    (layout-outputs self))
  
  
  (method package (sidebar-layout self)
    (stop-renders self)
    (change-video-layout 'sidebar)
    (layout-outputs self))
  
  
  (method package (gallery-layout self)
    (change-video-layout 'gallery)
    (layout-outputs self))
  
  
  (method package (layout-outputs self)
    (when (not-null? ordered-outputs)
      (let ((rectangles (layout self (length ordered-outputs))))
        (when rectangles
          (let ((reordered-outputs (if (and (eq? video-layout 'gallery) (memq? self-output ordered-outputs))
                                       (append (remove self-output ordered-outputs) (list self-output))
                                     ordered-outputs)))
            (for-each (lambda (output rect)
                        ;; quick hack to test self video
                        (let ((player (or (get-player output) (current-me))))
                          (let ((elem (get-camera-pane player)))
                            (if (not rect)
                                (when elem
                                  (set-render? elem #f))
                              (when elem
                                (set-render? elem #t))
                              (move output rect)
                              (update-panes output)))))
                      reordered-outputs
                      rectangles))))))
  
  
  (method package (layout self num-players)
    (let ((window (current-window)))
      (let ((bounds (get-content-rect window)))
        (let ((l (get-left bounds))
              (t (get-top bounds))
              (r (get-right bounds))
              (b (get-bottom bounds)))
          (case video-layout
            ((sidebar)
             (layout-tiles num-players (new Rect 10 70 210 (- b 100))))
            ((gallery)
             (if (= num-players 1)
                 (let ((rect (car (layout-tiles 2 bounds))))
                   (let ((size (rect-size rect)))
                     (let ((pos (center size (rect-size bounds))))
                       (list (position/size->rect pos size)))))
               (reverse (layout-tiles num-players bounds))))
            (else
             #f))))))
  
  
  (method package (circle-layout self)
    (change-video-layout 'circle)
    (update-circle-layout self))
  
  
  (method package (focus-layout self)
    (change-video-layout 'focus)
    (update-circle-layout self)
    (let ((focused-output (effective-focused-output self)))
      (when focused-output
        (focus focused-output))))
  
  
  (method (update-circle-layout self)
    (let ((count (length ordered-outputs)))
      (assert layout-circle-hook
        (with-safe-hook layout-circle-hook
          (lambda (procedure)
            (let ((placements (procedure ordered-outputs)))
              (for-each (lambda (output placement)
                          (bind (elevation radius rotation scale adjustment . rest) placement
                            (bind-optionals ((kind #f)) rest
                              (set-elevation output elevation)
                              (set-radius output radius)
                              (set-rotation output rotation)
                              (set-scale output scale)
                              (set-adjustment output adjustment)
                              (set-kind output kind)
                              (update-matrices output count)
                              (update-panes output))))
                        ordered-outputs
                        placements)))))))
  
  
  (method package (update-interface-matrices self)
    (let ((count (length ordered-outputs)))
      (for-each (lambda (output)
                  (update-interface-matrix output count))
                ordered-outputs)))
  
  
  ;;;
  ;;;; Self
  ;;;


  (method package (determine-self-level self new?)
    (let ((level (active-graphic-level)))
      (if (eq? video-layout 'focus)
          (focused-level level)
        (let ((count (+ (length ordered-outputs) (if new? 1 0))))
          (tiled-level level count)))))
  
  
  (method package (update-self-output self)
    (let ((client (current-client)))
      (let ((camera-stream (get-live-stream client))
            (camera-channel (get-camera-channel client)))
        (when (and camera-channel (on? camera-channel))
          (let ((camera-pipeline (get-pipeline camera-channel)))
            (let ((elements (get-elements camera-pipeline))
                  (new-level (determine-self-level self #f)))
              (define (find-actual-consumer)
                (find-if (lambda (element)
                           (and (is? element Camera-Self-Consumer)
                                (get-processing? element)))
                         elements))
              
              (define (find-new-consumer)
                (find-if (lambda (element)
                           (and (is? element Camera-Self-Consumer)
                                (= (get-level (get-profile element)) new-level)))
                         elements))
              
              (define (update-probe consumer processing?)
                (let ((profile (get-profile consumer))
                      (probe (get-probe consumer)))
                  (let ((name (get-name profile))
                        (framerate (get-framerate profile)))
                    (let ((rate (if processing? framerate 0)))
                      (gst_rate_probe_set_rate probe rate)))))
              
              (define (with-self-priority thunk)
                (let ((thread (current-thread)))
                  (let ((preserved-priority (thread-base-priority thread)))
                    (thread-base-priority-set! thread self-priority)
                    (thunk)
                    (thread-base-priority-set! thread preserved-priority))))
              
              (when (or (not self-level) (/= new-level self-level))
                (let ((actual-consumer (find-actual-consumer))
                      (new-consumer (find-new-consumer)))
                  (when (neq? new-consumer actual-consumer)
                    (with-self-priority
                      (lambda ()
                        (when on?
                          (update-probe new-consumer #t))
                        (let ((rank (and self-output (find-output-rank self self-output))))
                          (let ((new-output (create-self-output new-consumer)))
                            (set-video-output camera-stream new-output)
                            (set-output new-consumer new-output)
                            (when on?
                              ;; display one new buffer before stopping the
                              ;; actual consumer in order to remove flicker
                              ;; note that the current thread needs to be higher
                              ;; priority than the camera task else this will hang
                              (gst_app_sink_process_one_buffer new-consumer)
                              (update-probe actual-consumer #f))
                            (set-processing? actual-consumer #f)
                            (when self-output
                              (close-self-output self-consumer))
                            (set-processing? new-consumer #t)
                            (install-self-output new-consumer rank: rank)
                            (set! self-level new-level)
                            (update-layout self)))))))))))))))


;;;
;;;; Video-Src
;;;


(class Video-Src extends Stream-Src
  
  
  (slot task initialize #f accessors generate)
  
  
  (method (start-listeners self)
    (for-each start-listener sinks))
  
  
  (method (stop-listeners self)
    (for-each stop-listener sinks))
  
  
  (method package virtual (change-bitrate self consumer modifier)
    )
  
  
  (method public virtual abstract (task-priority self)
    )
  
  
  (method (task-start self name)
    (let ((task (new Task name (~ run-video self) priority: (task-priority self) stack: stack-size)))
      (start-listeners self)
      (start-task task)
      (set! self.task task)))
  
  
  (method (task-stop self)
    (stop-listeners self)
    (stop-task task)
    (set! task #f))
  
  
  (method protected virtual (run-video self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (process self task exit)
          (iter))))))


;;;
;;;; Video-Frame-Src
;;;


(class Video-Frame-Src extends Video-Src
  
  
  (method override (process self task exit)
    (for-each (lambda (consumer)
                (when (get-processing? consumer)
                  (gst_app_sink_process task exit consumer)))
              sinks)))


;;;
;;;; Video-Buffer-Src
;;;


(class Video-Buffer-Src extends Video-Src
  
  
  (method override (process self task exit)
    (for-each (lambda (consumer)
                (when (get-processing? consumer)
                  (gst_app_sink_process_buffers task exit consumer)))
              sinks)))


;;;
;;;; Camera
;;;


;; patch around a gstreamer bug in 10.16 where not
;; specifying the framerate on my mac ends up using
;; the default of 10000000/333333 and monterey then
;; complains the framerate is higher than supported
(cond-expand
  (mac
   (definition patch-version-10.16-framerate?
     (let ((version (platformOperatingSystemVersion)))
       (or (> (get-major version) 10)
           (>= (get-minor version) 16)))))
  (else))


(class Camera-Provider extends Object
  
  
  (slot name        getter generate)
  (slot identifier  getter generate)
  (slot resolutions getter generate)
  
  
  (method override (initialize self name identifier resolutions)
    (nextmethod self)
    (set! self.name name)
    (set! self.identifier identifier)
    (set! self.resolutions resolutions))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name)))))


(class Camera-Resolution extends Object
  
  
  (slot resolution getter generate)
  (slot framerate  getter generate)
  
  
  (method override (initialize self resolution framerate)
    (nextmethod self)
    (set! self.resolution resolution)
    (set! self.framerate framerate))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" resolution)))))


(definition public (has-camera?)
  (not-null? (camera-providers)))


(definition protected (camera-providers)
  (define (camera-device-identifier device)
    (with-unref ((element (gst_device_create_element device)))
      (cond-expand
        (mac (g_object_get_int element "device-index"))
        (windows (g_object_get_string element "device-path"))
        (else #f))))
  
  (define (camera-device-resolutions device)
    (let ((caps (gst_device_get_caps device)))
      (prog1 (let ((all '()))
               (loop (for i from 0 below (gst_caps_get_size caps))
                     (let ((struc (gst_caps_get_structure caps i))
                           (features (gst_caps_get_features caps i)))
                       (when (and (equal? (gst_structure_get_name struc) "video/x-raw")
                                  (gst_caps_features_is_system_memory features))
                         (let ((width (gst_structure_get_int struc "width"))
                               (height (gst_structure_get_int struc "height")))
                           (let ((resolution (new Dimension width height)))
                             (when (not (member? resolution all test: nu=?))
                               (let ((value (gst_structure_get_value struc "framerate")))
                                 ;; patch around a problem that only occurs on monterey so lets
                                 ;; not take any chances and risk impacting the other platforms...
                                 ;; gstreamer because of the approximation it does in converting a
                                 ;; double to a fraction ends up passing a value sligthly greater
                                 ;; than the range max which the mac rejects
                                 ;; note that the problem might also occur with framerate being a
                                 ;; list of ranges, but specifying an explicit framerate is so
                                 ;; brittle lets only fix it if it actually happens
                                 (define (determine-framerate value)
                                   (cond-expand
                                     (mac (if patch-version-10.16-framerate?
                                              (let ((type (g_value_type value)))
                                                (if (= type (GST_TYPE_FRACTION_RANGE))
                                                    (let ((min (fraction->bignum (gst_value_get_fraction_range_min value)))
                                                          (max (fraction->bignum (gst_value_get_fraction_range_max value))))
                                                      (let ((min-real (exact->inexact min))
                                                            (max-real (exact->inexact max)))
                                                        (let ((round (round max-real))
                                                              (floor (floor max-real)))
                                                          (if (and (= floor round) ;; close to floor
                                                                   (between? floor min-real max-real)) ;; inside range
                                                              (format "{a}/1" (flonum->fixnum floor))
                                                            #f))))
                                                #f))
                                            #f))
                                     (else #f)))
                                 
                                 (define (fraction->bignum fraction)
                                   (/ (gst_value_get_fraction_numerator fraction)
                                      (gst_value_get_fraction_denominator fraction)))
                                 
                                 (let ((framerate (determine-framerate value)))
                                   (set! all (cons (new Camera-Resolution resolution framerate) all))))))))))
               all)
        (gst_caps_unref caps))))
  
  (with-camera-devices
    (lambda (devices)
      (map (lambda (device)
             (let ((name (gst_device_get_display_name device))
                   (identifier (camera-device-identifier device))
                   (resolutions (camera-device-resolutions device)))
               (new Camera-Provider name identifier resolutions)))
           devices))))


(definition protected (with-camera-devices proc)
  (define (camera-devices)
    (define (collect-devices)
      (with-unref ((monitor (gst_device_monitor_new)))
        (let ((caps (gst_caps_new_empty_simple "video/x-raw")))
          (gst_device_monitor_add_filter monitor "Video/Source" caps)
          (gst_caps_unref caps))
        (let ((queue (new-queue)))
          (let (loop (devices (gst_device_monitor_get_devices monitor)))
            (if (not devices)
                (begin
                  (g_list_free devices)
                  (queue-list queue))
              (let ((device (gst_device_monitor_device_list_data devices)))
                (if (equal? (gst_device_get_type_name device) camerasrc)
                    (enqueue queue device)
                  (gst_device_unref_hack device)))
              (loop (gst_device_monitor_device_list_next devices)))))))
    
    ;; work around a gstreamer bug where devices is sometimes empty
    ;; this is clearly a bug in gstreamer as gst-device-monitor will
    ;; also sometimes fail to find the webcam on windows
    (let (loop (n 0))
      (if (>= n 100)
          '()
        (let ((devices (collect-devices)))
          (if (not-null? devices)
              devices
            (sleep .01)
            (loop (+ n 1)))))))
  
  (let ((devices (camera-devices)))
    (prog1 (proc devices)
      (gst_devices_unref devices))))


;;;
;;;; Camera-Video-Src
;;;


(definition protected camera-ksvideosrc?
  (world-setting 'world.camera-ksvideosrc? #f))

(definition protected (set-camera-ksvideosrc? ksvideosrc?)
  (set! camera-ksvideosrc? ksvideosrc?)
  (set! camerasrc (determine-camerasrc)))


(definition protected (determine-camerasrc)
  (cond-expand
    (mac "avfvideosrc")
    (windows (or (custom-video-src) (if camera-ksvideosrc? "ksvideosrc" "mfvideosrc")))
    (else "v4l2src")))

(definition protected camerasrc
  (determine-camerasrc))


(definition protected (effective-camera-provider providers)
  (let ((name (world-setting 'world.camera-name #f)))
    (if (not name)
        (car providers)
      (or (find providers name key: get-name test: equal? return: 'item)
          (car providers)))))


(definition protected (effective-camera-information target-resolution target-framerate)
  (define (sort-resolutions resolutions)
    (let ((target-area (get-area target-resolution)))
      (define (effective-area resolution)
        (let ((resolution (get-resolution resolution)))
          (let ((area (get-area resolution))
                (scale (fit-dimensions resolution target-resolution 'fit)))
            (* area scale))))
      
      (define (area-distance resolution)
        (let ((area (effective-area resolution)))
          (distance area target-area)))
      
      (sort < resolutions key: area-distance)))
  
  (let ((providers (camera-providers)))
    (let ((provider (effective-camera-provider providers)))
      (let ((resolution (car (sort-resolutions (get-resolutions provider)))))
        (define (effective-resolution)
          (get-resolution resolution))
        
        (define (effective-framerate)
          ;; patch see camera-providers for details
          (let ((framerate (get-framerate resolution)))
            (if framerate
                (format ", framerate={a}" framerate)
              "")))
        
        (values (get-name provider)
                (get-identifier provider)
                (effective-resolution)
                (effective-framerate))))))


(definition protected (camera-identifier-update src identifier)
  (cond-expand
    (mac (g_object_set_int src "device-index" (or identifier -1)))
    (windows (g_object_set_string src "device-path" (or identifier #f)))
    (else)))


(definition package (write-camera-name name)
  (set-setting options-settings 'world.camera-name name)
  (save-content options-settings))


(class Camera-Video-Src extends Video-Buffer-Src
  
  
  (slot resolution initialize #f accessors generate)
  (slot framerate  initialize #f accessors generate)
  (slot pipeline   initialize #f accessors generate)
  (slot probe      initialize #f accessors generate)
  
  
  (method override (initialize self (resolution: resolution #f) (framerate: framerate #f))
    (nextmethod self)
    (set! self.resolution resolution)
    (set! self.framerate framerate))
  
  
  (method override (require-consumer-caps/resolution self consumer)
    (let ((profile (get-profile consumer)))
      (let ((name (get-name profile)))
        (let ((sinkname (tie "sink{name}")))
          (with-unref ((appsink (gst_bin_get_by_name pipeline sinkname)))
            (wait-caps-string/resolution appsink))))))
  
  
  (method package (determine-caps self)
    (declare (proper-tail-calls))
    (with-unref ((src (gst_bin_get_by_name pipeline "src")))
      (with-unref ((pad (gst_element_get_static_pad src "src")))
        (let (loop (n 0))
          (if (> n 1000)
              #f
            (if (not (gst_pad_has_current_caps pad))
                (begin
                  (sleep .01)
                  (loop (+ n 1)))
              (let ((caps (gst_pad_get_current_caps pad)))
                (let ((caps-string (gst_caps_to_string caps)))
                  (gst_caps_unref caps)
                  caps-string))))))))
  
  
  (method package (determine-bitrate self)
    (let ((bitrate 0.))
      (for-each (lambda (consumer)
                  (when (and (is? consumer Camera-Video-Consumer)
                             (get-processing? consumer))
                    (let ((profile (get-profile consumer)))
                      (increase! bitrate (effective-bitrate consumer (get-min-bitrate profile) (get-bitrate profile))))))
                sinks)
      bitrate))
  
  
  (method override (change-bitrate self consumer modifier)
    (set-bitrate-modifier consumer modifier)
    (let ((profile (get-profile consumer)))
      (let ((name (get-name profile))
            (min-bitrate (get-min-bitrate profile))
            (bitrate (get-bitrate profile)))
        (let ((encname (tie "enc{name}")))
          (with-unref ((enc (gst_bin_get_by_name pipeline encname)))
            (g_object_set_uint enc "bitrate" (fxround (effective-bitrate consumer min-bitrate bitrate))))))))
  
  
  @not-used
  (method package (force-keyframes self)
    (for-each (lambda (consumer)
                (when (is? consumer Camera-Video-Consumer)
                  (let ((profile (get-profile consumer)))
                    (let ((name (get-name profile)))
                      (let ((sinkname (tie "sink{name}")))
                        (with-unref ((sink (gst_bin_get_by_name pipeline sinkname)))
                          (with-unref ((pad (gst_element_get_static_pad sink "sink")))
                            (gst_pad_push_force_key_unit pad))))))))
              sinks))
  
  
  (method package (update-identifier self identifier)
    (define (reset-probes)
      (gst_rate_probe_reset probe)
      (for-each (lambda (consumer)
                  (if (eq? (get-caps consumer) 'self)
                      (gst_rate_probe_reset (get-probe consumer))
                    (gst_rate_probe_reset (get-probe consumer))))
                sinks))
    
    (gst_element_set_state pipeline GST_STATE_NULL)
    (reset-probes)
    (with-unref ((src (gst_bin_get_by_name pipeline "src")))
      (camera-identifier-update src identifier))
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((max-resolution resolution)
          (max-framerate framerate))
      (receive (camera-name camera-identifier camera-resolution camera-framerate) (effective-camera-information resolution framerate)
        (let ((camera-width (get-width camera-resolution))
              (camera-height (get-height camera-resolution))
              (max-width (get-width max-resolution))
              (max-height (get-height max-resolution))
              (scale-camera? (nu/=? max-resolution camera-resolution)))
          (let ((pipeline (apply gst-pipeline
                                 (gst-element camerasrc
                                              do-timestamp: "true"
                                              name: "src")
                                 (tie "video/x-raw, width={camera-width}, height={camera-height}, pixel-aspect-ratio=(fraction)1/1{camera-framerate}")
                                 "queue name=queue"
                                 ;; for some reason doing the convert before the scale ends up taking less cpu
                                 ;; and as a side effect it ensures we always use the same format for the scale
                                 "videoconvert name=convert"
                                 (tie "video/x-raw, format=I420, width={camera-width}, height={camera-height}, pixel-aspect-ratio=(fraction)1/1")
                                 (and scale-camera?
                                      "videoscale method=sinc sharpness=1.15 name=downscale")
                                 (and scale-camera?
                                      (tie "video/x-raw, width={max-width}, height={max-height}, pixel-aspect-ratio=(fraction)1/1"))
                                 ;; hack around facetime camera having a noticeable red-shift
                                 (and (equal? camera-name "FaceTime HD Camera")
                                      "videobalance name=balance hue=-.02 saturation=.8")
                                 "tee name=tee"
                                 (append
                                   (collect (lambda (consumer)
                                              (and (is? consumer Camera-Self-Consumable)
                                                   (let ((profile (get-profile consumer)))
                                                     (let ((name (get-name profile))
                                                           (resolution (get-resolution profile)))
                                                       (let ((width (get-width resolution))
                                                             (height (get-height resolution))
                                                             (scale? (nu/=? resolution max-resolution)))
                                                         (list
                                                           "tee^."
                                                           (tie "queue name=queueself{name}")
                                                           (and scale?
                                                                (tie "videoscale method=sinc sharpness=1.15 name=scaleself{name}"))
                                                           (and scale?
                                                                (tie "video/x-raw, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1"))
                                                           (tie "videoconvert name=convertself{name}")
                                                           (tie "video/x-raw, format=BGRA, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                                           (tie "appsink sync=false async=false name=sinkself{name}")))))))
                                            sinks)
                                   (collect (lambda (consumer)
                                              (and (is? consumer Camera-Video-Consumable)
                                                   (let ((profile (get-profile consumer))
                                                         @hardware-encoding-needs-a-lot-more-work
                                                         (hardware? (get-hardware? consumer)))
                                                     (let ((name (get-name profile))
                                                           (level (get-level profile))
                                                           (resolution (get-resolution profile))
                                                           (framerate (get-framerate profile))
                                                           (min-bitrate (get-min-bitrate profile))
                                                           (bitrate (get-bitrate profile))
                                                           (codec (get-codec profile)))
                                                       (let ((width (get-width resolution))
                                                             (height (get-height resolution))
                                                             (scale? (nu/=? resolution max-resolution))
                                                             (effective-bitrate (fxround (effective-bitrate consumer min-bitrate bitrate))))
                                                         (list
                                                           "tee^."
                                                           (tie "queue name=queue{name}")
                                                           (and scale?
                                                                (tie "videoscale method=sinc sharpness=1.15 name=scale{name}"))
                                                           (and scale?
                                                                (tie "video/x-raw, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1"))
                                                           (and (eq? codec 'h264)
                                                                (if #f ;; hardware?
                                                                    #f
                                                                    @hardware-encoding-needs-a-lot-more-work
                                                                    (let ((key-int-max (and camera-keyframes (fxround (* (cast <fl> framerate) camera-keyframes)))))
                                                                      (gst-element "vtenc_h264"
                                                                                   allow-frame-reordering: "false"
                                                                                   bitrate: effective-bitrate
                                                                                   max-keyframe-interval: key-int-max
                                                                                   realtime: "true"
                                                                                   name: (tie "enc{name}")))
                                                                  (let ((key-int-max (and camera-keyframes (fxround (* (cast <fl> framerate) camera-keyframes))))
                                                                        (tune "zerolatency")
                                                                        (speed-preset "superfast")
                                                                        (threads (expt 2 (max 0 (- level 1)))))
                                                                    (gst-element "x264enc"
                                                                                 key-int-max: key-int-max
                                                                                 bitrate: effective-bitrate
                                                                                 tune: tune
                                                                                 speed-preset: speed-preset
                                                                                 threads: threads
                                                                                 name: (tie "enc{name}")))))
                                                           "h264parse"
                                                           (tie "appsink sync=false async=false name=sink{name}")))))))
                                            sinks)))))
            (gst_object_set_name pipeline "video.camera")
            (with-unref ((src (gst_bin_get_by_name pipeline "src")))
              (write-camera-name camera-name)
              (camera-identifier-update src camera-identifier)
              (with-unref ((pad (gst_element_get_static_pad src "src")))
                (set! probe (gst_pad_add_rate_probe pad max-framerate #t))))
            (for-each (lambda (consumer)
                        (if (eq? (get-caps consumer) 'self)
                            (let ((profile (get-profile consumer)))
                              (let ((name (get-name profile))
                                    (profile (get-profile consumer)))
                                (let ((framerate (get-framerate profile)))
                                  (let ((listener (open-stream-listener (format "cameraself{a}" name))))
                                    (with-unref ((appsink (gst_bin_get_by_name pipeline (format "sinkself{a}" name))))
                                      (gst_app_sink_connect_signals appsink listener)
                                      (setup-consumer consumer listener appsink)
                                      (with-unref ((queueself (gst_bin_get_by_name pipeline (tie "queueself{name}"))))
                                        (with-unref ((pad (gst_element_get_static_pad queueself "sink")))
                                          (let ((rate (if (get-processing? consumer) framerate 0)))
                                            (set-probe consumer (gst_pad_add_rate_probe pad rate #f))))))))))
                          (let ((profile (get-profile consumer)))
                            (let ((name (get-name profile))
                                  (framerate (get-framerate profile)))
                              (let ((listener (open-stream-listener (format "camera{a}" name))))
                                (with-unref ((appsink (gst_bin_get_by_name pipeline (format "sink{a}" name))))
                                  (gst_app_sink_connect_signals appsink listener)
                                  (setup-consumer consumer listener appsink)
                                  (with-unref ((queue (gst_bin_get_by_name pipeline (tie "queue{name}"))))
                                    (with-unref ((pad (gst_element_get_static_pad queue "sink")))
                                      (let ((rate (if (get-processing? consumer) framerate 0)))
                                        (set-probe consumer (gst_pad_add_rate_probe pad rate #f)))))))))))
                      sinks)
            (set! self.pipeline pipeline)
            (gst_element_set_state pipeline GST_STATE_READY))))))
  
  
  (method override (task-priority self)
    camera-priority)
  
  
  (method override (start-element self)
    (nextmethod self)
    (for-each (lambda (consumer)
                (start-processing consumer camera-priority))
              sinks)
    @live-sources-should-not-go-to-pause
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  @live-sources-should-not-go-to-pause
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (for-each (lambda (consumer)
                (stop-processing consumer))
              sinks)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_bin_release pipeline)
    (set! pipeline #f)
    (when probe
      (gst_pad_probe_free probe)
      (set! probe #f))
    (release-consumers self))
  
  
  ;; the following 2 methods are never called at the moment
  ;; as send-state only sends waiting state for images, and
  ;; also resetting the camera is probably a really bad idea
  ;; especially as the number of people in a circle grows
  
  @not-used
  (method override (resettable? self)
    #t)
  
  
  @not-used
  (method override (reset-media self)
    (force-keyframes self)))


;;;
;;;; Camera-Video-Consumer
;;;


(interface Camera-Video-Consumable
  
  
  (method public virtual abstract (get-profile self))
  (method public virtual abstract (set-probe self value)))


(class Camera-Video-Consumer extends Stream-Buffer-Consumer implements Camera-Video-Consumable
  
  
  (slot channel-no getter generate)
  (slot profile    getter explicit)
  (slot hardware?  getter generate)
  (slot probe      getter generate setter explicit)
  (slot rate       accessors generate)
  
  
  (method override (initialize self . rest)
    (bind-keywords ((channel-no #f) (profile #f) . others) rest
      (apply nextmethod self others)
      (set! self.channel-no channel-no)
      (set! self.profile profile)
      (set! self.hardware? #f @hardware-encoding-needs-a-lot-more-work
                              (and video-hardware?
                                ;; vtenc_h264 only accepts 640x360 and up
                                (>= (get-level profile) 2)))
      (set! self.probe #f)
      (set! self.rate (new Rate))))
  
  
  (method override (destroy self)
    (when probe
      (gst_pad_probe_free probe)
      (set! probe #f))
    (nextmethod self))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" (get-name profile) state))))
  
  
  (method override (get-profile self)
    profile)
  
  
  (method override (set-probe self value)
    (set! probe value))
  
  
  (method override (task-name self)
    (list 'camera (get-name profile)))


  (method override (consume-buffer self buffer)
    (site camera
      (let ((dts (gst_buffer_get_dts buffer))
            (pts (gst_buffer_get_pts buffer))
            (duration (gst_buffer_get_duration buffer))
            (keyframe? (gst_buffer_is_keyframe buffer)))
        (let ((flags (frame-flags keyframe? voice?)))
          (let ((client (current-client)))
            (send-client-media client channel-no buffer dts pts duration flags)
            @convert-to-buffer
            (let ((udp-client (get-udp-client client)))
              (when udp-client
                (let ((channel (find-send-channel udp-client channel-no)))
                  (when channel
                    (let ((recorder (get-recorder channel)))
                      (when recorder
                        (world.recording:record-media recorder buffer dts pts duration flags))))))))))
      (update rate))))


;;;
;;;; Camera-Self-Consumer
;;;


(interface Camera-Self-Consumable
  
  
  (method public virtual abstract (get-profile self))
  (method public virtual abstract (set-probe self value)))


(class Camera-Self-Consumer extends Stream-Buffer-Consumer implements Camera-Self-Consumable
  
  
  (slot stream-no initialize #f getter generate)
  (slot profile   initialize #f getter explicit)
  (slot output    initialize #f accessors generate)
  (slot probe     initialize #f getter generate setter explicit)
  
  
  (method override (initialize self . rest)
    (bind-keywords ((stream-no #f) (profile #f) . others) rest
      (apply nextmethod self others)
      (set! self.stream-no stream-no)
      (set! self.profile profile)
      (when processing?
        (open-self-output self))))
  
  
  (method override (destroy self)
    (close-self-output self)
    (when probe
      (gst_pad_probe_free probe)
      (set! probe #f))
    (nextmethod self))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" (get-name profile) state))))
  
  
  (method override (get-profile self)
    profile)
  
  
  (method override (set-probe self value)
    (set! probe value))
  
  
  (method override (task-name self)
    (list 'camera-self (get-name profile)))
  
  
  (method protected (open-self-output self)
    (unless output
      (set! output (create-self-output self))
      (install-self-output self)))
  
  
  (method protected (install-self-output self (rank: rank #f))
    (let ((video (current-video)))
      (install-output video (get-id output) output rank: rank)
      (set-self-level video (get-level profile))
      (set-self-output video output)
      (set-self-consumer video self)))
  
  
  (method protected (create-self-output self)
    (let ((me (current-me)))
      (let ((level (get-level profile))
            (resolution (get-resolution profile))
            (framerate (get-framerate profile))
            (bitrate (get-bitrate profile))
            (codec (get-codec profile)))
        (let ((id (list 'self level))
              (channel #f)
              (player me))
          (new Circle-Video-Sink
            id
            stream-no
            channel
            player
            level: level
            resolution: resolution
            framerate: framerate
            bitrate: bitrate
            codec: codec
            alpha-overlay: video-alpha
            flipped?: #t
            process?: #f)))))
  
  
  (method protected (close-self-output self)
    (let ((video (current-video)))
      (when output
        (close-output video (get-id output) output layout?: #f)
        (set-stream-state output 'off)
        (set-self-level video #f)
        (set-self-output video #f)
        (set-self-consumer video #f)
        (set! output #f))))
  
  
  (method override (consume-buffer self buffer)
    (site self
      (if (not output)
          (gst_buffer_unref buffer)
        (when (eq? (get-stream-state output) 'off)
          (set-stream-state output 'on))
        (set-stream-state output 'drawn)
        (draw-buffer output buffer))))
  
  
  (method override (consume-eos self)
    (when output
      (set-stream-state output 'off))))


;;;
;;;; Screen-Video-Src
;;;


(class Screen-Video-Src extends Video-Buffer-Src
  
  
  (slot resolution  initialize #f accessors generate)
  (slot framerate   initialize #f accessors generate)
  (slot min-bitrate initialize #f accessors generate)
  (slot bitrate     initialize #f accessors generate)
  (slot codec       initialize #f accessors generate)
  (slot pipeline    initialize #f accessors generate)
  
  
  (method override (initialize self (resolution: resolution #f) (framerate: framerate #f) (min-bitrate: min-bitrate #f) (bitrate: bitrate #f) (codec: codec #f))
    (nextmethod self)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.min-bitrate min-bitrate)
    (set! self.bitrate bitrate)
    (set! self.codec codec))
  
  
  (method override (require-caps/resolution self)
    (with-unref ((appsink (gst_bin_get_by_name pipeline "sink")))
      (wait-caps-string/resolution appsink)))
  
  
  (method override (change-bitrate self consumer modifier)
    (set-bitrate-modifier consumer modifier)
    (with-unref ((enc (gst_bin_get_by_name pipeline "enc")))
      (g_object_set_uint enc "bitrate" (fxround (effective-bitrate consumer min-bitrate bitrate)))))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((listener (open-stream-listener "screen"))
          (consumer (find-consumer self #f)))
      (let ((pipeline (gst-pipeline (cond-expand
                                      (mac "avfvideosrc capture-screen=true capture-screen-cursor=true capture-screen-mouse-clicks=true name=src")
                                      (windows "dx9screencapsrc name=src")
                                      (else "v4l2src name=src"))
                                    (tie "videorate max-rate={framerate}")
                                    ;; first step just on mac
                                    (cond-expand
                                      (mac (tie "video/x-raw, format=BGRA"))
                                      (else #f))
                                    "videoconvert"
                                    (and (eq? codec 'h264)
                                         (let ((key-int-max (and screen-share-keyframes (fxround (* (cast <fl> framerate) screen-share-keyframes))))
                                               (bitrate (fxround (effective-bitrate consumer min-bitrate bitrate)))
                                               (tune "zerolatency")
                                               (speed-preset "superfast"))
                                           (gst-element "x264enc"
                                                        key-int-max: key-int-max
                                                        bitrate: bitrate
                                                        tune: tune
                                                        speed-preset: speed-preset
                                                        name: "enc")))
                                    "appsink name=sink")))
        (gst_object_set_name pipeline "video.screen")
        (with-unref ((appsink (gst_bin_get_by_name pipeline "sink")))
          (gst_app_sink_connect_signals appsink listener)
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.pipeline pipeline)
          (setup-consumer consumer listener appsink)))))
  
  
  (method override (task-priority self)
    screen-priority)
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'screen-share)
    @live-sources-should-not-go-to-pause
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  @live-sources-should-not-go-to-pause
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_bin_release pipeline)
    (set! pipeline #f)
    (release-consumers self)))


;;;
;;;; Screen-Video-Consumer
;;;


(class Screen-Video-Consumer extends Stream-Buffer-Consumer
  
  
  (slot channel-no getter generate)
  
  
  (method override (initialize self channel-no . rest)
    (apply nextmethod self rest)
    (set! self.channel-no channel-no))


  (method override (consume-buffer self buffer)
    (site screen
      (let ((dts (gst_buffer_get_dts buffer))
            (pts (gst_buffer_get_pts buffer))
            (duration (gst_buffer_get_duration buffer))
            (keyframe? (gst_buffer_is_keyframe buffer)))
        (let ((flags (frame-flags keyframe? voice?)))
          (let ((client (current-client)))
            (send-client-media client channel-no buffer dts pts duration flags)
            @convert-to-buffer
            (let ((udp-client (get-udp-client client)))
              (when udp-client
                (let ((channel (find-send-channel udp-client channel-no)))
                  (when channel
                    (let ((recorder (get-recorder channel)))
                      (when recorder
                        (world.recording:record-media recorder buffer dts pts duration flags)))))))))))))


;;;
;;;; Window-Video-Src
;;;


(class Window-Video-Src extends Video-Buffer-Src
  
  
  (slot resolution   initialize #f accessors generate)
  (slot framerate    initialize #f accessors generate)
  (slot min-bitrate  initialize #f accessors generate)
  (slot bitrate      initialize #f accessors generate)
  (slot codec        initialize #f accessors generate)
  (slot pipeline     initialize #f accessors generate)
  (slot capture-task initialize #f accessors generate)
  
  
  (method override (initialize self (resolution: resolution #f) (framerate: framerate #f) (min-bitrate: min-bitrate #f) (bitrate: bitrate #f) (codec: codec #f))
    (nextmethod self)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.min-bitrate min-bitrate)
    (set! self.bitrate bitrate)
    (set! self.codec codec))
  
  
  (method override (require-caps/resolution self)
    (with-unref ((appsink (gst_bin_get_by_name pipeline "sink")))
      (wait-caps-string/resolution appsink)))
  
  
  (method override (change-bitrate self consumer modifier)
    (set-bitrate-modifier consumer modifier)
    (with-unref ((enc (gst_bin_get_by_name pipeline "enc")))
      (g_object_set_uint enc "bitrate" (fxround (effective-bitrate consumer min-bitrate bitrate)))))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (get-width resolution))
          (height (get-height resolution))
          (listener (open-stream-listener "window"))
          (consumer (find-consumer self #f)))
      (let ((pipeline (gst-pipeline "appsrc name=src"
                                    "videoflip method=vertical-flip"
                                    "videoconvert"
                                    (and (eq? codec 'h264)
                                         (let ((key-int-max (and window-share-keyframes (fxround (* (cast <fl> framerate) window-share-keyframes))))
                                               (bitrate (fxround (effective-bitrate consumer min-bitrate bitrate)))
                                               (tune "zerolatency")
                                               (speed-preset "superfast"))
                                           (gst-element "x264enc"
                                                        key-int-max: key-int-max
                                                        bitrate: bitrate
                                                        tune: tune
                                                        speed-preset: speed-preset
                                                        name: "enc")))
                                    "appsink sync=false name=sink")))
        (gst_object_set_name pipeline "video.window")
        (with-unref ((appsrc (gst_bin_get_by_name pipeline "src"))
                     (appsink (gst_bin_get_by_name pipeline "sink")))
          (gst_app_sink_connect_signals appsink listener)
          (gst-setup-video-source appsrc "video/x-raw" "BGRA" width height framerate)
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.pipeline pipeline)
          (setup-consumer consumer listener appsink)))))
  
  
  (method override (task-priority self)
    window-priority)
  
  
  (method override (start-element self)
    (nextmethod self)
    (capture-start self 'window-capture)
    (task-start self 'window-share)
    @live-sources-should-not-go-to-pause
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  @live-sources-should-not-go-to-pause
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (capture-stop self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_bin_release pipeline)
    (set! pipeline #f)
    (release-consumers self))
  
  
  (method (capture-start self name)
    (let ((task (new Task name (~ run-capture self) priority: share-priority)))
      (start-task task)
      (set! self.capture-task task)))
  
  
  (method (capture-stop self)
    (stop-task capture-task)
    (set! capture-task #f))
  
  
  (method (run-capture self task)
    (declare (proper-tail-calls))
    (let ((world (current-world)))
      (let ((width (get-width resolution))
            (height (get-height resolution))
            (period (/ 1. (cast <fl> framerate))))
        (let ((duration (flonum->timestamp period)))
          (with-task task
            (lambda (exit)
              (let ((handle (cairo_image_surface_create CAIRO_FORMAT_RGB24 width height)))
                (let ((data (cairo_image_surface_get_data handle)))
                  (with ((surface (new Surface handle)))
                    (let (loop)
                      (with-render-mutex
                        (lambda ()
                          (glReadPixels 0 0 width height GL_BGRA GL_UNSIGNED_BYTE data)
                          (with-unref ((src (gst_bin_get_by_name pipeline "src")))
                            (let ((data (cairo_image_surface_get_data handle))
                                  (size (* width height 4)))
                              (gst_app_src_write_pointer_now src data size duration)))))
                      (task-sleep task period exit)
                      (loop))))))))))))


;;;
;;;; Window-Video-Consumer
;;;


(class Window-Video-Consumer extends Stream-Buffer-Consumer
  
  
  (slot channel-no getter generate)
  
  
  (method override (initialize self channel-no . rest)
    (apply nextmethod self rest)
    (set! self.channel-no channel-no))


  (method override (consume-buffer self buffer)
    (site window
      (let ((dts (gst_buffer_get_dts buffer))
            (pts (gst_buffer_get_pts buffer))
            (duration (gst_buffer_get_duration buffer))
            (keyframe? (gst_buffer_is_keyframe buffer)))
        (let ((flags (frame-flags keyframe? voice?)))
          (let ((client (current-client)))
            (send-client-media client channel-no buffer dts pts duration flags)
            @convert-to-buffer
            (let ((udp-client (get-udp-client client)))
              (when udp-client
                (let ((channel (find-send-channel udp-client channel-no)))
                  (when channel
                    (let ((recorder (get-recorder channel)))
                      (when recorder
                        (world.recording:record-media recorder buffer dts pts duration flags)))))))))))))


;;;
;;;; File-Preprocess-Video-Src
;;;


(definition protected stream-keyframes
  (world-setting 'world.stream-keyframes #f))


(class File-Preprocess-Video-Src extends Video-Frame-Src implements File-Preprocessor
  
  
  (slot location   initialize #f accessors generate)
  (slot container  initialize #f accessors generate)
  (slot prime?     initialize #f accessors generate)
  (slot level      initialize #f accessors generate)
  (slot resolution initialize #f accessors generate)
  (slot framerate  initialize #f accessors generate)
  (slot bitrate    initialize #f accessors generate)
  (slot codec      initialize #f accessors generate)
  (slot pipeline   initialize #f accessors generate)
  (slot stat-probe initialize #f)
  
  
  (method override (initialize self location (container: container #f) (prime?: prime? #f) (level: level #f) (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f))
    (nextmethod self)
    (set! self.location location)
    (set! self.container container)
    (set! self.prime? prime?)
    (set! self.level level)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec))
  
  
  (method override (get-stat-probe self)
    stat-probe)
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (and (not prime?) (get-width resolution)))
          (height (and (not prime?) (get-height resolution)))
          (listener (open-stream-listener "preprocessvideo")))
      (let ((pipeline (if prime?
                          (case container
                            ((qt)
                             (case codec
                               ((h264)
                                (gst-pipeline (tie "filesrc name=filesrc")
                                              "qtdemux"
                                              "video/x-h264"
                                              "appsink name=appsink sync=false"))
                               ((mpeg)
                                (gst-pipeline (tie "filesrc name=filesrc")
                                              "qtdemux"
                                              "video/mpeg"
                                              "appsink name=appsink sync=false"))
                               (else
                                (error "Unsupported preprocess prime video codec: {a}" codec))))
                            ((mpegts)
                             (case codec
                               ((h264)
                                (gst-pipeline (tie "filesrc name=filesrc")
                                              "tsdemux"
                                              "video/x-h264"
                                              "h264parse"
                                              "appsink name=appsink sync=false"))
                               (else
                                (error "Unsupported preprocess prime video codec: {a}" codec))))
                            (else
                             (error "Unsupported preprocess prime video container: {a}" container)))
                        (gst-pipeline (tie "filesrc name=filesrc")
                                      ;; calls vtdec which generates errors in some files
                                      ;; "decodebin"
                                      "qtdemux"
                                      "avdec_h264 max-threads=1"
                                      (and framerate (tie "videorate max-rate={framerate}"))
                                      "videoscale method=sinc"
                                      "videoconvert"
                                      (tie "video/x-raw, format=I420, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                      (let ((key-int-max (and stream-keyframes (fxround (* (cast <fl> framerate) stream-keyframes))))
                                            (bitrate bitrate)
                                            (tune "zerolatency")
                                            (speed-preset "superfast"))
                                        ;; no point using a slower speed until
                                        ;; we can encode without tune=zerolatency
                                        (gst-element "x264enc"
                                                     threads: 1
                                                     key-int-max: key-int-max
                                                     bitrate: bitrate
                                                     tune: tune
                                                     speed-preset: speed-preset
                                                     name: "enc"))
                                      "h264parse"
                                      "appsink name=appsink sync=false"))))
        (gst_object_set_name pipeline "video.file")
        (with-unref ((filesrc (gst_bin_get_by_name pipeline "filesrc"))
                     (appsink (gst_bin_get_by_name pipeline "appsink")))
          (with-unref ((pad (gst_element_get_static_pad filesrc "src")))
            (set! stat-probe (gst_pad_add_stat_probe pad)))
          (gst_app_sink_connect_signals appsink listener)
          (g_object_set_utf-8-string filesrc "location" (path-normalize location))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.pipeline pipeline)
          (let ((size (if prime?
                          ;; quicky use resolution as big as any video we will preprocess
                          (* 1920 1080 4)
                        (* width height 4))))
            (setup-consumer (find-consumer self #f) listener appsink size))))))
  
  
  (method override (task-priority self)
    preprocess-video-priority)
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'video-preprocess)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_bin_release pipeline)
    (set! pipeline #f)
    (release-consumers self))
  
  
  (method override (run-video self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (site video-preprocess
            (process self task exit))
          (iter))))))


;;;
;;;; File-Stream-Video-Src
;;;


(class File-Stream-Video-Src extends Video-Frame-Src implements Media-Stream
  
  
  (slot profile      getter generate)
  (slot location     getter generate)
  (slot stream?      accessors explicit)
  (slot loop?        getter generate)
  (slot file         getter generate)
  (slot reader       getter generate)
  (slot time-base    getter generate)
  (slot consumer     getter generate)
  (slot pause?       getter generate)
  (slot flush?       getter generate)
  (slot delayed-seek getter generate)
  
  
  (method override (initialize self profile location (stream?: stream? #t) (loop?: loop? #f))
    (nextmethod self)
    (set! self.profile profile)
    (set! self.location location)
    (set! self.stream? stream?)
    (set! self.loop? loop?)
    (set! self.file #f)
    (set! self.reader #f)
    (set! self.time-base (new Time-Base))
    (set! self.consumer #f)
    (set! self.pause? #f)
    (set! self.flush? #f)
    (set! self.delayed-seek #f))
  
  
  (method override (task-priority self)
    stream-video-priority)
  
  
  (method override (start-element self)
    (nextmethod self)
    (set! file (new-file {Directory Documents} (tokenise-filename (add-extension location (get-extension profile)))))
    (set! reader (new Stream-Reader file))
    (set! consumer (car sinks))
    (task-start self (list 'video-stream (get-base file) (get-level profile))))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (close reader)
    (set! file #f)
    (set! reader #f))
  
  
  (method override (get-stream? self)
    stream?)
  
  
  (method override (set-stream? self flag)
    (set! stream? flag))
  
  
  (method override (play-stream self)
    (task-wakeup task
      (lambda (exit)
        (set! pause? #f)
        (reset time-base))))
  
  
  (method override (pause-stream self)
    (task-wakeup task
      (lambda (exit)
        (set! pause? #t)
        (task-sleep task #f exit))))
  
  
  (method override (goto-delayed self pos normalized-dts)
    (when (not delayed-seek)
      (task-wakeup task
        (lambda (exit)
          (task-sleep task #f exit))))
    (set! delayed-seek (cons pos normalized-dts)))
  
  
  (method override (goto-stream self pos normalized-dts)
    (task-wakeup task
      (lambda (exit)
        (if (not pos)
            (begin
              (when delayed-seek
                (bind (pos . normalized-dts) delayed-seek
                  (goto-position reader pos normalized-dts))
                (set! delayed-seek #f))
              (if pause?
                  (task-sleep task #f exit)
                (reset time-base)
                (set! flush? #t)))
          (goto-position reader pos normalized-dts)
          (when stream?
            (let ((frame (read-frame reader stream? #f)))
              (when frame
                (bind-values (buffer dts pts duration flags) frame
                  (consume-frame consumer buffer dts pts duration flags)))))
          (task-sleep task #f exit)))))
  
  
  (method override (backward-stream self pos normalized-dts)
    (when pause?
      (task-wakeup task
        (lambda (exit)
          (goto-position reader pos normalized-dts)
          (when stream?
            (let ((frame (read-frame reader stream? #f)))
              (when frame
                (bind-values (buffer dts pts duration flags) frame
                  (consume-frame consumer buffer dts pts duration flags)))))
          (task-sleep task #f exit)))))
  
  
  (method override (forward-stream self pos normalized-dts)
    (when pause?
      (task-wakeup task
        (lambda (exit)
          (goto-position reader pos normalized-dts)
          (when stream?
            (let ((frame (read-frame reader stream? #f)))
              (when frame
                (bind-values (buffer dts pts duration flags) frame
                  (consume-frame consumer buffer dts pts duration flags)))))
          (task-sleep task #f exit)))))
  
  
  (method override (run-video self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (if (stopping? task)
              (task-done task exit)
            ;; protect against stream? threaded change
            (let ((stream? stream?))
              (let ((frame (read-frame reader stream?)))
                (if (not frame)
                    (if loop?
                        (begin
                          (close reader)
                          (set! reader (new Stream-Reader file))
                          (set! time-base (new Time-Base))
                          (iter))
                      (task-done task exit))
                  (bind-values (buffer dts pts duration flags) frame
                    (let ((time (current-seconds))
                          (nanodts (timestamp->flonum dts)))
                      (update-start time-base time nanodts)
                      (let ((sendtime (remote->local time-base nanodts)))
                        (task-sleep task (- sendtime time) exit)
                        (when stream?
                          (if flush?
                              (set! flush? #f)
                            (site video-stream
                              (consume-frame consumer buffer dts pts duration flags)))))))))))
          (iter))))))


;;;
;;;; File-Stream-Image-Src
;;;


(class File-Stream-Image-Src extends Video-Frame-Src implements Media-Stream
  
  
  (slot file     getter generate)
  (slot consumer getter generate)
  
  
  (method override (initialize self location)
    (nextmethod self)
    (set! self.file (new-file {Directory Documents} (tokenise-filename (add-extension location "streamimage"))))
    (set! self.consumer #f))
  
  
  (method override (task-priority self)
    stream-image-priority)
  
  
  (method override (start-element self)
    (nextmethod self)
    (set! consumer (car sinks))
    (task-start self (list 'image-stream (get-base file))))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (set! file #f))
  
  
  (method override (get-stream? self)
    #t)
  
  
  (method override (set-stream? self flag)
    )
  
  
  (method override (run-video self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (read/consume-image self)
        (task-done task exit))))
  
  
  (method (read/consume-image self)
    (with ((reader (new Stream-Reader file)))
      (let ((frame (read-frame reader)))
        (bind-values (buffer dts pts duration flags) frame
          ;; using current seconds makes it so if we
          ;; change the image then everything just works
          ;; on the remote clients
          (let ((ts (flonum->timestamp (current-seconds))))
            (consume-frame consumer buffer ts ts duration flags))))))
  
  
  (method override (resettable? self)
    #t)
  
  
  (method override (reset-media self)
    (read/consume-image self))
  
  
  (method public (change-file self f)
    (set! file f)
    (reset-media self))
  
  
  (method (change-image self partition)
    (bind (base . files) partition
      (let ((streaming (find-if (lambda (file)
                                  (extension=? (get-extension file) world.streaming:streaming-image-extension))
                                files)))
        (if streaming
            (change-file self streaming)
          (let ((image (car files)))
            (world.preprocess:preprocess-file image feedback?: #f)
            (let ((streaming (new-brother image (add-extension (get-base image) world.streaming:streaming-image-extension))))
              (change-file self streaming)))))))
  
  
  (method public (previous-image self)
    (let ((partitions (collect-images self)))
      (let ((previous (previous-element partitions (get-base file) key: car test: filename=? cycle?: #f)))
        (if previous
            (change-image self previous)
          (bell)))))
  
  
  (method public (next-image self)
    (let ((partitions (collect-images self)))
      (let ((next (next-element partitions (get-base file) key: car test: filename=? cycle?: #f)))
        (if next
            (change-image self next)
          (bell)))))
  
  
  ;; simple solution until albums
  (method (collect-images self)
    (let ((dir (get-parent file)))
      (let ((files (collect-files dir
                     (lambda (file)
                       (let ((extension (get-extension file)))
                         (or (member? extension world.streaming:image-extensions test: extension=?)
                             (extension=? extension world.streaming:streaming-image-extension)))))))
        (partition files key: get-base test: filename=?)))))


;;;
;;;; Draw-Video-Src
;;;


(definition protected draw-resolution
  (world-setting 'world.draw-resolution {Dimension 1280 720}))

(definition protected draw-framerate
  (world-setting 'world.draw-framerate 5))

(definition protected draw-bitrate
  (world-setting 'world.draw-bitrate 1024))

(definition protected draw-codec
  (world-setting 'world.draw-codec 'h264))


(class Draw-Video-Src extends Video-Frame-Src
  
  
  (slot draw-proc  initialize #f accessors generate)
  (slot start-time initialize #f accessors generate)
  (slot resolution initialize #f accessors generate)
  (slot context    initialize #f accessors generate)
  (slot consumer   initialize #f getter generate)
  
  
  (method override (initialize self (draw-proc: draw-proc #f))
    (nextmethod self)
    (set! self.draw-proc draw-proc)
    (set! self.resolution draw-resolution))
  
  
  (method protected virtual (new-draw-context self)
    (new Draw-Context draw-resolution draw-framerate draw-bitrate))
  
  
  (method override (task-priority self)
    draw-video-priority)
  
  
  (method override (start-element self)
    (nextmethod self)
    (set! context (new-draw-context self))
    (set! start-time (current-seconds))
    (set! consumer (car sinks))
    (task-start self 'draw))
  
  
  (method override (play-element self)
    (nextmethod self))
  
  
  (method override (pause-element self)
    (nextmethod self))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (free-context self))
  
  
  (method (free-context self)
    (when context
      (close context)
      (set! context #f)))
  
  
  (method override (run-video self task)
    (declare (proper-tail-calls))
    (let ((tier (current-client)))
      (with-task task
        (lambda (exit)
          (let (iter)
            (if (stopping? task)
                (task-done task exit)
              (let ((surface (get-surface context)))
                (draw-stream self surface)
                (bind-values (color alpha dts pts duration flags) (extract context task exit)
                  (site draw-stream
                    (let ((effective-dts (flonum->timestamp (- (current-seconds) start-time))))
                      (consume-frame consumer color effective-dts effective-dts duration flags)))))
              (task-sleep task .1 exit)
              (iter)))))))
  
  
  (method protected virtual (draw-stream self surface)
    (clear surface)
    (when draw-proc
      (draw-proc surface resolution))))


;;;
;;;; File-Preprocess-Image-Src
;;;


(class File-Preprocess-Image-Src extends Draw-Video-Src implements File-Preprocessor
  
  
  (slot file          getter generate)
  (slot color         getter generate)
  (slot alpha         getter generate)
  (slot dts           getter generate)
  (slot pts           getter generate)
  (slot duration      getter generate)
  (slot flags         getter generate)
  (slot extract-mutex getter generate)
  (slot stat-probe)
  
  
  (method override (initialize self file)
    (nextmethod self)
    (set! self.file file)
    (set! self.color #f)
    (set! self.alpha #f)
    (set! self.dts #f)
    (set! self.pts #f)
    (set! self.duration #f)
    (set! self.flags 0)
    (set! self.extract-mutex (make-mutex 'extract)))
  
  
  (method override (get-stat-probe self)
    stat-probe)
  
  
  (method override (new-draw-context self)
    (let ((context (new Draw-Context draw-resolution draw-framerate draw-bitrate tune: (bitwise-ior stillimage zerolatency))))
      (let ((pipeline (get-color-pipeline context)))
        (with-unref ((src (gst_bin_get_by_name pipeline "src")))
          (with-unref ((pad (gst_element_get_static_pad src "src")))
            (set! stat-probe (gst_pad_add_stat_probe pad)))))
      context))
  
  
  (method (extract/cache self task exit)
    (mutex-lock! extract-mutex)
    (prog1 (if color
               (values color alpha dts pts duration flags)
             (let ((surface (get-surface context)))
               (draw-stream self surface)
               (bind-values (color alpha dts pts duration flags) (extract context task exit)
                 (set! self.color color)
                 (set! self.alpha alpha)
                 (set! self.dts dts)
                 (set! self.pts pts)
                 (set! self.duration duration)
                 (set! self.flags flags)
                 (values color alpha dts pts duration flags))))
      (mutex-unlock! extract-mutex)))
  
  
  (method override (run-video self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (bind-values (color alpha dts pts duration flags) (extract/cache self task exit)
          (site image-stream
            (let ((effective-dts (flonum->timestamp (- (current-seconds) start-time))))
              (consume-frame consumer color effective-dts effective-dts duration flags))))
        (free-context self)
        (consume-eos consumer)
        (continuation-return exit #f))))
  
  
  (method override (draw-stream self surface)
    (let ((rect (new Rect 0 0 (get-width draw-resolution) (get-height draw-resolution))))
      (with ((image (new Image moniker: file)))
        (fill-image surface
                    rect
                    image
                    mode: 'fit)))))


;;;
;;;; Video-Sink
;;;


(class Video-Sink extends Stream-Sink
  
  
  (slot level                         initialize #f accessors generate)
  (slot resolution                    initialize #f accessors generate)
  (slot framerate                     initialize #f accessors generate)
  (slot bitrate                       initialize #f accessors generate)
  (slot codec                         initialize #f accessors generate)
  (slot caps                          initialize #f accessors generate)
  (slot codec-data                    initialize #f accessors generate)
  (slot hardware?                     initialize #f accessors generate)
  (slot process?                      initialize #f accessors generate)
  (slot sync-audio?                   initialize #f accessors generate)
  (slot visualizer?                   initialize #f accessors generate)
  (slot alpha-overlay                 initialize #f accessors generate)
  (slot color-flow                    initialize #f getter generate)
  (slot color-pipeline                initialize #f accessors generate)
  (slot color-appsrc                  initialize #f accessors generate)
  (slot color-appsink                 initialize #f accessors generate)
  (slot color-listener                initialize #f accessors generate)
  (slot color-probe                   initialize #f accessors generate)
  (slot alpha?                        initialize #f accessors generate)
  (slot alpha-pipeline                initialize #f accessors generate)
  (slot alpha-appsrc                  initialize #f accessors generate)
  (slot alpha-appsink                 initialize #f accessors generate)
  (slot alpha-listener                initialize #f accessors generate)
  (slot window                        initialize 0  accessors generate)
  (slot hardware-pipeline             initialize #f accessors generate)
  (slot image-surface                 initialize #f accessors generate)
  (slot image-inhibit?                initialize #f accessors generate)
  (slot freeze?                       initialize #f getter generate)
  (slot task                          initialize #f accessors generate)
  (slot rate                          initialize #f accessors generate)
  (slot seek-callback                 initialize #f accessors generate)
  (slot wait-keyframe?                initialize #t accessors generate)
  (slot wait-replace?                 initialize #f accessors generate)
  (slot stream-state                  initialize 'off getter generate setter explicit)
  (slot stream-playing?               initialize #f getter generate)
  (slot stream-disconnected?          initialize #f getter generate)
  (slot source-adapter                initialize #f getter generate)
  (slot src-count            <fx>     initialize 0  getter generate)
  (slot sink-count           <fx>     initialize 0  getter generate)
  (slot rendered-count       <fx>     initialize 0  getter generate)
  (slot max-usage            <fx>     initialize 0  getter generate)
  
  
  (method override (initialize self (level: level #f) (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f) (caps: caps #f) (process?: process? #t) (alpha-overlay: alpha-overlay #f) (alpha?: alpha? #f) (sync-audio?: sync-audio? #f) (visualizer?: visualizer? #f))
    (nextmethod self)
    (set! self.name (determine-name self #f))
    (set! self.level level)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec)
    (set! self.caps caps)
    (set! self.codec-data (and caps (caps-string->codec-data caps)))
    (set! self.hardware? #f @intel-also-has-a-regression-that-needs-to-be-fixed
                         ;; until silicon fixed
                         (cond-expand
                           (silicon #f)
                           (else (and video-hardware? caps codec-data))))
    (set! self.process? process?)
    (set! self.sync-audio? sync-audio?)
    (set! self.visualizer? visualizer?)
    (set! self.alpha-overlay alpha-overlay)
    (set! self.alpha? alpha?)
    (set! self.rate (new Rate))
    (set! self.source-adapter (new Source-Coupler)))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name))))
  
  
  (method override (reset self)
    (if hardware?
        (reset hardware-pipeline)
      (reset source-adapter)))
  
  
  (method (determine-name self channel)
    (let ((name (determine-channel-name channel)))
      (if (not channel)
          name
        (let ((level (get-level channel)))
          (if (not level)
              name
            (format "{a} {a}" name (level->graphic-profile-name level)))))))
  
  
  (method package virtual (start-listeners self)
    (when color-listener
      (start-stream-listener color-listener))
    (when alpha-listener
      (start-stream-listener alpha-listener)))
  
  
  (method package virtual (stop-listeners self)
    (when color-listener
      (stop-stream-listener color-listener))
    (when alpha-listener
      (stop-stream-listener alpha-listener)))
  
  
  (method package virtual (resize self)
    )
  
  
  (method package virtual (move self rect)
    )
  
  
  (method package virtual (focus self)
    )
  
  
  (method package virtual (unfocus self)
    )
  
  
  (method package (set-stream-state self state)
    (when (neq? state stream-state)
      ;; only transition to drawn from on
      (when (or (neq? state 'drawn) (eq? stream-state 'on))
        (set! stream-state state)
        (update-render-rate)
        (invalidate-state self))))
  
  
  (method package (set-stream-disconnected self)
    (set! stream-state 'off)
    (set! stream-disconnected? #t)
    (update-render-rate)
    (invalidate-state self))
  
  
  (method package virtual (invalidate-state self . rest)
    )
  
  
  @assert-mutex
  (method package virtual (assert-channel-mutex self tag)
    )
  
  
  (method package (gather-health self)
    (if hardware?
        (cons name (cons 'hardware (gather-health hardware-pipeline)))
      (let ((usage (- src-count sink-count)))
        (cons name (cons 'software (list usage max-usage sink-count rendered-count))))))
  
  
  (method package virtual (setup-pipeline self)
    (let ((width (get-width resolution))
          (height (get-height resolution)))
      (assert caps)
      (let ((listener (open-stream-listener "videocolor"))
            (pipeline (gst-pipeline (format "appsrc caps=\"{a}\" min-latency=30000000 name=src" caps)
                                    (if sync-audio?
                                        "queue min-threshold-time=200000000 name=queue"
                                      "queue name=queue")
                                    (and (eq? codec 'h264) (tie "avdec_h264 max-threads=1 name=dec"))
                                    (and (eq? codec 'mpeg) (tie "avdec_mpeg4 max-threads=1 name=dec"))
                                    "videoconvertscale name=convertscale"
                                    (tie "video/x-raw, format=BGRA, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                    (if visualizer?
                                        (tie "appsink sync=false name=sink")
                                      (tie "appsink name=sink")))))
        (gst_object_set_name pipeline (string-append "video." name))
        (with-unref ((appsrc (gst_bin_get_by_name pipeline "src"))
                     (appsink (gst_bin_get_by_name pipeline "sink")))
          (with-unref ((pad (gst_element_get_static_pad appsink "sink")))
            (let ((probe (gst_pad_add_video_probe pad (get-write-file listener))))
              (gst_app_sink_connect_signals appsink listener)
              (g-object-set appsrc
                            "is-live"     'boolean #t
                            "stream-type" 'int     GST_APP_STREAM_TYPE_STREAM
                            "format"      'int     GST_FORMAT_TIME)
              (gst_element_set_state pipeline GST_STATE_READY)
              (set! self.color-pipeline pipeline)
              (set! self.color-appsrc appsrc)
              (set! self.color-appsink appsink)
              (set! self.color-listener listener)
              (set! self.color-probe probe)
              @assert-mutex
              (assert-channel-mutex self 'video-setup)
              (set! self.color-flow (new GStreamer-Flow pipeline appsrc appsink udp-video-process))))))
      (when alpha?
        (let ((listener (open-stream-listener "videoalpha"))
              (pipeline (gst-pipeline "appsrc min-latency=30000000 name=src"
                                      "avdec_h264 max-threads=1 name=dec"
                                      "appsink name=sink")))
          (gst_object_set_name pipeline (string-append "videoalpha." name))
          (with-unref ((appsrc (gst_bin_get_by_name pipeline "src"))
                       (appsink (gst_bin_get_by_name pipeline "sink")))
            (gst_app_sink_connect_signals appsink listener)
            (gst-app-src-set-caps appsrc "video/x-h264"
              "width"         'int      width
              "height"        'int      height
              "framerate"     'fraction (cons framerate 1)
              "stream-format" 'string   "byte-stream"
              "alignment"     'string   "au")
            (g-object-set appsrc
                          "is-live"     'boolean #t
                          "stream-type" 'int     GST_APP_STREAM_TYPE_STREAM
                          "format"      'int     GST_FORMAT_TIME)
            (gst_element_set_state pipeline GST_STATE_READY)
            (set! self.alpha-pipeline pipeline)
            (set! self.alpha-appsrc appsrc)
            (set! self.alpha-appsink appsink)
            (set! self.alpha-listener listener)
            (set! self.image-surface (new Image-Surface (new Dimension width height))))))))
  
  
  (method protected virtual abstract (setup-hardware self)
    )
  
  
  (method override (setup-element self)
    (nextmethod self)
    (when process?
      (if hardware?
          (setup-hardware self)
        (setup-pipeline self))))
  
  
  (method (task-start self name)
    (let ((procedure
            (lambda (task)
              (run-video self task))))
      (let ((task (new Task name procedure priority: video-output-priority stack: stack-size)))
        (start-listeners self)
        (start-task task)
        (set! self.task task))))
  
  
  (method (task-stop self)
    (stop-listeners self)
    (stop-task task)
    (set! task #f))
  
  
  (method override (start-element self)
    (nextmethod self)
    (when process?
      (if hardware?
          (start hardware-pipeline)
        (task-start self (list 'video-output name))
        (gst_element_set_state color-pipeline GST_STATE_PAUSED)
        (when alpha?
          (gst_element_set_state alpha-pipeline GST_STATE_PAUSED)))))
  
  
  (method override (play-element self)
    (nextmethod self)
    (when process?
      (when (not hardware?)
        (gst_element_set_state color-pipeline GST_STATE_PLAYING)
        (when alpha?
          (gst_element_set_state alpha-pipeline GST_STATE_PLAYING)))))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (when process?
      (when (not hardware?)
        (gst_element_set_state color-pipeline GST_STATE_PAUSED)
        (when alpha?
          (gst_element_set_state alpha-pipeline GST_STATE_PAUSED)))))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (when process?
      (if hardware?
          (stop hardware-pipeline)
        (gst_element_set_state color-pipeline GST_STATE_READY)
        (when alpha?
          (gst_element_set_state alpha-pipeline GST_STATE_READY))
        (task-stop self))))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when process?
      (if hardware?
          (release hardware-pipeline)
        @assert-mutex
        (assert-channel-mutex self 'release-video)
        (gst_pad_probe_free color-probe)
        (set! color-probe #f)
        (gst_bin_release color-pipeline)
        (set! color-pipeline #f)
        (set! color-appsrc #f)
        (set! color-appsink #f)
        (close-stream-listener color-listener)
        (set! color-listener #f)
        (when alpha?
          (gst_bin_release alpha-pipeline)
          (close image-surface)
          (set! alpha-pipeline #f)
          (set! alpha-appsrc #f)
          (set! alpha-appsink #f)
          (set! image-surface #f)
          (close-stream-listener alpha-listener)
          (set! alpha-listener #f)))
      (set! color-flow #f)
      (set-stream-state self 'off)))
  
  
  (method package (play-video self)
    (when (not stream-playing?)
      (play-element self)
      (set! stream-playing? #t)))
  
  
  (method protected virtual (write-video self color dts pts duration timestamp-offset (alpha #f))
    (if hardware?
        (cond-expand
          (mac (decode hardware-pipeline color dts pts duration timestamp-offset))
          (else #f))
      ;; QUICK TEST
      (when color-appsrc
        ;; QUICK TEST
        (when color
          (play-video self)
          (let ((timestamp-offset (or timestamp-offset (adapt-time source-adapter color-appsrc dts))))
            (let ((dts (max 0 (+ dts timestamp-offset)))
                  (pts (max 0 (+ pts timestamp-offset))))
              (when record-events?
                (let ((running-time (gst_element_get_running_time color-appsrc)))
                  (let ((distance (- running-time dts window)))
                    (cond ((< distance udp-video-early)
                           (record-event udp-id-media-early
                                         -1.
                                         -1.
                                         (fixnum->flonum udp-video)
                                         -1.
                                         -1.
                                         -1.
                                         -1.))
                          ((> distance udp-video-late)
                           (record-event udp-id-media-late
                                         -1.
                                         -1.
                                         (fixnum->flonum udp-video)
                                         -1.
                                         -1.
                                         -1.
                                         -1.))))))
              (if (u8vector? color)
                  (gst_app_src_write color-appsrc color (u8vector-length color) dts pts duration)
                (gst_app_src_write_buffer color-appsrc color dts pts duration))
              (increase! src-count)
              (let ((usage (- src-count sink-count)))
                (when (> usage max-usage)
                  (set! max-usage usage)))
              (when alpha?
                ;; QUICK TEST
                (when alpha-appsrc
                  ;; QUICK TEST
                  (when alpha
                    (gst_app_src_write alpha-appsrc alpha (u8vector-length alpha) dts pts duration))))))
          (when seek-callback
            (seek-callback dts))))))
      
  
  (method (run-video self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (if (stopping? task)
              (task-done task exit)
            (process self task exit)
            (task-halt task exit)
            (iter))))))
  
  
  (method override (process self task exit)
    (let ((color (wait-video self task exit color-listener color-appsink))
          (alpha (and alpha? (wait-video self task exit alpha-listener alpha-appsink))))
      (increase! sink-count)
      (site video-output
        (if freeze?
            (gst_buffer_unref color)
          (increase! rendered-count)
          (draw self color alpha))
        (set-stream-state self 'drawn))))
  

  (method (wait-video self task exit listener elem)
    (declare (proper-tail-calls))
    (let (loop)
      (let ((c (wait listener)))
        (case c
          ((#\!)
           (loop))
          ((#\<)
           (set! freeze? #t)
           (loop))
          ((#\>)
           (set! freeze? #f)
           (loop))
          ((#\^)
           (loop))
          ((#\@)
           (task-done task exit))
          ((#\.)
           (validate-try-pull-buffer (gst_app_sink_try_pull_buffer elem)))
          (else
           (error "Invalid app sink char {s}" c))))))

  
  (method package virtual (draw self color alpha)
    )
  
  
  (method package virtual abstract (draw-buffer self buffer)
    )
  
  
  @ziggy
  (method package (update self color alpha texture (background: background #f))
    (let ((width (get-width resolution))
          (height (get-height resolution)))
      (if (not alpha?)
          (move-u8vector->pointer! color (get-data texture))
          @experiments
          (if speakers-xp?
              (if (eq? (effective-focused-output (current-video)) self)
                  (move-u8vector->pointer! color (get-data texture))
                (add-alpha color .6 (get-data texture) (* width height)))
            ;; quick try
            (if (is? (current-space) together.gathering:Sphere-Space)
                (add-alpha color .6 (get-data texture) (* width height))
            (if alpha-overlay
                (add-alpha color alpha-overlay (get-data texture) (* width height))
              (move-u8vector->pointer! color (get-data texture)))))
        (let ((data (cairo_image_surface_get_data (get-handle image-surface))))
          (cairo_surface_flush (get-handle image-surface))
          (combine-alpha color alpha data (* width height))
          (cairo_surface_mark_dirty (get-handle image-surface))
          (unless image-inhibit?
            (let ((surface (get-surface texture)))
              (clear-glass surface resolution background: background)
              (draw-surface surface image-surface 0 0))))))
    (update rate)
    (unless image-inhibit?
      (map-texture texture)))
  
  
  (method package (update self color alpha texture)
    (let ((map (gst_buffer_map color)))
      (map-data texture (gst_mapinfo_data map))
      (gst_buffer_unmap color map)
      (gst_buffer_unref color)))
  
  
  (method package (update-buffer self buffer texture)
    (let ((map (gst_buffer_map buffer)))
      (map-data texture (gst_mapinfo_data map))
      (gst_buffer_unmap buffer map)
      (gst_buffer_unref buffer)))
  
  
  (method package virtual (render self)
    )
  
  
  (method (with-slide self texture thunk)
    (set! image-inhibit? #t)
    (thunk)
    (let ((height (cast <fl> (get-height resolution))))
      (let ((delta (/ height render-rate slide-duration))
            (surface (get-surface texture)))
        (thread-start!
          (new-thread
            (lambda ()
              (let (loop (slide (- height delta)))
                (let ((slide (max 0. slide)))
                  (let ((done? (<= slide 0.)))
                    (with-task-mutex
                      (lambda ()
                        (if (not image-surface)
                            (set! done? #t)
                          (translate surface 0 slide)
                          (clear-glass surface resolution)
                          (draw-surface surface image-surface 0 0)
                          (translate surface 0 (- slide))
                          (flush surface)
                          (map-texture texture))
                        (when done?
                          (set! image-inhibit? #f))))
                    (when (not done?)
                      (sleep render-period)
                      (loop (- slide delta)))))))
            'slide))))))


;;;
;;;; Draw-Video-Sink
;;;


(class Draw-Video-Sink extends Video-Sink
  
  
  (slot entity     initialize #f accessors generate)
  (slot pane       initialize #f accessors generate)
  (slot background initialize #f accessors generate)
  
  
  (method override (initialize self ent . rest)
    (apply nextmethod self alpha?: #t rest)
    (let ((p (cache-draw-pane ent (list @convert (eq? ent (current-me)) resolution: resolution))))
      (set! entity ent)
      (set! pane p)))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when entity
      (set-draw-pane entity #f)
      (set! entity #f)
      (set! pane #f)))
  
  
  (method override (draw self color alpha)
    ;; quicky
    (when pane
      (update self color alpha (get-texture (cache-quad-texture pane)) @ziggy background: @ziggy background)))
  
  
  (method override (render self)
    ;; nothing to do render done by player pane
    ))


;;;
;;;; Event-View
;;;


(class Event-View extends View)


(definition public (make-event-view)
  (let ((view (new Event-View)))
    (define (mouse-down event)
      (debug 'mouse-down))
    
    (define (mouse-up event)
      (debug 'mouse-up))
    
    (define (key-press event)
      (debug 'key-press))
    
    (set-mouse-down-handler view mouse-down)
    (set-mouse-up-handler view mouse-up)
    (set-key-press-handler view key-press)
    view))


(definition public (make-view . rest)
  (apply new View rest))


;;;
;;;; Draw-Pane
;;;


(definition public (make-draw-pane entity info)
  (let ((expanse (or (getf info expanse:) {Dimension$fl$ 6. 3.375}))
        (resolution (or (getf info resolution:) {Dimension 1280 720})))
    (new Draw-Pane
      title: "Draw"
      expanse: expanse
      resolution: resolution
      entity: entity
      info: info)))


(class Draw-Pane extends Entity-Pane
  
  
  (property info initialize #f accessors generate))


;;;
;;;; View-Pane
;;;


(definition public (make-view-pane entity view)
  (let ((expanse {Dimension$fl$ 6. 3.375})
        (resolution {Dimension 1280 720}))
    (let ((pane (new View-Pane
                  title: "View"
                  expanse: expanse
                  resolution: resolution
                  entity: entity)))
      (set-root pane view)
      (set-position view {Point 0 0})
      (set-size view resolution)
      pane)))


(class View-Pane extends Entity-Pane
  
  
  (method override (draw self surface)
    (when root
      (clear surface)
      (paint-drawing root surface '()))))


;;;
;;;; Overhead-Video-Sink
;;;


(class Overhead-Video-Sink extends Video-Sink
  
  
  (slot player initialize #f accessors generate)
  (slot pane   initialize #f accessors generate)
  
  
  (method override (initialize self entity . rest)
    (apply nextmethod self rest)
    (let ((p (cache-camera-pane entity (list (eq? entity (current-me)) resolution))))
      (set! player entity)
      (set! pane p)))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when player
      (set-camera-pane player #f)
      (set! player #f)
      (set! pane #f)))
  
  
  (method override (draw self color alpha)
    (update self color alpha (get-texture (cache-quad-texture pane))))
  
  
  (method override (render self)
    ;; nothing to do render done by player pane
    ))


;;;
;;;; Camera-Pane
;;;


(definition public (make-camera-pane data)
  (bind (me? resolution) data
    (new Camera-Pane
      title: "Camera"
      expanse: (new Dimension$fl$ 1. .5625)
      resolution: resolution
      data: data)))


(class Camera-Pane extends World-Pane
  
  
  (method override (draw self surface)
    (clear surface)))


;;;
;;;; Sheet-Video-Sink
;;;


(class Sheet-Video-Sink extends Video-Sink
  
  
  (slot player initialize #f accessors generate)
  (slot sheet  initialize #f accessors generate)
  
  
  (method override (initialize self entity . rest)
    (bind-keywords ((position #f) (size #f) . others) rest
      (apply nextmethod self others)
      (let ((world (current-world)))
        (let ((pos (or position {Point 0 0}))
              (size (or size {Dimension 320 180})))
          (let ((s (make-world-sheet 'video World-Sheet size resolution: resolution scale?: #f)))
            (make-orthographic-matrix! (get-projection-matrix s) 0. (get-width world) 0. (get-height world) 0. 10.)
            (set-position s pos)
            (set-size s size)
            (set! self.player entity)
            (set! self.sheet s))))))
  
  
  (method override (resize self)
    (let ((world (current-world)))
      (let ((width (get-width world))
            (height (get-height world)))
        (make-orthographic-matrix! (get-projection-matrix sheet) 0. width 0. height 0. 10.))))
  
  
  (method override (move self rect)
    (set-rect sheet rect))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when sheet
      (close sheet)
      (set! sheet #f)))
  
  
  (method override (draw self color alpha)
    (let ((texture (get-texture sheet)))
      (update self color alpha texture)))
  
  
  (method override (render self)
    (when (eq? stream-state 'drawn)
    ;; QUICKY
    (when sheet
      (render-sheet sheet)))))


;;;
;;;; Circle-Video-Sink
;;;


(class Circle-Video-Sink extends Video-Sink
  
  
  (slot id                initialize #f accessors generate)
  (slot stream-no         initialize #f accessors generate)
  (slot channel           initialize #f accessors generate)
  (slot player            initialize #f accessors generate)
  (slot elevation         initialize #f accessors generate)
  (slot radius            initialize #f accessors generate)
  (slot rotation          initialize #f accessors generate)
  (slot scale             initialize #f accessors generate)
  (slot adjustment        initialize #f accessors generate)
  (slot kind              initialize #f accessors generate)
  (slot plane             initialize #f accessors generate)
  (slot media-pane        initialize #f accessors generate)
  (slot media-sheet       initialize #f accessors generate)
  (slot media-texture     initialize #f accessors generate)
  (slot interface-pane    initialize #f accessors generate)
  (slot interface-sheet   initialize #f accessors generate)
  (slot interface-texture initialize #f accessors generate)
  
  
  (method override (initialize self id stream-no channel entity . rest)
    (bind-keywords ((root-view #f) (position #f) (size #f) (flipped? #f) . others) rest
      (apply nextmethod self others)
      (let ((window (current-window)))
        (set! self.name (determine-name self channel))
        (set! self.id id)
        (set! self.stream-no stream-no)
        (set! self.channel channel)
        (set! self.player entity)
        (when (and channel (sender? channel))
          (set! source-adapter (new Source-Rebaser)))
        ;; media
        (let ((position (or position {Point 0 0}))
              (size (or size {Dimension 640 360}))
              (expanse (resolution->expanse resolution))
              (texture (new Image-Texture (get-width resolution) (get-height resolution))))
          (let ((pane (make-sheet-pane
                        name: 'media
                        title: "Media"
                        position: position
                        size: size
                        expanse: expanse
                        resolution: resolution
                        texture: texture
                        flipped?: flipped?
                        hardware?: hardware?)))
            (set! self.media-pane pane)
            (set! self.media-sheet (get-sheet pane))
            (set! self.media-texture texture)))
        ;; interface
        (let ((position {Point 0 0})
              (size {Dimension 1280 720})
              (expanse (resolution->expanse {Dimension 1280 720}))
              (resolution {Dimension 1280 720}))
          (let ((texture (make-cairo-texture (get-width resolution) (get-height resolution) scale?: #t mipmap?: #t))
                (root (or root-view (new world.circle:Circle-View position: position size: size))))
            (let ((pane (make-sheet-pane
                          class: world.circle:Circle-Pane
                          name: 'interface
                          title: "Interface"
                          position: position
                          size: size
                          expanse: expanse
                          resolution: resolution
                          texture: texture
                          root: root)))
              (set! self.interface-pane pane)
              (set! self.interface-sheet (get-sheet pane))
              (set! self.interface-texture texture)
              (update root self))))
        ;; panes
        (update-panes self))))
  
  
  (method override (destroy self)
    (let ((window (current-window)))
      (unregister-pane window interface-pane)
      (unregister-sheet window interface-sheet))
    (close interface-pane)
    (close media-pane)
    (nextmethod self))
  
  
  (method override (setup-pipeline self)
    (nextmethod self)
    (when (and channel (receiver? channel))
      (set! window (process-window color-flow))))
  
  
  (method override (setup-hardware self)
    (cond-expand
      (mac
       (set! hardware-pipeline (new Hardware-Pipeline resolution codec-data (get-id media-texture)
                                    bound-callback: (lambda () (set-stream-state self 'drawn))))
       (set! color-flow (new Hardware-Flow hardware-pipeline udp-video-hardware-process)))
      (else)))
  
  
  (method package (update-panes self)
    (let ((window (current-window))
          (video (current-video)))
      (case video-layout
        ((gallery)
         (unregister-pane window interface-pane)
         (register-back-sheet window interface-sheet))
        ((circle focus)
         (register-pane window interface-pane)
         (cond ((and (eq? video-layout 'focus)
                     (eq? self (effective-focused-output video)))
                (register-back-sheet window interface-sheet))
               (else
                (unregister-sheet window interface-sheet)))))))
  
  
  (method package (update-matrices self count)
    (update-media-matrix self count)
    (update-interface-matrix self count))
  
  
  (method package (update-media-matrix self count)
    (let ((matrix (circle-matrix^ self radius (<= count circle-max-fixed))))
      (let ((position (matrix-translation matrix))
            (direction (matrix-direction matrix)))
        (set-position media-pane position)
        (set-matrix media-pane matrix)
        (set! plane (new Plane position direction)))))
  
  
  (method package (update-interface-matrix self count)
    (when radius
      (if (and speakers-xp? (eq? (effective-focused-output (current-video)) self))
          (let ((position (matrix-translation (get-matrix media-pane))))
            (let ((billboard-matrix (orthogonal-matrix^ (get-position (current-camera)) position) @w (billboard-matrix^ position)))
              (set-matrix media-pane billboard-matrix)
              (set-matrix interface-pane billboard-matrix)))
        (let ((flip? (not (xor (>= (plane-to-point-distance^ plane (get-position (current-camera))) 0.)
                               (> count circle-max-fixed)))))
          (set-matrix media-pane (circle-matrix^ self radius flip?))
          (if flip?
              (set-matrix interface-pane (circle-matrix^ self (+ radius -.005) flip?))
            (set-matrix interface-pane (circle-matrix^ self (+ radius .005) flip?)))))))
  
  
  (method (circle-matrix! self res <matrix> radius flip?)
    (let ((zone (current-zone)))
      (let ((billboard? (eq? kind 'billboard)))
        (matrix-multiply!
          res
          (if billboard?
              (billboard-matrix^ circle-position)
            (matrix-multiply^
              (make-translation-matrix^ circle-position)
              (make-lookat-matrix^ circle-lookat)
              (make-scaling-matrix^ circle-scale)))
          (make-translation-matrix^ (vertex^ 0. 0. (- adjustment)))
          (make-rotation-matrix^ (vertex^ 0. 1. 0.) rotation)
          (make-translation-matrix^ (vertex^ 0. elevation radius))
          (if (and flip? (not billboard?))
              (make-rotation-matrix^ (vertex^ 0. 1. 0.) PI)
            (make-identity-matrix^))
          (make-scaling-matrix^ (vertex^ scale scale scale))))))
  
  
  (method package (circle-view self)
    (get-root interface-pane))
  
  
  (method override (resize self)
    (let ((world (current-world)))
      (let ((width (get-width world))
            (height (get-height world)))
        (make-orthographic-matrix! (get-projection-matrix media-sheet) 0. width 0. height 0. 10.)
        (make-orthographic-matrix! (get-projection-matrix interface-sheet) 0. width 0. height 0. 10.))))
  
  
  (method override (move self rect)
    (set-rect media-sheet (fit-both resolution rect))
    (set-rect interface-sheet rect))
  
  
  (method package (focused? self)
    (and (eq? video-layout 'focus)
         (eq? (effective-focused-output (current-video)) self)))
  
  
  (method package (move-focused self)
    (let ((bounds (get-content-rect (current-window))))
      (let ((focused (focused-rect bounds)))
        (let ((adjusted (adjust-focused bounds focused)))
          (move self adjusted)))))
  
  
  (method override (focus self)
    (let ((window (current-window)))
      (move-focused self)
      (register-back-sheet window interface-sheet)))
  
  
  (method override (unfocus self)
    (let ((window (current-window)))
      (unregister-sheet window interface-sheet)))
  
  
  (method override (invalidate-state self (invalidate-audio? #f))
    (delay-event
      (lambda ()
        (with-task-mutex
          (lambda ()
            (parameterize ((paint-now? #t))
              (invalidate-texture interface-pane))
            (when invalidate-audio?
              ;; another quick patch around this called too early
              (let ((root (get-root interface-pane)))
                (when root
                  (world.circle:invalidate-audio root)))))))))
  
  
  @assert-mutex
  (method override (assert-channel-mutex self tag)
    (when (and channel (receiver? channel))
      (assert-mutex channel tag)))
  
  
  (method override (process self task exit)
    (nextmethod self task exit)
    (when (and (eq? stream-state 'drawn)
               ;; do not replace channel when freeze? as we
               ;; need draw to have mapped the new texture
               (not freeze?)
               wait-replace?)
      (with-task-mutex
        (lambda ()
          (unless (stopping? task)
            (when wait-replace?
              (parameterize ((paint-now? #t))
                (invalidate-texture interface-pane))
              (replace-channel (current-client) channel)
              (set! wait-replace? #f)))))))
  
  
  (method override (draw self color alpha)
    (update self color alpha media-texture))
  
  
  (method override (draw-buffer self buffer)
    (update-buffer self buffer media-texture))
  
  
  (method override (render self)
    (let ((world (current-world)))
      (define (render-sheets)
        (when (eq? stream-state 'drawn)
          (render-sheet media-sheet))
        (when (or video-interface?
                  (neq? stream-state 'drawn))
          (render-sheet interface-sheet)))
      
      (case video-layout
        ((gallery)
         (render-sheets))
        (else
         (when (focused? self)
           (render-sheets))
         (when (and (eq? stream-state 'drawn)
                    (or video-interface?
                        (not (focused? self))))
           (render-pane media-pane))
         (when (and (or (neq? video-layout 'focus)
                        (neq? stream-state 'drawn))
                    (or video-interface?
                        (neq? stream-state 'drawn)))
           (render-pane interface-pane))))))))
