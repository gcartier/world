;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Video
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.video jazz


(import (jazz.cairo)
        (jazz.component)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.io)
        (jazz.presence)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (jazz.time)
        (jazz.view)
        (jazz.window)
        (world)
        (world.autoload)
        (world.billboard)
        (world.configure)
        (world.console)
        (world.context)
        (world.entity)
        (world.event)
        (world.foreign)
        (world.geometry)
        (world.hook)
        (world.id)
        (world.interface)
        (world.interface.sheet)
        (world.io)
        (world.layout)
        (world.pane)
        (world.plane)
        (world.quad-texture)
        (world.settings)
        (world.stream)
        (world.task)
        (world.texture)
        (world.time)
        (world.udp)
        (world.window))


(definition protected self-resolution
  (world-setting 'world.self-resolution {Dimension 640 360}))


(definition protected video-resolution
  (world-setting 'world.video-resolution {Dimension 640 360}))

(definition protected video-framerate
  (world-setting 'world.video-framerate 15))

(definition protected video-bitrate
  (world-setting 'world.video-bitrate 1024))

(definition protected video-key-period
  (world-setting 'world.video-key-period #f))

(definition protected video-pass
  (world-setting 'world.video-pass #f))

(definition protected video-alpha
  (world-setting 'world.video-alpha 1.0 @wait 0.6))

(definition protected video-overlay?
  (world-setting 'world.video-overlay? #f))

(definition protected video-codec
  (world-setting 'world.video-codec 'h264))


(definition protected screen-share-resolution
  (world-setting 'world.screen-share-resolution {Dimension 1280 720}))

(definition protected screen-share-framerate
  (world-setting 'world.screen-share-framerate 5))

(definition protected screen-share-bitrate
  (world-setting 'world.screen-share-bitrate 1024))

(definition protected screen-share-codec
  (world-setting 'world.screen-share-codec 'h264))


(definition layouts
  '(;;overhead
    sidebar
    gallery))

(definition public video-layout
  (world-setting 'world.video-layout 'sidebar @currently-buggy-when-we-cycle 'overhead))


(definition public video-mode
  'fit)

(definition public (set-video-mode mode)
  (let ((video (current-video)))
    (set! video-mode mode)
    (if (eq? video-layout 'focus)
        (let ((focused-output (effective-focused-output video)))
          (when focused-output
            (move-focused focused-output)))
      (layout-outputs video))))


(definition protected video-interface?
  #t)

(definition protected (set-video-interface? flag)
  (set! video-interface? flag))


(definition protected video-show
  (world-setting 'world.video-show #f))


(definition protected speakers-xp?
  (world-setting 'world.speakers-xp? #f))


(definition protected slide-duration
  (world-setting 'world.slide-duration .2))


;;;
;;;; Kush
;;;


(definition public (kush-gauge width height rate motion)
  (/ (* width height rate motion 0.07) 1000.))


;;;
;;;; Header
;;;


;; first four bytes are always 00 00 00 01
(definition protected (video-buffer-header? buffer)
  (let ((pos 5))
    (and (< pos (u8vector-length buffer))
         (= (u8vector-ref buffer pos) 16))))


;;;
;;;; Focused
;;;


(definition (adjust-focused bounds rect)
  (if (eq? video-mode 'fit)
      rect
    ;; fill mode
    (let ((ratio (fit-rects rect bounds 'fill)))
      (let ((new-width (fxround (* (cast <fl> (rect-width rect)) ratio)))
            (new-height (fxround (* (cast <fl> (rect-height rect)) ratio))))
        (let ((pos (center (new Dimension new-width new-height) (rect-size bounds))))
          (let ((h (get-h pos))
                (v (get-v pos)))
            (new Rect h v (+ h new-width) (+ v new-height))))))))


(definition (focused-rect bounds)
  (car (layout-tiles 1 bounds)))


;;;
;;;; Circle
;;;


(definition protected layout-circle-hook
  #f)

(definition protected (set-layout-circle-hook proc)
  (set! layout-circle-hook (and proc (new Hook proc))))


;;;
;;;; Video
;;;


(class World-Video extends Object
  
  
  (slot outputs         getter generate)
  (slot ordered-outputs getter generate)
  (slot self-output     getter generate)
  (slot focused-output  accessors generate)
  (slot render-hook     accessors generate)
  
  
  (method override (initialize self)
    (nextmethod self)
    (set! self.outputs (make-table test: equal?))
    (set! ordered-outputs '())
    (set! self-output #f)
    (set! focused-output #f)
    (set! render-hook #f))
  
  
  (method package (resize self)
    (iterate-table outputs
      (lambda (id output)
        (resize output)))
    (when focused-output
      (resize focused-output))
    (layout-outputs self)
    (when (eq? video-layout 'focus)
      (let ((focused-output (effective-focused-output self)))
        (when focused-output
          (move-focused focused-output)))))
  
  
  ;;;
  ;;;; Outputs
  ;;;
  
  
  (method package (find-output self id)
    (table-ref outputs id #f))
  
  (method package (register-output self id output)
    (table-set! outputs id output))
  
  
  (method package (entity-output self id (position: position #f) (size: size #f) (resolution: resolution #f) (codec: codec #f))
    (or (table-ref outputs id #f)
        (let ((entity (find-entity id)))
          (let ((output (new Draw-Video-Sink entity
                             resolution: (or resolution {Dimension 1280 720})
                             framerate: video-framerate
                             bitrate: video-bitrate
                             codec: (or codec video-codec)
                             alpha-overlay: video-alpha
                             overlay?: video-overlay?)))
            (table-set! outputs id output)
            (play output)
            output))))
  
  
  (method package (player-output self id (channel: channel #f) (player: player #f) (position: position #f) (size: size #f) (resolution: resolution #f) (codec: codec #f))
    (define (add-output output)
      (if #f @wait-for-circle-tests (and self-output (neq? output self-output))
          ;; reposition so self output is always last
          (set! ordered-outputs (append! (remove! self-output ordered-outputs) (list output self-output)))
        (set! ordered-outputs (append! ordered-outputs (list output)))))
    
    (or (table-ref outputs id #f)
        ;; the or is a quick hack to test self video
        (let ((player (or player (find-entity id))))
          (let ((output (case video-layout
                          ((overhead)
                           (new Overhead-Video-Sink
                             player
                             resolution: (or resolution video-resolution)
                             framerate: video-framerate
                             bitrate: video-bitrate
                             codec: (or codec video-codec)
                             alpha-overlay: video-alpha
                             overlay?: video-overlay?))
                          (else
                           (new Circle-Video-Sink
                             id
                             channel
                             player
                             position: position
                             size: size
                             resolution: (if (not id) self-resolution (or resolution video-resolution))
                             framerate: video-framerate
                             bitrate: video-bitrate
                             codec: (or codec video-codec)
                             alpha-overlay: video-alpha
                             overlay?: video-overlay?
                             process?: (boolean id))))))
            (table-set! outputs id output)
            (when (not id)
              (set! self-output output))
            (add-output output)
            (play output)
            output))))
  
  
  (method package (channel-output self channel . rest)
    (let ((output (apply player-output self (get-no channel) channel: channel rest)))
      (invalidate-state output)
      (update-layouts self)
      output))
  
  
  (method package (visualizer-output self position size)
    (let ((output (new Sheet-Video-Sink
                    #f
                    position: position
                    size: size
                    resolution: self-resolution
                    framerate: video-framerate
                    bitrate: video-bitrate
                    codec: video-codec
                    alpha-overlay: video-alpha
                    overlay?: video-overlay?
                    process?: #t)))
      (play output)
      output))
  
  
  (method package (close-output self id output (layout?: layout? #t))
    (table-clear outputs id)
    (set! ordered-outputs (remove! output ordered-outputs))
    (when (eq? output self-output)
      (set! self-output #f))
    (when (eq? output focused-output)
      (set! focused-output #f))
    (release output)
    (close output)
    (when layout?
      (update-layouts self)))
  
  
  (method package (effective-focused-output self)
    (or focused-output
        (and (not-null? ordered-outputs)
             (car ordered-outputs))))
  
  
  (method package (change-focused-output self output)
    (when focused-output
      (unfocus focused-output))
    (set! focused-output output)
    (when output
      (focus output)))
  
  
  (method package (receive-server-video self id buffer timestamp duration)
    (let ((output (find-output self id)))
      (when output
        (if (not buffer)
            (set-stream-state output 'off)
          (when (eq? (get-stream-state output) 'off)
            (set-stream-state output 'on))
          (consume output buffer timestamp duration)
          (record-event udp-id-sink-media
                        (fixnum->flonum id)
                        (fixnum->flonum client-no)
                        (fixnum->flonum world.udp:udp-video)
                        -1.
                        -1.
                        -1.
                        (timestamp->flonum timestamp))))))
  
  
  (method package (receive-visualizer-video self output buffer timestamp duration)
    (if (not buffer)
        (set-stream-state output 'off)
      (when (eq? (get-stream-state output) 'off)
        (set-stream-state output 'on))
      (consume output buffer timestamp duration)))
  
  
  (method package (receive-video self id/output buffer timestamp duration)
    (if (is? id/output Video-Sink)
        (receive-visualizer-video self id/output buffer timestamp duration)
      (receive-server-video self id/output buffer timestamp duration)))
  
  
  (method package (receive-processor-draw self id color alpha timestamp duration background slide?)
    (if (not color)
        (let ((output (find-output self id)))
          (when output
            (close-output self id output)))
      (let ((output (entity-output self id)))
        (set-background output background)
        (if (not slide?)
            (consume output color timestamp duration alpha)
          (let ((texture (get-texture (cache-quad-texture (get-pane output)))))
            (with-slide output texture
              (lambda ()
                (consume output color timestamp duration alpha))))))))
  
  
  (method package (render-outputs self)
    (unless (and render-hook
                 (render-hook self))
      (if (eq? video-layout 'focus)
          (let ((focused-output (effective-focused-output self)))
            (when focused-output
              (render focused-output)))
        (for-each render ordered-outputs))
      (when (and (eq? video-layout 'focus) video-interface?)
        (let ((focused-output (effective-focused-output self)))
          (for-each (lambda (output)
                      (unless (eq? output focused-output)
                        (render output)))
                    ordered-outputs)))))
  
  
  ;;;
  ;;;; Layout
  ;;;
  
  
  (method (on-cycle-layouts self evt)
    (let ((world (current-world)))
      (cycle-layouts self)
      (display-message world (capitalize (symbol->string video-layout)))))
  
  
  (method (cycle-layouts self)
    (case video-layout
      ((overhead)
       (sidebar-layout self))
      ((sidebar)
       (gallery-layout self))
      ((gallery)
       (circle-layout self))
      ((circle)
       (focus-layout self))
      ((circle)
       (gallery-layout self))))
  
  
  (method protected (update-layouts self)
    (case video-layout
      ((overhead)
       (overhead-layout self))
      ((sidebar)
       (sidebar-layout self))
      ((gallery)
       (gallery-layout self))
      ((circle)
       (circle-layout self))
      ((focus)
       (focus-layout self))))
  
  
  (method (stop-renders self)
    (let ((zone (current-zone)))
      (for-each (lambda (player)
                  (let ((elem (get-camera-pane player)))
                    (when elem
                      (set-render? elem #f))))
                (get-players zone))))
  
  
  (method public (goto-layout self layout)
    (case layout
      ((circle)
       (circle-layout self))
      ((focus)
       (focus-layout self))
      ((gallery)
       (gallery-layout self))))
  
  
  (method package (overhead-layout self)
    (stop-renders self)
    (set! video-layout 'overhead)
    (layout-outputs self))
  
  
  (method package (sidebar-layout self)
    (stop-renders self)
    (set! video-layout 'sidebar)
    (layout-outputs self))
  
  
  (method package (gallery-layout self)
    (set! video-layout 'gallery)
    (layout-outputs self))
  
  
  (method package (layout-outputs self)
    (when (not-null? ordered-outputs)
      (let ((rectangles (layout self (length ordered-outputs))))
        (when rectangles
          (for-each (lambda (output rect)
                      ;; quick hacks to test self video
                      (let ((player (or (get-player output) (current-me))))
                        (let ((elem (get-camera-pane player)))
                          (if (not rect)
                              (when elem
                                (set-render? elem #f))
                            (when elem
                              (set-render? elem #t))
                            (move output rect)
                            (update-panes output)))))
                    ordered-outputs
                    rectangles)))))
  
  
  (method package (layout self num-players)
    (let ((window (current-window)))
      (let ((bounds (get-bounds window)))
        (let ((l (get-left bounds))
              (t (get-top bounds))
              (r (get-right bounds))
              (b (get-bottom bounds)))
          (case video-layout
            ((sidebar)
             (layout-tiles num-players (new Rect 10 70 210 (- b 100))))
            ((gallery)
             (let ((focused (focused-rect bounds)))
               (if (= num-players 1)
                   (list (adjust-focused bounds focused))
                 (reverse (layout-tiles num-players bounds)))))
            (else
             #f))))))
  
  
  (method package (circle-layout self)
    (set! video-layout 'circle)
    (update-circle-layout self))
  
  
  (method package (focus-layout self)
    (set! video-layout 'focus)
    (update-circle-layout self)
    (let ((focused-output (effective-focused-output self)))
      (when focused-output
        (move-focused focused-output))))
  
  
  (method (update-circle-layout self)
    (let ((count (length ordered-outputs)))
      (assert layout-circle-hook
        (with-safe-hook layout-circle-hook
          (lambda (procedure)
            (let ((matrices (procedure ordered-outputs)))
              (for-each (lambda (output placement)
                          (bind (translation . rotation) placement
                            (set-translation output translation)
                            (set-rotation output rotation)
                            (update-matrices output count)
                            (update-panes output)))
                        ordered-outputs
                        matrices)))))))
  
  
  (method protected (update-interface-matrices self)
    (let ((count (length ordered-outputs)))
      (for-each (lambda (output)
                  (update-interface-matrix output count))
                ordered-outputs))))


;;;
;;;; Video-Src
;;;


(class Video-Src extends Stream-Src
  
  
  (slot appsink               initialize #f accessors generate)
  (slot appsinkself           initialize #f accessors generate)
  (slot data     <u8vector+>  initialize #f accessors generate)
  (slot info     <u64vector+> initialize #f accessors generate)
  (slot task                  initialize #f accessors generate)
  (slot fifo                  initialize #f accessors generate)
  (slot selfdata <u8vector+>  initialize #f accessors generate)
  (slot selfinfo <u64vector+> initialize #f accessors generate)
  (slot selffifo              initialize #f accessors generate)
  
  
  (method package virtual (start-fifos self)
    (when fifo
      (start-stream-fifo fifo))
    (when selffifo
      (start-stream-fifo selffifo)))
  
  
  (method package virtual (stop-fifos self)
    (when fifo
      (stop-stream-fifo fifo))
    (when selffifo
      (stop-stream-fifo selffifo)))
  
  
  (method (task-start self name)
    (let ((procedure
            (lambda (task)
              (video-loop self task))))
      (let ((task (new Task name procedure priority: video-priority)))
        (start-fifos self)
        (start-task task)
        (set! self.task task))))
  
  
  (method (task-stop self)
    (stop-fifos self)
    (stop-task task)
    (set! task #f))
  
  
  (method protected virtual (video-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (if (stopping? task)
              (task-done task exit)
            (process self task exit)
            (task-halt task exit)
            (iter))))))
  
  
  (method override (process self task exit)
    (let ((size (gst_app_sink_wait task exit fifo appsink data info (reset-action self) (eos-action self)))
          (selfsize (and appsinkself (gst_app_sink_wait task exit selffifo appsinkself selfdata selfinfo #f #f))))
      (site (video on?: #t)
        (let ((buffer (subu8vector data 0 size))
              (timestamp (u64vector-ref info 0))
              (duration (u64vector-ref info 1)))
          (when (and video-show
                     (or (eq? video-show 'all)
                         (eq? video-show 'header)
                         (>= size video-show)))
            ;; h264 specific
            (let ((type (if (video-buffer-header? buffer)
                            '***header***
                          'delta)))
              (if (eq? video-show 'header)
                  (when (eq? type '***header***)
                    (terminal size type))
                (terminal size type))))
          (consume sink buffer timestamp duration)
          (record-event udp-id-src-media
                        -1.
                        (fixnum->flonum client-no)
                        (fixnum->flonum world.udp:udp-video)
                        -1.
                        (if (video-buffer-header? buffer) 1. -1.)
                        (fixnum->flonum size)
                        (timestamp->flonum timestamp)))
        (when selfsize
          (let ((buffer (subu8vector selfdata 0 selfsize))
                (timestamp (u64vector-ref selfinfo 0))
                (duration (u64vector-ref selfinfo 1)))
            (consume sinkself buffer timestamp duration)
            (record-event udp-id-src-self
                          -1.
                          (fixnum->flonum client-no)
                          (fixnum->flonum world.udp:udp-video)
                          -1.
                          -1.
                          (fixnum->flonum selfsize)
                          (timestamp->flonum timestamp)))))))
  
  
  (method protected virtual (reset-action self)
    #f)
  
  
  (method protected virtual (eos-action self)
    #f))


;;;
;;;; Camera-Video-Src
;;;


(class Camera-Video-Src extends Video-Src
  
  
  (slot resolution initialize #f accessors generate)
  (slot framerate  initialize #f accessors generate)
  (slot bitrate    initialize #f accessors generate)
  (slot codec      initialize #f accessors generate)
  (slot pipeline   initialize #f accessors generate)
  
  
  (method override (initialize self (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f))
    (nextmethod self)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (get-width resolution))
          (height (get-height resolution))
          (self-width (get-width self-resolution))
          (self-height (get-height self-resolution))
          (fifo (open-stream-fifo "camera"))
          (selffifo (open-stream-fifo "cameraself")))
      (let ((pipeline (gst-launch (cond-expand
                                    (mac "avfvideosrc")
                                    (windows "ksvideosrc")
                                    (else "v4l2src"))
                                  (tie "videorate max-rate={framerate}")
                                  "videoscale"
                                  "videoconvert"
                                  ;; this tie is there so the camera knows what resolution to use
                                  (tie "video/x-raw, width=1280, height=720, pixel-aspect-ratio=(fraction)1/1")
                                  "tee name=tee"
                                  (list
                                    "tee."
                                    "queue"
                                    "videoscale"
                                    "videoconvert"
                                    (tie "video/x-raw, format=I420, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                    "valve name=valve"
                                    (and (eq? codec 'h264)
                                         (let ((key-int-max (and video-key-period (fxround (* (cast <fl> framerate) video-key-period))))
                                               (pass video-pass)
                                               (psy-tune #f)
                                               (quantizer #f)
                                               (bitrate bitrate)
                                               (tune "zerolatency")
                                               (speed-preset "superfast"))
                                           (gst-element "x264enc"
                                                        key-int-max: key-int-max
                                                        pass: pass
                                                        psy-tune: psy-tune
                                                        quantizer: quantizer
                                                        bitrate: bitrate
                                                        tune: tune
                                                        speed-preset: speed-preset
                                                        name: "enc")))
                                    "appsink name=sink")
                                  (list
                                    "tee."
                                    "queue"
                                    "videoscale"
                                    "videoconvert"
                                    (tie "video/x-raw, format=BGRA, width={self-width}, height={self-height}, pixel-aspect-ratio=(fraction)1/1")
                                    "videoflip video-direction=horiz"
                                    "appsink name=sinkself"))))
        (gst_object_set_name pipeline "camera")
        (let ((appsink (gst_bin_get_by_name pipeline "sink"))
              (appsinkself (gst_bin_get_by_name pipeline "sinkself"))
              (data (make-u8vector (* width height 4)))
              (info (make-u64vector 2))
              (selfdata (make-u8vector (* self-width self-height 4)))
              (selfinfo (make-u64vector 2)))
          (gst_app_sink_connect_signals appsink fifo)
          (gst_app_sink_connect_signals appsinkself selffifo)
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.data data)
          (set! self.info info)
          (set! self.pipeline pipeline)
          (set! self.fifo fifo)
          (set! self.selffifo selffifo)
          (set! self.appsink appsink)
          (set! self.appsinkself appsinkself)
          (set! self.selfdata selfdata)
          (set! self.selfinfo selfinfo)))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'camera)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! info #f)
    (set! data #f)
    (set! pipeline #f)
    (set! appsink #f)
    (consume sink #f #f #f)
    (close-stream-fifo fifo)
    (set! fifo #f)
    (when selffifo
      (close-stream-fifo selffifo)
      (set! selffifo #f)))
  
  
  (method override (reset-cooldown self)
    1.)
  
  
  (method override (reset-media self channel)
    (gst_fifo_reset (get-write-file fifo)))
  
  
  (method override (reset-action self)
    (lambda ()
      (when pipeline
        (let ((valve (gst_bin_get_by_name pipeline "valve"))
              (encoder (gst_bin_get_by_name pipeline "enc")))
          (g_object_set valve "drop" (g_value_int 1))
          (gst_element_set_state encoder GST_STATE_READY)
          (gst_element_set_state encoder GST_STATE_PLAYING)
          (g_object_set valve "drop" (g_value_int 0)))))))


;;;
;;;; Screen-Video-Src
;;;


(class Screen-Video-Src extends Video-Src
  
  
  (slot resolution initialize #f accessors generate)
  (slot framerate  initialize #f accessors generate)
  (slot bitrate    initialize #f accessors generate)
  (slot codec      initialize #f accessors generate)
  (slot pipeline   initialize #f accessors generate)
  
  
  (method override (initialize self (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f))
    (nextmethod self)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (get-width resolution))
          (height (get-height resolution))
          (fifo (open-stream-fifo "screen")))
      (let ((pipeline (gst-launch (cond-expand
                                    (mac "avfvideosrc capture-screen=true")
                                    (windows "dx9screencapsrc")
                                    (else "v4l2src"))
                                  (tie "videorate max-rate={framerate}")
                                  "videoscale"
                                  "videoconvert"
                                  ;; this tie is there so the camera knows what resolution to use
                                  (tie "video/x-raw, width=1280, height=720, pixel-aspect-ratio=(fraction)1/1")
                                  "videoscale"
                                  "videoconvert"
                                  (tie "video/x-raw, format=I420, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                  "valve name=valve"
                                  (and (eq? codec 'h264)
                                       (let ((key-int-max (and video-key-period (fxround (* (cast <fl> framerate) video-key-period))))
                                             (pass video-pass)
                                             (psy-tune #f)
                                             (quantizer #f)
                                             (bitrate bitrate)
                                             (tune "zerolatency")
                                             (speed-preset "superfast"))
                                         (gst-element "x264enc"
                                                      key-int-max: key-int-max
                                                      pass: pass
                                                      psy-tune: psy-tune
                                                      quantizer: quantizer
                                                      bitrate: bitrate
                                                      tune: tune
                                                      speed-preset: speed-preset
                                                      name: "enc")))
                                  "appsink name=sink")))
        (gst_object_set_name pipeline "screen")
        (let ((appsink (gst_bin_get_by_name pipeline "sink"))
              (data (make-u8vector (* width height 4)))
              (info (make-u64vector 2)))
          (gst_app_sink_connect_signals appsink fifo)
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.data data)
          (set! self.info info)
          (set! self.pipeline pipeline)
          (set! self.fifo fifo)
          (set! self.appsink appsink)))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'screen)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! info #f)
    (set! data #f)
    (set! pipeline #f)
    (set! appsink #f)
    (consume sink #f #f #f)
    (close-stream-fifo fifo)
    (set! fifo #f))
  
  
  (method override (reset-cooldown self)
    1.)
  
  
  (method override (reset-media self channel)
    (gst_fifo_reset (get-write-file fifo)))
  
  
  (method override (reset-action self)
    (lambda ()
      (when pipeline
        (let ((valve (gst_bin_get_by_name pipeline "valve"))
              (encoder (gst_bin_get_by_name pipeline "enc")))
          (g_object_set valve "drop" (g_value_int 1))
          (gst_element_set_state encoder GST_STATE_READY)
          (gst_element_set_state encoder GST_STATE_PLAYING)
          (g_object_set valve "drop" (g_value_int 0)))))))


;;;
;;;; Test-Video-Src
;;;


(class Test-Video-Src extends Video-Src
  
  
  (slot resolution initialize #f accessors generate)
  (slot framerate  initialize #f accessors generate)
  (slot bitrate    initialize #f accessors generate)
  (slot codec      initialize #f accessors generate)
  (slot pipeline   initialize #f accessors generate)
  
  
  (method override (initialize self (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f))
    (nextmethod self)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (get-width resolution))
          (height (get-height resolution))
          (fifo (open-stream-fifo "testvideo")))
      (let ((pipeline (gst-launch "videotestsrc"
                                  "videoscale"
                                  "videoconvert"
                                  (tie "video/x-raw, format=I420, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                  (and (eq? codec 'h264) (tie "x264enc pass=qual quantizer=20 bitrate={bitrate} tune=zerolatency speed-preset=superfast"))
                                  "appsink name=sink")))
        (gst_object_set_name pipeline "test")
        (let ((appsink (gst_bin_get_by_name pipeline "sink"))
              (data (make-u8vector (* width height 4)))
              (info (make-u64vector 2)))
          (gst_app_sink_connect_signals appsink fifo)
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.data data)
          (set! self.info info)
          (set! self.pipeline pipeline)
          (set! self.appsink appsink)))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'test)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! info #f)
    (set! data #f)
    (set! pipeline #f)
    (set! appsink #f)
    (consume sink #f #f #f)
    (close-stream-fifo fifo)
    (set! fifo #f)))


;;;
;;;; File-Preprocess-Video-Src
;;;


(class File-Preprocess-Video-Src extends Video-Src
  
  
  (slot location   initialize #f accessors generate)
  (slot resolution initialize #f accessors generate)
  (slot framerate  initialize #f accessors generate)
  (slot bitrate    initialize #f accessors generate)
  (slot codec      initialize #f accessors generate)
  (slot pipeline   initialize #f accessors generate)
  
  
  (method override (initialize self location (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f))
    (nextmethod self)
    (set! self.location location)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (get-width resolution))
          (height (get-height resolution))
          (fifo (open-stream-fifo "preprocessvideo")))
      (let ((pipeline (gst-launch (tie "filesrc name=filesrc")
                                  "decodebin"
                                  (and framerate (tie "videorate max-rate={framerate}"))
                                  "videoscale"
                                  "videoconvert"
                                  (tie "video/x-raw, format=I420, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                  (let ((bitrate bitrate)
                                        (tune "zerolatency")
                                        (speed-preset "superfast"))
                                    (gst-element "x264enc"
                                                 bitrate: bitrate
                                                 tune: tune
                                                 speed-preset: speed-preset
                                                 name: "enc"))
                                  "appsink name=appsink sync=false")))
        (gst_object_set_name pipeline "file")
        (let ((filesrc (gst_bin_get_by_name pipeline "filesrc"))
              (appsink (gst_bin_get_by_name pipeline "appsink"))
              (data (make-u8vector (* width height 4)))
              (info (make-u64vector 2)))
          (gst_app_sink_connect_signals appsink fifo)
          (g_object_set_string filesrc "location" (path-normalize location))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.data data)
          (set! self.info info)
          (set! self.fifo fifo)
          (set! self.pipeline pipeline)
          (set! self.appsink appsink)))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'file)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! info #f)
    (set! data #f)
    (set! pipeline #f)
    (set! appsink #f)
    (consume sink #f #f #f)
    (close-stream-fifo fifo)
    (set! fifo #f))
  
  
  (method override (eos-action self)
    (lambda ()
      (consume sink #f #f #f)))
  
  
  (method override (video-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (if (stopping? task)
              (task-done task exit)
            (site (preprocess on?: #t)
              (process self task exit))
            (task-sleep task .001 exit)
            (iter)))))))


;;;
;;;; File-Stream-Video-Src
;;;


(class File-Stream-Video-Src extends Video-Src
  
  
  (slot location  getter generate)
  (slot file      getter generate)
  (slot port      getter generate)
  (slot time-base getter generate)
  
  
  (method override (initialize self location)
    (nextmethod self)
    (set! self.location location)
    (set! self.file #f)
    (set! self.port #f)
    (set! self.time-base (new Time-Base)))
  
  
  (method override (start-element self)
    (nextmethod self)
    (set! file (new-file {Directory Settings} (list "streams" (add-extension location "streamvideo"))))
    (set! port (open-input-file (path-settings file)))
    (task-start self 'video-stream))
  
  
  (method override (play-element self)
    (nextmethod self)
    (task-wakeup (get-thread task)
      (lambda (exit)
        )))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (task-wakeup (get-thread task)
      (lambda (exit)
        (task-sleep task +inf.0 exit))))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (close port)
    (set! file #f)
    (set! port #f))
  
  
  (method override (video-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (if (stopping? task)
              (task-done task exit)
            (receive (buffer timestamp duration) (read-frame port)
              (if (not buffer)
                  (task-done task exit)
                (let ((time (current-seconds))
                      (nanostamp (timestamp->flonum timestamp)))
                  (update-start time-base time nanostamp)
                  (let ((sendtime (remote->local time-base nanostamp)))
                    (task-sleep task (- sendtime time) exit)
                    (site (stream on?: #t)
                      (consume sink buffer timestamp duration)))))))
          (iter))))))


;;;
;;;; Draw-Video-Src
;;;


(class Draw-Video-Src extends Video-Src
  
  
  (slot draw-proc  initialize #f accessors generate)
  (slot start-time initialize #f accessors generate)
  (slot resolution initialize #f accessors generate)
  (slot context    initialize #f accessors generate)
  
  
  (method override (initialize self (draw-proc: draw-proc #f))
    (nextmethod self)
    (set! self.draw-proc draw-proc)
    (set! self.resolution video-resolution))
  
  
  (method protected virtual (new-draw-context self)
    (new Draw-Context video-resolution video-framerate video-bitrate))
  
  
  (method override (start-element self)
    (nextmethod self)
    (set! context (new-draw-context self))
    (set! start-time (current-seconds))
    (task-start self 'draw))
  
  
  (method override (play-element self)
    (nextmethod self))
  
  
  (method override (pause-element self)
    (nextmethod self))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (free-context self))
  
  
  (method (free-context self)
    (when context
      (close context)
      (set! context #f)))
  
  
  (method override (video-loop self task)
    (declare (proper-tail-calls))
    (let ((tier (current-client)))
      (with-task task
        (lambda (exit)
          (let (iter)
          (if (stopping? task)
              (task-done task exit)
            (let ((surface (get-surface context)))
              (draw-stream self surface)
              (receive (color alpha timestamp duration) (extract context task exit)
                (site (stream on?: #t)
                  (let ((effective-timestamp (flonum->timestamp (- (current-seconds) start-time))))
                    (consume sink color effective-timestamp duration)))))
            (task-sleep task .1 exit)
            (iter)))))))
  
  
  (method protected virtual (draw-stream self surface)
    (clear surface)
    (when draw-proc
      (draw-proc surface resolution))))


;;;
;;;; Image-Stream-Video-Src
;;;


(class Image-Stream-Video-Src extends Draw-Video-Src
  
  
  (slot location      getter generate)
  (slot file          getter generate)
  (slot color         getter generate)
  (slot alpha         getter generate)
  (slot timestamp     getter generate)
  (slot duration      getter generate)
  (slot extract-mutex getter generate)
  
  
  (method override (initialize self location)
    (nextmethod self)
    (set! self.location location)
    (set! self.file (new-file {Directory Settings} (list "streams" location)))
    (set! self.color #f)
    (set! self.alpha #f)
    (set! self.timestamp #f)
    (set! self.duration #f)
    (set! self.extract-mutex (make-mutex 'extract)))
  
  
  (method override (new-draw-context self)
    (new Draw-Context video-resolution video-framerate video-bitrate tune: (bitwise-ior stillimage zerolatency)))
  
  
  (method (extract/cache self task exit)
    (mutex-lock! extract-mutex)
    (prog1
        (if color
            (values color alpha timestamp duration)
          (let ((surface (get-surface context)))
            (draw-stream self surface)
            (receive (color alpha timestamp duration) (extract context task exit)
              (set! self.color color)
              (set! self.alpha alpha)
              (set! self.timestamp timestamp)
              (set! self.duration duration)
              (values color alpha timestamp duration))))
      (mutex-unlock! extract-mutex)))
  
  
  (method override (video-loop self task)
    (declare (proper-tail-calls))
    (let ((tier (current-client)))
      (with-task task
        (lambda (exit)
          (receive (color alpha timestamp duration) (extract/cache self task exit)
            (site (stream on?: #t)
              (let ((effective-timestamp (flonum->timestamp (- (current-seconds) start-time))))
                (consume sink color effective-timestamp duration))))
          (free-context self)
          (continuation-return exit #f)))))
  
  
  (method override (draw-stream self surface)
    (fill-image surface
                (new Rect 0 0 (get-width resolution) (get-height resolution))
                (new Image moniker: file)
                mode: 'fill))
  
  
  (method override (reset-media self channel)
    (receive (color alpha timestamp duration) (extract/cache self task exit)
      (let ((effective-timestamp (flonum->timestamp (- (current-seconds) start-time))))
        (consume sink color effective-timestamp duration)))))


;;;
;;;; Self-Sink
;;;


(class Self-Sink extends Stream-Sink
  
  
  (slot self-output initialize #f getter generate)
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((video (current-video))
          (me (current-me)))
      (set! self-output (player-output video #f player: me))
      (invalidate-state self-output)))
  
  
  (method override (release-element self)
    (let ((video (current-video)))
      (close-output video #f self-output)
      (set-stream-state self-output 'off))
    (nextmethod self))
  
  
  (method override (consume self buffer timestamp duration)
    (if (not buffer)
        (set-stream-state self-output 'off)
      (set-stream-state self-output 'drawn)
      (draw self-output buffer #f timestamp duration))))


;;;
;;;; Video-Sink
;;;


(class Video-Sink extends Stream-Sink
  
  
  (slot resolution                  initialize #f accessors generate)
  (slot framerate                   initialize #f accessors generate)
  (slot bitrate                     initialize #f accessors generate)
  (slot codec                       initialize #f accessors generate)
  (slot flip                        initialize #f accessors generate)
  (slot process?                    initialize #f accessors generate)
  (slot alpha-overlay               initialize #f accessors generate)
  (slot overlay?                    initialize #f accessors generate)
  (slot color-pipeline              initialize #f accessors generate)
  (slot color-appsrc                initialize #f accessors generate)
  (slot color-appsink               initialize #f accessors generate)
  (slot color-data     <u8vector+>  initialize #f accessors generate)
  (slot color-info     <u64vector+> initialize #f accessors generate)
  (slot color-fifo                  initialize #f accessors generate)
  (slot alpha?                      initialize #f accessors generate)
  (slot alpha-pipeline              initialize #f accessors generate)
  (slot alpha-appsrc                initialize #f accessors generate)
  (slot alpha-appsink               initialize #f accessors generate)
  (slot alpha-data     <u8vector+>  initialize #f accessors generate)
  (slot alpha-info     <u64vector+> initialize #f accessors generate)
  (slot alpha-fifo                  initialize #f accessors generate)
  (slot image-surface               initialize #f accessors generate)
  (slot image-inhibit?              initialize #f accessors generate)
  (slot task                        initialize #f accessors generate)
  (slot stream-state                initialize 'off getter generate setter explicit)
  (slot frame-count                 initialize #f)
  (slot frame-start                 initialize #f)
  (slot total-size                  initialize #f)
  
  
  (method override (initialize self (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f) (flip: flip #f) (process?: process? #t) (alpha-overlay: alpha-overlay #f) (overlay?: overlay? #f) (alpha?: alpha? #f))
    (nextmethod self)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec)
    (set! self.flip flip)
    (set! self.process? process?)
    (set! self.alpha-overlay alpha-overlay)
    (set! self.overlay? overlay?)
    (set! self.alpha? alpha?))
  
  
  (method package virtual (start-fifos self)
    (when color-fifo
      (start-stream-fifo color-fifo))
    (when alpha-fifo
      (start-stream-fifo alpha-fifo)))
  
  
  (method package virtual (stop-fifos self)
    (when color-fifo
      (stop-stream-fifo color-fifo))
    (when alpha-fifo
      (stop-stream-fifo alpha-fifo)))
  
  
  (method package virtual (resize self)
    )
  
  
  (method package virtual (move self rect)
    )
  
  
  (method package virtual (focus self)
    )
  
  
  (method package virtual (unfocus self)
    )
  
  
  (method package (set-stream-state self state)
    (when (neq? state stream-state)
      (set! stream-state state)
      (invalidate-state self)))
  
  
  (method package virtual (invalidate-state self)
    )
  
  
  (method package virtual (setup-pipeline self)
    (when process?
      (let ((width (get-width resolution))
            (height (get-height resolution)))
        (let ((fifo (open-stream-fifo "videocolor"))
              (pipeline (gst-launch (tie "appsrc name=src")
                                    (and (eq? codec 'h264) (tie "avdec_h264"))
                                    "videoscale"
                                    "videoconvert"
                                    (and flip (tie "videoflip video-direction={flip}"))
                                    (and alpha-overlay (tie "alpha alpha={alpha-overlay}"))
                                    (tie "video/x-raw, format=BGRA, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                    (tie "appsink name=sink"))))
          (gst_object_set_name pipeline "output")
          (let ((appsrc (gst_bin_get_by_name pipeline "src"))
                (appsink (gst_bin_get_by_name pipeline "sink"))
                (data (make-u8vector (* width height 4)))
                (info (make-u64vector 2)))
            (gst_app_sink_connect_signals appsink fifo)
            (case codec
              ((h264)
               (gst_app_src_set_caps appsrc
                                     (gst_caps "video/x-h264"
                                               "width"         (g_value_int width)
                                               "height"        (g_value_int height)
                                               "framerate"     (g_value_fraction framerate 1)
                                               "stream-format" (g_value_string "avc")
                                               "alignment"     (g_value_string "au"))))
              (else
               (gst_app_src_set_caps appsrc
                                     (gst_caps "video/x-raw"
                                               "format"    (g_value_string "I420")
                                               "width"     (g_value_int width)
                                               "height"    (g_value_int height)
                                               "framerate" (g_value_fraction framerate 1)))))
            (g_object_set appsrc
                          "is-live"     (g_value_boolean #t)
                          "stream-type" (g_value_int GST_APP_STREAM_TYPE_STREAM)
                          "format"      (g_value_int GST_FORMAT_TIME))
            (gst_element_set_state pipeline GST_STATE_READY)
            (set! self.color-data data)
            (set! self.color-info info)
            (set! self.color-pipeline pipeline)
            (set! self.color-appsrc appsrc)
            (set! self.color-appsink appsink)
            (set! self.color-fifo fifo)))
        (when alpha?
          (let ((fifo (open-stream-fifo "videoalpha"))
                (pipeline (gst-launch "appsrc name=src"
                                      "avdec_h264 name=dec"
                                      "appsink name=sink")))
            (gst_object_set_name pipeline "output")
            (let ((appsrc (gst_bin_get_by_name pipeline "src"))
                  (appsink (gst_bin_get_by_name pipeline "sink"))
                  (data (make-u8vector (/ (* width height 12) 8)))
                  (info (make-u64vector 2)))
              (gst_app_sink_connect_signals appsink fifo)
              (gst_app_src_set_caps appsrc
                                    (gst_caps "video/x-h264"
                                              "width"         (g_value_int width)
                                              "height"        (g_value_int height)
                                              "framerate"     (g_value_fraction framerate 1)
                                              "stream-format" (g_value_string "avc")
                                              "alignment"     (g_value_string "au")))
              (g_object_set appsrc
                            "is-live"     (g_value_boolean #t)
                            "stream-type" (g_value_int GST_APP_STREAM_TYPE_STREAM)
                            "format"      (g_value_int GST_FORMAT_TIME))
              (gst_element_set_state pipeline GST_STATE_READY)
              (set! self.alpha-data data)
              (set! self.alpha-info info)
              (set! self.alpha-pipeline pipeline)
              (set! self.alpha-appsrc appsrc)
              (set! self.alpha-appsink appsink)
              (set! self.alpha-fifo fifo)
              (set! self.image-surface (new Image-Surface (new Dimension width height)))))))))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (setup-pipeline self))
  
  
  (method (task-start self name)
    (let ((procedure
            (lambda (task)
              (video-loop self task))))
      (let ((task (new Task name procedure priority: video-priority)))
        (start-fifos self)
        (start-task task)
        (set! self.task task))))
  
  
  (method (task-stop self)
    (stop-fifos self)
    (stop-task task)
    (set! task #f))
  
  
  (method override (start-element self)
    (nextmethod self)
    (when process?
      (task-start self 'video-output)
      (gst_element_set_state color-pipeline GST_STATE_PAUSED)
      (when alpha?
        (gst_element_set_state alpha-pipeline GST_STATE_PAUSED))))
  
  
  (method override (play-element self)
    (nextmethod self)
    (when process?
      (gst_element_set_state color-pipeline GST_STATE_PLAYING)
      (when alpha?
        (gst_element_set_state alpha-pipeline GST_STATE_PLAYING))))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (when process?
      (gst_element_set_state color-pipeline GST_STATE_PAUSED)
      (when alpha?
        (gst_element_set_state alpha-pipeline GST_STATE_PAUSED))))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (when process?
      (gst_element_set_state color-pipeline GST_STATE_READY)
      (when alpha?
        (gst_element_set_state alpha-pipeline GST_STATE_READY))
      (task-stop self)))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when process?
      (gst_element_release color-pipeline)
      (set! color-info #f)
      (set! color-data #f)
      (set! color-pipeline #f)
      (set! color-appsrc #f)
      (set! color-appsink #f)
      (close-stream-fifo color-fifo)
      (set! color-fifo #f)
      (when alpha?
        (gst_element_release alpha-pipeline)
        (close image-surface)
        (set! alpha-info #f)
        (set! alpha-data #f)
        (set! alpha-pipeline #f)
        (set! alpha-appsrc #f)
        (set! alpha-appsink #f)
        (set! image-surface #f)
        (close-stream-fifo alpha-fifo)
        (set! alpha-fifo #f))
      (set-stream-state self 'off)))
  
  
  (method override (consume self color timestamp duration (alpha #f))
    ;; QUICK TEST
    (when color-appsrc
    ;; QUICK TEST
      (when color
        (gst_app_src_write_u8vector color-appsrc color (u8vector-length color) timestamp duration)))
    (when alpha?
      ;; QUICK TEST
      (when alpha-appsrc
        ;; QUICK TEST
        (when alpha
          (gst_app_src_write_u8vector alpha-appsrc alpha (u8vector-length alpha) timestamp duration)))))
  
  
  (method (video-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (if (stopping? task)
              (task-done task exit)
            (process self task exit)
            (task-halt task exit)
            (iter))))))
  
  
  (method override (process self task exit)
    (let ((color-bytes (gst_app_sink_wait task exit color-fifo color-appsink color-data color-info #f #f))
          (alpha-bytes (and alpha? (gst_app_sink_wait task exit alpha-fifo alpha-appsink alpha-data alpha-info #f #f))))
      (site (video-output on?: #t)
        (let ((timestamp (u64vector-ref color-info 0))
              (duration (u64vector-ref color-info 1)))
          (draw self color-data (and alpha? alpha-data) timestamp duration)
          (when (eq? stream-state 'on)
            (set-stream-state self 'drawn))))))
  
  
  (method package virtual (draw self color alpha timestamp duration)
    )
  
  
  (method package virtual (add-overlay self color alpha texture)
    (when overlay?
      (if (not frame-count)
          (begin
            (set! frame-count 1)
            (set! frame-start (current-seconds))
            (set! total-size (u8vector-length color)))
        (increase! frame-count)
        (increase! total-size (u8vector-length color))
        (let ((elapse (- (current-seconds) frame-start)))
          (let ((rate (/ (cast <fl> frame-count) elapse))
                (size (/ (cast <fl> total-size) frame-count))
                (surface (get-surface texture)))
            (set-font surface {Font font-name: tahoma point-size: 24 hint-style: slight hint-metrics: on})
            (draw-text surface 5 (- (get-height resolution) 30) (format "Rate: {r precision: 3}, Size: {a}" rate size) {Color World-Red}))))))
  
  
  (method package (update self color alpha texture (background: background #f))
    (if (not alpha?)
        (if speakers-xp?
            (if (eq? (effective-focused-output (current-video)) self)
                (move-u8vector->pointer! color (get-data texture))
              (let ((width (get-width resolution))
                    (height (get-height resolution)))
                (add-alpha color .6 (get-data texture) (* width height))))
          (move-u8vector->pointer! color (get-data texture)))
      (let ((width (get-width resolution))
            (height (get-height resolution))
            (data (cairo_image_surface_get_data (get-handle image-surface))))
        (cairo_surface_flush (get-handle image-surface))
        (combine-alpha color alpha data (* width height))
        (cairo_surface_mark_dirty (get-handle image-surface))
        (unless image-inhibit?
          (let ((surface (get-surface texture)))
            (clear-glass surface resolution background: background)
            (draw-surface surface image-surface 0 0)))))
    (add-overlay self color alpha texture)
    (unless image-inhibit?
      (map-texture texture)))
  
  
  (method package virtual (render self)
    )
  
  
  (method (with-slide self texture thunk)
    (set! image-inhibit? #t)
    (thunk)
    (let ((height (cast <fl> (get-height resolution))))
      (let ((delta (/ height render-rate slide-duration))
            (surface (get-surface texture)))
        (thread-start!
          (new-thread
            (lambda ()
              (let (loop (slide (- height delta)))
                (let ((slide (max 0. slide)))
                  (let ((done? (<= slide 0.)))
                    (with-task-mutex
                      (lambda ()
                        (if (not image-surface)
                            (set! done? #t)
                          (translate surface 0 slide)
                          (clear-glass surface resolution)
                          (draw-surface surface image-surface 0 0)
                          (translate surface 0 (- slide))
                          (map-texture texture))
                        (when done?
                          (set! image-inhibit? #f))))
                    (when (not done?)
                      (sleep render-period)
                      (loop (- slide delta)))))))
            'slide))))))


;;;
;;;; Draw-Video-Sink
;;;


(class Draw-Video-Sink extends Video-Sink
  
  
  (slot entity     initialize #f accessors generate)
  (slot pane       initialize #f accessors generate)
  (slot background initialize #f accessors generate)
  
  
  (method override (initialize self ent . rest)
    (apply nextmethod self alpha?: #t rest)
    (let ((p (cache-draw-pane ent (list (eq? ent (current-me)) resolution))))
      (set! entity ent)
      (set! pane p)))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when entity
      (set-draw-pane entity #f)
      (set! entity #f)
      (set! pane #f)))
  
  
  (method override (draw self color alpha timestamp duration)
    ;; quicky
    (when pane
      (update self color alpha (get-texture (cache-quad-texture pane)) background: background)))
  
  
  (method override (render self)
    ;; nothing to do render done by player pane
    ))


;;;
;;;; Event-View
;;;


(class Event-View extends View)


(definition public (make-event-view)
  (let ((view (new Event-View)))
    (define (mouse-down event)
      (debug 'mouse-down))
    
    (define (mouse-up event)
      (debug 'mouse-up))
    
    (define (key-press event)
      (debug 'key-press))
    
    (set-mouse-down-handler view mouse-down)
    (set-mouse-up-handler view mouse-up)
    (set-key-press-handler view key-press)
    view))


(definition public (make-view . rest)
  (apply new View rest))


;;;
;;;; Draw-Pane
;;;


(definition public (make-draw-pane entity info)
  (let ((expanse {Dimension$fl$ 6. 3.375})
        (resolution {Dimension 1280 720}))
    (let ((pane (new Draw-Pane
                  title: "Draw"
                  expanse: expanse
                  resolution: resolution
                  billboard: info
                  entity: entity)))
      (cond ((is? info View)
             (set-root pane info)
             (set-position info {Point 0 0})
             (set-size info resolution)
             pane)
            (else
             pane)))))


@c4
(definition public (make-c4-pane entity billboard)
  (let ((size {Dimension$fl$ 3.6363636363636362 3.})
        (resolution {Dimension 660 600}))
    (let ((pane (new Script-Pane
                  size: size
                  resolution: resolution
                  billboard: billboard
                  entity: entity))
          (view (new jazz.sample.c4:C4-Board position: {Point 0 0} size: resolution background: #f)))
      (set-root pane view)
      (let ((pos (center (get-size view) resolution)))
        (set-position view pos))
      pane)))
  
  
  @c4
  (method override (draw self surface)
    (let ((width (get-width resolution))
          (height (get-height resolution)))
      (let ((rect (new Rect 0 0 width height))
            (color {Color red: .000 green: .000 blue: .200 alpha: .3}))
        (clear surface)
        (fill-rect surface rect color)
        (frame-rect surface rect color)
        (paint-drawing root surface '())))
    (when quad-texture
      (map-texture (get-texture quad-texture))))


(class Draw-Pane extends Entity-Pane)


;;;
;;;; Overhead-Video-Sink
;;;


(class Overhead-Video-Sink extends Video-Sink
  
  
  (slot player initialize #f accessors generate)
  (slot pane   initialize #f accessors generate)
  
  
  (method override (initialize self entity . rest)
    (apply nextmethod self rest)
    (let ((p (cache-camera-pane entity (list (eq? entity (current-me)) resolution))))
      (set! player entity)
      (set! pane p)))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when player
      (set-camera-pane player #f)
      (set! player #f)
      (set! pane #f)))
  
  
  (method override (draw self color alpha timestamp duration)
    (update self color alpha (get-texture (cache-quad-texture pane))))
  
  
  (method override (render self)
    ;; nothing to do render done by player pane
    ))


;;;
;;;; Camera-Pane
;;;


(definition public (make-camera-pane billboard)
  (bind (me? resolution) billboard
    (new Camera-Pane
      title: "Camera"
      expanse: (new Dimension$fl$ 1. .5625)
      resolution: resolution
      billboard: billboard)))


(class Camera-Pane extends World-Pane
  
  
  (method override (draw self surface)
    (clear surface)))


;;;
;;;; Sheet-Video-Sink
;;;


(class Sheet-Video-Sink extends Video-Sink
  
  
  (slot player     initialize #f accessors generate)
  (slot sheet      initialize #f accessors generate)
  (slot draw-mode  initialize #f accessors generate)
  (slot draw-mutex initialize #f accessors generate)
  (slot last-color initialize #f accessors generate)
  
  
  (method override (initialize self entity . rest)
    (bind-keywords ((position #f) (size #f) . others) rest
      (apply nextmethod self others)
      (let ((world (current-world)))
        (let ((pos (or position {Point 0 0}))
              (size (or size {Dimension 320 180})))
          (let ((s (make-world-sheet 'video World-Sheet size resolution: resolution retina?: #f)))
            (make-orthographic-matrix! (get-projection-matrix s) 0. (get-width world) 0. (get-height world) 0. 10.)
            (set-position s pos)
            (set-size s size)
            (set! self.player entity)
            (set! self.sheet s)
            (set! self.draw-mode 'draw)
            (set! self.draw-mutex (make-mutex 'draw))
            (set! self.last-color #f))))))
  
  
  (method override (resize self)
    (let ((world (current-world)))
      (let ((width (get-width world))
            (height (get-height world)))
        (make-orthographic-matrix! (get-projection-matrix sheet) 0. width 0. height 0. 10.))))
  
  
  (method override (move self rect)
    (set-rect sheet rect))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when sheet
      (glDeleteTextures* (get-id (get-texture sheet)))
      (set! sheet #f)))
  
  
  (method package (change-draw-mode self mode)
    (unless (eq? mode draw-mode)
      (set! draw-mode mode)
      ;; super quick try
      (when last-color
        (parameterize ((testing? #t)) ;; oh boy fix me!
        (draw self last-color #f #f #f)))))
  
  
  (method override (draw self color alpha timestamp duration)
    (mutex-lock! draw-mutex)
    (when (or (eq? draw-mode 'draw) (testing?))
      (let ((texture (get-texture sheet)))
        (update self color alpha texture))
      (set! last-color color))
    (mutex-unlock! draw-mutex))
  
  
  (method override (add-overlay self color alpha texture)
    (when (neq? draw-mode 'draw)
      (case draw-mode
        ((freeze)
         (when world.udp:udp-freeze-overlay
           (fill-rect (get-surface texture) (size-rect resolution) world.udp:udp-freeze-overlay)))
        ((wait)
         (when world.udp:udp-wait-overlay
           (fill-rect (get-surface texture) (size-rect resolution) world.udp:udp-wait-overlay))))))
  
  
  (method override (render self)
    (when (eq? stream-state 'drawn)
    ;; QUICKY
    (when sheet
    (let ((world (current-world)))
      (let ((x (cast <fl> (get-left sheet)))
            (y (cast <fl> (get-top sheet)))
            (height (cast <fl> (get-height sheet))))
        (let ((matrix (make-translation-matrix (vertex x (- (get-height world) y height) 0.))))
          (render-sheet sheet matrix))))))))


;;;
;;;; Circle-Video-Sink
;;;


(class Circle-Video-Sink extends Video-Sink
  
  
  (slot id              initialize #f accessors generate)
  (slot channel         initialize #f accessors generate)
  (slot player          initialize #f accessors generate)
  (slot texture         initialize #f accessors generate)
  (slot translation     initialize #f accessors generate)
  (slot rotation        initialize #f accessors generate)
  (slot plane           initialize #f accessors generate)
  (slot media-pane      initialize #f accessors generate)
  (slot media-sheet     initialize #f accessors generate)
  (slot interface-pane  initialize #f accessors generate)
  (slot interface-sheet initialize #f accessors generate)
  (slot draw-mode       initialize #f accessors generate)
  (slot draw-mutex      initialize #f accessors generate)
  (slot last-color      initialize #f accessors generate)
  
  
  (method override (initialize self id channel entity . rest)
    (bind-keywords ((position #f) (size #f) . others) rest
      (apply nextmethod self others)
      (let ((window (current-window)))
        (set! self.id id)
        (set! self.channel channel)
        (set! self.player entity)
        (set! self.texture (make-cairo-texture (get-width resolution) (get-height resolution)))
        (set! self.draw-mode 'draw)
        (set! self.draw-mutex (make-mutex 'draw))
        (set! self.last-color #f)
        (let ((position (or position {Point 0 0}))
              (size (or size {Dimension 640 360})))
          ;; media
          (let ((pane (make-sheet-pane
                        name: 'media
                        title: "Media"
                        position: position
                        size: size
                        expanse: (new Dimension$fl$ 10. (/ 10. (/ 16. 9.)))
                        resolution: resolution
                        texture: texture)))
            (set! self.media-pane pane)
            (set! self.media-sheet (get-sheet pane)))
          ;; interface
          (let ((position {Point 0 0})
                (size {Dimension 1280 720})
                (expanse (new Dimension$fl$ 10. (/ 10. (/ 16. 9.))))
                (resolution {Dimension 1280 720}))
            (let ((texture (make-cairo-texture (get-width resolution) (get-height resolution)))
                  (root (new world.circle:Circle-View position: position size: size)))
              (let ((pane (make-sheet-pane
                            name: 'interface
                            title: "Interface"
                            position: position
                            size: size
                            expanse: expanse
                            resolution: resolution
                            texture: texture
                            root: root
                            root-mousable?: #t)))
                (set! self.interface-pane pane)
                (set! self.interface-sheet (get-sheet pane))
                (set-output root self)
                (update-volume root))))
          ;; panes
          (update-panes self)))))
  
  
  (method override (destroy self)
    (let ((window (current-window)))
      (unregister-pane window media-pane)
      (unregister-sheet window media-sheet)
      (unregister-pane window interface-pane)
      (unregister-sheet window interface-sheet))
    (nextmethod self))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (let ((effective-name (if (not channel) "Me" (get-name channel))))
          (format output "{a}" effective-name)))))
  
  
  (method package (update-panes self)
    (let ((window (current-window))
          (video (current-video)))
      (case video-layout
        ((gallery)
         (unregister-pane window media-pane)
         (unregister-pane window interface-pane)
         (register-sheet window media-sheet)
         (register-sheet window interface-sheet)
         (when (eq? self (effective-focused-output video))
           (send-sheet-to-back window media-sheet)
           (send-sheet-to-back window interface-sheet)))
        ((circle focus)
         (unregister-sheet window media-sheet)
         (unregister-sheet window interface-sheet)
         (register-pane window media-pane)
         (register-pane window interface-pane)
         (when (eq? self (effective-focused-output video))
           (register-sheet window media-sheet)
           (register-sheet window interface-sheet))))))
  
  
  (method package (update-matrices self count)
    (update-media-matrix self count)
    (update-interface-matrix self count))
  
  
  (method package (update-media-matrix self count)
    (let ((matrix (circle-matrix self translation (<= count 3))))
      (set-matrix media-pane matrix)
      (set! plane (new Plane (matrix-translation matrix) (matrix-direction matrix)))))
  
  
  (method package (update-interface-matrix self count)
    (when translation
      (if (and speakers-xp? (eq? (effective-focused-output (current-video)) self))
          (let ((position (matrix-translation (get-matrix media-pane))))
            (let ((billboard-matrix (orthogonal-matrix& (get-position (current-camera)) position) @w (billboard-matrix& position)))
              (set-matrix media-pane billboard-matrix)
              (set-matrix interface-pane billboard-matrix)))
        (set-matrix media-pane (circle-matrix self translation (<= count 3)))
      (if (xor (>= (plane-to-point-distance& plane (get-position (current-camera))) 0.)
               (> count 3))
          (set-matrix interface-pane (circle-matrix self (+ translation .005) #f))
        (set-matrix interface-pane (circle-matrix self (+ translation -.005) #t))))))
  
  
  (method (circle-matrix self translation flip?)
    (matrix-multiply&
      (make-rotation-matrix& (vertex& 0. 1. 0.) rotation)
      (make-translation-matrix& (vertex& 0. 0. translation))
      (if flip?
          (make-rotation-matrix (vertex& 0. 1. 0.) PI)
        (make-identity-matrix&))))
  
  
  (method override (resize self)
    (let ((world (current-world)))
      (let ((width (get-width world))
            (height (get-height world)))
        (make-orthographic-matrix! (get-projection-matrix media-sheet) 0. width 0. height 0. 10.)
        (make-orthographic-matrix! (get-projection-matrix interface-sheet) 0. width 0. height 0. 10.))))
  
  
  (method override (move self rect)
    (set-rect media-sheet rect)
    (set-rect interface-sheet rect))
  
  
  (method package (focused? self)
    (and (eq? video-layout 'focus)
         (eq? (effective-focused-output (current-video)) self)))
  
  
  (method package (move-focused self)
    (let ((bounds (get-bounds (current-window))))
      (let ((focused (focused-rect bounds)))
        (let ((adjusted (adjust-focused bounds focused)))
          (move self adjusted)))))
  
  
  (method override (focus self)
    (let ((window (current-window)))
      (move-focused self)
      (register-sheet window media-sheet)
      (register-sheet window interface-sheet)
      (send-sheet-to-back window media-sheet)
      (send-sheet-to-back window interface-sheet)))
  
  
  (method override (unfocus self)
    (let ((window (current-window)))
      (unregister-sheet window media-sheet)
      (unregister-sheet window interface-sheet)))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when texture
      (glDeleteTextures* (get-id texture))
      (set! texture #f)))
  
  
  (method override (invalidate-state self)
    (redraw-texture interface-pane))
  
  
  (method package (change-draw-mode self mode)
    (unless (eq? mode draw-mode)
      (set! draw-mode mode)
      ;; super quick try
      (when last-color
        (parameterize ((testing? #t)) ;; oh boy fix me!
        (draw self last-color #f #f #f)))))
  
  
  (method override (draw self color alpha timestamp duration)
    (mutex-lock! draw-mutex)
    (when (or (eq? draw-mode 'draw) (testing?))
      (update self color alpha texture)
      (set! last-color color))
    (when channel
      (record-event udp-id-draw-video
                    -1.
                    (fixnum->flonum client-no)
                    (fixnum->flonum world.udp:udp-video)
                    -1.
                    -1.
                    -1.
                    (if (not timestamp)
                        -1.
                      (timestamp->flonum timestamp))))
    (mutex-unlock! draw-mutex))
  
  
  (method override (add-overlay self color alpha texture)
    (when (and channel (neq? draw-mode 'draw))
      (case draw-mode
        ((freeze)
         (when world.udp:udp-freeze-overlay
           (fill-rect (get-surface texture) (size-rect resolution) world.udp:udp-freeze-overlay)))
        ((wait)
         (when world.udp:udp-wait-overlay
           (fill-rect (get-surface texture) (size-rect resolution) world.udp:udp-wait-overlay))))))
  
  
  (method override (render self)
    (let ((world (current-world)))
      (define (render-sheets)
        (when (eq? stream-state 'drawn)
          (let ((sheet media-sheet))
            (let ((x (cast <fl> (get-left sheet)))
                  (y (cast <fl> (get-top sheet)))
                  (height (cast <fl> (get-height sheet))))
              (let ((matrix (make-translation-matrix (vertex x (- (get-height world) y height) 0.))))
                (render-sheet sheet matrix)))))
        (when (or video-interface?
                  (neq? stream-state 'drawn))
          (let ((sheet interface-sheet))
            (let ((x (cast <fl> (get-left sheet)))
                  (y (cast <fl> (get-top sheet)))
                  (height (cast <fl> (get-height sheet))))
              (let ((matrix (make-translation-matrix (vertex x (- (get-height world) y height) 0.))))
                (render-sheet sheet matrix))))))
      
      (case video-layout
        ((gallery)
         (render-sheets))
        (else
         (when (focused? self)
           (render-sheets))
         (when (and (eq? stream-state 'drawn)
                    (or video-interface?
                        (not (focused? self))))
           (render-pane media-pane))
         (when (and (or (neq? video-layout 'focus)
                        (neq? stream-state 'drawn))
                    (or video-interface?
                        (neq? stream-state 'drawn)))
           (render-pane interface-pane))))))))
