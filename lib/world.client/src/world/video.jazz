;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Video
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.video jazz


(import (jazz.cairo)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.io)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (jazz.view)
        (jazz.window)
        (world)
        (world.autoload)
        (world.configure)
        (world.console)
        (world.context)
        (world.entity)
        (world.foreign)
        (world.geometry)
        (world.id)
        (world.interface)
        (world.interface.sheet)
        (world.io)
        (world.layout)
        (world.pane)
        (world.quad-texture)
        (world.settings)
        (world.task))


(definition protected self-resolution
  (world-setting 'world.self-resolution {Dimension 640 360}))


(definition protected video-resolution
  (world-setting 'world.video-resolution {Dimension 640 360}))

(definition protected video-framerate
  (world-setting 'world.video-framerate 15))

(definition protected video-bitrate
  (world-setting 'world.video-bitrate 1024 @wait 2048))

(definition protected video-key-period
  (world-setting 'world.video-key-period #f))

(definition protected video-pass
  (world-setting 'world.video-pass #f))

(definition protected video-alpha
  (world-setting 'world.video-alpha 1.0 @wait 0.6))

(definition protected video-overlay?
  (world-setting 'world.video-overlay? #f))

(definition protected video-codec
  (world-setting 'world.video-codec 'h264))


(definition layouts
  '(;;overhead
    sidebar
    gallery
    fullscreen))

(definition video-layout
  (world-setting 'world.video-layout 'sidebar @currently-buggy-when-we-cycle 'overhead))


(definition public video-mode
  'fit)

(definition public (set-video-mode mode)
  (let ((video (current-video)))
    (set! video-mode mode)
    (layout-outputs video)
    (invalidate-interface)))


(definition video-show
  (world-setting 'world.video-show #f))


(definition public capture-screen?
  #f)

(definition public (set-capture-screen? flag)
  (set! capture-screen? flag))


(definition slide-duration
  (world-setting 'world.slide-duration .2))


;;;
;;;; Kush
;;;


(definition public (kush-gauge width height rate motion)
  (/ (* width height rate motion 0.07) 1000.))


;;;
;;;; Access
;;;


(definition public (get-video-layout)
  video-layout)

(definition public (set-video-layout layout)
  (set! video-layout layout))


;;;
;;;; Video
;;;


(definition protected (new-world-video)
  (let ((camera-src (new Camera-Video-Src
                      resolution: video-resolution
                      framerate: video-framerate
                      bitrate: video-bitrate
                      codec: video-codec))
        (server-sink (new Stream-Sink
                       consumer: (lambda (buffer timestamp duration)
                                 (let ((video (current-video)))
                                   (send-camera-video video buffer timestamp duration)))))
        (self-sink (new Stream-Sink
                     consumer: (lambda (buffer timestamp duration)
                                 (let ((video (current-video)))
                                   (let ((sink (find-output video #f)))
                                     (set-stream-state sink 'drawn)
                                     (draw sink buffer #f timestamp duration)))))))
    (new World-Video input: (pipeline camera-src (if self-sink
                                                     (list server-sink self-sink)
                                                   server-sink)))))


;; first four bytes are always 00 00 00 01
(definition protected (video-buffer-header? buffer (offset 0))
  (let ((pos (+ offset 5)))
    (and (< pos (u8vector-length buffer))
         (= (u8vector-ref buffer pos) 16))))


(class World-Video extends Object
  
  
  (slot input             getter generate)
  (slot inputs            getter generate)
  (slot outputs           getter generate)
  (slot ordered-outputs   getter generate)
  (slot fullscreen-output accessors generate)
  (slot self-output       getter generate)
  (slot camera-mutex      getter generate)
  (slot render-hook       accessors generate)
  
  
  (method override (initialize self (input: input #f))
    (nextmethod self)
    (set! self.input input)
    (set! self.inputs (make-table test: equal?))
    (set! self.outputs (make-table test: equal?))
    (set! ordered-outputs '())
    (set! fullscreen-output #f)
    (set! self-output #f)
    (set! camera-mutex (make-mutex 'camera))
    (set! render-hook #f))
  
  
  (method package (autostart self)
    (when (world-setting 'world.video-autostart? #f)
      (start self)))
  
  
  (method package (start self)
    (start input))
  
  
  (method package (stop self)
    (release input))
  
  
  (method (with-camera-mutex self thunk)
    (mutex-lock! camera-mutex)
    (prog1 (thunk)
      (mutex-unlock! camera-mutex)))
  
  
  (method package (send-camera-video self buffer timestamp duration)
    (with-camera-mutex self
      (lambda ()
        (let ((tier (current-client)))
          (send-client-video tier buffer timestamp duration)))))
  
  
  (method package (reset-camera self)
    (with-camera-mutex self
      (lambda ()
        (let ((camera (car (get-elements input))))
          (let ((pipeline (get-pipeline camera)))
            (and pipeline
                 (let ((valve (gst_bin_get_by_name pipeline "valve"))
                       (encoder (gst_bin_get_by_name pipeline "enc")))
                   (g_object_set valve "drop" (g_value_int 1))
                   (gst_element_set_state encoder GST_STATE_READY)
                   (gst_element_set_state encoder GST_STATE_PLAYING)
                   (g_object_set valve "drop" (g_value_int 0)))))))))
  
  
  (method package (resize self)
    (iterate-table outputs
      (lambda (id output)
        (when (sheet? output)
          (resize output))))
    (layout-outputs self))
  
  
  ;; kind of hack because of an import conflict
  (method (video-layout-ref self)
    video-layout)
  
  
  ;;;
  ;;;; Input
  ;;;
  
  
  (method (on-toggle-video self evt)
    (toggle-video self))
  
  
  (method package (toggle-video self)
    (when (client?)
      (if (video-playing? self)
          (stop-video self)
        (start-video self))))
  
  
  (method package (start-video self (feedback?: feedback? #t))
    (when (client?)
      (let ((world (current-world)))
        (start self)
        (update-parameter world 'video)
        (when feedback?
          (display-on/off world "Video" (playing? input))))))
  
  
  (method package (stop-video self (feedback?: feedback? #t))
    (when (client?)
      (let ((world (current-world)))
        (stop self)
        (when self-output
          (set-stream-state self-output 'off))
        (update-parameter world 'video)
        (when feedback?
          (display-on/off world "Video" (playing? input))))))
  
  
  (method package (video-playing? self)
    (playing? input))
  
  
  ;;;
  ;;;; Inputs
  ;;;
  
  
  (method package (find-input self id)
    (table-ref inputs id #f))
  
  (method package (register-input self id input)
    (table-set! inputs id input))
  
  
  (method package (close-input self id input)
    (table-clear inputs id)
    (release input))
  
  
  ;;;
  ;;;; Outputs
  ;;;
  
  
  (method package (find-output self id)
    (table-ref outputs id #f))
  
  (method package (register-output self id output)
    (table-set! outputs id output))
  
  
  (method package (entity-output self id (position: position #f) (size: size #f) (resolution: resolution #f) (layout: layout #f) (codec: codec #f))
    (or (table-ref outputs id #f)
        (let ((entity (find-entity id)))
          (let ((output (new Draw-Video-Sink entity
                             resolution: (or resolution {Dimension 1280 720})
                             framerate: video-framerate
                             bitrate: video-bitrate
                             codec: (or codec video-codec)
                             alpha-overlay: video-alpha
                             overlay?: video-overlay?)))
            (table-set! outputs id output)
            (setup output)
            (start output)
            output))))
  
  
  (method package (player-output self id (player: player #f) (position: position #f) (size: size #f) (resolution: resolution #f) (layout: layout #f) (codec: codec #f))
    (define (add-output output)
      (if (and self-output (neq? output self-output))
          ;; reposition so self output is always last
          (set! ordered-outputs (append! (remove! self-output ordered-outputs) (list output self-output)))
        (set! ordered-outputs (append! ordered-outputs (list output)))))
    
    (or (table-ref outputs id #f)
        ;; the or is a quick hack to test self video
        (let ((player (or player (find-entity id))))
          (let ((output (case (or layout video-layout)
                          ((overhead)
                           (new Camera-Video-Sink
                             player
                             resolution: (or resolution video-resolution)
                             framerate: video-framerate
                             bitrate: video-bitrate
                             codec: (or codec video-codec)
                             alpha-overlay: video-alpha
                             overlay?: video-overlay?))
                          (else
                           (new Sheet-Video-Sink
                             id
                             player
                             position: position
                             size: size
                             resolution: (if (not id) self-resolution (or resolution video-resolution))
                             framerate: video-framerate
                             bitrate: video-bitrate
                             codec: (or codec video-codec)
                             alpha-overlay: video-alpha
                             overlay?: video-overlay?
                             process?: id)))))
            (table-set! outputs id output)
            (when (not id)
              (set! self-output output))
            (add-output output)
            (update-layouts self)
            (setup output)
            (start output)
            output))))
  
  
  (method package (close-output self id output)
    (table-clear outputs id)
    (set! ordered-outputs (remove! output ordered-outputs))
    (when (eq? output self-output)
      (set! self-output #f))
    (when (eq? output fullscreen-output)
      (set! fullscreen-output #f))
    (release output)
    (update-layouts self))
  
  
  (method package (effective-fullscreen-output self)
    (or fullscreen-output
        (and (not-null? ordered-outputs)
             (car ordered-outputs))))
  
  
  (method package (receive-server-video self id buffer timestamp duration)
    (let ((output (find-output self id)))
      (when output
        (if (not buffer)
            (set-stream-state output 'off)
          (when (eq? (get-stream-state output) 'off)
            (set-stream-state output 'on))
          (consume output buffer timestamp duration)))))
  
  
  (method package (receive-processor-draw self id color alpha timestamp duration background slide?)
    (if (not color)
        (let ((output (find-output self id)))
          (when output
            (close-output self id output)))
      (let ((output (entity-output self id)))
        (set-background output background)
        (if (not slide?)
            (consume output color timestamp duration alpha)
          (let ((texture (get-texture (cache-quad-texture (get-pane output)))))
            (with-slide output texture
              (lambda ()
                (consume output color timestamp duration alpha))))))))
  
  
  (method package (render-outputs self)
    (unless (and render-hook
                 (render-hook self))
      (if (eq? video-layout 'fullscreen)
          (let ((fullscreen-output (effective-fullscreen-output self)))
            (when fullscreen-output
              (render fullscreen-output)))
        ;; use ordered-outputs so order is stable
        (for-each render ordered-outputs))))
  
  
  (method package (render-minis self)
    (unless (and render-hook
                 (render-hook self))
      (when (eq? video-layout 'fullscreen)
        (let ((fullscreen-output (effective-fullscreen-output self)))
          (for-each (lambda (output)
                      (unless (eq? output fullscreen-output)
                        (render output)))
                    ordered-outputs)))))
  
  
  ;;;
  ;;;; Layout
  ;;;
  
  
  (method (on-cycle-layouts self evt)
    (let ((world (current-world)))
      (cycle-layouts self)
      (display-message world (capitalize (symbol->string video-layout)))))
  
  
  (method (cycle-layouts self)
    (case video-layout
      ((overhead)
       (sidebar-layout self))
      ((sidebar)
       (gallery-layout self))
      ((gallery)
       (fullscreen-layout self))
      ((fullscreen)
       (overhead-layout self))))
  
  
  (method (update-layouts self)
    (case video-layout
      ((overhead)
       (overhead-layout self))
      ((sidebar)
       (sidebar-layout self))
      ((gallery)
       (gallery-layout self))
      ((fullscreen)
       (fullscreen-layout self))))
  
  
  (method (stop-renders self)
    (let ((zone (current-zone)))
      (for-each (lambda (player)
                  (let ((elem (get-camera-pane player)))
                    (when elem
                      (set-render? elem #f))))
                (get-players zone))))
  
  
  (method package (overhead-layout self)
    (stop-renders self)
    (set! video-layout 'overhead)
    (layout-outputs self))
  
  
  (method package (sidebar-layout self)
    (stop-renders self)
    (set! video-layout 'sidebar)
    (layout-outputs self))
  
  
  (method package (gallery-layout self)
    (set! video-layout 'gallery)
    (layout-outputs self))
  
  
  (method package (fullscreen-layout self)
    (set! video-layout 'fullscreen)
    (layout-outputs self))
  
  
  (method package (layout-outputs self)
    (when (not-null? ordered-outputs)
      (let ((rectangles (layout self (length ordered-outputs))))
        (when rectangles
          (for-each (lambda (output rect)
                      ;; quick hacks to test self video
                      (let ((player (or (get-player output) (current-me))))
                        (let ((elem (get-camera-pane player)))
                          (if (not rect)
                              (when elem
                                (set-render? elem #f))
                            (when elem
                              (set-render? elem #t))
                            (move output rect)))))
                    ordered-outputs
                    rectangles)))))
  
  
  (method package (layout self num-players)
    (let ((window (current-window)))
      (let ((bounds (get-bounds window)))
        (let ((l (get-left bounds))
              (t (get-top bounds))
              (r (get-right bounds))
              (b (get-bottom bounds)))
          (define (adjust-fullscreen rect)
            (if (eq? video-mode 'fit)
                rect
              ;; fill mode
              (let ((ratio (fit-rects rect bounds 'fill)))
                (let ((new-width (fxround (* (cast <fl> (rect-width rect)) ratio)))
                      (new-height (fxround (* (cast <fl> (rect-height rect)) ratio))))
                  (let ((pos (center (new Dimension new-width new-height) (rect-size bounds))))
                    (let ((h (get-h pos))
                          (v (get-v pos)))
                      (new Rect h v (+ h new-width) (+ v new-height))))))))
          
          (case video-layout
            ((sidebar)
             (layout-tiles num-players (new Rect 10 70 210 (- b 100))))
            ((gallery)
             (if (= num-players 1)
                 (list (adjust-fullscreen (car (layout-tiles 1 bounds))))
               (reverse (layout-tiles num-players bounds))))
            ((fullscreen)
             (let ((width (if (> num-players 2) 224 288))
                   (height (if (> num-players 2) 126 162)))
               (let ((full (car (layout-tiles 1 bounds)))
                     (border 0))
                 (let ((r (- r border))
                       (fullscreen-output (effective-fullscreen-output self)))
                   (map (lambda (output)
                          (if (eq? output fullscreen-output)
                              (adjust-fullscreen full)
                            (prog1 (new Rect (- r width) (- b height) r b)
                              (decrease! r (+ width border)))))
                        ordered-outputs)))))
            (else
             #f)))))))


;;;
;;;; Video-Src
;;;


(class Video-Src extends Stream-Src
  
  
  (slot appsink               initialize #f accessors generate)
  (slot appsinkself           initialize #f accessors generate)
  (slot data     <u8vector+>  initialize #f accessors generate)
  (slot info     <u64vector+> initialize #f accessors generate)
  (slot task                  initialize #f accessors generate)
  
  
  (method (task-start self name)
    (let ((procedure
            (lambda (task)
              (video-task self task))))
      (let ((task (new Task name procedure priority: video-priority)))
        (start-task task)
        (set! self.task task))))
  
  
  (method (task-stop self)
    (halt-task task)
    (set! task #f))
  
  
  (method protected virtual (video-task self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-seconds)))
          ;; not 100% correct if preempted before task-mutex
          (let ((time (current-seconds)))
            (unless (stopping? task)
              (site (video on?: #t)
                (let ((elapse (- time previous))
                      (max-elapse 10.))
                  ;; ignore ridiculous elapses like
                  ;; coming back from computer sleep
                  (unless (> elapse max-elapse)
                    (let ((history (current-history)))
                      (unless (get-paused? history)
                        (process self)))))))
            (let ((duration (- (current-seconds) time)))
              (task-sleep task video-period duration exit))
            (iter time))))))
  
  
  (method override (process self)
    (let ((size (gst_app_sink_read appsink data info)))
      (when (/= size -1)
        (let ((buffer (subu8vector data 0 size))
              (timestamp (u64vector-ref info 0))
              (duration (u64vector-ref info 1)))
          (when (and video-show
                     (or (eq? video-show 'all)
                         (eq? video-show 'header)
                         (>= size video-show)))
            ;; h264 specific
            (let ((type (if (video-buffer-header? buffer)
                            '***header***
                          'delta)))
              (if (eq? video-show 'header)
                  (when (eq? type '***header***)
                    (terminal size type))
                (terminal size type))))
          (consume sink buffer timestamp duration))))
    (let ((size (gst_app_sink_read appsinkself data info)))
      (when (/= size -1)
        (let ((buffer (subu8vector data 0 size))
              (timestamp (u64vector-ref info 0))
              (duration (u64vector-ref info 1)))
          (consume sinkself buffer timestamp duration))))))


;;;
;;;; Camera-Video-Src
;;;


(class Camera-Video-Src extends Video-Src
  
  
  (slot resolution initialize #f accessors generate)
  (slot framerate  initialize #f accessors generate)
  (slot bitrate    initialize #f accessors generate)
  (slot codec      initialize #f accessors generate)
  (slot pipeline   initialize #f accessors generate)
  
  
  (method override (initialize self (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f))
    (nextmethod self)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (get-width resolution))
          (height (get-height resolution))
          (self-width (get-width self-resolution))
          (self-height (get-height self-resolution)))
      (let ((pipeline (gst-launch (cond-expand
                                    (mac (if capture-screen?
                                             "avfvideosrc capture-screen=true"
                                           "avfvideosrc"))
                                    (windows "ksvideosrc")
                                    (else "v4l2src"))
                                  "videoscale"
                                  "videoconvert"
                                  ;; this tie is there so the camera knows what resolution and framerate to use
                                  (tie "video/x-raw, width=1280, height=720, pixel-aspect-ratio=(fraction)1/1, framerate={framerate}/1")
                                  "tee name=tee"
                                  (list
                                    "tee."
                                    "queue"
                                    "videoscale"
                                    "videoconvert"
                                    (tie "video/x-raw, format=I420, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1, framerate={framerate}/1")
                                    "valve name=valve"
                                    (and (eq? codec 'h264)
                                         (let ((key-int-max (and video-key-period (fxround (* (cast <fl> framerate) video-key-period))))
                                               (pass video-pass)
                                               (psy-tune #f)
                                               (quantizer #f)
                                               (bitrate bitrate)
                                               (tune "zerolatency")
                                               (speed-preset "superfast"))
                                           (let ((elem
                                                   (gst-element "x264enc"
                                                                key-int-max: key-int-max
                                                                pass: pass
                                                                psy-tune: psy-tune
                                                                quantizer: quantizer
                                                                bitrate: bitrate
                                                                tune: tune
                                                                speed-preset: speed-preset
                                                                name: "enc")))
                                             @w (format :terminal "size={a}x{a} framerate={a}{%}" width height framerate)
                                             @w (format :terminal "{a}{%}" elem)
                                             elem)))
                                    "appsink name=sink")
                                  (list
                                    "tee."
                                    "queue"
                                    "valve name=valveself"
                                    "videoscale"
                                    "videoconvert"
                                    (tie "video/x-raw, format=BGRA, width={self-width}, height={self-height}, pixel-aspect-ratio=(fraction)1/1, framerate={framerate}/1")
                                    "videoflip video-direction=horiz"
                                    "appsink name=sinkself"))))
        (gst_object_set_name pipeline "camera")
        (let ((appsink (gst_bin_get_by_name pipeline "sink"))
              (appsinkself (gst_bin_get_by_name pipeline "sinkself"))
              (data (make-u8vector (* (max width self-width) (max height self-height) 4)))
              (info (make-u64vector 2)))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.data data)
          (set! self.info info)
          (set! self.pipeline pipeline)
          (set! self.appsink appsink)
          (set! self.appsinkself appsinkself)))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'camera)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! info #f)
    (set! data #f)
    (set! pipeline #f)
    (set! appsink #f)
    (consume sink #f #f #f)))


;;;
;;;; Screen-Video-Src
;;;


(class Screen-Video-Src extends Video-Src)


;;;
;;;; Test-Video-Src
;;;


(class Test-Video-Src extends Video-Src
  
  
  (slot resolution initialize #f accessors generate)
  (slot framerate  initialize #f accessors generate)
  (slot bitrate    initialize #f accessors generate)
  (slot codec      initialize #f accessors generate)
  (slot pipeline   initialize #f accessors generate)
  
  
  (method override (initialize self (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f))
    (nextmethod self)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (get-width resolution))
          (height (get-height resolution)))
      (let ((pipeline (gst-launch "videotestsrc"
                                  "videoscale"
                                  "videoconvert"
                                  (tie "video/x-raw, format=I420, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1, framerate={framerate}/1")
                                  (and (eq? codec 'h264) (tie "x264enc pass=qual quantizer=20 bitrate={bitrate} tune=zerolatency speed-preset=superfast"))
                                  "appsink name=sink")))
        (gst_object_set_name pipeline "test")
        (let ((appsink (gst_bin_get_by_name pipeline "sink"))
              (data (make-u8vector (* width height 4)))
              (info (make-u64vector 2)))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.data data)
          (set! self.info info)
          (set! self.pipeline pipeline)
          (set! self.appsink appsink)))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'test)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! info #f)
    (set! data #f)
    (set! pipeline #f)
    (set! appsink #f)
    (consume sink #f #f #f)))


;;;
;;;; File-Video-Src
;;;


(class File-Video-Src extends Video-Src
  
  
  (slot location                initialize #f accessors generate)
  (slot resolution              initialize #f accessors generate)
  (slot framerate               initialize #f accessors generate)
  (slot bitrate                 initialize #f accessors generate)
  (slot codec                   initialize #f accessors generate)
  (slot pipeline                initialize #f accessors generate)
  (slot audio?                  initialize #t accessors generate)
  (slot audio-sink              initialize #f accessors generate)
  (slot audio-appsink           initialize #f accessors generate)
  (slot audio-data <u8vector+>  initialize #f accessors generate)
  (slot audio-info <u64vector+> initialize #f accessors generate)
  
  
  (method override (initialize self location (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f) (audio?: audio? #t))
    (nextmethod self)
    (set! self.location location)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec)
    (set! self.audio? audio?))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (get-width resolution))
          (height (get-height resolution)))
      (let ((pipeline (gst-launch (tie "filesrc name=filesrc")
                                  "decodebin name=decoder"
                                  (and audio?
                                       (list "decoder."
                                             "queue"
                                             "audioconvert"
                                             "audioresample"
                                             (cond-expand
                                               (windows "audio/x-raw, format=S16LE, layout=interleaved, rate=80000, channels=2")
                                               (else "audio/x-raw, format=F32LE, layout=interleaved, rate=80000, channels=2"))
                                             "appsink name=audioappsink"))
                                  (list "decoder."
                                        "videoscale"
                                        "videoconvert"
                                        (tie "video/x-raw, format=I420, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                        "appsink name=appsink"))))
        (gst_object_set_name pipeline "file")
        (let ((filesrc (gst_bin_get_by_name pipeline "filesrc"))
              (appsink (gst_bin_get_by_name pipeline "appsink"))
              (data (make-u8vector (* width height 4)))
              (info (make-u64vector 2))
              (audio-appsink (and audio? (gst_bin_get_by_name pipeline "audioappsink")))
              (audio-data (and audio? (make-u8vector (* width height 4))))
              (audio-info (and audio? (make-u64vector 2))))
          (g_object_set_string filesrc "location" (path-normalize location))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.data data)
          (set! self.info info)
          (set! self.pipeline pipeline)
          (set! self.appsink appsink)
          (when audio?
            (set! self.audio-appsink audio-appsink)
            (set! self.audio-data audio-data)
            (set! self.audio-info audio-info))))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'file)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (set! info #f)
    (set! data #f)
    (set! pipeline #f)
    (set! appsink #f)
    (consume sink #f #f #f)
    (set! audio-info #f)
    (set! audio-data #f)
    (set! audio-appsink #f)
    (when audio-sink
      (consume audio-sink #f #f #f)))
  
  
  (method override (process self)
    (nextmethod self)
    (when audio-sink
      (let ((size (gst_app_sink_read audio-appsink audio-data audio-info)))
        (when (/= size -1)
          (let ((buffer (subu8vector audio-data 0 size))
                (timestamp (u64vector-ref audio-info 0))
                (duration (u64vector-ref audio-info 1)))
            (consume audio-sink buffer timestamp duration)))))))


;;;
;;;; Video-Sink
;;;


(class Video-Sink extends Stream-Sink
  
  
  (slot resolution                  initialize #f accessors generate)
  (slot framerate                   initialize #f accessors generate)
  (slot bitrate                     initialize #f accessors generate)
  (slot codec                       initialize #f accessors generate)
  (slot flip                        initialize #f accessors generate)
  (slot process?                    initialize #f accessors generate)
  (slot alpha-overlay               initialize #f accessors generate)
  (slot overlay?                    initialize #f accessors generate)
  (slot color-pipeline              initialize #f accessors generate)
  (slot color-appsrc                initialize #f accessors generate)
  (slot color-appsink               initialize #f accessors generate)
  (slot color-data     <u8vector+>  initialize #f accessors generate)
  (slot color-info     <u64vector+> initialize #f accessors generate)
  (slot color-bytes                 initialize #f accessors generate)
  (slot alpha?                      initialize #f accessors generate)
  (slot alpha-pipeline              initialize #f accessors generate)
  (slot alpha-appsrc                initialize #f accessors generate)
  (slot alpha-appsink               initialize #f accessors generate)
  (slot alpha-data     <u8vector+>  initialize #f accessors generate)
  (slot alpha-info     <u64vector+> initialize #f accessors generate)
  (slot alpha-bytes                 initialize #f accessors generate)
  (slot image-surface               initialize #f accessors generate)
  (slot image-inhibit?              initialize #f accessors generate)
  (slot task                        initialize #f accessors generate)
  (slot stream-state                initialize 'off getter generate setter explicit)
  (slot frame-count                 initialize #f)
  (slot frame-start                 initialize #f)
  (slot total-size                  initialize #f)
  
  
  (method override (initialize self (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f) (flip: flip #f) (process?: process? #t) (alpha-overlay: alpha-overlay #f) (overlay?: overlay? #f) (alpha?: alpha? #f))
    (nextmethod self)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec)
    (set! self.flip flip)
    (set! self.process? process?)
    (set! self.alpha-overlay alpha-overlay)
    (set! self.overlay? overlay?)
    (set! self.alpha? alpha?))
  
  
  (method package virtual (sheet? self)
    #f)
  
  
  (method package (set-stream-state self state)
    (when (neq? state stream-state)
      (set! stream-state state)
      (invalidate-interface)))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (when process?
      (let ((width (get-width resolution))
            (height (get-height resolution)))
        (let ((pipeline (gst-launch (tie "appsrc name=src")
                                    (and (eq? codec 'h264) (tie "avdec_h264"))
                                    "videoscale"
                                    "videoconvert"
                                    (and flip (tie "videoflip video-direction={flip}"))
                                    (and alpha-overlay (tie "alpha alpha={alpha-overlay}"))
                                    (tie "video/x-raw, format=BGRA, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1, framerate={framerate}/1")
                                    (tie "appsink name=sink"))))
          (gst_object_set_name pipeline "output")
          (let ((appsrc (gst_bin_get_by_name pipeline "src"))
                (appsink (gst_bin_get_by_name pipeline "sink"))
                (data (make-u8vector (* width height 4)))
                (info (make-u64vector 2)))
            (case codec
              ((h264)
               (gst_app_src_set_caps appsrc
                                     (gst_caps "video/x-h264"
                                               "width"         (g_value_int width)
                                               "height"        (g_value_int height)
                                               "framerate"     (g_value_fraction framerate 1)
                                               "stream-format" (g_value_string "avc")
                                               "alignment"     (g_value_string "au"))))
              (else
               (gst_app_src_set_caps appsrc
                                     (gst_caps "video/x-raw"
                                               "format"    (g_value_string "I420")
                                               "width"     (g_value_int width)
                                               "height"    (g_value_int height)
                                               "framerate" (g_value_fraction framerate 1)))))
            (g_object_set appsrc
                          "is-live"     (g_value_boolean #t)
                          "stream-type" (g_value_int GST_APP_STREAM_TYPE_STREAM)
                          "format"      (g_value_int GST_FORMAT_TIME))
            (gst_element_set_state pipeline GST_STATE_READY)
            (set! self.color-data data)
            (set! self.color-info info)
            (set! self.color-bytes #f)
            (set! self.color-pipeline pipeline)
            (set! self.color-appsrc appsrc)
            (set! self.color-appsink appsink)))
        (when alpha?
          (let ((pipeline (gst-launch "appsrc name=src"
                                      "avdec_h264 name=dec"
                                      "appsink name=sink")))
            (gst_object_set_name pipeline "output")
            (let ((appsrc (gst_bin_get_by_name pipeline "src"))
                  (appsink (gst_bin_get_by_name pipeline "sink"))
                  (data (make-u8vector (/ (* width height 12) 8)))
                  (info (make-u64vector 2)))
              (gst_app_src_set_caps appsrc
                                    (gst_caps "video/x-h264"
                                              "width"         (g_value_int width)
                                              "height"        (g_value_int height)
                                              "framerate"     (g_value_fraction framerate 1)
                                              "stream-format" (g_value_string "avc")
                                              "alignment"     (g_value_string "au")))
              (g_object_set appsrc
                            "is-live"     (g_value_boolean #t)
                            "stream-type" (g_value_int GST_APP_STREAM_TYPE_STREAM)
                            "format"      (g_value_int GST_FORMAT_TIME))
              (gst_element_set_state pipeline GST_STATE_READY)
              (set! self.alpha-data data)
              (set! self.alpha-info info)
              (set! self.alpha-bytes #f)
              (set! self.alpha-pipeline pipeline)
              (set! self.alpha-appsrc appsrc)
              (set! self.alpha-appsink appsink)
              (set! self.image-surface (new Image-Surface (new Dimension width height)))))))))
  
  
  (method override (start-element self)
    (define (task-start name)
      (let ((procedure
              (lambda (task)
                (video-task self task))))
        (let ((task (new Task name procedure priority: video-priority)))
          (start-task task)
          (set! self.task task))))
    
    (nextmethod self)
    (when process?
      (task-start 'video)
      (gst_element_set_state color-pipeline GST_STATE_PLAYING)
      (when alpha?
        (gst_element_set_state alpha-pipeline GST_STATE_PLAYING))))
  
  
  (method override (stop-element self)
    (define (task-stop)
      (halt-task task)
      (set! task #f))
    
    (nextmethod self)
    (when process?
      (task-stop)
      (gst_element_set_state color-pipeline GST_STATE_READY)
      (when alpha?
        (gst_element_set_state alpha-pipeline GST_STATE_READY))))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when process?
      (gst_element_release color-pipeline)
      (set! color-info #f)
      (set! color-data #f)
      (set! color-bytes #f)
      (set! color-pipeline #f)
      (set! color-appsrc #f)
      (set! color-appsink #f)
      (when alpha?
        (gst_element_release alpha-pipeline)
        (close image-surface)
        (set! alpha-info #f)
        (set! alpha-data #f)
        (set! alpha-bytes #f)
        (set! alpha-pipeline #f)
        (set! alpha-appsrc #f)
        (set! alpha-appsink #f)
        (set! image-surface #f))
      (set-stream-state self 'off)))
  
  
  (method override (consume self color timestamp duration (alpha #f))
    ;; QUICK TEST
    (when color-appsrc
    ;; QUICK TEST
      (when color
        (gst_app_src_write3 color-appsrc color (u8vector-length color) timestamp duration)))
    (when alpha?
      ;; QUICK TEST
      (when alpha-appsrc
        ;; QUICK TEST
        (when alpha
          (gst_app_src_write3 alpha-appsrc alpha (u8vector-length alpha) timestamp duration)))))
  
  
  (method (video-task self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-seconds)))
          ;; not 100% correct if preempted before task-mutex
          (let ((time (current-seconds)))
            (unless (stopping? task)
              (site (video-output on?: #t)
                (let ((elapse (- time previous))
                      (max-elapse 10.))
                  ;; ignore ridiculous elapses like
                  ;; coming back from computer sleep
                  (unless (> elapse max-elapse)
                    (let ((history (current-history)))
                      (unless (get-paused? history)
                        (process self)))))))
            (let ((duration (- (current-seconds) time)))
              (task-sleep task video-period duration exit))
            (iter time))))))
  
  
  (method override (process self)
    (when (not color-bytes)
      (let ((size (gst_app_sink_read color-appsink color-data color-info)))
        (when (/= size -1)
          (set! color-bytes size))))
    (when (and alpha? (not alpha-bytes))
      (let ((size (gst_app_sink_read alpha-appsink alpha-data alpha-info)))
        (when (/= size -1)
          (set! alpha-bytes size))))
    (when (and color-bytes (or (not alpha?) alpha-bytes))
      (let ((timestamp (u64vector-ref color-info 0))
            (duration (u64vector-ref color-info 1)))
        (draw self color-data (and alpha? alpha-data) timestamp duration)
        (set! color-bytes #f)
        (set! alpha-bytes #f)
        (when (eq? stream-state 'on)
          (set-stream-state self 'drawn)))))
  
  
  (method package virtual (draw self color alpha timestamp duration)
    )
  
  
  (method package (update self color alpha texture (background: background #f))
    (define (add-overlay)
      (if (not frame-count)
          (begin
            (set! frame-count 1)
            (set! frame-start (current-seconds))
            (set! total-size (u8vector-length color)))
        (increase! frame-count)
        (increase! total-size (u8vector-length color))
        (let ((elapse (- (current-seconds) frame-start)))
          (let ((rate (/ (cast <fl> frame-count) elapse))
                (size (/ (cast <fl> total-size) frame-count)))
            (set-font (get-surface texture) {Font font-name: tahoma point-size: 24 hint-style: slight hint-metrics: on})
            (draw-text (get-surface texture) 5 (- (get-height resolution) 30) (format "Rate: {r precision: 3}, Size: {a}" rate size) {Color World-Red})))))
    
    (if (not alpha?)
        (move-u8vector->pointer! color (get-data texture))
      (let ((width (get-width resolution))
            (height (get-height resolution))
            (data (cairo_image_surface_get_data (get-handle image-surface))))
        (cairo_surface_flush (get-handle image-surface))
        (combine-alpha color alpha data (* width height))
        (cairo_surface_mark_dirty (get-handle image-surface))
        (unless image-inhibit?
          (let ((surface (get-surface texture)))
            (clear-glass surface resolution background: background)
            (draw-surface surface image-surface 0 0)))))
    (when overlay?
      (add-overlay))
    (unless image-inhibit?
      (map-texture texture)))
  
  
  (method package virtual (render self)
    )
  
  
  (method (with-slide self texture thunk)
    (set! image-inhibit? #t)
    (thunk)
    (let ((height (cast <fl> (get-height resolution))))
      (let ((delta (/ height render-rate slide-duration))
            (surface (get-surface texture)))
        (thread-start!
          (new-thread
            (lambda ()
              (let (loop (slide (- height delta)))
                (let ((slide (max 0. slide)))
                  (let ((done? (<= slide 0.)))
                    (with-task-mutex
                      (lambda ()
                        (if (not image-surface)
                            (set! done? #t)
                          (translate surface 0 slide)
                          (clear-glass surface resolution)
                          (draw-surface surface image-surface 0 0)
                          (translate surface 0 (- slide))
                          (map-texture texture))
                        (when done?
                          (set! image-inhibit? #f))))
                    (when (not done?)
                      (sleep render-period)
                      (loop (- slide delta)))))))
            'slide))))))


;;;
;;;; Draw-Video-Sink
;;;


(class Draw-Video-Sink extends Video-Sink
  
  
  (slot entity     initialize #f accessors generate)
  (slot pane       initialize #f accessors generate)
  (slot background initialize #f accessors generate)
  
  
  (method override (initialize self ent . rest)
    (apply nextmethod self alpha?: #t rest)
    (let ((p (cache-draw-pane ent (list (eq? ent (current-me)) resolution))))
      (set! entity ent)
      (set! pane p)))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when entity
      (set-draw-pane entity #f)
      (set! entity #f)
      (set! pane #f)))
  
  
  (method override (draw self color alpha timestamp duration)
    ;; quicky
    (when pane
      (update self color alpha (get-texture (cache-quad-texture pane)) background: background)))
  
  
  (method override (render self)
    ;; nothing to do render done by player pane
    ))


;;;
;;;; Event-View
;;;


(class Event-View extends View)


(definition public (make-event-view)
  (let ((view (new Event-View)))
    (define (mouse-down event)
      (debug 'mouse-down))
    
    (define (mouse-up event)
      (debug 'mouse-up))
    
    (define (key-press event)
      (debug 'key-press))
    
    (set-mouse-down-handler view mouse-down)
    (set-mouse-up-handler view mouse-up)
    (set-key-press-handler view key-press)
    view))


(definition public (make-view . rest)
  (apply new View rest))


;;;
;;;; Draw-Pane
;;;


(definition public (make-draw-pane entity info)
  (let ((size {Dimension$fl$ 6. 3.375})
        (resolution {Dimension 1280 720}))
    (let ((pane (new Draw-Pane
                  title: "Draw"
                  size: size
                  resolution: resolution
                  billboard: info
                  entity: entity)))
      (cond ((is? info View)
             (set-root pane info)
             (set-position info {Point 0 0})
             (set-size info resolution)
             pane)
            (else
             pane)))))


@c4
(definition public (make-c4-pane entity billboard)
  (let ((size {Dimension$fl$ 3.6363636363636362 3.})
        (resolution {Dimension 660 600}))
    (let ((pane (new Script-Pane
                  size: size
                  resolution: resolution
                  billboard: billboard
                  entity: entity))
          (view (new jazz.sample.c4:C4-Board position: {Point 0 0} size: resolution background: #f)))
      (set-root pane view)
      (let ((pos (center (get-size view) resolution)))
        (set-position view pos))
      pane)))
  
  
  @c4
  (method override (draw self surface)
    (let ((width (get-width resolution))
          (height (get-height resolution)))
      (let ((rect (new Rect 0 0 width height))
            (color {Color red: .000 green: .000 blue: .200 alpha: .3}))
        (clear surface)
        (fill-rect surface rect color)
        (frame-rect surface rect color)
        (paint-drawing root surface '())))
    (when quad-texture
      (map-texture (get-texture quad-texture))))


(class Draw-Pane extends Entity-Pane)


;;;
;;;; Camera-Video-Sink
;;;


(class Camera-Video-Sink extends Video-Sink
  
  
  (slot player initialize #f accessors generate)
  (slot pane   initialize #f accessors generate)
  
  
  (method override (initialize self entity . rest)
    (apply nextmethod self rest)
    (let ((p (cache-camera-pane entity (list (eq? entity (current-me)) resolution))))
      (set! player entity)
      (set! pane p)))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when player
      (set-camera-pane player #f)
      (set! player #f)
      (set! pane #f)))
  
  
  (method override (draw self color alpha timestamp duration)
    (update self color alpha (get-texture (cache-quad-texture pane))))
  
  
  (method override (render self)
    ;; nothing to do render done by player pane
    ))


;;;
;;;; Camera-Pane
;;;


(definition public (make-camera-pane billboard)
  (bind (me? resolution) billboard
    (new Camera-Pane
      title: "Camera"
      size: (new Dimension$fl$ 1. .5625)
      resolution: resolution
      billboard: billboard)))


(class Camera-Pane extends World-Pane
  
  
  (method override (draw self surface)
    (clear surface)))


;;;
;;;; Texture-Video-Sink
;;;


(class Texture-Video-Sink extends Video-Sink
  
  
  (slot quad-texture initialize #f getter generate)
  (slot matrix       initialize #f getter generate)
  
  
  (method override (initialize self matrix . rest)
    (bind-keywords ((size #f) . others) rest
      (define (determine-size)
        (or size
            (let ((ratio (/ (cast <fl> (get-width resolution)) (cast <fl> (get-height resolution)))))
              (let ((w ratio)
                    (h 1.))
                (new Dimension$fl$ w h)))))
      
      (apply nextmethod self others)
      (let ((size (determine-size)))
        (let ((w (get-width size))
              (h (get-height size)))
          (let ((v1 (vertex (/ w -2.) (/ h -2.) 0.))
                (v2 (vertex (/ w -2.) (/ h  2.) 0.))
                (v3 (vertex (/ w  2.) (/ h  2.) 0.))
                (v4 (vertex (/ w  2.) (/ h -2.) 0.)))
            (let ((quad-texture (make-quad-texture (get-width resolution) (get-height resolution) v1 v2 v3 v4)))
              (set! self.quad-texture quad-texture)
              (set! self.matrix matrix)))))))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when quad-texture
      (glDeleteTextures* (get-id (get-texture quad-texture)))
      (set! quad-texture #f)))
  
  
  (method override (draw self color alpha timestamp duration)
    (update self color alpha (get-texture quad-texture)))
  
  
  (method override (render self)
    (when (eq? stream-state 'drawn)
      (render-texture quad-texture matrix))))


;;;
;;;; Sheet-Video-Sink
;;;


(class Sheet-Video-Sink extends Video-Sink
  
  
  (slot id     initialize #f accessors generate)
  (slot player initialize #f accessors generate)
  (slot size   initialize #f accessors generate)
  (slot sheet  initialize #f accessors generate)
  
  
  (method override (initialize self id entity . rest)
    (bind-keywords ((position #f) (size #f) . others) rest
      (apply nextmethod self others)
      (let ((world (current-world)))
        (let ((pos (or position {Point 0 0}))
              (size (or size {Dimension 320 180})))
          (let ((s (make-world-sheet 'video World-Sheet size resolution: resolution retina?: #f)))
            (make-orthographic-matrix! (get-projection-matrix s) 0. (get-width world) 0. (get-height world) 0. 10.)
            (set-position s pos)
            (set-size s size)
            (set! self.id id)
            (set! self.player entity)
            (set! self.sheet s))))))
  
  
  (method override (sheet? self)
    #t)
  
  
  (method package (resize self)
    (let ((world (current-world)))
      (let ((width (get-width world))
            (height (get-height world)))
        (make-orthographic-matrix! (get-projection-matrix sheet) 0. width 0. height 0. 10.))))
  
  
  (method package (move self rect)
    (set-rect sheet rect))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when sheet
      (glDeleteTextures* (get-id (get-texture sheet)))
      (set! sheet #f)))
  
  
  (method override (draw self color alpha timestamp duration)
    (update self color alpha (get-texture sheet)))
  
  
  (method override (render self)
    (when (eq? stream-state 'drawn)
    ;; QUICKY
    (when sheet
    (let ((world (current-world)))
      (let ((x (cast <fl> (get-left sheet)))
            (y (cast <fl> (get-top sheet)))
            (h (cast <fl> (get-height sheet))))
        (let ((matrix (make-translation-matrix (vertex x (- (get-height world) y h) 0.))))
          (render-sheet sheet matrix))))))))


;;;
;;;; Test
;;;


(definition test-pipeline #f)
(definition file-pipeline #f)
(definition camera-pipeline #f)
(definition circle-pipelines #f)


(definition next-names
  (copy common-names))

(definition next-src
  0)


(definition (make-texture-pipeline name size resolution framerate codec video-src matrix (audio-sink #f))
  (let ((video (current-video)))
    (let ((bitrate video-bitrate))
      (let ((video-sink (new Texture-Video-Sink
                          matrix
                          size: size
                          resolution: resolution
                          framerate: framerate
                          bitrate: bitrate
                          codec: codec
                          flip: 'vert)))
        (let ((pipeline (pipeline video-src video-sink)))
          ;; quick first solution
          (when audio-sink
            (set-elements pipeline (append (get-elements pipeline) (list audio-sink))))
          (register-input video name video-src)
          (register-output video name video-sink)
          (start pipeline)
          pipeline)))))


(definition protected (make-test-video)
  (let ((size #f)
        (resolution {Dimension 300 200})
        (framerate (cond-expand (unix 25) (else 30)))
        (bitrate video-bitrate)
        (codec 'none))
    (make-texture-pipeline 'test size resolution framerate codec
      (new Test-Video-Src
        resolution: resolution
        framerate: framerate
        bitrate: bitrate
        codec: codec)
      (copy-matrix (matrix-multiply& (make-translation-matrix (vertex -9.5 7. 4.5))
                                     (make-scaling-matrix (vertex 6. 6. 6.))
                                     (make-rotation-matrix (vertex 0. 1. 0.) PI/4))))))


(definition protected (make-file-video (file: file #f) (resolution: resolution #f) (position: position #f) (audio?: audio? #t) (volume: volume #f))
  (let ((size #f)
        (resolution (or resolution {Dimension 1280 720}))
        (framerate (cond-expand (unix 25) (else 30)))
        (bitrate video-bitrate))
    (let ((file-src (new File-Video-Src
                      (parse (or file {File Home "Media" "sintel.webm"}))
                      resolution: resolution
                      framerate: framerate
                      bitrate: bitrate
                      codec: 'none
                      audio?: audio?))
          (audio-sink (and audio?
                           (new world.audio:Audio-Sink
                             codec: 'none
                             volume: volume))))
      (when audio?
        (set-audio-sink file-src audio-sink))
      (make-texture-pipeline 'file size resolution framerate 'none
        file-src
        (copy-matrix (matrix-multiply& (make-translation-matrix (or position (vertex 0. 7. 0.)))
                                       (make-scaling-matrix (vertex 6. 6. 6.))))
        ;; quick first solution
        audio-sink))))


(definition protected (make-camera-video)
  (let ((size #f)
        (resolution {Dimension 1280 720})
        (framerate (cond-expand (unix 25) (else 30)))
        (bitrate video-bitrate)
        (codec 'none))
    (make-texture-pipeline 'camera size resolution framerate codec
      (new Camera-Video-Src
        resolution: resolution
        framerate: framerate
        bitrate: bitrate
        codec: codec)
      (copy-matrix (matrix-multiply& (make-translation-matrix (vertex 10. 7. 5.))
                                     (make-scaling-matrix (vertex 6. 6. 6.))
                                     (make-rotation-matrix (vertex 0. 1. 0.) (- PI/4)))))))


(definition protected (make-circle-videos)
  (let ((count 15))
    (loop (for n from 0 below count)
          (collect (let ((name (string->symbol (format "circle{a}" n)))
                         (size #f)
                         (resolution {Dimension 300 200})
                         (framerate (cond-expand (unix 25) (else 30)))
                         (bitrate video-bitrate)
                         (codec 'none))
                     (make-texture-pipeline name size resolution framerate codec
                       (new Test-Video-Src
                         resolution: resolution
                         framerate: framerate
                         bitrate: bitrate
                         codec: codec)
                       (copy-matrix (matrix-multiply& (make-translation-matrix (vertex 0. 7. 0.))
                                                      (make-scaling-matrix (vertex 6. 6. 6.))
                                                      (make-rotation-matrix (vertex 0. 1. 0.) (* (/ PI*2 (cast <fl> count)) (cast <fl> n)))
                                                      (make-translation-matrix (vertex 0. 0. 4.))))))))))


(definition (random-name!)
  (let ((name (random-element next-names)))
    (set! next-names (remove! name next-names))
    name))


(definition (random-src!)
  (let ((n next-src))
    (set! next-src (modulo (+ next-src 1) 3))
    (element (list Test-Video-Src File-Video-Src Camera-Video-Src) n)))


(definition protected (add-player)
  (let ((world (current-world))
        (video (current-video)))
    (define (layout-player)
      (let ((current-count (length (get-ordered-outputs video))))
        (let ((new-count (+ current-count 1)))
          (let ((rectangles (layout video new-count)))
            (and rectangles
                 (last rectangles))))))
    
    (let ((name (random-name!))
          (src-class (random-src!))
          (rect (layout-player)))
      (let ((file? (eq? src-class File-Video-Src))
            (audio? #f))
        (let ((position (and rect (rect-position rect)))
              (size (and rect (rect-size rect)))
              (resolution (if file? {Dimension 854 480} video-resolution))
              (framerate video-framerate)
              (bitrate video-bitrate)
              (codec 'none))
          (let ((video-src (if file?
                               (new File-Video-Src
                                 "~/Media/sintel.webm"
                                 resolution: resolution
                                 framerate: framerate
                                 bitrate: bitrate
                                 codec: codec)
                             (new src-class
                               resolution: resolution
                               framerate: framerate
                               bitrate: bitrate
                               codec: codec)))
                (video-sink (player-output video name position: position size: size resolution: resolution codec: codec))
                (audio-sink (and (and file? audio?)
                                 (new world.audio:Audio-Sink
                                   codec: 'none))))
            (when audio-sink
              (set-audio-sink video-src audio-sink))
            (let ((pipeline (if audio-sink
                                (pipeline video-src video-sink audio-sink)
                              (pipeline video-src video-sink))))
              (register-input video name video-src)
              (setup pipeline)
              (start pipeline)
              (sleep .25) ; flicker heuristic. should wait until every new output has drawn
              (update-layouts video)
              (display-message world (format "{a} joined" name))
              pipeline)))))))


(definition protected (remove-player)
  (let ((world (current-world))
        (video (current-video)))
    (let ((ordered-outputs (get-ordered-outputs video)))
      (if (null? ordered-outputs)
          (bell)
        (let ((output (random-element ordered-outputs)))
          (let ((name (table-find (get-outputs video) output)))
            (let ((input (find-input video name)))
              (stop input)
              (stop output)
              (close-input video name input)
              (close-output video name output)
              (update-layouts video)
              (display-message world (format "{a} left" name)))))))))


(definition (close-pipelines pipelines)
  (let ((video (current-video)))
    (for-each stop pipelines)
    (for-each (lambda (pipeline)
                (bind (input output) (get-elements pipeline)
                  (let ((id (table-find (get-outputs video) output)))
                    (close-input video id input)
                    (close-output video id output))))
              pipelines)))


(definition protected (video-test7)
  (set! circle-pipelines (if (not circle-pipelines)
                             (make-circle-videos)
                           (close-pipelines circle-pipelines)
                           #f)))


(definition protected (video-test8)
  (add-player))


(definition protected (video-test9)
  (remove-player))


(definition protected (video-test0)
  (if (not test-pipeline)
      (set! test-pipeline (make-test-video))
    (if (not file-pipeline)
        (set! file-pipeline (make-file-video))
      (set! camera-pipeline (make-camera-video))))))
