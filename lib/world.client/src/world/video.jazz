;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Video
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Barbara Samson


(module world.video jazz


(import (jazz.cairo)
        (jazz.component)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.io)
        (jazz.listener)
        (jazz.opengl.glew)
        (jazz.opengl.texture)
        (jazz.presence)
        (jazz.settings)
        (jazz.stream)
        (jazz.stream.syntax (phase syntax))
        (jazz.syntax (phase syntax))
        (jazz.time)
        (jazz.view)
        (jazz.window)
        (world)
        (world.autoload)
        (world.billboard)
        (world.configure)
        (world.console)
        (world.context)
        (world.entity)
        (world.event)
        (world.foreign)
        (world.geometry)
        (world.hook)
        (world.id)
        (world.interface)
        (world.interface.sheet)
        (world.io)
        (world.layout)
        (world.media)
        (world.pane)
        (world.plane)
        (world.profile)
        (world.quad-texture)
        (world.settings)
        (world.stream)
        (world.task)
        (world.texture)
        (world.time)
        (world.udp)
        (world.window))


(definition protected video-resolution
  (world-setting 'world.video-resolution {Dimension 640 360}))

(definition protected video-framerate
  (world-setting 'world.video-framerate 15))

(definition protected video-bitrate
  (world-setting 'world.video-bitrate 1024))

(definition protected video-codec
  (world-setting 'world.video-codec 'h264))

(definition protected video-profile
  (world-setting 'world.video-profile (find-setting 'caps.profile.video effective-base-profile)))

(definition protected video-single?
  (world-setting 'world.video-single? #f))

(definition protected video-hardware?
  (world-setting 'world.video-hardware? #f))


(definition protected camera-profile
  (world-setting 'world.camera-profile (find-setting 'caps.profile.camera effective-base-profile)))

(definition protected camera-profile-override
  camera-profile)

(definition protected camera-keyframes
  (world-setting 'world.camera-keyframes 2))


(definition protected screen-share-resolution
  (world-setting 'world.screen-share-resolution {Dimension 1280 720}))

(definition protected screen-share-framerate
  (world-setting 'world.screen-share-framerate 5))

(definition protected screen-share-bitrate
  (world-setting 'world.screen-share-bitrate 1024))

(definition protected screen-share-codec
  (world-setting 'world.screen-share-codec 'h264))

(definition protected screen-share-keyframes
  (world-setting 'world.screen-share-keyframes 2))


(definition layouts
  '(;;overhead
    sidebar
    gallery))

(definition public video-layout
  (world-setting 'world.video-layout 'sidebar @currently-buggy-when-we-cycle 'overhead))

(definition (change-video-layout layout)
  (set! video-layout layout)
  (set-setting options-settings 'world.video-layout layout))


(definition public video-mode
  'fit)

(definition public (set-video-mode mode)
  (let ((video (current-video)))
    (set! video-mode mode)
    (if (eq? video-layout 'focus)
        (let ((focused-output (effective-focused-output video)))
          (when focused-output
            (move-focused focused-output)))
      (layout-outputs video))))


(definition protected video-interface?
  #t)

(definition protected (set-video-interface? flag)
  (set! video-interface? flag))


(definition magnus-no
  #f)

(definition protected (set-magnus-no no)
  (set! magnus-no no))

(definition protected (read-video-interface? no)
  (if (eqv? no magnus-no)
      #f
    video-interface?))


(definition protected video-alpha
  (world-setting 'world.video-alpha #f @wait 0.6))


(definition protected speakers-xp?
  (world-setting 'world.speakers-xp? #f))


(definition protected slide-duration
  (world-setting 'world.slide-duration .2))


(definition protected hide-widget?
  (world-setting 'world.hide-widget? #f))


;;;
;;;; Kush
;;;


(definition public (kush-gauge width height rate motion)
  (/ (* width height rate motion 0.07) 1000.))


;;;
;;;; Codec
;;;


(class H264-Codec extends Codec
  
  
  (method override (buffer-keyframe? self buffer)
    (h264-buffer-keyframe? buffer)))


(register-codec (new H264-Codec 'h264 'video))


;;;
;;;; Profile
;;;


(class Video-Profile extends Object
  
  
  (slot name       getter generate)
  (slot level      getter generate)
  (slot extension  getter generate)
  (slot resolution getter generate)
  (slot framerate  getter generate)
  (slot selfrate   getter generate)
  (slot bitrate    getter generate)
  (slot codec      getter generate)
  
  
  (method override (initialize self name level resolution framerate selfrate bitrate codec)
    (nextmethod self)
    (set! self.name name)
    (set! self.level level)
    (set! self.extension (format "streamvideo{a}" (or level "")))
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.selfrate selfrate)
    (set! self.bitrate bitrate)
    (set! self.codec codec))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name)))))


(definition protected (change-video-profile profile)
  (set! video-profile profile))


;;;
;;;; Profiles
;;;


(definition protected video-profile-names
  (make-table test: eq?))

(definition protected video-profile-levels
  (make-table test: eqv?))


(definition protected (register-video-profile profile)
  (table-set! video-profile-names (get-name profile) profile)
  (table-set! video-profile-levels (get-level profile) profile))

(definition protected (name->video-profile name)
  (table-ref video-profile-names name))

(definition protected (level->video-profile level)
  (table-ref video-profile-levels level))


(definition public (active-video-profile)
  (name->video-profile video-profile))

(definition public (maximum-video-profile)
  (name->video-profile maximum-base-profile))


(definition public (video-profile-level)
  (get-level (active-video-profile)))


(definition public (video-profile-extension)
  (get-extension (active-video-profile)))


(definition public (streaming-video-extensions)
  (map get-extension (streaming-video-profiles)))


(definition public (streaming-video-profiles)
  (let ((profile (maximum-video-profile)))
    (streaming-profiles profile)))


(definition public (streaming-profiles profile)
  (if video-single?
      (list profile)
    (let ((level (get-level profile)))
      (loop (for l from level downto 0)
            (collect (level->video-profile l))))))


(definition protected (locate-stream-video-channel stream)
  (let ((receive-level (stream-receive-video-level stream)))
    (table-search (lambda (no channel)
                    (and (= (get-media-kind channel) udp-video)
                         (= (get-level channel) receive-level)
                         channel))
                  (get-channels stream))))


(definition protected (stream-receive-video-level stream)
  (stream-video-level stream (video-profile-level)))


(register-video-profile (new Video-Profile 'high     4  {Dimension 1920 1080} 30 30 4096 'h264))
(register-video-profile (new Video-Profile 'good     3  {Dimension 1280  720} 20 30 2048 'h264))
(register-video-profile (new Video-Profile 'medium   2  {Dimension  640  360} 15 20 1024 'h264))
;;EXPERIMENT
;;(register-video-profile (new Video-Profile 'low      1  {Dimension  480  270} 12 15  768 'h264))
(register-video-profile (new Video-Profile 'low      1  {Dimension  320  180} 12 15  768 'h264))
(register-video-profile (new Video-Profile 'poor     0  {Dimension  224  126}  8 12  256 'h264))
;;RECOVERY
;;(register-video-profile (new Video-Profile 'recovery #f {Dimension  224 	126}  2  8  384 'h264))


;;;
;;;; Camera Profile
;;;


(definition protected (change-camera-profile-override profile)
  (set! camera-profile-override profile))


(definition protected (active-camera-profile)
  (name->video-profile camera-profile))

(definition protected (maximum-camera-profile)
  (name->video-profile maximum-base-profile))


(definition protected (camera-profile-level)
  (get-level (active-camera-profile)))


(definition protected (camera-profile-override-level)
  (get-level (name->video-profile camera-profile-override)))


;;;
;;;; Focused
;;;


(definition (adjust-focused bounds rect)
  (if (eq? video-mode 'fit)
      rect
    ;; fill mode
    (let ((ratio (fit-rects rect bounds 'fill)))
      (let ((new-width (fxround (* (cast <fl> (rect-width rect)) ratio)))
            (new-height (fxround (* (cast <fl> (rect-height rect)) ratio))))
        (let ((pos (center (new Dimension new-width new-height) (rect-size bounds))))
          (let ((h (get-h pos))
                (v (get-v pos)))
            (new Rect h v (+ h new-width) (+ v new-height))))))))


(definition (focused-rect bounds)
  (car (layout-tiles 1 bounds)))


;;;
;;;; Circle
;;;


(definition protected circle-max-fixed
  2)


(definition protected layout-circle-hook
  #f)

(definition protected (set-layout-circle-hook proc)
  (set! layout-circle-hook (and proc (new Hook proc))))


;;;
;;;; Video
;;;


(class World-Video extends Object
  
  
  (slot outputs         getter generate)
  (slot ordered-outputs getter generate)
  (slot focused-output  getter generate)
  (slot self-output     accessors generate)
  (slot self-consumer   accessors generate)
  (slot render-hook     accessors generate)
  
  
  (method override (initialize self)
    (nextmethod self)
    (set! self.outputs (make-table test: equal?))
    (set! ordered-outputs '())
    (set! focused-output #f)
    (set! self-output #f)
    (set! self-consumer #f)
    (set! render-hook #f))
  
  
  (method package (resize self)
    (table-iterate outputs
      (lambda (id output)
        (resize output)))
    (when focused-output
      (resize focused-output))
    (layout-outputs self)
    (when (eq? video-layout 'focus)
      (let ((focused-output (effective-focused-output self)))
        (when focused-output
          (move-focused focused-output)))))
  
  
  ;; only in together at the moment
  (method (on-toggle-video self evt)
    (let ((world (current-world)))
      (display-cancel world "Unimplemented")))
  
  
  ;;;
  ;;;; Outputs
  ;;;
  
  
  (method package (find-output self id)
    (table-ref outputs id #f))
  
  
  (method package (install-output self id output (rank: rank #f))
    (setup output)
    (table-set! outputs id output)
    (set! ordered-outputs (if rank
                              (insert! ordered-outputs rank output)
                            (append! ordered-outputs (list output))))
    (start output))
  
  
  (method package (entity-output self id (position: position #f) (size: size #f) (resolution: resolution #f) (codec: codec #f))
    (or (table-ref outputs id #f)
        (let ((entity (find-entity id)))
          (let ((output (new Draw-Video-Sink entity
                             resolution: (or resolution {Dimension 1280 720})
                             framerate: video-framerate
                             bitrate: video-bitrate
                             codec: (or codec video-codec)
                             alpha-overlay: video-alpha)))
            (setup output)
            (table-set! outputs id output)
            (play output)
            output))))
  
  
  (method package (player-output self id (channel: channel #f) (player: player #f) (rank: rank #f) (position: position #f) (size: size #f) (level: level #f) (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f) (caps: caps #f) (sync-audio?: sync-audio? #f) (root-view: root-view #f))
    (or (table-ref outputs id #f)
        ;; the or is a quick hack to test self video
        (let ((player (or player (find-entity id))))
          (let ((output (case video-layout
                          ((overhead)
                           (new Overhead-Video-Sink
                             player
                             level: level
                             resolution: (or resolution video-resolution)
                             framerate: (or framerate video-framerate)
                             bitrate: (or bitrate video-bitrate)
                             codec: (or codec video-codec)
                             caps: caps
                             alpha-overlay: video-alpha))
                          (else
                           (new Circle-Video-Sink
                             id
                             channel
                             player
                             position: position
                             size: size
                             level: level
                             resolution: (or resolution video-resolution)
                             framerate: (or framerate video-framerate)
                             bitrate: (or bitrate video-bitrate)
                             codec: (or codec video-codec)
                             caps: caps
                             alpha-overlay: video-alpha
                             process?: (boolean id)
                             sync-audio?: sync-audio?
                             root-view: root-view)))))
            (install-output self id output rank: rank)
            output))))
  
  
  (method package (channel-output self channel (rank: rank #f) (sync-audio?: sync-audio? #f) (root-view: root-view #f))
    (let ((no (get-no channel))
          (level (get-level channel))
          (resolution (get-resolution channel))
          (framerate (get-framerate channel))
          (bitrate (get-bitrate channel))
          (codec (get-codec channel))
          (caps (get-caps channel))
          (player (current-me)))
      (assert resolution
        (let ((output (player-output self no
                        channel: channel
                        player: player
                        rank: rank
                        level: level
                        resolution: resolution
                        framerate: framerate
                        bitrate: bitrate
                        codec: codec
                        caps: caps
                        sync-audio?: sync-audio?
                        root-view: root-view)))
          (invalidate-state output)
          (update-layouts self)
          (effective-base-profile-update)
          output))))
  
  
  (method package (visualizer-output self position size)
    (let ((output (new Sheet-Video-Sink
                    #f
                    position: position
                    size: size
                    resolution: video-resolution
                    framerate: video-framerate
                    bitrate: video-bitrate
                    codec: video-codec
                    alpha-overlay: video-alpha
                    process?: #t)))
      (play output)
      output))
  
  
  (method package (replace-output self output new-channel (sync-audio?: sync-audio? #f))
    (let ((id (get-id output)))
      (let ((rank (find-output-rank self output))
            (focused? (eq? output focused-output)))
        (close-output self id output layout?: #f)
        (let ((new-output (channel-output self new-channel rank: rank sync-audio?: sync-audio?)))
          (when focused?
            (change-focused-output self new-output))))))
  
  
  (method package (close-output self id output (layout?: layout? #t))
    (table-clear outputs id)
    (set! ordered-outputs (remove! output ordered-outputs))
    (when (eq? output focused-output)
      (set! focused-output #f))
    (release output)
    (close output)
    (when layout?
      (update-layouts self)
      (effective-base-profile-update)))
  
  
  (method package (find-output-rank self output)
    (find ordered-outputs output))
  
  
  (method package (effective-focused-output self)
    (or focused-output
        (and (not-null? ordered-outputs)
             (car ordered-outputs))))
  
  
  (method package (change-focused-output self output)
    (let ((focus-layout? (eq? video-layout 'focus)))
      (when (and focus-layout? focused-output)
        (unfocus focused-output))
      (set! focused-output output)
      (when (and focus-layout? output)
        (focus output))))
  
  
  (method package (receive-server-video self id buffer dts pts duration keyframe?)
    (let ((output (find-output self id)))
      (define (receive)
        (when (eq? (get-stream-state output) 'off)
          (set-stream-state output 'on))
        (consume-video output buffer dts pts duration keyframe?)
        (when udp-record-src/sink?
          (let ((origin (get-origin (get-stream (get-channel output)))))
            (record-event udp-id-sink-media
                          (fixnum->flonum id)
                          (fixnum->flonum origin)
                          (fixnum->flonum udp-video)
                          -1.
                          -1.
                          -1.
                          (timestamp->flonum dts)))))
      
      (when output
        (cond ((not buffer)
               (set-stream-state output 'off))
              ((get-wait-keyframe? output)
               (when keyframe?
                 (set-wait-keyframe? output #f)
                 (receive)))
              (else
               (receive))))))
  
  
  (method package (receive-visualizer-video self output buffer dts pts duration keyframe?)
    (if (not buffer)
        (set-stream-state output 'off)
      (when (eq? (get-stream-state output) 'off)
        (set-stream-state output 'on))
      (consume-video output buffer dts pts duration keyframe?)))
  
  
  (method package (receive-video self id/output buffer dts pts duration keyframe?)
    (if (is? id/output Video-Sink)
        (receive-visualizer-video self id/output buffer dts pts duration keyframe?)
      (receive-server-video self id/output buffer dts pts duration keyframe?)))
  
  
  (method package (receive-processor-draw self id color alpha dts pts duration background slide?)
    (if (not color)
        (let ((output (find-output self id)))
          (when output
            (close-output self id output)))
      (let ((output (entity-output self id)))
        (set-background output background)
        (if (not slide?)
            (consume-video output color dts pts duration #f alpha)
          (let ((texture (get-texture (cache-quad-texture (get-pane output)))))
            (with-slide output texture
              (lambda ()
                (consume-video output color dts pts duration #f alpha))))))))
  
  
  (method package (render-outputs self)
    (unless (and render-hook
                 (render-hook self))
      (if (eq? video-layout 'focus)
          (let ((focused-output (effective-focused-output self)))
            (when focused-output
              (render focused-output)))
        (for-each render ordered-outputs))
      (when (and (eq? video-layout 'focus) (if hide-widget? (read-video-interface? 1) #t))
        (let ((focused-output (effective-focused-output self)))
          (for-each (lambda (output)
                      (unless (eq? output focused-output)
                        (render output)))
                    ordered-outputs)))))
  
  
  (method package (invalidate-outputs self)
    (for-each (lambda (output)
                (invalidate-texture (get-interface-pane output)))
              ordered-outputs))
  
  
  ;;;
  ;;;; Layout
  ;;;
  
  
  (method (on-cycle-layouts self evt)
    (let ((world (current-world)))
      (cycle-layouts self)
      (display-message world (capitalize (symbol->string video-layout)))))
  
  
  (method (cycle-layouts self)
    (case video-layout
      ((overhead)
       (sidebar-layout self))
      ((sidebar)
       (gallery-layout self))
      ((gallery)
       (circle-layout self))
      ((circle)
       (focus-layout self))
      ((circle)
       (gallery-layout self))))
  
  
  (method protected (update-layouts self)
    (case video-layout
      ((overhead)
       (overhead-layout self))
      ((sidebar)
       (sidebar-layout self))
      ((gallery)
       (gallery-layout self))
      ((circle)
       (circle-layout self))
      ((focus)
       (focus-layout self))))
  
  
  (method (stop-renders self)
    (let ((zone (current-zone)))
      (for-each (lambda (player)
                  (let ((elem (get-camera-pane player)))
                    (when elem
                      (set-render? elem #f))))
                (get-players zone))))
  
  
  (method public (goto-layout self layout)
    (case layout
      ((circle)
       (circle-layout self))
      ((focus)
       (focus-layout self))
      ((gallery)
       (gallery-layout self))))
  
  
  (method package (overhead-layout self)
    (stop-renders self)
    (change-video-layout 'overhead)
    (layout-outputs self))
  
  
  (method package (sidebar-layout self)
    (stop-renders self)
    (change-video-layout 'sidebar)
    (layout-outputs self))
  
  
  (method package (gallery-layout self)
    (change-video-layout 'gallery)
    (layout-outputs self))
  
  
  (method package (layout-outputs self)
    (when (not-null? ordered-outputs)
      (let ((rectangles (layout self (length ordered-outputs))))
        (when rectangles
          (let ((reordered-outputs (if (and (eq? video-layout 'gallery) self-output)
                                       (append (remove self-output ordered-outputs) (list self-output))
                                     ordered-outputs)))
            (for-each (lambda (output rect)
                        ;; quick hacks to test self video
                        (let ((player (or (get-player output) (current-me))))
                          (let ((elem (get-camera-pane player)))
                            (if (not rect)
                                (when elem
                                  (set-render? elem #f))
                              (when elem
                                (set-render? elem #t))
                              (move output rect)
                              (update-panes output)))))
                      reordered-outputs
                      rectangles))))))
  
  
  (method package (layout self num-players)
    (let ((window (current-window)))
      (let ((bounds (get-bounds window)))
        (let ((l (get-left bounds))
              (t (get-top bounds))
              (r (get-right bounds))
              (b (get-bottom bounds)))
          (case video-layout
            ((sidebar)
             (layout-tiles num-players (new Rect 10 70 210 (- b 100))))
            ((gallery)
             (if (= num-players 1)
                 (list (adjust-focused bounds (focused-rect bounds)))
               (reverse (layout-tiles num-players bounds))))
            (else
             #f))))))
  
  
  (method package (circle-layout self)
    (change-video-layout 'circle)
    (update-circle-layout self))
  
  
  (method package (focus-layout self)
    (change-video-layout 'focus)
    (update-circle-layout self)
    (let ((focused-output (effective-focused-output self)))
      (when focused-output
        (focus focused-output))))
  
  
  (method (update-circle-layout self)
    (let ((count (length ordered-outputs)))
      (assert layout-circle-hook
        (with-safe-hook layout-circle-hook
          (lambda (procedure)
            (let ((matrices (procedure ordered-outputs)))
              (for-each (lambda (output placement)
                          (bind (translation . rotation) placement
                            (set-translation output translation)
                            (set-rotation output rotation)
                            (update-matrices output count)
                            (update-panes output)))
                        ordered-outputs
                        matrices)))))))
  
  
  (method protected (update-interface-matrices self)
    (let ((count (length ordered-outputs)))
      (for-each (lambda (output)
                  (update-interface-matrix output count))
                ordered-outputs))))


;;;
;;;; Video-Src
;;;


(class Video-Src extends Stream-Src
  
  
  (slot task initialize #f accessors generate)
  
  
  (method (start-listeners self)
    (for-each start-listener sinks))
  
  
  (method (stop-listeners self)
    (for-each stop-listener sinks))
  
  
  (method (task-start self name)
    (let ((procedure
            (lambda (task)
              (video-loop self task))))
      (let ((task (new Task name procedure priority: video-priority)))
        (start-listeners self)
        (start-task task)
        (set! self.task task))))
  
  
  (method (task-stop self)
    (stop-listeners self)
    (stop-task task)
    (set! task #f))
  
  
  (method protected virtual (video-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (process self task exit)
          (iter)))))
  
  
  (method override (process self task exit)
    (for-each (lambda (consumer)
                (when (get-processing? consumer)
                  (gst_app_sink_process task exit consumer)))
              sinks)))


;;;
;;;; Camera-Video-Src
;;;


(definition public (camera-resolutions)
  (let ((devices (camera-devices)))
    (if (null? devices)
        '()
      ;; todo manage multiple cameras
      (prog1 (let ((device (car devices)))
               (camera-device-resolutions device))
        (for-each (lambda (device)
                    ;; hack around what seems to be a memory
                    ;; leak of the device not freeing its caps
                    (let ((caps (gst_device_get_caps device)))
                      (gst_object_unref device)
                      (gst_caps_unref caps)
                      (gst_caps_unref caps)))
                  devices)))))


(definition protected (camera-devices)
  (with-unref ((monitor (gst_device_monitor_new)))
    (let ((caps (gst_caps_new_empty_simple "video/x-raw")))
      (gst_device_monitor_add_filter monitor "Video/Source" caps)
      (gst_caps_unref caps))
    (let ((queue (new-queue)))
      (let (loop (devices (gst_device_monitor_get_devices monitor)))
        (if (not devices)
            (begin
              (g_list_free devices)
              (queue-list queue))
          (enqueue queue (gst_device_monitor_device_list_data devices))
          (loop (gst_device_monitor_device_list_next devices)))))))


(definition protected (camera-device-resolutions device)
  (let ((caps (gst_device_get_caps device)))
    (prog1 (let ((all '()))
             (loop (for i from 0 below (gst_caps_get_size caps))
                   (let ((struc (gst_caps_get_structure caps i)))
                     (when (equal? (gst_structure_get_name struc) "video/x-raw")
                       (let ((width (gst_structure_get_int struc "width"))
                             (height (gst_structure_get_int struc "height")))
                         (let ((resolution (new Dimension width height)))
                           (when (not (member? resolution all test: nu=?))
                             (set! all (cons resolution all))))))))
             all)
      (gst_caps_unref caps))))


(definition protected (cache-camera-resolutions)
  (or camera-resolutions
      (let ((resolutions (sort > (camera-resolutions) key: get-area)))
        (set! camera-resolutions resolutions)
        resolutions)))


(definition protected maximum-camera-resolution
  (* 1280 720))

(definition protected decreasing-camera-resolutions
  #f)

(definition protected current-camera-resolution
  #f)

(definition protected (cache-decreasing-camera-resolutions)
  (define (keep-resolution? resolution)
    (<= (get-area resolution) maximum-camera-resolution))
  
  (or decreasing-camera-resolutions
      (let ((resolutions (collect-if keep-resolution? (sort > (camera-resolutions) key: get-area))))
        (set! decreasing-camera-resolutions resolutions)
        resolutions)))

(definition protected (determine-camera-resolution)
  (or current-camera-resolution
      (let ((resolution (car (cache-decreasing-camera-resolutions))))
        (set! current-camera-resolution resolution)
        resolution)))

(definition protected (change-camera-resolution resolution)
  (set! current-camera-resolution resolution))


(class Camera-Video-Src extends Video-Src
  
  
  (slot resolution initialize #f accessors generate)
  (slot framerate  initialize #f accessors generate)
  (slot selfrate   initialize #f accessors generate)
  (slot pipeline   initialize #f accessors generate)
  (slot probe      initialize #f accessors generate)
  
  
  (method override (initialize self (resolution: resolution #f) (framerate: framerate #f) (selfrate: selfrate #f))
    (nextmethod self)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.selfrate selfrate))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((camera-resolution (determine-camera-resolution))
          (max-resolution resolution)
          (max-framerate selfrate))
      (let ((camera-width (get-width camera-resolution))
            (camera-height (get-height camera-resolution))
            (max-width (get-width max-resolution))
            (max-height (get-height max-resolution)))
        (let ((pipeline (apply gst-pipeline
                               (cond-expand
                                 (mac "avfvideosrc name=src")
                                 (windows "ksvideosrc name=src")
                                 (else "v4l2src name=src"))
                               (tie "video/x-raw, width={camera-width}, height={camera-height}, pixel-aspect-ratio=(fraction)1/1")
                               "videoscale method=sinc"
                               (tie "video/x-raw, width={max-width}, height={max-height}, pixel-aspect-ratio=(fraction)1/1")
                               "tee name=tee"
                               (append
                                 (collect (lambda (consumer)
                                            (and (is? consumer Camera-Self-Consumer)
                                                 (let ((profile (get-profile consumer)))
                                                   (let ((name (get-name profile))
                                                         (resolution (get-resolution profile)))
                                                     (let ((width (get-width resolution))
                                                           (height (get-height resolution))
                                                           (scale? (nu/=? resolution max-resolution)))
                                                       (list
                                                         "tee."
                                                         (tie "queue name=queueself{name}")
                                                         (and scale? "videoscale method=sinc")
                                                         "videoconvert"
                                                         (tie "video/x-raw, format=BGRA, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                                         "videoflip video-direction=horiz"
                                                         (tie "appsink async=false sync=false name=sinkself{name}")))))))
                                          sinks)
                                 (collect (lambda (consumer)
                                            (and (is? consumer Camera-Video-Consumer)
                                                 (let ((profile (get-profile consumer)))
                                                   (let ((name (get-name profile))
                                                         (resolution (get-resolution profile))
                                                         (bitrate (get-bitrate profile))
                                                         (codec (get-codec profile)))
                                                     (let ((width (get-width resolution))
                                                           (height (get-height resolution))
                                                           (scale? (nu/=? resolution max-resolution)))
                                                       `("tee."
                                                         ,(tie "queue name=queue{name}")
                                                         ,(and scale? "videoscale method=sinc")
                                                         "videoconvert"
                                                         ,(tie "video/x-raw, format=I420, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                                         ,(and (eq? codec 'h264)
                                                               (let ((key-int-max (and camera-keyframes (fxround (* (cast <fl> framerate) camera-keyframes))))
                                                                     (tune "zerolatency")
                                                                     (speed-preset "superfast")
                                                                     (threads #f @wait-threads (and needs-scaling? "1")))
                                                                 (gst-element "x264enc"
                                                                              key-int-max: key-int-max
                                                                              bitrate: bitrate
                                                                              tune: tune
                                                                              speed-preset: speed-preset
                                                                              threads: threads)))
                                                         ,(tie "appsink async=false sync=false name=sink{name}")))))))
                                          sinks)))))
          (gst_object_set_name pipeline "camera")
          (with-unref ((src (gst_bin_get_by_name pipeline "src")))
            (with-unref ((pad (gst_element_get_static_pad src "src")))
              (set! probe (gst_pad_add_rate_probe pad max-framerate))))
          (for-each (lambda (consumer)
                      (if (eq? (get-caps consumer) 'self)
                          (let ((profile (get-profile consumer)))
                            (let ((name (get-name profile))
                                  (profile (get-profile consumer)))
                              (let ((resolution (get-resolution profile))
                                    (selfrate (get-selfrate profile)))
                                (let ((width (get-width resolution))
                                      (height (get-height resolution))
                                      (listener (open-stream-listener (format "cameraself{a}" name))))
                                  (with-unref ((appsink (gst_bin_get_by_name pipeline (format "sinkself{a}" name))))
                                    (gst_app_sink_connect_signals appsink listener)
                                    (setup-consumer consumer listener appsink (* width height 4))
                                    (with-unref ((queueself (gst_bin_get_by_name pipeline (tie "queueself{name}"))))
                                      (with-unref ((pad (gst_element_get_static_pad queueself "sink")))
                                        (if (get-processing? consumer)
                                            (set-probe consumer (gst_pad_add_rate_probe pad selfrate))
                                          (set-probe consumer (gst_pad_add_drop_probe pad))))))))))
                        (let ((profile (get-profile consumer)))
                          (let ((name (get-name profile))
                                (resolution (get-resolution profile))
                                (framerate (get-framerate profile)))
                            (let ((width (get-width resolution))
                                  (height (get-height resolution))
                                  (listener (open-stream-listener (format "camera{a}" name))))
                              (with-unref ((appsink (gst_bin_get_by_name pipeline (format "sink{a}" name))))
                                (gst_app_sink_connect_signals appsink listener)
                                (setup-consumer consumer listener appsink (* width height 4))
                                (with-unref ((queue (gst_bin_get_by_name pipeline (tie "queue{name}"))))
                                  (with-unref ((pad (gst_element_get_static_pad queue "sink")))
                                    (if (get-processing? consumer)
                                        (set-probe consumer (gst_pad_add_rate_probe pad framerate))
                                      (set-probe consumer (gst_pad_add_drop_probe pad)))))))))))
                    sinks)
          (set! self.pipeline pipeline)
          (gst_element_set_state pipeline GST_STATE_READY)))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (for-each (lambda (consumer)
                (when (get-processing? consumer)
                  (start-processing consumer video-priority)))
              sinks)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (for-each (lambda (consumer)
                (when (get-processing? consumer)
                  (stop-processing consumer)))
              sinks)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (when probe
      (gst_pad_probe_free probe)
      (set! probe #f))
    (release-consumers self)))


;;;
;;;; Camera-Video-Consumer
;;;


(class Camera-Video-Consumer extends Stream-Consumer
  
  
  (slot channel-no getter generate)
  (slot profile    getter generate)
  (slot probe      accessors generate)
  (slot rate       accessors generate)
  
  
  (method override (initialize self . rest)
    (bind-keywords ((channel-no #f) (profile #f) . others) rest
      (apply nextmethod self others)
      (set! self.channel-no channel-no)
      (set! self.profile profile)
      (set! self.probe #f)
      (set! self.rate (new Rate))))
  
  
  (method override (destroy self)
    (when probe
      (gst_pad_probe_free probe)
      (set! probe #f))
    (nextmethod self))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" (get-name profile) state))))
  
  
  (method override (task-name self)
    (let ((name (get-name profile)))
      (string->symbol (format "camera{a}" name))))


  (method override (consume-frame self buffer dts pts duration keyframe?)
    (send-client-media (current-client) channel-no buffer dts pts duration keyframe?)
    (update rate (get-framerate profile))))


;;;
;;;; Camera-Self-Consumer
;;;


(class Camera-Self-Consumer extends Stream-Consumer
  
  
  (slot profile initialize #f getter generate)
  (slot output  initialize #f accessors generate)
  (slot probe   initialize #f accessors generate)
  
  
  (method override (initialize self . rest)
    (bind-keywords ((profile #f) . others) rest
      (apply nextmethod self others)
      (set! self.profile profile)
      (when (or processing? self-split?)
        (open-self-output self))))
  
  
  (method override (destroy self)
    (close-self-output self)
    (when probe
      (gst_pad_probe_free probe)
      (set! probe #f))
    (nextmethod self))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" (get-name profile) state))))
  
  
  (method override (task-name self)
    (let ((name (get-name profile)))
      (string->symbol (format "cameraself{a}" name))))
  
  
  (method protected (open-self-output self)
    (unless output
      (set! output (create-self-output self))
      (install-self-output self)))
  
  
  (method protected (install-self-output self (rank: rank #f))
    (let ((video (current-video)))
      (install-output video (get-id output) output rank: rank)
      (set-self-output video output)
      (set-self-consumer video self)
      (update-layouts video)
      (effective-base-profile-update)
      (invalidate-state output)))
  
  
  (method protected (create-self-output self)
    (let ((me (current-me)))
      (let ((level (get-level profile))
            (resolution (get-resolution profile))
            (framerate (get-framerate profile))
            (bitrate (get-bitrate profile))
            (codec (get-codec profile)))
        (let ((id (list 'self level))
              (channel #f)
              (player me))
          (new Circle-Video-Sink
            id
            channel
            player
            level: level
            resolution: resolution
            framerate: framerate
            bitrate: bitrate
            codec: codec
            alpha-overlay: video-alpha
            process?: #t)))))
  
  
  (method protected (close-self-output self)
    (let ((video (current-video)))
      (when output
        (close-output video (get-id output) output)
        (set-stream-state output 'off)
        (set-self-output video #f)
        (set-self-consumer video #f)
        (set! output #f))))
  
  
  (method override (consume-frame self buffer dts pts duration keyframe?)
    (when output
      (if (not buffer)
          (set-stream-state output 'off)
        (set-stream-state output 'drawn)
        (draw output buffer #f dts pts duration)
        (when udp-record-src/sink?
          (let ((size (u8vector-length buffer)))
            (record-event udp-id-src-media
                          -1. ;; todo channel no
                          (fixnum->flonum client-no)
                          (fixnum->flonum udp-video)
                          -1.
                          -1.
                          (fixnum->flonum size)
                          (timestamp->flonum dts)))))))
  
  
  (method override (consume-eos self)
    (when output
      (set-stream-state output 'off))))


;;;
;;;; Screen-Video-Src
;;;


(class Screen-Video-Src extends Video-Src
  
  
  (slot resolution initialize #f accessors generate)
  (slot framerate  initialize #f accessors generate)
  (slot bitrate    initialize #f accessors generate)
  (slot codec      initialize #f accessors generate)
  (slot pipeline   initialize #f accessors generate)
  
  
  (method override (initialize self (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f))
    (nextmethod self)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (get-width resolution))
          (height (get-height resolution))
          (listener (open-stream-listener "screen")))
      (let ((pipeline (gst-pipeline (cond-expand
                                      (mac "avfvideosrc capture-screen=true")
                                      (windows "dx9screencapsrc")
                                      (else "v4l2src"))
                                    (tie "videorate max-rate={framerate}")
                                    "videoscale"
                                    "videoconvert"
                                    ;; inform the camera to use high resolution
                                    (tie "video/x-raw, width=1280, height=720, pixel-aspect-ratio=(fraction)1/1")
                                    "videoscale"
                                    "videoconvert"
                                    (tie "video/x-raw, format=I420, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                    (and (eq? codec 'h264)
                                         (let ((key-int-max (and screen-share-keyframes (fxround (* (cast <fl> framerate) screen-share-keyframes))))
                                               (bitrate bitrate)
                                               (tune "zerolatency")
                                               (speed-preset "superfast"))
                                           (gst-element "x264enc"
                                                        key-int-max: key-int-max
                                                        bitrate: bitrate
                                                        tune: tune
                                                        speed-preset: speed-preset
                                                        name: "enc")))
                                    "appsink name=sink")))
        (gst_object_set_name pipeline "screen")
        (with-unref ((appsink (gst_bin_get_by_name pipeline "sink")))
          (gst_app_sink_connect_signals appsink listener)
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.pipeline pipeline)
          (setup-consumer (find-consumer self #f) listener appsink (* width height 4))))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'screen)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (release-consumers self)))


;;;
;;;; Screen-Video-Consumer
;;;


(class Screen-Video-Consumer extends Stream-Consumer
  
  
  (slot channel-no getter generate)
  
  
  (method override (initialize self channel-no . rest)
    (apply nextmethod self rest)
    (set! self.channel-no channel-no))


  (method override (consume-frame self buffer dts pts duration keyframe?)
    (send-client-media (current-client) channel-no buffer dts pts duration keyframe?)))


;;;
;;;; File-Video-Src
;;;


(class File-Video-Src extends Video-Src
  
  
  (slot location   initialize #f accessors generate)
  (slot resolution initialize #f accessors generate)
  (slot pipeline   initialize #f accessors generate)
  
  
  (method override (initialize self location (resolution: resolution #f))
    (nextmethod self)
    (set! self.location location)
    (set! self.resolution resolution))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (get-width resolution))
          (height (get-height resolution))
          (listener (open-stream-listener "file")))
      (let ((pipeline (gst-pipeline (tie "filesrc name=filesrc")
                                    "qtdemux"
                                    "appsink name=appsink")))
        (gst_object_set_name pipeline "file")
        (with-unref ((filesrc (gst_bin_get_by_name pipeline "filesrc"))
                     (appsink (gst_bin_get_by_name pipeline "appsink")))
          (gst_monitor pipeline 'events "appsink")
          (gst_app_sink_connect_signals appsink listener)
          (g_object_set_string filesrc "location" (path-normalize (parse (new-file {Directory Documents} (add-extension location "mp4")))))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.pipeline pipeline)
          (setup-consumer (find-consumer self #f) listener appsink (* width height 4))))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'file)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (release-consumers self)))


;;;
;;;; File-Preprocess-Video-Src
;;;


(definition protected stream-keyframes
  (world-setting 'world.stream-keyframes #f))


(class File-Preprocess-Video-Src extends Video-Src
  
  
  (slot location   initialize #f accessors generate)
  (slot prime?     initialize #f accessors generate)
  (slot level      initialize #f accessors generate)
  (slot resolution initialize #f accessors generate)
  (slot framerate  initialize #f accessors generate)
  (slot bitrate    initialize #f accessors generate)
  (slot codec      initialize #f accessors generate)
  (slot pipeline   initialize #f accessors generate)
  
  
  (method override (initialize self location (prime?: prime? #f) (level: level #f) (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f))
    (nextmethod self)
    (set! self.location location)
    (set! self.prime? prime?)
    (set! self.level level)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (let ((width (and (not prime?) (get-width resolution)))
          (height (and (not prime?) (get-height resolution)))
          (listener (open-stream-listener "preprocessvideo")))
      (let ((pipeline (if prime?
                          (gst-pipeline (tie "filesrc name=filesrc")
                                        "qtdemux"
                                        "video/x-h264"
                                        "appsink name=appsink sync=false")
                        (gst-pipeline (tie "filesrc name=filesrc")
                                      ;; calls vtdec which generates errors in some files
                                      ;; "decodebin"
                                      "qtdemux"
                                      "avdec_h264 max-threads=1"
                                      (and framerate (tie "videorate max-rate={framerate}"))
                                      "videoscale method=sinc"
                                      "videoconvert"
                                      (tie "video/x-raw, format=I420, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                      (let ((key-int-max (and stream-keyframes (fxround (* (cast <fl> framerate) stream-keyframes))))
                                            (bitrate bitrate)
                                            (tune "zerolatency")
                                            (speed-preset "superfast"))
                                        ;; no point using a slower speed until
                                        ;; we can encode without tune=zerolatency
                                        (gst-element "x264enc"
                                                     threads: 1
                                                     key-int-max: key-int-max
                                                     bitrate: bitrate
                                                     tune: tune
                                                     speed-preset: speed-preset
                                                     name: "enc"))
                                      "appsink name=appsink sync=false"))))
        (gst_object_set_name pipeline "file")
        (with-unref ((filesrc (gst_bin_get_by_name pipeline "filesrc"))
                     (appsink (gst_bin_get_by_name pipeline "appsink")))
          (gst_app_sink_connect_signals appsink listener)
          (g_object_set_string filesrc "location" (path-normalize location))
          (gst_element_set_state pipeline GST_STATE_READY)
          (set! self.pipeline pipeline)
          (let ((size (if prime?
                          ;; quicky use resolution as big as any video we will preprocess
                          (* 1920 1080 4)
                        (* width height 4))))
            (setup-consumer (find-consumer self #f) listener appsink size))))))
  
  
  (method override (start-element self)
    (nextmethod self)
    (task-start self 'file)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (play-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PLAYING))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (gst_element_set_state pipeline GST_STATE_PAUSED))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (gst_element_set_state pipeline GST_STATE_READY))
  
  
  (method override (release-element self)
    (nextmethod self)
    (gst_element_release pipeline)
    (release-consumers self))
  
  
  (method override (video-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (site preprocess
            (process self task exit))
          (iter))))))


;;;
;;;; File-Stream-Video-Src
;;;


(class File-Stream-Video-Src extends Video-Src implements Media-Stream
  
  
  (slot profile      getter generate)
  (slot location     getter generate)
  (slot stream?      accessors explicit)
  (slot file         getter generate)
  (slot reader       getter generate)
  (slot time-base    getter generate)
  (slot consumer     getter generate)
  (slot pause?       getter generate)
  (slot flush?       getter generate)
  (slot delayed-seek getter generate)
  
  
  (method override (initialize self profile location (stream?: stream? #t))
    (nextmethod self)
    (set! self.profile profile)
    (set! self.location location)
    (set! self.stream? stream?)
    (set! self.file #f)
    (set! self.reader #f)
    (set! self.time-base (new Time-Base))
    (set! self.consumer #f)
    (set! self.pause? #f)
    (set! self.flush? #f)
    (set! self.delayed-seek #f))
  
  
  (method override (start-element self)
    (nextmethod self)
    (set! file (new-file {Directory Documents} (add-extension location (get-extension profile))))
    (set! reader (new Stream-Reader file))
    (set! consumer (car sinks))
    (task-start self 'video-stream))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (close reader)
    (set! file #f)
    (set! reader #f))
  
  
  (method override (get-stream? self)
    stream?)
  
  
  (method override (set-stream? self flag)
    (set! stream? flag))
  
  
  (method override (play-stream self)
    (task-wakeup (get-thread task)
      (lambda (exit)
        (set! pause? #f)
        (reset time-base))))
  
  
  (method override (pause-stream self)
    (task-wakeup (get-thread task)
      (lambda (exit)
        (set! pause? #t)
        (task-sleep task +inf.0 exit))))
  
  
  (method override (goto-delayed self pos normalized-dts)
    (when (not delayed-seek)
      (task-wakeup (get-thread task)
        (lambda (exit)
          (task-sleep task +inf.0 exit))))
    (set! delayed-seek (cons pos normalized-dts)))
  
  
  (method override (goto-stream self pos normalized-dts)
    (task-wakeup (get-thread task)
      (lambda (exit)
        (if (not pos)
            (begin
              (when delayed-seek
                (bind (pos . normalized-dts) delayed-seek
                  (goto-position reader pos normalized-dts))
                (set! delayed-seek #f))
              (if pause?
                  (task-sleep task +inf.0 exit)
                (reset time-base)
                (set! flush? #t)))
          (goto-position reader pos normalized-dts)
          (when stream?
            (receive (buffer dts pts duration keyframe?) (read-frame reader stream? #f)
              (consume-frame consumer buffer dts pts duration keyframe?)))
          (task-sleep task +inf.0 exit)))))
  
  
  (method override (backward-stream self pos normalized-dts)
    (when pause?
      (task-wakeup (get-thread task)
        (lambda (exit)
          (goto-position reader pos normalized-dts)
          (when stream?
            (receive (buffer dts pts duration keyframe?) (read-frame reader stream? #f)
              (consume-frame consumer buffer dts pts duration keyframe?)))
          (task-sleep task +inf.0 exit)))))
  
  
  (method override (forward-stream self pos normalized-dts)
    (when pause?
      (task-wakeup (get-thread task)
        (lambda (exit)
          (goto-position reader pos normalized-dts)
          (when stream?
            (receive (buffer dts pts duration keyframe?) (read-frame reader stream? #f)
              (consume-frame consumer buffer dts pts duration keyframe?)))
          (task-sleep task +inf.0 exit)))))
  
  
  (method override (video-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (if (stopping? task)
              (task-done task exit)
            ;; protect against stream? threaded change
            (let ((stream? stream?))
              (receive (buffer dts pts duration keyframe?) (read-frame reader stream?)
                (if (not buffer)
                    (if stream-loop?
                        (begin
                          (close reader)
                          (set! reader (new Stream-Reader file))
                          (set! time-base (new Time-Base))
                          (iter))
                      (task-done task exit))
                  (let ((time (current-seconds))
                        (nanodts (timestamp->flonum dts)))
                    (update-start time-base time nanodts)
                    (let ((sendtime (remote->local time-base nanodts)))
                      (task-sleep task (- sendtime time) exit)
                      (when stream?
                        (if flush?
                            (set! flush? #f)
                          (site stream
                            (consume-frame consumer buffer dts pts duration keyframe?))))))))))
          (iter))))))


;;;
;;;; Draw-Video-Src
;;;


(definition protected draw-resolution
  (world-setting 'world.draw-resolution {Dimension 1280 720}))

(definition protected draw-framerate
  (world-setting 'world.draw-framerate 5))

(definition protected draw-bitrate
  (world-setting 'world.draw-bitrate 1024))

(definition protected draw-codec
  (world-setting 'world.draw-codec 'h264))


(class Draw-Video-Src extends Video-Src
  
  
  (slot draw-proc  initialize #f accessors generate)
  (slot start-time initialize #f accessors generate)
  (slot resolution initialize #f accessors generate)
  (slot context    initialize #f accessors generate)
  (slot consumer   initialize #f getter generate)
  
  
  (method override (initialize self (draw-proc: draw-proc #f))
    (nextmethod self)
    (set! self.draw-proc draw-proc)
    (set! self.resolution draw-resolution))
  
  
  (method protected virtual (new-draw-context self)
    (new Draw-Context draw-resolution draw-framerate draw-bitrate))
  
  
  (method override (start-element self)
    (nextmethod self)
    (set! context (new-draw-context self))
    (set! start-time (current-seconds))
    (set! consumer (car sinks))
    (task-start self 'draw))
  
  
  (method override (play-element self)
    (nextmethod self))
  
  
  (method override (pause-element self)
    (nextmethod self))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (task-stop self)
    (free-context self))
  
  
  (method (free-context self)
    (when context
      (close context)
      (set! context #f)))
  
  
  (method override (video-loop self task)
    (declare (proper-tail-calls))
    (let ((tier (current-client)))
      (with-task task
        (lambda (exit)
          (let (iter)
          (if (stopping? task)
              (task-done task exit)
            (let ((surface (get-surface context)))
              (draw-stream self surface)
              (receive (color alpha dts pts duration keyframe?) (extract context task exit)
                (site stream
                  (let ((effective-dts (flonum->timestamp (- (current-seconds) start-time))))
                    (consume-frame consumer color effective-dts effective-dts duration keyframe?)))))
            (task-sleep task .1 exit)
            (iter)))))))
  
  
  (method protected virtual (draw-stream self surface)
    (clear surface)
    (when draw-proc
      (draw-proc surface resolution))))


;;;
;;;; Image-Stream-Video-Src
;;;


(class Image-Stream-Video-Src extends Draw-Video-Src
  
  
  (slot location      getter generate)
  (slot file          getter generate)
  (slot color         getter generate)
  (slot alpha         getter generate)
  (slot dts           getter generate)
  (slot pts           getter generate)
  (slot duration      getter generate)
  (slot keyframe?     getter generate)
  (slot extract-mutex getter generate)
  
  
  (method override (initialize self location)
    (nextmethod self)
    (set! self.location location)
    (set! self.file (new-file {Directory Documents} location))
    (set! self.color #f)
    (set! self.alpha #f)
    (set! self.dts #f)
    (set! self.pts #f)
    (set! self.duration #f)
    (set! self.keyframe? #f)
    (set! self.extract-mutex (make-mutex 'extract)))
  
  
  (method override (new-draw-context self)
    (new Draw-Context draw-resolution draw-framerate draw-bitrate tune: (bitwise-ior stillimage zerolatency)))
  
  
  (method (extract/cache self task exit)
    (mutex-lock! extract-mutex)
    (prog1
        (if color
            (values color alpha dts pts duration keyframe?)
          (let ((surface (get-surface context)))
            (draw-stream self surface)
            (receive (color alpha dts pts duration keyframe?) (extract context task exit)
              (set! self.color color)
              (set! self.alpha alpha)
              (set! self.dts dts)
              (set! self.pts pts)
              (set! self.duration duration)
              (set! self.keyframe? keyframe?)
              (values color alpha dts pts duration keyframe?))))
      (mutex-unlock! extract-mutex)))
  
  
  (method override (video-loop self task)
    (declare (proper-tail-calls))
    (let ((tier (current-client)))
      (with-task task
        (lambda (exit)
          (receive (color alpha dts pts duration keyframe?) (extract/cache self task exit)
            (site stream
              (let ((effective-dts (flonum->timestamp (- (current-seconds) start-time))))
                (consume-frame consumer color effective-dts effective-dts duration keyframe?))))
          (free-context self)
          (continuation-return exit #f)))))
  
  
  (method override (draw-stream self surface)
    (let ((rect (new Rect 0 0 (get-width resolution) (get-height resolution))))
      (with ((image (new Image moniker: file)))
        (let ((size (image-size image)))
          (if (> (get-width size) (get-height size))
              (fill-image surface
                          rect
                          image
                          mode: 'fill)
            (fill-image surface
                        rect
                        image
                        mode: 'fit))))))
  
  
  (method override (resettable? self)
    #t)
  
  
  (method override (reset-media self channel)
    (receive (color alpha dts pts duration keyframe?) (extract/cache self task exit)
      (let ((effective-dts (flonum->timestamp (- (current-seconds) start-time))))
        (consume-frame consumer color effective-dts effective-dts duration keyframe?)))))


;;;
;;;; Video-Sink
;;;


(class Video-Sink extends Stream-Sink
  
  
  (slot level                       initialize #f accessors generate)
  (slot resolution                  initialize #f accessors generate)
  (slot framerate                   initialize #f accessors generate)
  (slot bitrate                     initialize #f accessors generate)
  (slot codec                       initialize #f accessors generate)
  (slot caps                        initialize #f accessors generate)
  (slot process?                    initialize #f accessors generate)
  (slot sync-audio?                 initialize #f accessors generate)
  (slot alpha-overlay               initialize #f accessors generate)
  (slot color-pipeline              initialize #f accessors generate)
  (slot color-appsrc                initialize #f accessors generate)
  (slot color-appsink               initialize #f accessors generate)
  (slot color-data     <u8vector+>  initialize #f accessors generate)
  (slot color-info     <u64vector+> initialize #f accessors generate)
  (slot color-listener              initialize #f accessors generate)
  (slot alpha?                      initialize #f accessors generate)
  (slot alpha-pipeline              initialize #f accessors generate)
  (slot alpha-appsrc                initialize #f accessors generate)
  (slot alpha-appsink               initialize #f accessors generate)
  (slot alpha-data     <u8vector+>  initialize #f accessors generate)
  (slot alpha-info     <u64vector+> initialize #f accessors generate)
  (slot alpha-listener              initialize #f accessors generate)
  (slot image-surface               initialize #f accessors generate)
  (slot image-inhibit?              initialize #f accessors generate)
  (slot task                        initialize #f accessors generate)
  (slot rate                        initialize #f accessors generate)
  (slot seek-callback               initialize #f accessors generate)
  (slot wait-keyframe?              initialize #t accessors generate)
  (slot stream-state                initialize 'off getter generate setter explicit)
  (slot stream-playing?             initialize #f getter generate)
  (slot moving-deviation            initialize 0. getter generate)
  (slot timestamp-offset            initialize 0  getter generate)
  
  
  (method override (initialize self (level: level #f) (resolution: resolution #f) (framerate: framerate #f) (bitrate: bitrate #f) (codec: codec #f) (caps: caps #f) (process?: process? #t) (alpha-overlay: alpha-overlay #f) (alpha?: alpha? #f) (sync-audio?: sync-audio? #f))
    (nextmethod self)
    (set! self.level level)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec codec)
    (set! self.caps caps)
    (set! self.process? process?)
    (set! self.sync-audio? sync-audio?)
    (set! self.alpha-overlay alpha-overlay)
    (set! self.alpha? alpha?)
    (set! self.rate (new Rate)))
  
  
  (method package virtual (start-listeners self)
    (when color-listener
      (start-stream-listener color-listener))
    (when alpha-listener
      (start-stream-listener alpha-listener)))
  
  
  (method package virtual (stop-listeners self)
    (when color-listener
      (stop-stream-listener color-listener))
    (when alpha-listener
      (stop-stream-listener alpha-listener)))
  
  
  (method package virtual (resize self)
    )
  
  
  (method package virtual (move self rect)
    )
  
  
  (method package virtual (focus self)
    )
  
  
  (method package virtual (unfocus self)
    )
  
  
  (method package (set-stream-state self state)
    (when (neq? state stream-state)
      (set! stream-state state)
      (invalidate-state self)))
  
  
  (method package virtual (invalidate-state self . rest)
    )
  
  
  (method package virtual (setup-pipeline self)
    (when process?
      (let ((width (get-width resolution))
            (height (get-height resolution))
            (hardware? video-hardware?))
        (let ((listener (open-stream-listener "videocolor"))
              (pipeline (gst-pipeline (format "appsrc{? caps=\"{a}\"~} name=src" caps)
                                      (if sync-audio?
                                          "queue min-threshold-time=200000000 name=queue"
                                        "queue")
                                      (and (not hardware?) (eq? codec 'h264) (tie "avdec_h264 max-threads=1"))
                                      ;; try
                                      (and hardware? "h264parse")
                                      (and hardware? "vtdec_hw")
                                      "videoscale"
                                      "videoconvert"
                                      (and alpha-overlay (tie "alpha alpha={alpha-overlay}"))
                                      (tie "video/x-raw, format=BGRA, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                      (tie "appsink name=sink"))))
          (gst_object_set_name pipeline "output")
          (with-unref ((appsrc (gst_bin_get_by_name pipeline "src"))
                       (appsink (gst_bin_get_by_name pipeline "sink")))
            (let ((data (make-u8vector (* width height 4)))
                  (info (make-u64vector 4)))
              (gst_app_sink_connect_signals appsink listener)
              (when (not caps)
                (case codec
                  ((h264)
                   (gst-app-src-set-caps appsrc "video/x-h264"
                     "width"         'int      width
                     "height"        'int      height
                     "framerate"     'fraction (cons framerate 1)
                     "stream-format" 'string   "byte-stream"
                     "alignment"     'string   "au"))
                  (else
                   (gst-app-src-set-caps appsrc "video/x-raw"
                     "format"    'string   "I420"
                     "width"     'int      width
                     "height"    'int      height
                     "framerate" 'fraction (cons framerate 1)))))
              (g-object-set appsrc
                "is-live"     'boolean #t
                "stream-type" 'int     GST_APP_STREAM_TYPE_STREAM
                "format"      'int     GST_FORMAT_TIME)
              (gst_element_set_state pipeline GST_STATE_READY)
              (set! self.color-data data)
              (set! self.color-info info)
              (set! self.color-pipeline pipeline)
              (set! self.color-appsrc appsrc)
              (set! self.color-appsink appsink)
              (set! self.color-listener listener))))
        (when alpha?
          (let ((listener (open-stream-listener "videoalpha"))
                (pipeline (gst-pipeline "appsrc name=src"
                                        "avdec_h264 max-threads=1 name=dec"
                                        "appsink name=sink")))
            (gst_object_set_name pipeline "output")
            (with-unref ((appsrc (gst_bin_get_by_name pipeline "src"))
                         (appsink (gst_bin_get_by_name pipeline "sink")))
              (let ((data (make-u8vector (/ (* width height 12) 8)))
                    (info (make-u64vector 4)))
                (gst_app_sink_connect_signals appsink listener)
                (gst-app-src-set-caps appsrc "video/x-h264"
                  "width"         'int      width
                  "height"        'int      height
                  "framerate"     'fraction (cons framerate 1)
                  "stream-format" 'string   "byte-stream"
                  "alignment"     'string   "au")
                (g-object-set appsrc
                  "is-live"     'boolean #t
                  "stream-type" 'int     GST_APP_STREAM_TYPE_STREAM
                  "format"      'int     GST_FORMAT_TIME)
                (gst_element_set_state pipeline GST_STATE_READY)
                (set! self.alpha-data data)
                (set! self.alpha-info info)
                (set! self.alpha-pipeline pipeline)
                (set! self.alpha-appsrc appsrc)
                (set! self.alpha-appsink appsink)
                (set! self.alpha-listener listener)
                (set! self.image-surface (new Image-Surface (new Dimension width height))))))))))
  
  
  (method override (setup-element self)
    (nextmethod self)
    (setup-pipeline self))
  
  
  (method (task-start self name)
    (let ((procedure
            (lambda (task)
              (video-loop self task))))
      (let ((task (new Task name procedure priority: video-priority)))
        (start-listeners self)
        (start-task task)
        (set! self.task task))))
  
  
  (method (task-stop self)
    (stop-listeners self)
    (stop-task task)
    (set! task #f))
  
  
  (method override (start-element self)
    (nextmethod self)
    (when process?
      (task-start self 'video-output)
      (gst_element_set_state color-pipeline GST_STATE_PAUSED)
      (when alpha?
        (gst_element_set_state alpha-pipeline GST_STATE_PAUSED))))
  
  
  (method override (play-element self)
    (nextmethod self)
    (when process?
      (gst_element_set_state color-pipeline GST_STATE_PLAYING)
      (when alpha?
        (gst_element_set_state alpha-pipeline GST_STATE_PLAYING))))
  
  
  (method override (pause-element self)
    (nextmethod self)
    (when process?
      (gst_element_set_state color-pipeline GST_STATE_PAUSED)
      (when alpha?
        (gst_element_set_state alpha-pipeline GST_STATE_PAUSED))))
  
  
  (method override (stop-element self)
    (nextmethod self)
    (when process?
      (gst_element_set_state color-pipeline GST_STATE_READY)
      (when alpha?
        (gst_element_set_state alpha-pipeline GST_STATE_READY))
      (task-stop self)))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when process?
      (gst_element_release color-pipeline)
      (set! color-info #f)
      (set! color-data #f)
      (set! color-pipeline #f)
      (set! color-appsrc #f)
      (set! color-appsink #f)
      (close-stream-listener color-listener)
      (set! color-listener #f)
      (when alpha?
        (gst_element_release alpha-pipeline)
        (close image-surface)
        (set! alpha-info #f)
        (set! alpha-data #f)
        (set! alpha-pipeline #f)
        (set! alpha-appsrc #f)
        (set! alpha-appsink #f)
        (set! image-surface #f)
        (close-stream-listener alpha-listener)
        (set! alpha-listener #f))
      (set-stream-state self 'off)))
  
  
  (method protected virtual (consume-video self color dts pts duration keyframe? (alpha #f))
    ;; QUICK TEST
    (when color-appsrc
      ;; QUICK TEST
      (when color
        (when (not stream-playing?)
          (play-element self)
          (set! stream-playing? #t))
        (let ((perfect-offset (- (gst_element_get_running_time color-appsrc) dts)))
          (let ((deviation (timestamp->flonum (abs (- perfect-offset timestamp-offset))))
                (tolerance .05))
            (set! moving-deviation (/ (+ (* moving-deviation 31.) deviation) 32.))
            (when (> moving-deviation tolerance)
              (set! timestamp-offset perfect-offset)
              (set! moving-deviation 0.))))
        (gst_app_src_write color-appsrc color (u8vector-length color) dts pts duration)
        (when seek-callback
          (seek-callback dts))))
    (when alpha?
      ;; QUICK TEST
      (when alpha-appsrc
        ;; QUICK TEST
        (when alpha
          (gst_app_src_write alpha-appsrc alpha (u8vector-length alpha) dts pts duration)))))
      
  
  (method (video-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (if (stopping? task)
              (task-done task exit)
            (process self task exit)
            (task-halt task exit)
            (iter))))))
  
  
  (method override (process self task exit)
    (let ((color-bytes (gst_app_sink_wait task exit color-listener color-appsink color-data color-info #f #f))
          (alpha-bytes (and alpha? (gst_app_sink_wait task exit alpha-listener alpha-appsink alpha-data alpha-info #f #f))))
      (site video-output
        (let ((dts (u64vector-ref color-info 0))
              (pts (u64vector-ref color-info 1))
              (duration (u64vector-ref color-info 2)))
          (draw self color-data (and alpha? alpha-data) dts pts duration)
          (when (eq? stream-state 'on)
            (set-stream-state self 'drawn))))))
  
  
  (method package virtual (draw self color alpha dts pts duration)
    )
  
  
  (method package (update self color alpha texture (background: background #f))
    (if (not alpha?)
        (if speakers-xp?
            (if (eq? (effective-focused-output (current-video)) self)
                (move-u8vector->pointer! color (get-data texture))
              (let ((width (get-width resolution))
                    (height (get-height resolution)))
                (add-alpha color .6 (get-data texture) (* width height))))
          (move-u8vector->pointer! color (get-data texture)))
      (let ((width (get-width resolution))
            (height (get-height resolution))
            (data (cairo_image_surface_get_data (get-handle image-surface))))
        (cairo_surface_flush (get-handle image-surface))
        (combine-alpha color alpha data (* width height))
        (cairo_surface_mark_dirty (get-handle image-surface))
        (unless image-inhibit?
          (let ((surface (get-surface texture)))
            (clear-glass surface resolution background: background)
            (draw-surface surface image-surface 0 0)))))
    (when framerate
      (update rate framerate))
    (unless image-inhibit?
      (map-texture texture)))
  
  
  (method package virtual (render self)
    )
  
  
  (method (with-slide self texture thunk)
    (set! image-inhibit? #t)
    (thunk)
    (let ((height (cast <fl> (get-height resolution))))
      (let ((delta (/ height render-rate slide-duration))
            (surface (get-surface texture)))
        (thread-start!
          (new-thread
            (lambda ()
              (let (loop (slide (- height delta)))
                (let ((slide (max 0. slide)))
                  (let ((done? (<= slide 0.)))
                    (with-task-mutex
                      (lambda ()
                        (if (not image-surface)
                            (set! done? #t)
                          (translate surface 0 slide)
                          (clear-glass surface resolution)
                          (draw-surface surface image-surface 0 0)
                          (translate surface 0 (- slide))
                          (flush surface)
                          (map-texture texture))
                        (when done?
                          (set! image-inhibit? #f))))
                    (when (not done?)
                      (sleep render-period)
                      (loop (- slide delta)))))))
            'slide))))))


;;;
;;;; Draw-Video-Sink
;;;


(class Draw-Video-Sink extends Video-Sink
  
  
  (slot entity     initialize #f accessors generate)
  (slot pane       initialize #f accessors generate)
  (slot background initialize #f accessors generate)
  
  
  (method override (initialize self ent . rest)
    (apply nextmethod self alpha?: #t rest)
    (let ((p (cache-draw-pane ent (list (eq? ent (current-me)) resolution))))
      (set! entity ent)
      (set! pane p)))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when entity
      (set-draw-pane entity #f)
      (set! entity #f)
      (set! pane #f)))
  
  
  (method override (draw self color alpha dts pts duration)
    ;; quicky
    (when pane
      (update self color alpha (get-texture (cache-quad-texture pane)) background: background)))
  
  
  (method override (render self)
    ;; nothing to do render done by player pane
    ))


;;;
;;;; Event-View
;;;


(class Event-View extends View)


(definition public (make-event-view)
  (let ((view (new Event-View)))
    (define (mouse-down event)
      (debug 'mouse-down))
    
    (define (mouse-up event)
      (debug 'mouse-up))
    
    (define (key-press event)
      (debug 'key-press))
    
    (set-mouse-down-handler view mouse-down)
    (set-mouse-up-handler view mouse-up)
    (set-key-press-handler view key-press)
    view))


(definition public (make-view . rest)
  (apply new View rest))


;;;
;;;; Draw-Pane
;;;


(definition public (make-draw-pane entity info)
  (let ((expanse {Dimension$fl$ 6. 3.375})
        (resolution {Dimension 1280 720}))
    (let ((pane (new Draw-Pane
                  title: "Draw"
                  expanse: expanse
                  resolution: resolution
                  billboard: info
                  entity: entity)))
      (cond ((is? info View)
             (set-root pane info)
             (set-position info {Point 0 0})
             (set-size info resolution)
             pane)
            (else
             pane)))))


@c4
(definition public (make-c4-pane entity billboard)
  (let ((size {Dimension$fl$ 3.6363636363636362 3.})
        (resolution {Dimension 660 600}))
    (let ((pane (new Script-Pane
                  size: size
                  resolution: resolution
                  billboard: billboard
                  entity: entity))
          (view (new jazz.sample.c4:C4-Board position: {Point 0 0} size: resolution background: #f)))
      (set-root pane view)
      (let ((pos (center (get-size view) resolution)))
        (set-position view pos))
      pane)))
  
  
  @c4
  (method override (draw self surface)
    (let ((width (get-width resolution))
          (height (get-height resolution)))
      (let ((rect (new Rect 0 0 width height))
            (color {Color red: .000 green: .000 blue: .200 alpha: .3}))
        (clear surface)
        (fill-rect surface rect color)
        (frame-rect surface rect color)
        (paint-drawing root surface '())))
    (when quad-texture
      (flush surface)
      (map-texture (get-texture quad-texture))))


(class Draw-Pane extends Entity-Pane)


;;;
;;;; Overhead-Video-Sink
;;;


(class Overhead-Video-Sink extends Video-Sink
  
  
  (slot player initialize #f accessors generate)
  (slot pane   initialize #f accessors generate)
  
  
  (method override (initialize self entity . rest)
    (apply nextmethod self rest)
    (let ((p (cache-camera-pane entity (list (eq? entity (current-me)) resolution))))
      (set! player entity)
      (set! pane p)))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when player
      (set-camera-pane player #f)
      (set! player #f)
      (set! pane #f)))
  
  
  (method override (draw self color alpha dts pts duration)
    (update self color alpha (get-texture (cache-quad-texture pane))))
  
  
  (method override (render self)
    ;; nothing to do render done by player pane
    ))


;;;
;;;; Camera-Pane
;;;


(definition public (make-camera-pane billboard)
  (bind (me? resolution) billboard
    (new Camera-Pane
      title: "Camera"
      expanse: (new Dimension$fl$ 1. .5625)
      resolution: resolution
      billboard: billboard)))


(class Camera-Pane extends World-Pane
  
  
  (method override (draw self surface)
    (clear surface)))


;;;
;;;; Sheet-Video-Sink
;;;


(class Sheet-Video-Sink extends Video-Sink
  
  
  (slot player initialize #f accessors generate)
  (slot sheet  initialize #f accessors generate)
  
  
  (method override (initialize self entity . rest)
    (bind-keywords ((position #f) (size #f) . others) rest
      (apply nextmethod self others)
      (let ((world (current-world)))
        (let ((pos (or position {Point 0 0}))
              (size (or size {Dimension 320 180})))
          (let ((s (make-world-sheet 'video World-Sheet size resolution: resolution scale?: #f)))
            (make-orthographic-matrix! (get-projection-matrix s) 0. (get-width world) 0. (get-height world) 0. 10.)
            (set-position s pos)
            (set-size s size)
            (set! self.player entity)
            (set! self.sheet s))))))
  
  
  (method override (resize self)
    (let ((world (current-world)))
      (let ((width (get-width world))
            (height (get-height world)))
        (make-orthographic-matrix! (get-projection-matrix sheet) 0. width 0. height 0. 10.))))
  
  
  (method override (move self rect)
    (set-rect sheet rect))
  
  
  (method override (release-element self)
    (nextmethod self)
    (when sheet
      (close sheet)
      (set! sheet #f)))
  
  
  (method override (draw self color alpha dts pts duration)
    (let ((texture (get-texture sheet)))
      (update self color alpha texture)))
  
  
  (method override (render self)
    (when (eq? stream-state 'drawn)
    ;; QUICKY
    (when sheet
      (render-sheet sheet)))))


;;;
;;;; Circle-Video-Sink
;;;


(class Circle-Video-Sink extends Video-Sink
  
  
  (slot id                initialize #f accessors generate)
  (slot channel           initialize #f accessors generate)
  (slot player            initialize #f accessors generate)
  (slot translation       initialize #f accessors generate)
  (slot rotation          initialize #f accessors generate)
  (slot plane             initialize #f accessors generate)
  (slot media-pane        initialize #f accessors generate)
  (slot media-sheet       initialize #f accessors generate)
  (slot media-texture     initialize #f accessors generate)
  (slot interface-pane    initialize #f accessors generate)
  (slot interface-sheet   initialize #f accessors generate)
  (slot interface-texture initialize #f accessors generate)
  
  
  (method override (initialize self id channel entity . rest)
    (bind-keywords ((root-view #f) (position #f) (size #f) . others) rest
      (apply nextmethod self others)
      (let ((window (current-window)))
        (set! self.id id)
        (set! self.channel channel)
        (set! self.player entity)
        ;; media
        (let ((position (or position {Point 0 0}))
              (size (or size {Dimension 640 360}))
              (texture (make-cairo-texture (get-width resolution) (get-height resolution))))
          (let ((pane (make-sheet-pane
                        name: 'media
                        title: "Media"
                        position: position
                        size: size
                        expanse: (resolution->expanse resolution)
                        resolution: resolution
                        texture: texture)))
            (set! self.media-pane pane)
            (set! self.media-sheet (get-sheet pane))
            (set! self.media-texture texture)))
        ;; interface
        (let ((position {Point 0 0})
              (size {Dimension 1280 720})
              (expanse (resolution->expanse {Dimension 1280 720}))
              (resolution {Dimension 1280 720}))
          (let ((texture (make-cairo-texture (get-width resolution) (get-height resolution) scale?: #t mipmap?: #t))
                (root (or root-view (new world.circle:Circle-View position: position size: size))))
            (let ((pane (make-sheet-pane
                          class: world.circle:Circle-Pane
                          name: 'interface
                          title: "Interface"
                          position: position
                          size: size
                          expanse: expanse
                          resolution: resolution
                          texture: texture
                          root: root)))
              (set! self.interface-pane pane)
              (set! self.interface-sheet (get-sheet pane))
              (set! self.interface-texture texture)
              (update root self))))
        ;; panes
        (update-panes self))))
  
  
  (method override (destroy self)
    (let ((window (current-window)))
      (unregister-pane window media-pane)
      (unregister-sheet window media-sheet)
      (unregister-pane window interface-pane)
      (unregister-sheet window interface-sheet))
    (close interface-pane)
    (close media-pane)
    (nextmethod self))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (let ((effective-name (if (not channel) "Me" (get-name (get-stream channel)))))
          (format output "{a}" effective-name)))))
  
  
  (method package (update-panes self)
    (let ((window (current-window))
          (video (current-video)))
      (case video-layout
        ((gallery)
         (unregister-pane window media-pane)
         (unregister-pane window interface-pane)
         (register-sheet window media-sheet)
         (register-sheet window interface-sheet))
        ((circle focus)
         (register-pane window media-pane)
         (register-pane window interface-pane)
         (cond ((and (eq? video-layout 'focus)
                     (eq? self (effective-focused-output video)))
                (register-sheet window media-sheet)
                (register-sheet window interface-sheet))
               (else
                (unregister-sheet window media-sheet)
                (unregister-sheet window interface-sheet)))))))
  
  
  (method package (update-matrices self count)
    (update-media-matrix self count)
    (update-interface-matrix self count))
  
  
  (method package (update-media-matrix self count)
    (let ((matrix (circle-matrix self translation (<= count circle-max-fixed))))
      (set-matrix media-pane matrix)
      (set! plane (new Plane (matrix-translation matrix) (matrix-direction matrix)))))
  
  
  (method package (update-interface-matrix self count)
    (when translation
      (if (and speakers-xp? (eq? (effective-focused-output (current-video)) self))
          (let ((position (matrix-translation (get-matrix media-pane))))
            (let ((billboard-matrix (orthogonal-matrix& (get-position (current-camera)) position) @w (billboard-matrix& position)))
              (set-matrix media-pane billboard-matrix)
              (set-matrix interface-pane billboard-matrix)))
        (let ((flip? (not (xor (>= (plane-to-point-distance& plane (get-position (current-camera))) 0.)
                               (> count circle-max-fixed)))))
          (set-matrix media-pane (circle-matrix self translation flip?))
          (if flip?
              (set-matrix interface-pane (circle-matrix self (+ translation -.005) flip?))
            (set-matrix interface-pane (circle-matrix self (+ translation .005) flip?)))))))
  
  
  (method (circle-matrix self translation flip?)
    (matrix-multiply&
      (make-rotation-matrix& (vertex& 0. 1. 0.) rotation)
      (make-translation-matrix& (vertex& 0. 0. translation))
      (if flip?
          (make-rotation-matrix (vertex& 0. 1. 0.) PI)
        (make-identity-matrix&))))
  
  
  (method package (circle-view self)
    (get-root interface-pane))
  
  
  (method override (resize self)
    (let ((world (current-world)))
      (let ((width (get-width world))
            (height (get-height world)))
        (make-orthographic-matrix! (get-projection-matrix media-sheet) 0. width 0. height 0. 10.)
        (make-orthographic-matrix! (get-projection-matrix interface-sheet) 0. width 0. height 0. 10.))))
  
  
  (method override (move self rect)
    (set-rect media-sheet (fit-both resolution rect))
    (set-rect interface-sheet rect))
  
  
  (method package (focused? self)
    (and (eq? video-layout 'focus)
         (eq? (effective-focused-output (current-video)) self)))
  
  
  (method package (move-focused self)
    (let ((bounds (get-bounds (current-window))))
      (let ((focused (focused-rect bounds)))
        (let ((adjusted (adjust-focused bounds focused)))
          (move self adjusted)))))
  
  
  (method override (focus self)
    (let ((window (current-window)))
      (move-focused self)
      (register-sheet window media-sheet)
      (register-sheet window interface-sheet)))
  
  
  (method override (unfocus self)
    (let ((window (current-window)))
      (unregister-sheet window media-sheet)
      (unregister-sheet window interface-sheet)))
  
  
  (method override (invalidate-state self (invalidate-audio? #f))
    (invalidate-texture interface-pane)
    (when invalidate-audio?
      (invalidate-audio (get-root interface-pane))))
  
  
  (method override (draw self color alpha dts pts duration)
    (update self color alpha media-texture)
    (when channel
      (record-event udp-id-draw-video
                    -1.
                    (fixnum->flonum client-no)
                    (fixnum->flonum udp-video)
                    -1.
                    -1.
                    -1.
                    (timestamp->flonum dts))))
  
  
  (method override (render self)
    (let ((world (current-world)))
      (define (render-sheets)
        (when (eq? stream-state 'drawn)
          (render-sheet media-sheet))
        (when (or (read-video-interface? 2)
                  (neq? stream-state 'drawn))
          (render-sheet interface-sheet)))
      
      (case video-layout
        ((gallery)
         (render-sheets))
        (else
         (when (focused? self)
           (render-sheets))
         (when (and (eq? stream-state 'drawn)
                    (or (if hide-widget? (read-video-interface? 3) #t)
                        (not (focused? self))))
           (render-pane media-pane))
         (when (and (or (neq? video-layout 'focus)
                        (neq? stream-state 'drawn))
                    (or (read-video-interface? 4)
                        (neq? stream-state 'drawn)))
           (render-pane interface-pane))))))))
