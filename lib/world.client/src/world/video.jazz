;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Video
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.video jazz


(import (jazz.graphic)
        (jazz.gstreamer)
        (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.billboard)
        (world.configure)
        (world.foreign.gstreamer)
        (world.geometry)
        (world.id)
        (world.quad-texture)
        (world.settings)
        (world.stream)
        (world.syntax (phase syntax))
        (world.task))


(definition protected video-resolution
  (world-setting 'world.video-resolution {Dimension 1280 720}))

(definition video-framerate
  (world-setting 'world.video-framerate 30))

(definition video-alpha
  (world-setting 'world.video-alpha 0.6))

(definition video-overlay?
  (world-setting 'world.video-overlay? #f))


(definition layouts
  '(none
    overhead
    sidebar
    fullscreen))

(definition video-layout
  (world-setting 'world.video-layout 'overhead))


(definition public (kush-gauge width height rate motion)
  (/ (* width height rate motion 0.07) 1000.))


;;;
;;;; Task
;;;


(definition public (video-task task <Task>)
  (declare (proper-tail-calls))
  (let ((video (current-video)))
    (with-task task
      (lambda (exit)
        (let (iter (previous (current-seconds)))
          (let ((time (current-seconds)))
            (let ((elapse (- time previous)))
              (unless (stopping?~ task)
                (site (video on?: #t)
                  (process-video~ video)))
              (let ((duration (- (current-seconds) time)))
                (task-sleep task video-period duration exit))
              (iter time))))))))


;;;
;;;; Input
;;;


(class World-Video extends Object
  
  
  (slot video?          <bool>     initialize #f accessors generate)
  (slot input-pipeline             initialize #f accessors generate)
  (slot input-appsink              initialize #f accessors generate)
  (slot input-buffer    <u8vector> initialize #f accessors generate)
  (slot output?         <bool>     initialize #f accessors generate)
  (slot output-pipeline            initialize #f accessors generate)
  (slot output-appsrc              initialize #f accessors generate)
  (slot output-appsink             initialize #f accessors generate)
  (slot output-buffer   <u8vector> initialize #f accessors generate)
  
  
  (method override (initialize)
    (set! video? (world-setting 'world.video? #f))
    (when (and video? (client?))
      (start-video)))
  
  
  ;;;
  ;;;; Events
  ;;;
  
  
  (method (on-toggle-video evt)
    (toggle-video))
  
  
  (method (on-cycle-layouts evt)
    (cycle-layouts))
  
  
  ;;;
  ;;;; Process
  ;;;
  
  
  (method (toggle-video)
    (when (client?)
      (let ((world (current-world)))
        (if (not video?)
            (start-video)
          (stop-video))
        (update-parameter~ world 'video)
        (display-on/off~ world "Video" video?))))
  
  
  (method (start-video)
    (unless video?
      (init-gstreamer)
      (let ((width (get-width~ video-resolution))
            (height (get-height~ video-resolution))
            (framerate video-framerate)
            (alpha video-alpha))
        (let ((description (format "avfvideosrc ! videoscale ! videoconvert ! video/x-raw, width={a}, height={a}, framerate={a}/1 ! x264enc pass=qual quantizer=20 tune=zerolatency ! appsink name=appsink" width height framerate)))
          (let ((pipeline (gst_parse_launch description)))
            (let ((appsink (gst_bin_get_by_name pipeline "appsink"))
                  (buffer (make-u8vector (* width height 4))))
              (gst_element_set_state pipeline GST_STATE_PLAYING)
              (set! input-buffer buffer)
              (set! input-pipeline pipeline)
              (set! input-appsink appsink)
              (set! video? #t)))))))
  
  
  (method (stop-video)
    (when video?
      (gst_element_set_state input-pipeline GST_STATE_NULL)
      (gst_object_unref input-pipeline)
      (set! input-buffer #f)
      (set! input-pipeline #f)
      (set! input-appsink #f)
      (set! video? #f)))
  
  
  (method (start-output)
    (unless output?
      (init-gstreamer)
      (let ((width (get-width~ video-resolution))
            (height (get-height~ video-resolution))
            (framerate video-framerate)
            (alpha video-alpha))
        (let ((description @w (format "appsrc name=appsrc ! video/x-h264, width={a}, height={a} ! avdec_h264 ! alpha alpha={a} ! appsink name=appsink" width height alpha)
                           (format "appsrc name=appsrc ! avdec_h264 ! appsink name=appsink")))
          (let ((pipeline (gst_parse_launch description)))
            (let ((appsrc (gst_bin_get_by_name pipeline "appsrc"))
                  (appsink (gst_bin_get_by_name pipeline "appsink"))
                  (buffer (make-u8vector (* width height 4))))
              (gst_app_src_set_stream_type appsrc GST_APP_STREAM_TYPE_STREAM)
              (gst_element_set_state pipeline GST_STATE_PLAYING)
              (set! output-buffer buffer)
              (set! output-pipeline pipeline)
              (set! output-appsrc appsrc)
              (set! output-appsink appsink)
              (set! output? #t)))))))
  
  
  (method (stop-output)
    (when output?
      (gst_element_set_state output-pipeline GST_STATE_NULL)
      (gst_object_unref output-pipeline)
      (set! output-buffer #f)
      (set! output-pipeline #f)
      (set! output-appsrc #f)
      (set! output-appsink #f)
      (set! output? #f)))
  
  
  (method (process-video)
    (when (client?)
      (when video?
        (let ((size (gst_app_sink_read input-appsink input-buffer)))
          (when (/= size -1)
            (send-client-video~ (client-tier) (subu8vector input-buffer 0 size)))))
      (when output?
        (let ((size (gst_app_sink_read output-appsink output-buffer)))
          (when (/= size -1)
            (terminal 'decoded size)
            @w
            (display-server-video mega-hack-id output-buffer)))))))


;;;
;;;; Output
;;;


(definition frame-count
  #f)

(definition frame-start
  #f)

(definition total-size
  #f)


;; mega hack for quick test
(definition mega-hack-id
  #f)


(definition public (write-server-video id bytes)
  @w (
  (terminal (u8vector-length bytes))
  (let ((video (current-video)))
    (start-output~ video)
    (set! mega-hack-id id)
    (let ((mega-hack-appsrc (get-output-appsrc~ video)))
      (gst_app_src_write mega-hack-appsrc bytes (u8vector-length bytes) (gst_clock_get_time (gst_pipeline_get_clock (get-output-pipeline~ video))))))))


(definition public (display-server-video id bytes)
  (define (update-texture texture)
    (define (add-overlay)
      (if (not frame-count)
          (begin
            (set! frame-count 1)
            (set! frame-start (current-seconds))
            (set! total-size (u8vector-length bytes)))
        (increase! frame-count)
        (increase! total-size (u8vector-length bytes))
        (let ((elapse (- (current-seconds) frame-start)))
          (let ((rate (/ (cast <fl> frame-count) elapse))
                (size (/ (cast <fl> total-size) frame-count)))
            (set-font~ (get-surface~ texture) {Font font-name: tahoma point-size: 24 hint-style: slight hint-metrics: on})
            (draw-text~ (get-surface~ texture) 5 (- (get-height~ video-resolution) 30) (format "Rate: {r precision: 3}, Size: {a}" rate size) {Color World-Red})))))
    
    (copy_to_texture bytes (u8vector-length bytes) (get-data~ texture))
    (when video-overlay?
      (add-overlay))
    (map-texture~ texture))
  
  (case video-layout
    ((overhead)
     (let ((player (find-entity id)))
       (let ((elem (cache-billboard-camera~ player (list (eq? player (current-me))))))
         (update-texture (get-texture~ (cache-quad-texture~ elem))))))
    ((sidebar fullscreen)
     (let ((player (find-entity id)))
       (let ((view (cache-camera-player~ player (case video-layout
                                                  ((sidebar) video-resolution @w {Dimension 320 180})
                                                  ((fullscreen) video-resolution @w {Dimension 1280 720})))))
         (update-texture (get-texture~ view)))))))


;;;
;;;; Layouts
;;;


(definition (cycle-layouts)
  (let ((zone (current-zone)))
    (case video-layout
      ((none)
       (for-each (lambda (player)
                   (let ((elem (get-billboard-camera~ player)))
                     (when elem
                       (set-render?~ elem #t))))
                 (get-players~ zone))
       (set! video-layout 'overhead))
      ((overhead)
       (for-each (lambda (player)
                   (let ((elem (get-billboard-camera~ player)))
                     (when elem
                       (set-render?~ elem #f))))
                 (get-players~ zone))
       (set! video-layout 'sidebar))
      ((sidebar)
       (for-each (lambda (player)
                   (let ((elem (get-billboard-camera~ player)))
                     (when elem
                       (set-render?~ elem #f))))
                 (get-players~ zone))
       (set! video-layout 'fullscreen))
      ((sidebar)
       (for-each (lambda (player)
                   (let ((elem (get-billboard-camera~ player)))
                     (when elem
                       (set-render?~ elem #f))))
                 (get-players~ zone))
       (set! video-layout 'none)))))


;;;
;;;; Billboard
;;;


(definition public (make-billboard-camera billboard)
  (new Billboard-Camera
    billboard: billboard))


(class Billboard-Camera extends Billboard-Element
  
  
  (method override (make-billboard-texture)
    (bind (me?) billboard
      (let ((width (get-width~ video-resolution))
            (height (get-height~ video-resolution)))
        (let ((w 1.)
              (h .5625))
          (let ((v1 (vertex (/ w -2.) (/ h  2.) 0.))
                (v2 (vertex (/ w -2.) (/ h -2.) 0.))
                (v3 (vertex (/ w  2.) (/ h -2.) 0.))
                (v4 (vertex (/ w  2.) (/ h  2.) 0.)))
            (let ((quad-texture <Quad-Texture> (make-quad-texture width height v1 v2 v3 v4)))
              (let ((texture (get-texture~ quad-texture)))
                (let ((surface (get-surface~ texture)))
                  (clear~ surface)
                  (map-texture~ texture)))
              quad-texture))))))
  
  
  (method override (billboard-top)
    2.6)
  
  
  (method override (billboard-center)
    .4)))
