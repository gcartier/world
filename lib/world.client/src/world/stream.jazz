;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Stream
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.stream jazz


(import (jazz.cairo)
        (jazz.graphic)
        (jazz.io)
        (jazz.platform)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (jazz.version)
        (world)
        (world.context)
        (world.media)
        (world.settings)
        (world.task))


(definition protected stream-multiple?
  (world-setting 'world.stream-multiple? #f))

(definition protected stream-repeatable?
  (world-setting 'world.stream-repeatable? #f))

(definition protected stream-private?
  (world-setting 'world.stream-private? #f))

(definition protected stream-silent?
  (world-setting 'world.stream-silent? #f))

(definition protected stream-local?
  (world-setting 'world.stream-local? #f))

(definition protected stream-compare?
  (world-setting 'world.stream-compare? #f))


(definition protected self-split?
  (world-setting 'world.self-split? #f))


;;;
;;;; Listener
;;;


(definition public (gst_app_sink_wait task exit listener elem vec info reset-action eos-action)
  (declare (proper-tail-calls))
  (let (loop)
    (let ((c (wait listener)))
      (case c
        ((#\!)
         (when reset-action
           (reset-action))
         (loop))
        ((#\^)
         (when eos-action
           (eos-action))
         (loop))
        ((#\@)
         (task-done task exit))
        (else
         (let ((size (gst_app_sink_try_pull elem vec info)))
           (assert (/= size -1)
             size)))))))


;; PRIME
@w
(definition public (gst_app_sink_wait2 task exit listener elem vec info reset-action eos-action)
  (declare (proper-tail-calls))
  (let (loop)
    (let ((c (wait listener)))
      (case c
        ((#\!)
         (when reset-action
           (reset-action))
         (loop))
        ((#\^)
         (when eos-action
           (eos-action))
         (loop))
        ((#\@)
         (task-done task exit))
        (else
         (let ((size (gst_app_sink_try_pull2 elem vec info)))
           (assert (/= size -1)
             size)))))))


@processpresent (
(definition processpresent?
  (world-setting 'world.processpresent? #f))

(definition processmutex
  (make-mutex 'process))

(definition processperiod
  #f)

(definition protected (processperiod-set! period)
  (set! processperiod period))

(definition processfirst
  #f)

(definition protected (processreset)
  (set! processfirst #f))

(definition (processpresent timestamp)
  (mutex-lock! processmutex)
  (prog1 (begin
           (when (not processfirst)
             (set! processfirst timestamp))
           (let ((diff (- timestamp processfirst)))
             (fxround (/ (exact->inexact diff) processperiod))))
    (mutex-unlock! processmutex))))


(definition public (gst_app_sink_process task exit consumer)
  (declare (proper-tail-calls))
  (let ((listener (get-listener consumer))
        (element (get-element consumer))
        (data (get-data consumer))
        (info (get-info consumer)))
    (let (loop)
      (if (get-closed? listener)
          (task-done task exit)
        (let ((c (wait listener)))
          (case c
            ((#\!)
             (reset-action consumer)
             (loop))
            ((#\^)
             (eos-action consumer)
             (loop))
            ((#\@)
             (task-done task exit))
            (else
             (let ((size (gst_app_sink_try_pull element data info)))
               (assert (/= size -1)
                 (let ((buffer (subu8vector data 0 size))
                       (timestamp (u64vector-ref info 0))
                       (duration (u64vector-ref info 1)))
                   (consume consumer buffer timestamp duration)))))))))))


(definition public (gst_app_sink_process_one consumer)
  (let ((listener (get-listener consumer))
        (element (get-element consumer))
        (data (get-data consumer))
        (info (get-info consumer)))
    (let ((c (wait listener)))
      (assert (eqv? c #\.)
        (let ((size (gst_app_sink_try_pull element data info)))
          (assert (/= size -1)
            (let ((buffer (subu8vector data 0 size))
                  (timestamp (u64vector-ref info 0))
                  (duration (u64vector-ref info 1)))
              (consume consumer buffer timestamp duration))))))))


;;;
;;;; Consumer
;;;


(class Stream-Consumer extends Stream-Sink
  
  
  (slot caps                  initialize #f accessors generate)
  (slot listener              initialize #f accessors generate)
  (slot element               initialize #f accessors generate)
  (slot data     <u8vector+>  initialize #f accessors generate)
  (slot info     <u64vector+> initialize #f accessors generate)
  (slot task                  initialize #f accessors generate)
  (slot processing?           initialize #t accessors generate)
  
  
  (method override (initialize self (caps: caps #f) (processing?: processing? #t) (name: name #f) (consumer: consumer #f))
    (nextmethod self name: name consumer: consumer)
    (set! self.caps caps)
    (set! self.processing? processing?))
  
  
  (method override (consumer? self)
    #t)
  
  
  (method protected virtual (task-name self)
    'consumer)
  
  
  (method protected (setup-consumer self listener element size)
    (set! self.listener listener)
    (set! self.element element)
    (set! self.data (make-u8vector size))
    (set! self.info (make-u64vector 2)))
  
  
  (method protected (release-consumer self)
    (consume self #f #f #f)
    (close-stream-listener listener)
    (set! listener #f)
    (set! element #f)
    (set! data #f)
    (set! info #f))
  
  
  (method protected (start-listener self)
    (when listener
      (start-stream-listener listener)))
  
  
  (method protected (stop-listener self)
    (when listener
      (stop-stream-listener listener)))
  
  
  (method protected (start-processing self priority)
    (let ((procedure
            (lambda (task)
              (consumer-loop self task))))
      (let ((task (new Task (task-name self) procedure priority: priority)))
        (start-listener self)
        (start-task task)
        (set! self.task task))))
  
  
  (method protected (stop-processing self)
    (stop-listener self)
    (stop-task task)
    (set! task #f))
  
  
  (method protected (consumer-loop self task)
    (declare (proper-tail-calls))
    (with-task task
      (lambda (exit)
        (let (iter)
          (process self task exit)
          (iter)))))
  
  
  (method override (process self task exit)
    (gst_app_sink_process task exit self))
  
  
  (method protected virtual (reset-action self)
    )
  
  
  (method protected virtual (eos-action self)
    (consume self #f #f #f)))


;;;
;;;; Stream
;;;


(definition protected stream-loop?
  (world-setting 'world.stream-loop? #f))


(interface Media-Stream
  
  
  (method public virtual abstract (get-stream? self))
  (method public virtual abstract (set-stream? self flag))
  (method public virtual abstract (play-stream self))
  (method public virtual abstract (pause-stream self))
  (method public virtual abstract (seek-stream self pos)))


;;;
;;;; Format
;;;


(definition protected stream-version
  {Version 1 0 0})


(definition version-offset <fx>
  0)

(definition version-size <fx>
  1024)


(definition metadata-offset <fx>
  (+ version-offset version-size))

(definition metadata-size <fx>
  3072)


(definition index-offset <fx>
  (+ metadata-offset metadata-size))

(definition index-unit <fx>
  8)

(definition index-count <fx>
  4096)

(definition index-size <fx>
  (* index-unit index-count))


(definition sections-offset <fx>
  (+ index-offset index-size))


(definition header-unit <fx>
  (+ 8 8 8 4 4))

(definition header-count <fx>
  4096)

(definition header-size <fx>
  (* header-unit header-count))


;;;
;;;; Reader
;;;


(class Stream-Reader extends Object
  
  
  (slot port             getter generate)
  (slot frame            getter generate)
  (slot position         getter generate)
  (slot version          getter generate)
  (slot metadata         getter generate)
  (slot count            getter generate)
  (slot start            getter generate)
  (slot end              getter generate)
  (slot duration         getter generate)
  (slot kind             getter generate)
  (slot level            getter generate)
  (slot resolution       getter generate)
  (slot framerate        getter generate)
  (slot bitrate          getter generate)
  (slot codec            getter generate)
  (slot caps             getter generate)
  (slot index            getter generate)
  (slot temporary        getter generate)
  (slot timestamp-offset getter generate)
  
  
  (method override (initialize self file (timestamp-offset 0))
    (nextmethod self)
    (set! self.port (open-input-file (path-settings file)))
    (set! self.frame 0)
    (set! self.position 0)
    (set! self.temporary (make-u8vector 8))
    (set! self.timestamp-offset timestamp-offset)
    (set! self.version (read-version self))
    (set! self.metadata (read-metadata self))
    (set! self.count (getf metadata count:))
    (set! self.start (getf metadata start:))
    (set! self.end (getf metadata end:))
    (set! self.duration (getf metadata duration:))
    (set! self.kind (getf metadata kind:))
    (set! self.level (getf metadata level:))
    (set! self.resolution (getf metadata resolution:))
    (set! self.framerate (getf metadata framerate:))
    (set! self.bitrate (getf metadata bitrate:))
    (set! self.codec (require-codec (getf metadata codec:)))
    (set! self.caps (getf metadata caps:))
    (set! self.index (read-index self)))
  
  
  (method override (destroy self)
    (close-port port)
    (nextmethod self))
  
  
  (method (read-version self)
    (input-port-byte-position port version-offset)
    (read-binary port))
  
  
  (method (read-metadata self)
    (input-port-byte-position port metadata-offset)
    (read-binary port))
  
  
  (method (read-index self)
    (input-port-byte-position port index-offset)
    (let ((index (make-u64vector index-count)))
      (loop (for n from 0 below index-count)
            (read-subu8vector temporary 0 8 port)
            (u64vector-set! index n (scan-u64 temporary 0)))
      index))
  
  
  (method protected (read-frame self read-buffer?)
    (if (>= frame count)
        (values #f #f #f)
      (let ((section (quotient frame header-count))
            (rank (modulo frame header-count)))
        (increase! frame)
        (set! position (+ (u64vector-ref index section) (* rank header-unit)))
        (input-port-byte-position port position)
        (read-subu8vector temporary 0 8 port)
        (let ((timestamp (+ (scan-s64 temporary 0) timestamp-offset)))
          (read-subu8vector temporary 0 8 port)
          (let ((duration (scan-u64 temporary 0)))
            (if read-buffer?
                (begin
                  (read-subu8vector temporary 0 8 port)
                  (let ((offset (scan-u64 temporary 0)))
                    (let ((size (read-32-bit-integer port)))
                      (set! position offset)
                      (input-port-byte-position port position)
                      (let ((buffer (make-u8vector size)))
                        (read-subu8vector buffer 0 size port)
                        (values buffer timestamp duration)))))
              (values #t timestamp duration)))))))
  
  
  ;; test
  (method protected (read-header self frame)
    (let ((section (quotient frame header-count))
          (rank (modulo frame header-count)))
      (input-port-byte-position port (+ (u64vector-ref index section) (* rank header-unit)))
      (read-subu8vector temporary 0 8 port)
      (let ((timestamp (+ (scan-s64 temporary 0) timestamp-offset)))
        (read-subu8vector temporary 0 8 port)
        (let ((duration (scan-u64 temporary 0)))
          (read-subu8vector temporary 0 8 port)
          (let ((offset (scan-u64 temporary 0)))
            (let ((size (read-32-bit-integer port)))
              (let ((header? (= (read-32-bit-integer port) 1)))
                (values timestamp duration size header?))))))))
  
  
  ;; test
  (method protected (read-header? self frame)
    (let ((section (quotient frame header-count))
          (rank (modulo frame header-count)))
      (input-port-byte-position port (+ (u64vector-ref index section) (* rank header-unit) 8 8 8 4))
      (= (read-32-bit-integer port) 1)))
  
  
  (method protected (find-header self frame)
    (declare (proper-tail-calls))
    (let (loop (fr frame))
      (if (< fr 0)
          #f
        (let ((header? (read-header? self fr)))
          (if header?
              fr
            (loop (- fr 1)))))))
  
  
  (method protected (seek self pos)
    (let ((ts (inexact->exact (+ start (* duration pos))))
          (fr (fxround (* (cast <fl> (- count 1)) pos))))
      (if (eq? kind 'audio)
          (set! frame fr)
        (let ((hf (find-header self fr)))
          (when hf
            (set! frame hf)))))))


;;;
;;;; Writer
;;;


(class Stream-Writer extends Object
  
  
  (slot port            getter generate)
  (slot kind            getter generate)
  (slot level           getter generate)
  (slot resolution      getter generate)
  (slot framerate       getter generate)
  (slot bitrate         getter generate)
  (slot codec           getter generate)
  (slot metadata        getter generate)
  (slot index           getter generate)
  (slot header          getter generate)
  (slot frame           getter generate)
  (slot position        getter generate)
  (slot temporary       getter generate)
  (slot start-timestamp getter generate)
  (slot end-timestamp   getter generate)
  ;; quicky for test PRIME
  (slot header-total initialize 0 getter generate)
  
  
  (method override (initialize self file kind level resolution framerate bitrate codec)
    (nextmethod self)
    (set! self.port (open-output-file (path-settings file)))
    (set! self.kind kind)
    (set! self.level level)
    (set! self.resolution resolution)
    (set! self.framerate framerate)
    (set! self.bitrate bitrate)
    (set! self.codec (require-codec codec))
    (set! self.metadata '())
    (set! self.index (make-u64vector index-count))
    (set! self.header (new-queue))
    (set! self.frame 0)
    (set! self.position 0)
    (set! self.temporary (make-u8vector 8))
    (set! self.start-timestamp #f)
    (set! self.end-timestamp #f)
    (write-start self))
  
  
  (method override (destroy self)
    (write-end self)
    (close-port port)
    (nextmethod self))
  
  
  (method public (set-resolution self reso)
    (set! resolution reso))
  
  
  (method public (add-metadata self property value)
    (set! metadata (append metadata (list property value))))
  
  
  (method public (write-start self)
    (set! position sections-offset)
    (output-port-byte-position port position))
  
  
  (method public (write-frame self buffer timestamp duration)
    (when (= frame 0)
      (set! start-timestamp timestamp))
    (set! end-timestamp timestamp)
    (when (= (modulo frame header-count) 0)
      (let ((section (quotient frame header-count)))
        (u64vector-set! index section position)
        (increase! position header-size)
        (output-port-byte-position port position)))
    (let ((size (u8vector-length buffer))
          (header? (buffer-header? codec buffer)))
      ;; PRIME
      (when header?
        (increase! header-total))
      (enqueue header (list timestamp duration position size header?))
      (write-subu8vector buffer 0 size port)
      (increase! frame)
      (increase! position size))
    (when (= (modulo frame header-count) 0)
      (write-header self (- (quotient frame header-count) 1))))
  
  
  (method (write-header self section)
    (let ((pos (u64vector-ref index section)))
      (output-port-byte-position port pos)
      (loop (for n from 0 below header-count)
            (for info in (queue-list header))
            (bind (timestamp duration position size header?) info
              (put-s64 temporary 0 timestamp)
              (write-subu8vector temporary 0 8 port)
              (put-u64 temporary 0 duration)
              (write-subu8vector temporary 0 8 port)
              (put-u64 temporary 0 position)
              (write-subu8vector temporary 0 8 port)
              (write-32-bit-integer size port)
              (write-32-bit-integer (if header? 1 0) port)))
      (set! header (new-queue))))
  
  
  (method public (write-end self)
    (when (/= (modulo frame header-count) 0)
      (write-header self (quotient frame header-count)))
    (write-version self)
    (write-metadata self)
    (write-index self))
  
  
  (method (write-version self)
    (output-port-byte-position port version-offset)
    (assert (<= (write-binary stream-version port) version-size)))
  
  
  (method (write-metadata self)
    (define (stream-metadata)
      (let ((duration (and start-timestamp
                           end-timestamp
                           (- end-timestamp start-timestamp))))
        (list
          count: frame
          start: start-timestamp
          end: end-timestamp
          duration: duration
          kind: kind
          level: level
          resolution: resolution
          framerate: framerate
          bitrate: bitrate
          codec: (get-name codec))))
    
    (output-port-byte-position port metadata-offset)
    (assert (<= (write-binary (append (stream-metadata) metadata) port) metadata-size)))
  
  
  (method (write-index self)
    (output-port-byte-position port index-offset)
    (loop (for n from 0 below index-count)
          (put-u64 temporary 0 (u64vector-ref index n))
          (write-subu8vector temporary 0 8 port))))


;;;
;;;; Old
;;;


(definition public (read-frame-old port)
  (let ((temporary (make-u8vector 8)))
    (read-subu8vector temporary 0 8 port)
    (let ((timestamp (scan-s64 temporary 0)))
      (read-subu8vector temporary 0 8 port)
      (let ((duration (scan-u64 temporary 0)))
        (let ((size (read-32-bit-integer port)))
          (if (eof-object? size)
              (values #f #f #f)
            (let ((buffer (make-u8vector size)))
              (read-subu8vector buffer 0 size port)
              (values buffer timestamp duration))))))))


(definition public (read-audio-header-old codec port)
  (case codec
    ((opus)
     #f)
    ((vorbis)
     (receive (b1 t1 d1) (read-frame-old port)
       (receive (b2 t2 d2) (read-frame-old port)
         (receive (b3 t3 d3) (read-frame-old port)
           (let ((headers (list (list b1 t1 d1)
                                (list b2 t2 d2)
                                (list b3 t3 d3))))
             (object->u8vector headers))))))))


;;;
;;;; Draw
;;;


;; quantization
;; chroma subsampling

;; input 3686400
;; output first frame
;; quantizer=10 131874
;; quantizer=20 131865
;; quantizer=21 131865 (default)
;; quantizer=30 70973
;; quantizer=40 24978
;; quantizer=50 6898


(class Draw-Context extends Object
  
  
  (slot resolution     getter generate)
  (slot surface        getter generate)
  (slot color-listener getter generate)
  (slot color-pipeline getter generate)
  (slot alpha-listener getter generate)
  (slot alpha-pipeline getter generate)
  
  
  (method override (initialize self resolution framerate bitrate (tune: tune #f))
    (nextmethod self)
    (set! self.resolution resolution)
    (set! self.surface (new Image-Surface resolution))
    (set! self.color-listener (open-stream-listener "drawcolor"))
    (set! self.color-pipeline (make-color-pipeline color-listener resolution framerate bitrate tune))
    (set! self.alpha-listener (open-stream-listener "drawalpha"))
    (set! self.alpha-pipeline (make-alpha-pipeline alpha-listener resolution framerate bitrate tune)))
  
  
  (method override (destroy self)
    (close surface)
    (gst_element_release color-pipeline)
    (gst_element_release alpha-pipeline)
    (close-stream-listener color-listener)
    (close-stream-listener alpha-listener)
    (nextmethod self))
  
  
  (method public (extract self task exit)
    (let ((width (get-width resolution))
          (height (get-height resolution)))
      (let ((start (real-time))
            (pixels (* width height)))
        (let ((color-src (gst_bin_get_by_name color-pipeline "src"))
              (color-sink (gst_bin_get_by_name color-pipeline "sink"))
              (alpha-src (gst_bin_get_by_name alpha-pipeline "src"))
              (alpha-sink (gst_bin_get_by_name alpha-pipeline "sink")))
          ;; feed drawing into src
          (let ((data (cairo_image_surface_get_data (get-handle surface)))
                (size (* pixels 4))
                (alpha-size (/ (* pixels 12) 8))
                (timestamp 0)
                (duration 100))
            (let ((color-buffer (make-u8vector size))
                  (color-info (make-u64vector 2))
                  (alpha-buffer (make-u8vector alpha-size))
                  (alpha-info (make-u64vector 2))
                  (alpha-data (heap-calloc alpha-size 1)))
              (separate-alpha data alpha-data pixels)
              (gst_app_src_write_pointer color-src data size timestamp duration)
              (gst_app_src_write_pointer alpha-src alpha-data alpha-size timestamp duration)
              ;; retrieve frames from sink
              (let ((color-bytes (gst_app_sink_wait task exit color-listener color-sink color-buffer color-info #f #f))
                    (alpha-bytes (gst_app_sink_wait task exit alpha-listener alpha-sink alpha-buffer alpha-info #f #f)))
                (let ((timestamp (u64vector-ref color-info 0))
                      (duration (u64vector-ref color-info 1)))
                  ;(debug (- (real-time) start) color-bytes alpha-bytes)
                  (values (subu8vector color-buffer 0 color-bytes) (subu8vector alpha-buffer 0 alpha-bytes) timestamp duration)))))))))
  
  
  (method protected (reset self)
    (gst_element_set_state color-pipeline GST_STATE_READY)
    (gst_element_set_state color-pipeline GST_STATE_PLAYING)
    (gst_element_set_state alpha-pipeline GST_STATE_READY)
    (gst_element_set_state alpha-pipeline GST_STATE_PLAYING)))


(definition protected stillimage
  1)

(definition protected fastdecode
  2)

(definition protected zerolatency
  4)


(definition default-tune
  zerolatency)


(definition (make-color-pipeline listener resolution framerate bitrate tune)
  (let ((width (get-width resolution))
        (height (get-height resolution))
        (tune (or tune default-tune)))
    (let ((pipeline (gst-pipeline "appsrc name=src"
                                  "videoconvert name=convert"
                                  (tie "video/x-raw, format=I420, width={width}, height={height}, framerate={framerate}/1")
                                  (tie "x264enc pass=qual quantizer=20 bitrate={bitrate} tune={tune} speed-preset=superfast name=enc")
                                  "appsink name=sink")))
      (let ((src (gst_bin_get_by_name pipeline "src"))
            (sink (gst_bin_get_by_name pipeline "sink")))
        (gst_app_sink_connect_signals sink listener)
        (gst-setup-source src "video/x-raw" "BGRA" width height framerate)
        (gst_element_set_state pipeline GST_STATE_PLAYING))
      pipeline)))


(definition (make-alpha-pipeline listener resolution framerate bitrate tune)
  (let ((width (get-width resolution))
        (height (get-height resolution))
        (tune (or tune default-tune)))
    (let ((pipeline (gst-pipeline "appsrc name=src"
                                  (tie "x264enc pass=qual quantizer=20 bitrate={bitrate} tune={tune} speed-preset=superfast name=enc")
                                  "appsink name=sink")))
      (let ((src (gst_bin_get_by_name pipeline "src"))
            (sink (gst_bin_get_by_name pipeline "sink")))
        (gst_app_sink_connect_signals sink listener)
        (gst-setup-source src "video/x-raw" "I420" width height framerate)
        (gst_element_set_state pipeline GST_STATE_PLAYING))
      pipeline))))
