;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Geometry
;;;


(module world.geometry jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl))


(proclaim (warn optimizations))


;;;
;;;; Vertex
;;;


(definition public inline (vertex x y z)
  (f32vector x y z))


(definition public (vertex=? v1 <f32vector> v2 <f32vector>) <bool>
  (and (= (vertex-x v1) (vertex-x v2))
       (= (vertex-y v1) (vertex-y v2))
       (= (vertex-z v1) (vertex-z v2))))


(definition public inline (vertex-x vert)
  (f32vector-ref vert 0))

(definition public inline (vertex-y vert)
  (f32vector-ref vert 1))

(definition public inline (vertex-z vert)
  (f32vector-ref vert 2))


;;;
;;;; Matrix
;;;


;; 0  4  8 12
;; 1  5  9 13
;; 2  6 10 14
;; 3  7 11 15


(definition public (matrix f0 f4 f8 f12 f1 f5 f9 f13 f2 f6 f10 f14 f3 f7 f11 f15)
  (f32vector f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15))


(definition public (make-matrix) <f32vector>
  (make-f32vector 16))


(definition public (matrix=? m1 <f32vector> m2 <f32vector>) <bool>
  (and (= (matrix-ref m1  0) (matrix-ref m2  0))
       (= (matrix-ref m1  1) (matrix-ref m2  1))
       (= (matrix-ref m1  2) (matrix-ref m2  2))
       (= (matrix-ref m1  3) (matrix-ref m2  3))
       (= (matrix-ref m1  4) (matrix-ref m2  4))
       (= (matrix-ref m1  5) (matrix-ref m2  5))
       (= (matrix-ref m1  6) (matrix-ref m2  6))
       (= (matrix-ref m1  7) (matrix-ref m2  7))
       (= (matrix-ref m1  8) (matrix-ref m2  8))
       (= (matrix-ref m1  9) (matrix-ref m2  9))
       (= (matrix-ref m1 10) (matrix-ref m2 10))
       (= (matrix-ref m1 11) (matrix-ref m2 11))
       (= (matrix-ref m1 12) (matrix-ref m2 12))
       (= (matrix-ref m1 13) (matrix-ref m2 13))
       (= (matrix-ref m1 14) (matrix-ref m2 14))
       (= (matrix-ref m1 15) (matrix-ref m2 15))))


(definition public inline (matrix-ref mat <f32vector> ind <fx>) <fl>
  (f32vector-ref mat ind))


(definition public inline (matrix-set! mat <f32vector> ind <fx> val <object>) <void>
  (f32vector-set! mat ind val))


(definition public (make-identity-matrix) <f32vector>
  (let ((mat (make-matrix)))
    (matrix-set-identity! mat)
    mat))


(definition public (matrix-set-identity! mat <f32vector>) <void>
  (matrix-set! mat  0 1.)
  (matrix-set! mat  1 0.)
  (matrix-set! mat  2 0.)
  (matrix-set! mat  3 0.)
  (matrix-set! mat  4 0.)
  (matrix-set! mat  5 1.)
  (matrix-set! mat  6 0.)
  (matrix-set! mat  7 0.)
  (matrix-set! mat  8 0.)
  (matrix-set! mat  9 0.)
  (matrix-set! mat 10 1.)
  (matrix-set! mat 11 0.)
  (matrix-set! mat 12 0.)
  (matrix-set! mat 13 0.)
  (matrix-set! mat 14 0.)
  (matrix-set! mat 15 1.))


(definition public (matrix-copy! dst <f32vector> src <f32vector>) <void>
  (matrix-set! dst  0 (matrix-ref src 0))
  (matrix-set! dst  1 (matrix-ref src 1))
  (matrix-set! dst  2 (matrix-ref src 2))
  (matrix-set! dst  3 (matrix-ref src 3))
  (matrix-set! dst  4 (matrix-ref src 4))
  (matrix-set! dst  5 (matrix-ref src 5))
  (matrix-set! dst  6 (matrix-ref src 6))
  (matrix-set! dst  7 (matrix-ref src 7))
  (matrix-set! dst  8 (matrix-ref src 8))
  (matrix-set! dst  9 (matrix-ref src 9))
  (matrix-set! dst 10 (matrix-ref src 10))
  (matrix-set! dst 11 (matrix-ref src 11))
  (matrix-set! dst 12 (matrix-ref src 12))
  (matrix-set! dst 13 (matrix-ref src 13))
  (matrix-set! dst 14 (matrix-ref src 14))
  (matrix-set! dst 15 (matrix-ref src 15)))


(definition public (matrix-multiply a <f32vector> b <f32vector>) <f32vector>
  (let ((mat (make-matrix)))
    (loop (for i from 0 below 4)
        (loop (for j from 0 below 4)
              (let ((ind (+ (* j 4) i)))
                (matrix-set! mat ind 0.)
                (loop (for k from 0 below 4)
                      (matrix-set! mat ind (+ (matrix-ref mat ind)
                                              (* (matrix-ref a (+ (* k 4) i))
                                                 (matrix-ref b (+ (* j 4) k)))))))))
    mat))


(definition public (make-translation-matrix x <fl> y <fl> z <fl>) <f32vector>
  (let ((mat (make-matrix)))
    (matrix-set-translation! mat x y z)
    mat))


(definition public (matrix-set-translation! mat <f32vector> x <fl> y <fl> z <fl>) <void>
  (matrix-set-identity! mat)
  (matrix-set! mat 12 x)
  (matrix-set! mat 13 y)
  (matrix-set! mat 14 z))


(definition public (make-projection-matrix fov <fl> ratio <fl> near <fl> far <fl>) <void>
  (let ((mat (make-identity-matrix))
        (f (/ 1.0 (tan (* fov (/ PI 360.))))))
    (matrix-set! mat  0 (/ f ratio))
    (matrix-set! mat  5 f)
    (matrix-set! mat 10 (/ (+ far near) (- near far)))
    (matrix-set! mat 14 (/ (* 2.0 far near) (- near far)))
    (matrix-set! mat 11 -1.)
    mat))


(definition public (make-view-matrix position <f32vector> lookat <f32vector>) <void>
  (let* ((up (vertex 0.0 1.0 0.0))
         (dir (vertex-normalize (vertex- lookat position)))
         (right (vertex-normalize (cross-product dir up)))
         (up (vertex-normalize (cross-product right dir)))
         (view (matrix (vertex-x right)   (vertex-y right)   (vertex-z right)   0.0
                       (vertex-x up)      (vertex-y up)      (vertex-z up)      0.0
                       (- (vertex-x dir)) (- (vertex-y dir)) (- (vertex-z dir)) 0.0
                       0.0                0.0                0.0                1.0))
         (translate (make-translation-matrix (- (vertex-x position))
                                             (- (vertex-y position))
                                             (- (vertex-z position)))))
    (matrix-multiply view translate)))


;;;
;;;; LookAt
;;;


(class LookAt extends Object
  
  
  (slot sight <f32vector> accessors generate)
  (slot up    <f32vector> accessors generate)
  (slot right <f32vector> accessors generate)
  
  
  (method override (initialize sight <f32vector> up <f32vector> right <f32vector>)
    (set! sight~self sight)
    (set! up~self up)
    (set! right~self right))
  
  
  (method public (rotate angle <fl> vert <f32vector>) <void>
    (set! sight (vertex-normalize (rotate-upon angle vert sight)))
    (set! up (vertex-normalize (rotate-upon angle vert up)))
    (set! right (vertex-normalize (rotate-upon angle vert right))))
  
  
  (method public (validate-normalized)
    (define (validate vert)
      (unless (near? (vertex-norm vert) 1. .0001)
        (error "Vertex {s} is not normalized" vert)))
    
    (validate sight)
    (validate up)
    (validate right)))


;;;
;;;; Cuboid
;;;


(class Cuboid extends Object
  
  
  (slot left   <fl> accessors generate)
  (slot bottom <fl> accessors generate)
  (slot back   <fl> accessors generate)
  (slot right  <fl> accessors generate)
  (slot top    <fl> accessors generate)
  (slot front  <fl> accessors generate)
  
  
  (method override (initialize left <fl> bottom <fl> back <fl> right <fl> top <fl> front <fl>)
    (set! left~self left)
    (set! bottom~self bottom)
    (set! back~self back)
    (set! right~self right)
    (set! top~self top)
    (set! front~self front))
  
  
  (method override (print printer readably)
    (format printer "~{{a} {r precision: 1} {r precision: 1} {r precision: 1} {r precision: 1} {r precision: 1} {r precision: 1}}"
            (category-name (class-of self))
            left
            bottom
            back
            right
            top
            front)))


;;;
;;;; Operations
;;;


(definition public (vertex+ v1 <f32vector> v2 <f32vector>) <f32vector>
  (vertex
    (+ (vertex-x v1) (vertex-x v2))
    (+ (vertex-y v1) (vertex-y v2))
    (+ (vertex-z v1) (vertex-z v2))))


(definition public (vertex- v1 <f32vector> v2 <f32vector>) <f32vector>
  (vertex
    (- (vertex-x v1) (vertex-x v2))
    (- (vertex-y v1) (vertex-y v2))
    (- (vertex-z v1) (vertex-z v2))))


(definition public (vertex-negate v <f32vector>) <f32vector>
  (vertex
    (- (vertex-x v))
    (- (vertex-y v))
    (- (vertex-z v))))


(definition public (vertex-scalar* v <f32vector> r <fl>) <f32vector>
  (vertex
    (* r (vertex-x v))
    (* r (vertex-y v))
    (* r (vertex-z v))))


(definition public (rotate-upon angle <fl> u <f32vector> v <f32vector>) <f32vector>
  (let ((c <fl> (cos angle))
        (s <fl> (sin angle))
        (x (vertex-x u))
        (y (vertex-y u))
        (z (vertex-z u))
        (i (vertex-x v))
        (j (vertex-y v))
        (k (vertex-z v)))
    (vertex
      (+ (* i (+ (* x x (- 1 c)) c))
         (* j (- (* x y (- 1 c)) (* z s)))
         (* k (+ (* x z (- 1 c)) (* y s))))
      (+ (* i (+ (* y x (- 1 c)) (* z s)))
         (* j (+ (* y y (- 1 c)) c))
         (* k (- (* y z (- 1 c)) (* x s))))
      (+ (* i (- (* x z (- 1 c)) (* y s)))
         (* j (+ (* y z (- 1 c)) (* x s)))
         (* k (+ (* z z (- 1 c)) c))))))


(definition public (vertex-norm v <f32vector>) <fl>
  (let ((x (vertex-x v))
        (y (vertex-y v))
        (z (vertex-z v)))
    (sqrt (+ (* x x)
             (* y y)
             (* z z)))))


(definition public (vertex-normalize v <f32vector>) <f32vector>
  (vertex-scalar* v (/ (vertex-norm v))))


(definition public (vertex-distance v1 <f32vector> v2 <f32vector>) <fl>
  (vertex-norm (vertex- v2 v1)))


(definition public (inner-product u <f32vector> v <f32vector>) <fl>
  (+ (* (vertex-x u) (vertex-x v))
     (* (vertex-y u) (vertex-y v))
     (* (vertex-z u) (vertex-z v))))


(definition public (cross-product u <f32vector> v <f32vector>) <f32vector>
  (let ((a (vertex-x u))
        (b (vertex-y u))
        (c (vertex-z u))
        (d (vertex-x v))
        (e (vertex-y v))
        (f (vertex-z v)))
    (vertex
      (- (* b f) (* c e))
      (- (* c d) (* a f))
      (- (* a e) (* b d)))))


(definition public (vector-angle v1 <f32vector> v2 <f32vector>) <fl>
  (acos (inner-product v1 v2)))


(definition public (vertical-angle vert world-up)
  (- (vector-angle vert world-up)
     PI/2))


(definition public (plane-normal v1 <f32vector> v2 <f32vector> v3 <f32vector>) <f32vector>
  (cross-product (vertex- v2 v1)
                 (vertex- v3 v1)))


(definition public (ray-triangle-distance p <f32vector> d <f32vector> v0 <f32vector> v1 <f32vector> v2 <f32vector>) <fl+>
  (let* ((e1 (vertex- v1 v0))
         (e2 (vertex- v2 v0))
         (h (cross-product d e2))
         (a (inner-product e1 h)))
    (if (and (> a -0.00001) (< a 0.00001))
        #f
      (let* ((f (/ 1 a))
             (s (vertex- p v0))
             (u (* f (inner-product s h))))
        (if (or (< u 0.0) (> u 1.0))
            #f
          (let* ((q (cross-product s e1))
                 (v (* f (inner-product d q))))
            (if (or (< v 0.0) (> (+ u v) 1.0))
                #f
              ;; at this stage we can compute t to find out where
              ;; the intersection point is on the line
              (let ((t (* f (inner-product e2 q))))
                (if (> t 0.00001) ;; ray intersection
                    t
                  ;; this means that there is a line intersection
                  ;; but not a ray intersection
                  #f)))))))))


(definition public (ray-intersects-triangle? p <f32vector> d <f32vector> v0 <f32vector> v1 <f32vector> v2 <f32vector>) <bool>
  (boolean (ray-triangle-distance p d v0 v1 v2)))


;;;
;;;; OpenGL
;;;


(definition public (gl-plane-normal v1 v2 v3)
  (let ((normal (plane-normal v1 v2 v3)))
    (glNormal3f (vertex-x normal)
                (vertex-y normal)
                (vertex-z normal))))


;;;
;;;; Utilities
;;;


(definition public (random-in max)
  (- (* (random-real) max 2) max)))
