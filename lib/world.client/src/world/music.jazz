;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Music
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.music jazz


(import (jazz.audio)
        (jazz.event)
        (jazz.io)
        (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.configure)
        (world.context)
        (world.geometry)
        (world.settings)
        (world.sound)
        (world.task))


(hub effective-music)
(hub play-music)


;;;
;;;; Task
;;;


(definition public (music-task task <Task>)
  (declare (proper-tail-calls))
  (let ((music (current-music)))
    (with-task task
      (lambda (exit)
        (set-music-thread music (current-thread))
        (let (iter (previous (current-seconds)))
          (let ((time (current-seconds)))
            (let ((elapse (- time previous)))
              (when (running? task)
                (site (music on?: #t)
                  (process-music music)))
              (let ((duration (- (current-seconds) time)))
                (task-wait task music-period duration exit))
              (iter time))))))))


;;;
;;;; Music
;;;


(class World-Music extends Object
  
  
  (slot music?          <bool>   initialize #f   accessors generate)
  (slot music-style     <object> initialize #f   accessors generate)
  (slot music-volume    <fl>     initialize #f   accessors generate)
  (slot music-playing   <object> initialize #f   getter generate)
  (slot music-path      <object> initialize #f   getter generate)
  (slot music-thread    <object> initialize #f   accessors generate)
  (slot music-mutex     <object> initialize #f   getter generate)
  (slot silence-minimum <fl>     initialize 2. @w 60.  accessors generate)
  (slot silence-maximum <fl>     initialize 5. @w 180. accessors generate)
  (slot silence-end     <fl+>    initialize #f   accessors generate)
  
  
  (method override (initialize self)
    (set! music? (world-setting 'world.music? #t))
    (set! music-style (world-setting 'world.music-style #f))
    (set! music-volume (world-setting 'world.music-volume default-music-volume))
    (set! music-mutex (make-mutex 'music)))
  
  
  (method (with-music-mutex self thunk)
    (mutex-lock! music-mutex)
    (prog1 (thunk)
      (mutex-unlock! music-mutex)))
  
  
  ;;;
  ;;;; Events
  ;;;
  
  
  (method (on-toggle-music self evt)
    (toggle-music self))
  
  
  (method (on-change-music self evt)
    (change-music self)
    (display-music self))
  
  
  (method (on-display-music self evt)
    (display-music self))
  
  
  ;;;
  ;;;; Music
  ;;;
  
  
  (method package (initial-music self)
    (when music?
      (enter-silence self minimum: 0. maximum: 15.)))
  
  
  (method (toggle-music self)
    (let ((world (current-world)))
      (if music-playing
          (close-music self)
        (change-music self))
      (display-on/off world "Music" (music-playing? self))))
  
  
  (method package (change-music? self flag)
    (set! music? flag)
    (if music?
        (change-music self)
      (close-music self)))
  
  
  (method package (change-music self)
    (let ((world (current-world)))
      (let ((path (random-music self)))
        (if (not path)
            (display-error world "No music found")
          (play-music self path)))))
  
  
  (method package (random-music self (style: style music-style))
    (let ((world (current-world)))
      (let ((queue (new-queue)))
        (iterate-assets world
          (lambda (assets)
            (let ((music-dir (new-directory (get-directory assets) "music")))
              (when (exists? music-dir)
                (let ((music-context (and style (make-search-context style))))
                  (iterate-directory music-dir
                    (lambda (path kind)
                      (let ((path (join path "/")))
                        (when (or (extension=? (filename-extension path) "mp3")
                                  (extension=? (filename-extension path) "ogg"))
                          (when (or (not style)
                                    (search (join (subpath (get-parent (get-directory assets)) (new-file music-dir (tokenise-filename path))) "/")
                                            music-context))
                            (enqueue queue (filename-spine path))))))
                    full?: #f
                    files?: #t
                    directories?: #f))))))
        (let ((music-list (queue-list queue)))
          (and (not-null? music-list)
               (concatenate "music/" (random-element music-list)))))))
  
  
  ;; music task
  (method package (process-music self)
    (with-music-mutex self
      (lambda ()
        ;; silence ended
        (when (and silence-end (>= (current-seconds) silence-end))
          (set! silence-end #f)
          (post-event
            (lambda ()
              (change-music self)))))))
  
  
  (method (music-ended self)
    (post-event
      (lambda ()
        (when music-playing
          (close-music self)
          (enter-silence self)))))
  
  
  (method (enter-silence self (minimum: minimum #f) (maximum: maximum #f))
    (with-music-mutex self
      (lambda ()
        (set! silence-end (+ (current-seconds) (random-between (or minimum silence-minimum) (or maximum silence-maximum)))))))
  
  
  (method (play-intro-music self)
    (maybe-play-music self "music/Intro"))
  
  
  (method package (music-playing? self)
    (boolean music-playing))
  
  
  (method (maybe-play-music self path)
    (when music?
      (play-music self path)))
  
  
  (method public (play-music self path)
    (let ((world (current-world)))
      (with-music-mutex self
        (lambda ()
          (let ((file (effective-music self path)))
            (when file
              (let ((sound (new-sound file)))
                (close-playing self)
                (set! music-playing sound)
                (set! music-path path)
                (set! silence-end #f)
                (set-volume sound music-volume)
                (register-playing-sound sound (lambda (sound)
                                                (music-ended self)
                                                (close sound)))
                (play sound)
                (update-parameter world 'music)
                sound)))))))
  
  
  (method public (effective-music self path)
    (let ((world (current-world)))
      (and path
           (continuation-capture
             (lambda (return)
               (iterate-assets world
                 (lambda (assets)
                   (let ((mp3 (new-file (get-directory assets) (add-extension path "mp3"))))
                     (if (exists? mp3)
                         (continuation-return return mp3)
                       (let ((ogg (new-file (get-directory assets) (add-extension path "ogg"))))
                         (when (exists? ogg)
                           (continuation-return return ogg)))))))
               #f)))))
  
  
  (method package (close-music self)
    (with-music-mutex self
      (lambda ()
        (close-playing self))))
  
  
  (method (close-playing self)
    (let ((world (current-world)))
      (when music-playing
        (unregister-playing-sound music-playing)
        (close music-playing)
        (set! music-playing #f)
        (set! music-path #f)
        (set! silence-end #f)
        (update-parameter world 'music))))
  
  
  (method (display-music self)
    (let ((world (current-world)))
      (if music-playing
          (display-status world (format "Playing {a}" music-path))
        (display-status world "No music playing"))))))
