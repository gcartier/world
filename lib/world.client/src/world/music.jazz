;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Music
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.music jazz


(import (jazz.audio)
        (jazz.event)
        (jazz.io)
        (jazz.syntax (phase syntax))
        (world)
        (world.autoload)
        (world.configure)
        (world.geometry)
        (world.settings)
        (world.sound)
        (world.syntax (phase syntax))
        (world.task))


;;;
;;;; Task
;;;


(definition public (music-task task <Task>)
  (declare (proper-tail-calls))
  (let ((music (current-music)))
    (with-task task
      (lambda (exit)
        (set-music-thread~ music (current-thread))
        (let (iter (previous (current-seconds)))
          (let ((time (current-seconds)))
            (let ((elapse (- time previous)))
              (unless (stopping?~ task)
                (site (music on?: #t)
                  (process-music~ music)))
              (let ((duration (- (current-seconds) time)))
                (task-sleep task music-period duration exit))
              (iter time))))))))


;;;
;;;; Music
;;;


(class World-Music extends Object
  
  
  (slot music?          <bool>   initialize #f   accessors generate)
  (slot music-style     <object> initialize #f   accessors generate)
  (slot music-volume    <fl>     initialize #f   accessors generate)
  (slot music-playing   <object> initialize #f   getter generate)
  (slot music-path      <object> initialize #f   getter generate)
  (slot music-thread    <object> initialize #f   accessors generate)
  (slot music-mutex     <object> initialize #f   getter generate)
  (slot silence-minimum <fl>     initialize 2. @w 60.  accessors generate)
  (slot silence-maximum <fl>     initialize 5. @w 180. accessors generate)
  (slot silence-end     <fl+>    initialize #f   accessors generate)
  
  
  (method override (initialize)
    (set! music? (world-setting 'world.music? #t))
    (set! music-style (world-setting 'world.music-style #f))
    (set! music-volume (world-setting 'world.music-volume default-music-volume))
    (set! music-mutex (make-mutex 'music)))
  
  
  (method (with-music-mutex thunk)
    (mutex-lock! music-mutex)
    (prog1 (thunk)
      (mutex-unlock! music-mutex)))
  
  
  ;;;
  ;;;; Events
  ;;;
  
  
  (method (on-toggle-music evt)
    (toggle-music))
  
  
  (method (on-change-music evt)
    (change-music)
    (display-music))
  
  
  (method (on-display-music evt)
    (display-music))
  
  
  ;;;
  ;;;; Music
  ;;;
  
  
  (method (initial-music)
    (when music?
      (enter-silence minimum: 0. maximum: 15.)))
  
  
  (method (toggle-music)
    (let ((world (current-world)))
      (if music-playing
          (close-music)
        (change-music))
      (display-on/off~ world "Music" (music-playing?))))
  
  
  (method (change-music? flag)
    (set! music? flag)
    (if music?
        (change-music)
      (close-music)))
  
  
  (method (change-music)
    (let ((world (current-world)))
      (let ((queue (new-queue)))
        (iterate-assets~ world
          (lambda (assets)
            (let ((music-dir (new-directory~ (get-directory~ assets) "music")))
              (when (exists?~ music-dir)
                (let ((music-context (make-search-context music-style)))
                  (iterate-directory~ music-dir
                    (lambda (path kind)
                      (let ((path (join path "/")))
                        (when (or (extension=? (extract-extension path) "mp3")
                                  (extension=? (extract-extension path) "ogg"))
                          (when (or (not music-style)
                                    (search (join (subpath~ (get-parent~ (get-directory~ assets)) (new-file~ music-dir (tokenise-filename path))) "/")
                                            music-context))
                            (enqueue queue (extract-spine path))))))
                    full?: #f
                    files?: #t
                    directories?: #f))))))
        (let ((music-list (queue-list queue)))
          (if (null? music-list)
              (display-error~ world "No music found")
            (let ((music (random-element music-list)))
              (play-music (concatenate "music/" music))))))))
  
  
  ;; music task
  (method (process-music)
    (with-music-mutex
      (lambda ()
        ;; silence ended
        (when (and silence-end (>= (current-seconds) silence-end))
          (set! silence-end #f)
          (post-event
            (lambda ()
              (change-music))))
        ;; music ended
        (when (music-ended?)
          (post-event
            (lambda ()
              (close-music)
              (enter-silence)))))))
  
  
  (method (enter-silence (minimum: minimum #f) (maximum: maximum #f))
    (with-music-mutex
      (lambda ()
        (set! silence-end (+ (current-seconds) (random-between (or minimum silence-minimum) (or maximum silence-maximum)))))))
  
  
  (method (play-intro-music)
    (maybe-play-music "music/Intro"))
  
  
  (method (music-playing?)
    (boolean music-playing))
  
  
  (method (music-ended?)
    (and music-playing (ready?~ music-playing) (not (playing?~ music-playing))))
  
  
  (method (maybe-play-music path)
    (when music?
      (play-music path)))
  
  
  (method (play-music path)
    (let ((world (current-world)))
      (with-music-mutex
        (lambda ()
          (let ((file (effective-music path)))
            (when file
              (let ((sound (new-stream-sound file)))
                (close-playing)
                (set! music-playing sound)
                (set! music-path path)
                (set! silence-end #f)
                (set-volume~ sound music-volume)
                (play~ sound)
                (update-parameter~ world 'music)
                sound)))))))
  
  
  (method (effective-music path)
    (let ((world (current-world)))
      (and path
           (continuation-capture
             (lambda (return)
               (iterate-assets~ world
                 (lambda (assets)
                   (let ((mp3 (new-file~ (get-directory~ assets) (make-filename path "mp3"))))
                     (if (exists?~ mp3)
                         (continuation-return return mp3)
                       (let ((ogg (new-file~ (get-directory~ assets) (make-filename path "ogg"))))
                         (when (exists?~ ogg)
                           (continuation-return return ogg)))))))
               #f)))))
  
  
  (method (close-music)
    (with-music-mutex
      (lambda ()
        (close-playing))))
  
  
  (method (close-playing)
    (let ((world (current-world)))
      (when music-playing
        (close~ music-playing)
        (set! music-playing #f)
        (set! music-path #f)
        (set! silence-end #f)
        (update-parameter~ world 'music))))
  
  
  (method (display-music)
    (let ((world (current-world)))
      (if music-playing
          (display-status~ world (format "Playing {a}" music-path))
        (display-status~ world "No music playing"))))))
