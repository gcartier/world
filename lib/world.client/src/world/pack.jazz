;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Texture Packs
;;;


(module world.pack jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (world)
        (world.foreign)
        (world.texture)
        (time))


;;;
;;;; Pack
;;;


(definition padding
  100)

(definition width-threshold
  2000)


(class Pack extends Object
  
  
  (slot names   initialize (new-queue)               getter generate)
  (slot images  initialize (make-table test: equal?) getter generate)
  (slot h       initialize padding                   getter generate)
  (slot v       initialize padding                   getter generate)
  (slot width   initialize 0                         getter generate)
  (slot height  initialize 0                         getter generate)
  (slot texture initialize #f                        getter generate)
  
  
  (method public (image-names)
    (sort di<? (table-keys images)))
  
  
  (method public (image-rect name)
    (or (table-ref images name #f)
        (error "Unable to find image: {s}" name)))
  
  
  (method public (add-file file)
    (let ((name (get-base~ file))
          (image (cairo_image_surface_create_from_png (parse~ file))))
      (enqueue names name)
      (let ((image-width (cairo_image_surface_get_width image))
            (image-height (cairo_image_surface_get_height image)))
        (let ((right (+ h image-width))
              (bottom (+ v image-height)))
          (table-set! images name (cons (new Surface image) (new Rect h v right bottom)))
          (let ((right (+ right padding))
                (bottom (+ bottom padding)))
            (when (> right width)
              (set! width right))
            (when (> bottom height)
              (set! height bottom))
            (if (< right width-threshold)
                (set! h (+ right padding))
              (set! h padding)
              (set! v (+ height padding))))))))
  
  
  (method public (add-directory dir)
    (iterate-directory~ dir
      (lambda (file)
        (when (extension=? (get-extension~ file) "png")
          (add-file file))
        files?: #t
        directories?: #f)))
  
  
  (method public (add-directory-if-exists dir)
    (when (exists?~ dir)
      (add-directory dir)))
  
  
  (method public (complete)
    (define (blit-images surface)
      (for-each (lambda (name)
                  (bind (image . rect) (table-ref images name #f)
                    ;; poor man improvement of mipmapping based on the assumption that texture colors are roughly uniform
                    (let ((pos (rect-position rect))
                          (size (rect-size rect)))
                      (let ((h (get-h~ pos))
                            (v (get-v~ pos))
                            (width (get-width~ size))
                            (height (get-height~ size)))
                        (with-clip~ surface (inflate-rect rect padding padding)
                          (lambda ()
                            (blit-surface~ surface image destination: (new Point (- h width) (- v height)))
                            (blit-surface~ surface image destination: (new Point h (- v height)))
                            (blit-surface~ surface image destination: (new Point (+ h width) (- v height)))
                            (blit-surface~ surface image destination: (new Point (- h width) v))
                            (blit-surface~ surface image destination: (new Point (+ h width) v))
                            (blit-surface~ surface image destination: (new Point (- h width) (+ v height)))
                            (blit-surface~ surface image destination: (new Point h (+ v height)))
                            (blit-surface~ surface image destination: (new Point (+ h width) (+ v height)))
                            (blit-surface~ surface image destination: pos)))))
                    (table-set! images name (new Rect$fl$
                                              (normalize-x (get-left~ rect))
                                              (normalize-y (get-top~ rect))
                                              (normalize-x (get-right~ rect))
                                              (normalize-y (get-bottom~ rect))))))
                (table-keys images)))
    
    (define (normalize-x x)
      (/ (cast <fl> x) (cast <fl> width)))
    
    (define (normalize-y y)
      (/ (cast <fl> y) (cast <fl> height)))
    
    (set! names (queue-list names))
    (let ((surface (new Surface (cairo_image_surface_create CAIRO_FORMAT_ARGB32 width height))))
      ;; fill with a neutral color to again try and help with mipmapping
      (fill-rect~ surface (new Rect 0 0 width height) {Color Medium-Gray})
      (blit-images surface)
      (let ((tex (new Image-Texture width height surface: surface)))
        (map-texture~ tex)
        (set! texture tex))))))
