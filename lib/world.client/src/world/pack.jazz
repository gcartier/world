;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Texture Packs
;;;


(module world.pack jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.network)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.window)
        (world)
        (world.foreign)
        (world.texture)
        (time))


;;;
;;;; Pack
;;;


(definition width-threshold
  2000)

(definition full-coordinates
  (new Rect$fl$ 0. 0. 1. 1.))


(class Pack extends Object
  
  
  (slot names   initialize (new-queue) getter generate)
  (slot images  initialize (make-table test: equal?) getter generate)
  (slot h       initialize 0 getter generate)
  (slot v       initialize 0 getter generate)
  (slot width   initialize 0 getter generate)
  (slot height  initialize 0 getter generate)
  (slot texture initialize #f getter generate)
  
  
  (method public (get-image name)
    (if (not name)
        full-coordinates
      (or (table-ref images name #f)
          (error "Unable to find image: {s}" name))))
  
  
  (method public (add-file file)
    (let ((name (get-base~ file))
          (image (cairo_image_surface_create_from_png (parse~ file))))
      (enqueue names name)
      (let ((image-width (cairo_image_surface_get_width image))
            (image-height (cairo_image_surface_get_height image)))
        (let ((right (+ h image-width))
              (bottom (+ v image-height)))
          (table-set! images name (cons (new Surface image) (new Rect h v right bottom)))
          (when (> right width)
            (set! width right))
          (when (> bottom height)
            (set! height bottom))
          (if (< right width-threshold)
              (set! h right)
            (set! h 0)
            (set! v height))))))
  
  
  (method public (add-directory dir)
    (iterate-directory~ dir
      (lambda (file)
        (when (extension=? (get-extension~ file) "png")
          (add-file file))
        files?: #t
        directories?: #f)))
  
  
  (method public (add-directory-if-exists dir)
    (when (exists?~ dir)
      (add-directory dir)))
  
  
  (method public (complete program)
    (define (blit-images surface)
      (for-each (lambda (name)
                  (bind (image . rect) (table-ref images name #f)
                    (blit-surface~ surface image destination: (rect-position rect))
                    (table-set! images name (new Rect$fl$
                                              (normalize-x (get-left~ rect))
                                              (normalize-y (get-top~ rect))
                                              (normalize-x (get-right~ rect))
                                              (normalize-y (get-bottom~ rect))))))
                (table-keys images)))
    
    (define (normalize-x x)
      (/ (cast <fl> x) (cast <fl> width)))
    
    (define (normalize-y y)
      (/ (cast <fl> y) (cast <fl> height)))
    
    (set! names (queue-list names))
    (let ((surface (new Surface (cairo_image_surface_create CAIRO_FORMAT_ARGB32 width height))))
      (blit-images surface)
      (let ((tex (new Cairo-Texture width height surface: surface program: program)))
        (map-texture~ tex)
        (set! texture tex))))))
