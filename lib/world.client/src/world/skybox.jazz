;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Skybox
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.skybox jazz


(import (jazz.cairo)
        (jazz.graphic)
        (jazz.io)
        (gaea.dye)
        (gaea.engine)
        (gaea.geometry)
        (gaea.opengl.glew)
        (gaea.texture)
        (world)
        (world.asset)
        (world.assets)
        (world.camera)
        (world.context)
        (world.image)
        (world.programs)
        (world.shape)
        (world.texture))


(definition public (skybox-kind path)
  (let ((name (filename-name path)))
    (cond ((filename=? name "left.png") 'left)
          ((filename=? name "lf.png") 'lf)
          (else #f))))


;; quicky until we read a .skybox
(definition public (skybox-fog path)
  (cond ((equal? path "world/nebula") (dye .111 .004 .222 1.))
        ((equal? path "world/calm_sea") (dye .524 .710 .732 1.))
        ((equal? path "world/dark_sea") (dye .804 .551 .004 1.))
        ((equal? path "world/earth") (dye 0. 0. 0. 1.))
        (else (error "Unable to create skybox fog for {a}" path))))


(definition skyboxes
  '())

(definition public (get-skyboxes)
  skyboxes)


(definition protected (collect-skyboxes)
  (let ((world (current-world)))
    (let ((queue (new-queue)))
      (iterate-assets world
        (lambda (assets)
          (iterate-entries assets
            (lambda (path)
              (when (starts-with? path "skybox/")
                (let ((kind (skybox-kind path)))
                  (when kind
                    (let ((dirpath (filename-dir path)))
                      (let ((skybox-path (substring dirpath (string-length "skybox/") (- (string-length dirpath) 1))))
                        (let ((fog (skybox-fog skybox-path)))
                          (enqueue queue (new Skybox assets skybox-path kind fog))))))))))))
      (sort di<? (queue-list queue) key: get-path))))


(definition public (prepare-skyboxes)
  (set! skyboxes (collect-skyboxes)))


(definition public (find-skybox path)
  (find-if (lambda (skybox)
             (di=? (get-path skybox) path))
           skyboxes))


(definition skybox-mesh
  #f)

(definition skybox-program
  #f)


(definition public (prepare-skybox-program)
  (let ((zone (current-zone)))
    (when (not skybox-program)
      (let ((program (new Skybox-Program)))
        (let ((mesh (generate-cube-mesh)))
          (set-array mesh (create-array program mesh))
          (set! skybox-mesh mesh)
          (set! skybox-program program))))))


;;;
;;;; Skybox
;;;


(class Skybox extends Object
  
  
  (slot assets                  getter generate)
  (slot path                    getter generate)
  (slot kind      initialize #f getter generate)
  (slot sample    initialize #f getter generate)
  (slot world     initialize #f getter generate)
  (slot sky       initialize #f getter generate)
  (slot fog       initialize #f getter generate)
  
  
  (method override (initialize self assets path kind fog)
    (set! self.assets assets)
    (set! self.path path)
    (set! self.kind kind)
    (set! self.fog fog))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{s}" path))))
  
  
  ;;;
  ;;;; Prepare
  ;;;
  
  
  (method public (prepare self)
    (let ((size #f))
      (define (make-image base)
        (let ((name (add-extension base "png")))
          (let ((asset (new Asset assets (append (list "skybox") (tokenise-filename path) (list name)))))
            (bind-values (width height data) (read-image asset)
              (let ((image-size (new Dimension width height)))
                (if (not size)
                    (set! size image-size)
                  (when (nu/=? image-size size)
                    (error "Inconsistant skybox sizes"))))
              data))))
      
      (define (close-image obj)
        (unless (u8vector? obj)
          (cairo_surface_destroy obj)))
      
      (define (with-images proc)
        (case kind
          ((left)
           (proc (make-image "right")
                 (make-image "left")
                 (make-image "back")
                 (make-image "front")
                 (make-image "up")
                 (make-image "down")))
          ((lf)
           (proc (make-image "ft")
                 (make-image "bk")
                 (make-image "lf")
                 (make-image "rt")
                 (make-image "up")
                 (make-image "dn")))))
      
      (define (with-fog front back left right down proc)
        (define (apply-fog image (full? #f))
          (let ((width (get-width size))
                (height (get-height size))
                (color (dye->color fog)))
            (let ((surface (if (u8vector? image)
                               (let ((cairo-format CAIRO_FORMAT_ARGB32))
                                 (let ((stride (cairo_format_stride_for_width cairo-format width)))
                                   (new Surface (cairo_image_surface_create_for_data (still-u8vector-body image) CAIRO_FORMAT_ARGB32 width height stride))))
                             (new Surface image handle-shared?: #t))))
              (if full?
                  (fill-rect surface (new Rect 0 0 width height) color)
                (let ((mid (fxround/ height 3))
                      (low (fxround/ height 2)))
                  (let ((alpha (copy-object color #f)))
                    (set-alpha alpha 0.)
                    (gradient-fill-rect surface (new Rect 0 mid width low) (list (list 0 alpha) (list 1 color)) direction: 'vertical)
                    (fill-rect surface (new Rect 0 low width height) color))))
              (flush surface)
              (close surface)
              image)))
        
        (proc (apply-fog front)
              (apply-fog back)
              (apply-fog left)
              (apply-fog right)
              (apply-fog down #t)))
      
      (unless world
        (with-images
          (lambda (front back left right up down)
            (let ((texture (new Image-Texture (get-width size) (get-height size))))
              (map-texture-cube texture front back up down right left)
              (set! world texture)
              (with-fog front back left right down
                (lambda (front back left right down)
                  (let ((texture (new Image-Texture (get-width size) (get-height size))))
                    (map-texture-cube texture front back up down right left)
                    (set! sky texture))))
              (close-image front)
              (close-image back)
              (close-image left)
              (close-image right)
              (close-image up)
              (close-image down)))))))
  
  
  (method public (sample-texture self)
    (or sample
        (let ((base (case kind
                      ((left) "front")
                      ((lf) "ft"))))
          (let ((name (add-extension base "png")))
            (let ((asset (new Asset assets (append (list "skybox") (tokenise-filename path) (list name)))))
              (let ((file (retrieve-file asset)))
                (bind-values (image-width image-height surface) (cairo-surface-from-file file)
                  (let ((data (cairo_image_surface_get_data surface)))
                    (let ((texture (new Image-Texture image-width image-height data: data file: file)))
                      (map-texture texture)
                      (cairo_surface_destroy surface)
                      (set! sample texture)
                      sample)))))))))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method public (draw-worldbox self)
    (let ((camera (current-camera)))
      (let ((projection-matrix (get-projection-matrix camera))
            (view-matrix (make-view-matrix& (vertex& 0. 0. 0.) (get-lookat camera))))
        (use skybox-program)
        (glDepthFunc GL_LEQUAL)
        (bind-uniforms skybox-program projection-matrix view-matrix world)
        (draw-array skybox-mesh)
        (unbind-uniforms skybox-program)
        (glDepthFunc GL_LESS)
        (unuse skybox-program)
        (check-engine-error))))
  
  
  (method public (draw-skybox self)
    (let ((camera (current-camera)))
      (let ((projection-matrix (get-projection-matrix camera))
            (view-matrix (make-view-matrix& (vertex& 0. 0. 0.) (get-lookat camera))))
        (use skybox-program)
        (glDepthFunc GL_LEQUAL)
        (bind-uniforms skybox-program projection-matrix view-matrix sky)
        (draw-array skybox-mesh)
        (unbind-uniforms skybox-program)
        (glDepthFunc GL_LESS)
        (unuse skybox-program)
        (check-engine-error))))))
