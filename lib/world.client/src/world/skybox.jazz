;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Skybox
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.skybox jazz


(import (jazz.cairo)
        (jazz.graphic)
        (jazz.io)
        (jazz.opengl.glew)
        (jazz.opengl.texture)
        (gaea.dye)
        (gaea.geometry)
        (world)
        (world.asset)
        (world.assets)
        (world.camera)
        (world.context)
        (world.image)
        (world.programs)
        (world.shape)
        (world.texture))


(definition public (skybox-kind path)
  (let ((name (filename-name path)))
    (cond ((filename=? name "left.png") 'left)
          ((filename=? name "lf.png") 'lf)
          (else #f))))


(definition skyboxes
  '())

(definition public (get-skyboxes)
  skyboxes)


(definition protected (collect-skyboxes)
  (let ((world (current-world)))
    (let ((queue (new-queue)))
      (iterate-assets world
        (lambda (assets)
          (iterate-entries assets
            (lambda (path)
              (when (starts-with? path "skybox/")
                (let ((kind (skybox-kind path)))
                  (when kind
                    (let ((dirpath (filename-dir path)))
                      (let ((skybox-path (substring dirpath (string-length "skybox/") (- (string-length dirpath) 1))))
                        (enqueue queue (new Skybox assets skybox-path kind)))))))))))
      (sort di<? (queue-list queue) key: get-path))))


(definition public (prepare-skyboxes)
  (set! skyboxes (collect-skyboxes)))


(definition public (find-skybox path)
  (find-if (lambda (skybox)
             (di=? (get-path skybox) path))
           skyboxes))


(definition skybox-mesh
  #f)

(definition skybox-program
  #f)


(definition public (prepare-skybox-program)
  (let ((zone (current-zone)))
    (when (not skybox-program)
      (let ((program (new Skybox-Program)))
        (let ((mesh (generate-cube-mesh)))
          (set-array mesh (create-array program mesh))
          (set! skybox-mesh mesh)
          (set! skybox-program program))))))


;;;
;;;; Skybox
;;;


(class Skybox extends Object
  
  
  (slot assets                getter generate)
  (slot path                  getter generate)
  (slot kind    initialize #f getter generate)
  (slot texture initialize #f getter generate)
  (slot sample  initialize #f getter generate)
  
  
  (method override (initialize self assets path kind)
    (set! self.assets assets)
    (set! self.path path)
    (set! self.kind kind))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{s}" path))))
  
  
  ;;;
  ;;;; Prepare
  ;;;
  
  
  (method public (prepare self)
    (let ((size #f))
      (define (make-image base)
        (let ((name (add-extension base "png")))
          (let ((asset (new Asset assets (append (list "skybox") (tokenise-filename path) (list name)))))
            (bind-values (width height data) (read-image asset)
              (let ((image-size (new Dimension width height)))
                (if (not size)
                    (set! size image-size)
                  (when (nu/=? image-size size)
                    (error "Inconsistant skybox sizes"))))
              data))))
      
      (define (close-image obj)
        (unless (u8vector? obj)
          (cairo_surface_destroy obj)))
      
      (define (with-images proc)
        (case kind
          ((left)
           (proc (make-image "right")
                 (make-image "left")
                 (make-image "back")
                 (make-image "front")
                 (make-image "up")
                 (make-image "down")))
          ((lf)
           (proc (make-image "ft")
                 (make-image "bk")
                 (make-image "lf")
                 (make-image "rt")
                 (make-image "up")
                 (make-image "dn")))))
      
      (unless texture
        (with-images
          (lambda (front back left right up down)
            (let ((tex (new Image-Texture (get-width size) (get-height size))))
              (map-texture-cube tex front back up down right left)
              (set! texture tex)
              (close-image front)
              (close-image back)
              (close-image left)
              (close-image right)
              (close-image up)
              (close-image down)))))))
  
  
  (method public (sample-texture self)
    (or sample
        (let ((base (case kind
                      ((left) "front")
                      ((lf) "ft"))))
          (let ((name (add-extension base "png")))
            (let ((asset (new Asset assets (append (list "skybox") (tokenise-filename path) (list name)))))
              (let ((file (retrieve-file asset)))
                (bind-values (image-width image-height surface) (cairo-surface-from-file file)
                  (let ((data (cairo_image_surface_get_data surface)))
                    (let ((tex (new Image-Texture image-width image-height data: data file: file)))
                      (map-texture tex)
                      (cairo_surface_destroy surface)
                      (set! sample tex)
                      sample)))))))))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method public (draw-skybox self)
    (let ((camera (current-camera)))
      (let ((projection-matrix (get-projection-matrix camera))
            (view-matrix (make-view-matrix& (vertex& 0. 0. 0.) (get-lookat camera))))
        (use skybox-program)
        (glDepthFunc GL_LEQUAL)
        (bind-uniforms skybox-program projection-matrix view-matrix texture)
        (draw-array skybox-mesh)
        (unbind-uniforms skybox-program)
        (glDepthFunc GL_LESS)
        (unuse skybox-program)
        (gl-check-error))))))
