;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Entities
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.entity jazz


(import (jazz.jml)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (world)
        (world.animation)
        (world.autoload)
        (world.draw)
        (world.dye)
        (world.dyes)
        (world.element)
        (world.foreign)
        (world.foreign.obj)
        (world.geometry)
        (world.mesh)
        (world.quad)
        (world.shader)
        (world.syntax (phase syntax)))


(definition animations?
  #t)

(definition public (get-animations?)
  animations?)

(definition public (set-animations? flag)
  (set! animations? flag))


;;;
;;;; Entity
;;;


(class Entity extends Element
  
  
  (property path      <object> initialize #f accessors generate)
  (property animate?  <bool>   initialize #f accessors generate)
  (property animation <object> initialize #f accessors generate)
  
  
  (slot model          <object>    initialize #f getter generate)
  (slot morphing       <Morphing+> initialize #f getter generate)
  (slot animation-tick <object>    initialize #f getter generate)
  (slot matrix         <f64vector> initialize (make-identity-matrix) getter generate)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set-color white-dye))
  
  
  (method override (finish rest)
    (nextmethod rest)
    (setup-model))
  
  
  (method (setup-model)
    (when path
      (let ((world (current-world)))
        (set-model (find-model~ world path))
        (when (and animate? animations?)
          (setup-morphing animation)))))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" (and model (get-name~ model)) (present-vertex position)))))
  
  
  (method public (set-model mdl)
    (set! model mdl)
    (update-radiuses))

  
  (method public (set-matrix mat)
    (matrix-copy! matrix mat))
  
  
  (method override (position-update)
    (nextmethod)
    (update-matrix))
  
  
  (method override (scale-update)
    (nextmethod)
    (update-radiuses)
    (update-matrix))
  
  
  (method override (center-update)
    (if (not model)
        (nextmethod)
      ;; quick hack until everything unified
      (let ((bounds (get-bounds~ model)))
        (if (not bounds)
            (nextmethod)
          (matrix-transform-3x4! center matrix (get-center~ model))))))
  
  
  (method (update-radiuses)
    (when model
      (let ((bounds (get-bounds~ model)))
        (when bounds
          (set-radiuses (vertex* (cuboid-radiuses bounds) scale))))))
  
  
  (method override (update-matrix)
    (matrix-multiply! matrix (make-translation-matrix& (get-x) (get-y) (get-z)) (matrix-multiply& (make-lookat-matrix& lookat) (make-scaling-matrix& (vertex-x scale) (vertex-y scale) (vertex-z scale))))
    ;; needs cleanup
    (center-update))
  
  
  ;;;
  ;;;; Bounds
  ;;;
  
  
  (method public (for-each-bounding-quad sphere-matrix poly proc)
    (let ((bounds (make-cuboid&)))
      (get-bounds! bounds)
      (let ((left (cuboid-left bounds))
            (right (cuboid-right bounds))
            (bottom (cuboid-bottom bounds))
            (top (cuboid-top bounds))
            (back (cuboid-back bounds))
            (front (cuboid-front bounds)))
        (define (transform v1 v2 v3 v4)
          (proc (make-quad self
                           (matrix+-transform-3x4 sphere-matrix v1)
                           (matrix+-transform-3x4 sphere-matrix v2)
                           (matrix+-transform-3x4 sphere-matrix v3)
                           (matrix+-transform-3x4 sphere-matrix v4))))
        
        ;; front face
        (transform (vertex left top front) (vertex left bottom front) (vertex right bottom front) (vertex right top front))
        ;; back face
        (transform (vertex right top back) (vertex right bottom back) (vertex left bottom back) (vertex left top back))
        ;; left face
        (transform (vertex left top back) (vertex left bottom back) (vertex left bottom front) (vertex left top front))
        ;; right face
        (transform (vertex right top front) (vertex right bottom front) (vertex right bottom back) (vertex right top back))
        ;; top face
        (transform (vertex left top back) (vertex left top front) (vertex right top front) (vertex right top back))
        ;; bottom face
        (transform (vertex left bottom front) (vertex left bottom back) (vertex right bottom back) (vertex right bottom front)))))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method override (draw-3d-textured)
    (if (not model)
        (nextmethod)
      (draw-entity)))
  
  
  (method override (draw-3d)
    (if (not model)
        (nextmethod)
      (draw-entity)))
  
  
  (method (draw-entity)
    (let ((world (current-world)))
      (let ((mesh (get-mesh~ model))
            (program (find-mesh-program~ world (entity-program))))
        (use~ program)
        (bind-render-uniforms~ program (get-material~ mesh) matrix)
        (entity-bind-uniforms program mesh matrix)
        ;(glDisable GL_DEPTH_TEST)
        ;(glEnable GL_CULL_FACE)
        ;(glCullFace GL_FRONT)
        ;(glFrontFace GL_CCW)
        (glEnable GL_ALPHA_TEST)
        (glAlphaFunc GL_GEQUAL .7)
        ;(glDisable GL_BLEND)
        (draw-mesh~ program mesh)
        (glDisable GL_ALPHA_TEST)
        ;(glDisable GL_CULL_FACE)
        ;(glEnable GL_DEPTH_TEST)
        ;(glEnable GL_BLEND)
        ;(glBlendFunc GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA)
        (unbind-uniforms~ program)
        (unbind-render-uniforms~ program)
        (unuse~ program))))
  
  
  (method protected virtual (entity-program)
    (if (and animate? animations? morphing)
        'skeletal-phong
      'dynamic-phong))
  
  
  (method protected virtual (entity-bind-uniforms program mesh matrix)
    (if (and animate? animations? morphing)
        (let ((bone-matrices (get-bone-matrices~ morphing)))
          (assert bone-matrices)
          (bind-uniforms~ program mesh matrix bone-matrices))
      (bind-uniforms~ program mesh matrix)))
    
  
  ;;;
  ;;;; Animation
  ;;;
  
  
  (method public (setup-morphing (name #f))
    (let ((world (current-world)))
      (when (not morphing)
        (change-morphing name)
        (when morphing
          (set! animation-tick animate)
          (register-tick~ world animation-tick)))))
  
  
  (method public (change-morphing name (frame: frame #f))
    (let ((animation (require-animation~ model name)))
      (when (has-bones?~ animation)
        (unless (and morphing (eq? animation (get-animation~ morphing)))
          (if (not morphing)
              (set! morphing (new Morphing animation))
            (change-animation~ morphing animation))
          (goto-time~ morphing (or frame 0.))))))
  
  
  (method public (transition-morphing name)
    (if (not morphing)
        (change-morphing name)
      (let ((animation (require-animation~ model name))
            (transition (get-transition~ morphing)))
        (unless (or (and transition (eq? animation (get-animation~ transition)))
                    (and (not transition) (eq? animation (get-animation~ morphing))))
          (if (not (get-transition~ morphing))
              (set-transition~ morphing (new Morphing animation))
            (change-animation~ (get-transition~ morphing) animation))
          (set-transition-frame~ morphing 0.)))))
  
  
  (method public (free-morphing)
    (let ((world (current-world)))
      (when morphing
        (unregister-tick~ world animation-tick)
        (set! animation-tick #f)
        (set! morphing #f))))
  
  
  (method (animate elapse)
    (when (and animate? animations? animation-tick morphing)
      (animate~ morphing elapse)
      (when (transition-done?~ morphing)
        (let ((new-morphing (get-transition~ morphing)))
          (set-transition~ morphing #f)
          (set-transition-frame~ morphing #f)
          (set! morphing new-morphing)
          (goto-time~ morphing 0.)))))
  
  
  (method (toggle-animated)
    (let ((world (current-world)))
      (if animation-tick
          (begin
            (unregister-tick~ world animation-tick)
            (set! animation-tick #f))
        (set! animation-tick animate)
        (register-tick~ world animation-tick))))
  
  
  (method (set-frame frame)
    (goto-time~ morphing frame))))
