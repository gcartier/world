;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Entities
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.entity jazz


(import (jazz.jml)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (world)
        (world.animation)
        (world.autoload)
        (world.camera)
        (world.draw)
        (world.dye)
        (world.dyes)
        (world.element)
        (world.foreign)
        (world.foreign.obj)
        (world.generate)
        (world.geometry)
        (world.material)
        (world.mesh)
        (world.model)
        (world.opengl)
        (world.parallelepiped)
        (world.quad)
        (world.renderer)
        (world.shader)
        (world.support)
        (world.syntax (phase syntax)))


;;;
;;;; Entity
;;;


(class Entity extends Element
  
  
  (property model       <object> initialize #f getter generate setter explicit)
  (property meshes-mask <object> initialize #f getter generate setter explicit)
  (property physical?   <bool>   initialize #f accessors generate)
  (property animate?    <bool>   initialize #f accessors generate)
  (property animation   <object> initialize #f accessors generate)
  (property shaders     <object> initialize #f getter generate setter explicit)
  
  
  (slot model-cache    <Model+>     initialize #f getter generate)
  (slot model-update   <procedure+> initialize #f accessors generate)
  (slot meshes         <object>     initialize #f accessors generate)
  (slot morphing       <Morphing+>  initialize #f getter generate)
  (slot animation-tick <object>     initialize #f getter generate)
  (slot renderer       <object>     initialize #f accessors generate)
  (slot camera         <Camera+>    initialize #f accessors generate)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set-color white-dye))
  
  
  (method override (destroy)
    (free-morphing)
    (nextmethod))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" model (present-vertex position)))))
  
  
  (method public (set-model mdl)
    (if (is? mdl Model)
        (set-model-cache mdl)
      (set! model mdl)
      (set! model-cache #f)))
  
  
  (method (cache-model)
    (or model-cache
        (begin
          (set-model-cache (resolve-model))
          model-cache)))
  
  
  (method protected virtual (resolve-model)
    (let ((world (current-world)))
      (assert model)
      (find-model~ world model)))
  
  
  (method (set-model-cache model)
    (define (effective-meshes model)
      (let ((meshes (get-meshes~ model)))
        (if (not meshes-mask)
            meshes
          (list->vector (loop (for mesh in-vector meshes)
                              (for render? in meshes-mask)
                              (when render?
                                (collect mesh)))))))
    
    (set! model-cache model)
    (when model
      (set! meshes (effective-meshes model))
      (when model-update
        (model-update self model))
      (reset-radiuses)
      (update-matrix)
      (when (and animate? (get-animations?) (find-animation~ model animation))
        (setup-morphing animation))))
  
  
  (method public (set-meshes-mask mask)
    (set! meshes-mask mask)
    (set! meshes #f)
    (set! model-cache #f))
  
  
  (method protected (entity-meshes)
    meshes)
  
  
  (method protected (entity-animate?)
    (and animate? (get-animations?) morphing))
  
  
  (method public virtual (set-shaders value)
    (set! shaders value)
    (set! renderer (and value (require-renderer value))))
  
  
  (method override (element-radiuses)
    (let ((model (cache-model)))
      (let ((bounds (get-bounds~ model)))
        (vertex* (vertex* (cuboid-radiuses bounds) scale) (get-scale~ model)))))
  
  
  (method override (effective-matrix&)
    (matrix-multiply& matrix (get-global-matrix~ (cache-model))))
  
  
  (method override (transformed-bounds)
    (let ((model (cache-model)))
      (let ((matrix (effective-matrix&))
            (bounds (get-bounds~ model)))
        (let ((left (cuboid-left bounds))
              (right (cuboid-right bounds))
              (bottom (cuboid-bottom bounds))
              (top (cuboid-top bounds))
              (back (cuboid-back bounds))
              (front (cuboid-front bounds)))
          (parallelepiped (matrix-transform-3x4 matrix (vertex left bottom back))
                          (matrix-transform-3x4 matrix (vertex left bottom front))
                          (matrix-transform-3x4 matrix (vertex left top back))
                          (matrix-transform-3x4 matrix (vertex left top front))
                          (matrix-transform-3x4 matrix (vertex right bottom back))
                          (matrix-transform-3x4 matrix (vertex right bottom front))
                          (matrix-transform-3x4 matrix (vertex right top back))
                          (matrix-transform-3x4 matrix (vertex right top front)))))))
  
  
  (method override (selection-bounds)
    (let ((model (cache-model)))
      (let ((matrix (effective-matrix&))
            (bounds (get-bounds~ model)))
        (let ((radiuses (cuboid-radiuses bounds)))
          (let ((radius-x (max .25 (vertex-x radiuses)))
                (radius-z (max .25 (vertex-z radiuses))))
            (let ((left (- radius-x))
                  (right radius-x)
                  (bottom (min 0. (cuboid-bottom bounds)))
                  (top (cuboid-top bounds))
                  (back (- radius-z))
                  (front radius-z))
              (parallelepiped (matrix-transform-3x4 matrix (vertex left bottom back))
                              (matrix-transform-3x4 matrix (vertex left bottom front))
                              (matrix-transform-3x4 matrix (vertex left top back))
                              (matrix-transform-3x4 matrix (vertex left top front))
                              (matrix-transform-3x4 matrix (vertex right bottom back))
                              (matrix-transform-3x4 matrix (vertex right bottom front))
                              (matrix-transform-3x4 matrix (vertex right top back))
                              (matrix-transform-3x4 matrix (vertex right top front)))))))))
  
  
  (method override (transformed-center)
    (let ((model (cache-model)))
      (let ((matrix (effective-matrix&))
            (center (get-center~ model)))
        (matrix-transform-3x4 matrix center))))
  
  
  (method override (transformed-radiuses)
    (let ((model (cache-model)))
      (vertex* (vertex* (cuboid-radiuses (get-bounds~ model)) scale)
               (get-scale~ model))))
  
  
  (method override (element-polygons)
    (if (not physical?)
        (nextmethod)
      (let ((model (cache-model)))
        (polygons-extract self (get-polygons~ model) matrix))))
  
  
  ;;;
  ;;;; Bounds
  ;;;
  
  
  (method public (for-each-bounding-quad sphere-matrix poly proc)
    (let ((bounds (selection-bounds)))
      (iterate-parallelepiped-quads bounds sphere-matrix poly proc self)))

  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method override (draw-target dye)
    (draw-target-parallelepiped dye))
  
  
  (method override (draw-target-circle)
    (let ((model (cache-model)))
      (glLineWidth 2.)
      (glDisable GL_LIGHTING)
      (case (get-anchor~ model)
        ((center)
         (let ((r (/ (target-radius) 1.5))
               (y (- (get-y) (* (/ (cuboid-height (get-bounds~ model)) 2.) (get-scale-y)))))
           (gl-horizontal-circle (vertex (get-x) y (get-z)) r (dye->color purple-dye))))
        ((origin)
         (let ((radius (max .5 (target-radius))))
           (gl-horizontal-circle (vertex (get-x) (get-y) (get-z)) (/ radius 1.8) (dye->color purple-dye)))))
      (glEnable GL_LIGHTING)
      (glLineWidth 1.)))
  
  
  (method (draw-target-parallelepiped dye (line-width: line-width #f))
    (gl-colorize-dye dye)
    (glLineWidth (or line-width 2.))
    (glDisable GL_LIGHTING)
    (render-parallelepiped (selection-bounds)
                           (lambda (proc)
                             (glBegin GL_LINE_LOOP)
                             (proc)
                             (glEnd)))
    (glEnable GL_LIGHTING)
    (glLineWidth 1.))
  
  
  (method override (target-moveable?)
    (not physical?))
  
  
  ;;;
  ;;;; Animation
  ;;;
  
  
  (method public (setup-morphing (name #f))
    (let ((world (current-world)))
      (when morphing
        (free-morphing))
      (change-morphing name)
      (when morphing
        (set! animation-tick animate)
        (register-tick~ world animation-tick))))
  
  
  (method public (change-morphing name (frame: frame #f))
    (let ((animation (require-animation~ (cache-model) name)))
      (when (has-bones?~ animation)
        (unless (and morphing (eq? animation (get-animation~ morphing)))
          (if (not morphing)
              (set! morphing (new Morphing animation))
            (change-animation~ morphing animation))
          (goto-time~ morphing (or frame 0.))))))
  
  
  (method public (transition-morphing name)
    (if (not morphing)
        (change-morphing name)
      (let ((animation (require-animation~ (cache-model) name))
            (transition (get-transition~ morphing)))
        (unless (or (and transition (eq? animation (get-animation~ transition)))
                    (and (not transition) (eq? animation (get-animation~ morphing))))
          (if (not (get-transition~ morphing))
              (set-transition~ morphing (new Morphing animation))
            (change-animation~ (get-transition~ morphing) animation))
          (set-transition-frame~ morphing 0.)))))
  
  
  (method public (free-morphing)
    (let ((world (current-world)))
      (when morphing
        (unregister-tick~ world animation-tick)
        (set! animation-tick #f)
        (set! morphing #f))))
  
  
  (method (animate elapse)
    (let ((world (current-world)))
      (when (and animate? (get-animations?) animation-tick morphing)
        (when (in-frustum?~ (or camera (get-eye~ world)) position)
          (animate~ morphing elapse)
          (when (transition-done?~ morphing)
            (let ((new-morphing (get-transition~ morphing)))
              (set-transition~ morphing #f)
              (set-transition-frame~ morphing #f)
              (set! morphing new-morphing)
              (goto-time~ morphing 0.)))))))
  
  
  (method (toggle-animated)
    (let ((world (current-world)))
      (if animation-tick
          (begin
            (unregister-tick~ world animation-tick)
            (set! animation-tick #f))
        (set! animation-tick animate)
        (register-tick~ world animation-tick))))
  
  
  (method (set-frame frame)
    (goto-time~ morphing frame))))
