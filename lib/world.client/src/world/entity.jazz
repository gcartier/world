;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Entities
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.entity jazz


(import (jazz.jml)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (world)
        (world.animation)
        (world.autoload)
        (world.camera)
        (world.draw)
        (world.dye)
        (world.dyes)
        (world.element)
        (world.foreign)
        (world.foreign.obj)
        (world.geometry)
        (world.material)
        (world.mesh)
        (world.model)
        (world.opengl)
        (world.quad)
        (world.shader)
        (world.shape)
        (world.syntax (phase syntax)))


(definition animations?
  #t)

(definition public (get-animations?)
  animations?)

(definition public (set-animations? flag)
  (set! animations? flag))


;;;
;;;; Entity
;;;


(class Entity extends Element
  
  
  (property path      <object> initialize #f accessors generate)
  (property animate?  <bool>   initialize #f accessors generate)
  (property animation <object> initialize #f accessors generate)
  (property program   <object> initialize #f accessors generate)
  
  
  (slot model          <Model+>     initialize #f getter generate)
  (slot model-update   <procedure+> initialize #f accessors generate)
  (slot material       <Material+>  initialize #f accessors generate)
  (slot morphing       <Morphing+>  initialize #f getter generate)
  (slot animation-tick <object>     initialize #f getter generate)
  (slot matrix         <f64vector>  initialize (make-identity-matrix) getter generate)
  (slot camera         <Camera+>    initialize #f accessors generate)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set-color white-dye))
  
  
  (method override (destroy)
    (free-morphing)
    (nextmethod))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" path (present-vertex position)))))
  
  
  (method (cache-model)
    (let ((world (current-world)))
      (or model
          (when path
            (set-model (find-model~ world path))
            model))))
  
  
  (method public (set-model mdl)
    (set! model mdl)
    (when model-update
      (model-update self mdl))
    (update-radiuses)
    (update-matrix)
    (when (and animate? animations? (find-animation~ model animation))
      (setup-morphing animation)))

  
  (method public (set-matrix mat)
    (matrix-copy! matrix mat))
  
  
  (method override (position-update)
    (nextmethod)
    (update-matrix))
  
  
  (method override (scale-update)
    (nextmethod)
    (update-radiuses)
    (update-matrix))
  
  
  (method (update-radiuses)
    (when model
      (let ((bounds (get-bounds~ model)))
        (when bounds
          (set-radiuses (vertex* (cuboid-radiuses bounds) scale))))))
  
  
  (method override (update-matrix)
    (matrix-multiply! matrix (make-translation-matrix& (get-x) (get-y) (get-z)) (matrix-multiply& (if model
                                                                                                      (matrix-multiply& (make-rotation-matrix& 0. (- PI/2) 0.)
                                                                                                                        (make-lookat-matrix& lookat))
                                                                                                    (make-lookat-matrix& lookat))
                                                                                                  (make-scaling-matrix& (vertex-x scale) (vertex-y scale) (vertex-z scale)))))
  
  
  ;; a try for testing
  (method override (transformed-bounds)
    (let ((model (cache-model)))
      (if (not model)
          (nextmethod)
        (let ((bounds (get-bounds~ model)))
          ;; until unification
          (if (not bounds)
              (nextmethod)
            (let ((left (cuboid-left bounds))
                  (right (cuboid-right bounds))
                  (bottom (cuboid-bottom bounds))
                  (top (cuboid-top bounds))
                  (back (cuboid-back bounds))
                  (front (cuboid-front bounds)))
              (let ((v1 (matrix-transform-3x4 matrix (vertex left bottom back)))
                    (v2 (matrix-transform-3x4 matrix (vertex left bottom front)))
                    (v3 (matrix-transform-3x4 matrix (vertex left top back)))
                    (v4 (matrix-transform-3x4 matrix (vertex left top front)))
                    (v5 (matrix-transform-3x4 matrix (vertex right bottom back)))
                    (v6 (matrix-transform-3x4 matrix (vertex right bottom front)))
                    (v7 (matrix-transform-3x4 matrix (vertex right top back)))
                    (v8 (matrix-transform-3x4 matrix (vertex right top front))))
                (define (bound proc accessor)
                  (apply proc (list (accessor v1)
                                    (accessor v2)
                                    (accessor v3)
                                    (accessor v4)
                                    (accessor v5)
                                    (accessor v6)
                                    (accessor v7)
                                    (accessor v8))))
                
                (cuboid (bound min vertex-x)
                        (bound min vertex-y)
                        (bound min vertex-z)
                        (bound max vertex-x)
                        (bound max vertex-y)
                        (bound max vertex-z)))))))))
  
  
  ;;;
  ;;;; Bounds
  ;;;
  
  
  (method public (for-each-bounding-quad sphere-matrix poly proc)
    (let ((bounds (make-cuboid&)))
      (get-bounds! bounds)
      (iterate-cuboid-quads bounds sphere-matrix poly proc self)))
  
  
  ;;;
  ;;;; Material
  ;;;
  
  
  (method public (effective-material)
    (or material (get-material~ (get-mesh~ (cache-model)))))

  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method override (draw-3d-textured)
    (let ((model (cache-model)))
      (if (not model)
          (nextmethod)
        (draw-entity))))
  
  
  (method override (draw-3d)
    (let ((model (cache-model)))
      (if (not model)
          (nextmethod)
        (draw-entity))))
  
  
  (method (draw-entity)
    (let ((world (current-world)))
      (let ((mesh (get-mesh~ (cache-model)))
            (program (find-mesh-program~ world (entity-program))))
        (use~ program)
        (bind-render-uniforms~ program (effective-material) matrix)
        (entity-bind-uniforms program mesh matrix)
        ;(glDisable GL_DEPTH_TEST)
        ;(glEnable GL_CULL_FACE)
        ;(glCullFace GL_FRONT)
        ;(glFrontFace GL_CCW)
        (glEnable GL_ALPHA_TEST)
        (glAlphaFunc GL_GEQUAL .7)
        ;(glDisable GL_BLEND)
        (draw-mesh~ program mesh)
        (glDisable GL_ALPHA_TEST)
        ;(glDisable GL_CULL_FACE)
        ;(glEnable GL_DEPTH_TEST)
        ;(glEnable GL_BLEND)
        ;(glBlendFunc GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA)
        (unbind-uniforms~ program)
        (unbind-render-uniforms~ program)
        (unuse~ program))))
  
  
  (method protected virtual (entity-program)
    (if (and animate? animations? morphing)
        'skeletal-phong
      (or program 'dynamic-phong)))
  
  
  (method protected virtual (entity-bind-uniforms program mesh matrix)
    (if (and animate? animations? morphing)
        (let ((bone-matrices (get-bone-matrices~ morphing)))
          (assert bone-matrices)
          (bind-uniforms~ program mesh matrix bone-matrices))
      (bind-uniforms~ program mesh matrix #f)))
  
  
  (method override (draw-target dye)
    (let ((model (cache-model)))
      (if (not model)
          (nextmethod dye)
        (let ((bounds (get-bounds~ model)))
          (let ((left (cuboid-left bounds))
                (right (cuboid-right bounds))
                (bottom (cuboid-bottom bounds))
                (top (cuboid-top bounds))
                (back (cuboid-back bounds))
                (front (cuboid-front bounds)))
            (gl-colorize-dye dye)
            (glLineWidth 2.)
            (glDisable GL_LIGHTING)
            (render-parallelepiped (matrix-transform-3x4 matrix (vertex left bottom back))
                                   (matrix-transform-3x4 matrix (vertex left bottom front))
                                   (matrix-transform-3x4 matrix (vertex left top back))
                                   (matrix-transform-3x4 matrix (vertex left top front))
                                   (matrix-transform-3x4 matrix (vertex right bottom back))
                                   (matrix-transform-3x4 matrix (vertex right bottom front))
                                   (matrix-transform-3x4 matrix (vertex right top back))
                                   (matrix-transform-3x4 matrix (vertex right top front))
              (lambda (proc)
                (glBegin GL_LINE_LOOP)
                (proc)
                (glEnd)))
            (glEnable GL_LIGHTING)
            (glLineWidth 1.))))))
    
  
  ;;;
  ;;;; Animation
  ;;;
  
  
  (method public (setup-morphing (name #f))
    (let ((world (current-world)))
      (when (not morphing)
        (change-morphing name)
        (when morphing
          (set! animation-tick animate)
          (register-tick~ world animation-tick)))))
  
  
  (method public (change-morphing name (frame: frame #f))
    (let ((animation (require-animation~ (cache-model) name)))
      (when (has-bones?~ animation)
        (unless (and morphing (eq? animation (get-animation~ morphing)))
          (if (not morphing)
              (set! morphing (new Morphing animation))
            (change-animation~ morphing animation))
          (goto-time~ morphing (or frame 0.))))))
  
  
  (method public (transition-morphing name)
    (if (not morphing)
        (change-morphing name)
      (let ((animation (require-animation~ (cache-model) name))
            (transition (get-transition~ morphing)))
        (unless (or (and transition (eq? animation (get-animation~ transition)))
                    (and (not transition) (eq? animation (get-animation~ morphing))))
          (if (not (get-transition~ morphing))
              (set-transition~ morphing (new Morphing animation))
            (change-animation~ (get-transition~ morphing) animation))
          (set-transition-frame~ morphing 0.)))))
  
  
  (method public (free-morphing)
    (let ((world (current-world)))
      (when morphing
        (unregister-tick~ world animation-tick)
        (set! animation-tick #f)
        (set! morphing #f))))
  
  
  (method (animate elapse)
    (let ((world (current-world)))
      (when (and animate? animations? animation-tick morphing)
        (when (in-frustum?~ (or camera (get-eye~ world)) position)
          (animate~ morphing elapse)
          (when (transition-done?~ morphing)
            (let ((new-morphing (get-transition~ morphing)))
              (set-transition~ morphing #f)
              (set-transition-frame~ morphing #f)
              (set! morphing new-morphing)
              (goto-time~ morphing 0.)))))))
  
  
  (method (toggle-animated)
    (let ((world (current-world)))
      (if animation-tick
          (begin
            (unregister-tick~ world animation-tick)
            (set! animation-tick #f))
        (set! animation-tick animate)
        (register-tick~ world animation-tick))))
  
  
  (method (set-frame frame)
    (goto-time~ morphing frame))))
