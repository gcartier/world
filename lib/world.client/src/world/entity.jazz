;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Entities
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.entity jazz


(import (jazz.jml)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (world)
        (world.animation)
        (world.autoload)
        (world.camera)
        (world.draw)
        (world.dye)
        (world.dyes)
        (world.element)
        (world.foreign)
        (world.foreign.obj)
        (world.generate)
        (world.geometry)
        (world.material)
        (world.mesh)
        (world.model)
        (world.opengl)
        (world.parallelepiped)
        (world.quad)
        (world.renderer)
        (world.shader)
        (world.support)
        (world.syntax (phase syntax)))


;;;
;;;; Entity
;;;


(class Entity extends Element
  
  
  (property path      <object> initialize #f accessors generate)
  (property physical? <bool>   initialize #f accessors generate)
  (property animate?  <bool>   initialize #f accessors generate)
  (property animation <object> initialize #f accessors generate)
  (property renderer  <object> initialize #f accessors generate)
  
  
  (slot model          <Model+>     initialize #f getter generate)
  (slot model-update   <procedure+> initialize #f accessors generate)
  (slot meshes-mask    <object>     initialize #f accessors generate)
  (slot morphing       <Morphing+>  initialize #f getter generate)
  (slot animation-tick <object>     initialize #f getter generate)
  (slot camera         <Camera+>    initialize #f accessors generate)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set-color white-dye))
  
  
  (method override (destroy)
    (free-morphing)
    (nextmethod))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" path (present-vertex position)))))
  
  
  (method (cache-model)
    (or model
        (begin
          (set-model (resolve-model))
          model)))
  
  
  (method protected virtual (resolve-model)
    (let ((world (current-world)))
      (assert path)
      (find-model~ world path)))
  
  
  (method public (set-model mdl)
    (set! model mdl)
    (when model
      (when model-update
        (model-update self model))
      (reset-radiuses)
      (update-matrix)
      (when (and animate? (get-animations?) (find-animation~ model animation))
        (setup-morphing animation))))
  
  
  (method protected (entity-meshes model)
    (or meshes-mask (get-meshes~ model)))
  
  
  (method protected (entity-animate?)
    (and animate? (get-animations?) morphing))
  
  
  (method override (element-radiuses)
    (let ((model (cache-model)))
      (let ((bounds (get-bounds~ model)))
        (vertex* (vertex* (cuboid-radiuses bounds) scale) (get-scale~ model)))))
  
  
  (method override (effective-matrix&)
    (matrix-multiply& matrix (get-global-matrix~ model)))
  
  
  (method override (transformed-bounds)
    (let ((model (cache-model)))
      (let ((matrix (effective-matrix&))
            (bounds (get-bounds~ model)))
        (let ((left (cuboid-left bounds))
              (right (cuboid-right bounds))
              (bottom (cuboid-bottom bounds))
              (top (cuboid-top bounds))
              (back (cuboid-back bounds))
              (front (cuboid-front bounds)))
          (parallelepiped (matrix-transform-3x4 matrix (vertex left bottom back))
                          (matrix-transform-3x4 matrix (vertex left bottom front))
                          (matrix-transform-3x4 matrix (vertex left top back))
                          (matrix-transform-3x4 matrix (vertex left top front))
                          (matrix-transform-3x4 matrix (vertex right bottom back))
                          (matrix-transform-3x4 matrix (vertex right bottom front))
                          (matrix-transform-3x4 matrix (vertex right top back))
                          (matrix-transform-3x4 matrix (vertex right top front)))))))
  
  
  (method override (transformed-center)
    (let ((model (cache-model)))
      (let ((matrix (effective-matrix&))
            (center (get-center~ model)))
        (matrix-transform-3x4 matrix center))))
  
  
  (method override (transformed-radiuses)
    (vertex* (vertex* (cuboid-radiuses (get-bounds~ model)) scale)
             (get-scale~ model)))
  
  
  (method override (element-polygons)
    (if (not physical?)
        (nextmethod)
      (let ((model (cache-model)))
        (polygons-extract self (get-polygons~ model) matrix))))
  
  
  ;;;
  ;;;; Bounds
  ;;;
  
  
  (method public (for-each-bounding-quad sphere-matrix poly proc)
    (let ((bounds (transformed-bounds)))
      (iterate-parallelepiped-quads bounds sphere-matrix poly proc self)))

  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method override (draw-target dye)
    (draw-target-parallelepiped dye))
  
  
  (method override (draw-target-circle)
    (let ((model (cache-model)))
      (glLineWidth 2.)
      (glDisable GL_LIGHTING)
      (case (get-anchor~ model)
        ((center)
         (let ((r (/ (target-radius) 1.5))
               (y (- (get-y) (* (/ (cuboid-height (get-bounds~ model)) 2.) (get-scale-y)))))
           (gl-horizontal-circle (vertex (get-x) y (get-z)) r (dye->color purple-dye))))
        ((origin)
         (gl-horizontal-circle (vertex (get-x) (get-y) (get-z)) (/ (target-radius) 1.8) (dye->color purple-dye))))
      (glEnable GL_LIGHTING)
      (glLineWidth 1.)))
  
  
  (method (draw-target-parallelepiped dye)
    (gl-colorize-dye dye)
    (glLineWidth 2.)
    (glDisable GL_LIGHTING)
    (render-parallelepiped (transformed-bounds)
                           (lambda (proc)
                             (glBegin GL_LINE_LOOP)
                             (proc)
                             (glEnd)))
    (glEnable GL_LIGHTING)
    (glLineWidth 1.))
  
  
  (method override (target-moveable?)
    (not physical?))
  
  
  ;;;
  ;;;; Animation
  ;;;
  
  
  (method public (setup-morphing (name #f))
    (let ((world (current-world)))
      (when morphing
        (free-morphing))
      (change-morphing name)
      (when morphing
        (set! animation-tick animate)
        (register-tick~ world animation-tick))))
  
  
  (method public (change-morphing name (frame: frame #f))
    (let ((animation (require-animation~ (cache-model) name)))
      (when (has-bones?~ animation)
        (unless (and morphing (eq? animation (get-animation~ morphing)))
          (if (not morphing)
              (set! morphing (new Morphing animation))
            (change-animation~ morphing animation))
          (goto-time~ morphing (or frame 0.))))))
  
  
  (method public (transition-morphing name)
    (if (not morphing)
        (change-morphing name)
      (let ((animation (require-animation~ (cache-model) name))
            (transition (get-transition~ morphing)))
        (unless (or (and transition (eq? animation (get-animation~ transition)))
                    (and (not transition) (eq? animation (get-animation~ morphing))))
          (if (not (get-transition~ morphing))
              (set-transition~ morphing (new Morphing animation))
            (change-animation~ (get-transition~ morphing) animation))
          (set-transition-frame~ morphing 0.)))))
  
  
  (method public (free-morphing)
    (let ((world (current-world)))
      (when morphing
        (unregister-tick~ world animation-tick)
        (set! animation-tick #f)
        (set! morphing #f))))
  
  
  (method (animate elapse)
    (let ((world (current-world)))
      (when (and animate? (get-animations?) animation-tick morphing)
        (when (in-frustum?~ (or camera (get-eye~ world)) position)
          (animate~ morphing elapse)
          (when (transition-done?~ morphing)
            (let ((new-morphing (get-transition~ morphing)))
              (set-transition~ morphing #f)
              (set-transition-frame~ morphing #f)
              (set! morphing new-morphing)
              (goto-time~ morphing 0.)))))))
  
  
  (method (toggle-animated)
    (let ((world (current-world)))
      (if animation-tick
          (begin
            (unregister-tick~ world animation-tick)
            (set! animation-tick #f))
        (set! animation-tick animate)
        (register-tick~ world animation-tick))))
  
  
  (method (set-frame frame)
    (goto-time~ morphing frame))))
