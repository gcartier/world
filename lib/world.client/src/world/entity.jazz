;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Entities
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.entity jazz


(import (jazz.jml)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (world)
        (world.animation)
        (world.autoload)
        (world.camera)
        (world.draw)
        (world.dye)
        (world.dyes)
        (world.element)
        (world.foreign)
        (world.foreign.obj)
        (world.generate)
        (world.geometry)
        (world.material)
        (world.mesh)
        (world.model)
        (world.opengl)
        (world.quad)
        (world.shader)
        (world.syntax (phase syntax)))


(definition animations?
  #t)

(definition public (get-animations?)
  animations?)

(definition public (set-animations? flag)
  (set! animations? flag))


;;;
;;;; Entity
;;;


(class Entity extends Element
  
  
  (property path      <object> initialize #f accessors generate)
  (property animate?  <bool>   initialize #f accessors generate)
  (property animation <object> initialize #f accessors generate)
  (property program   <object> initialize #f accessors generate)
  
  
  (slot model          <Model+>     initialize #f getter generate)
  (slot model-update   <procedure+> initialize #f accessors generate)
  (slot material       <Material+>  initialize #f accessors generate)
  (slot morphing       <Morphing+>  initialize #f getter generate)
  (slot animation-tick <object>     initialize #f getter generate)
  (slot camera         <Camera+>    initialize #f accessors generate)
  
  
  (method override (prepare rest)
    (nextmethod rest)
    (set-color white-dye))
  
  
  (method override (destroy)
    (free-morphing)
    (nextmethod))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" path (present-vertex position)))))
  
  
  (method (cache-model)
    (or model
        (begin
          (set-model (resolve-model))
          model)))
  
  
  (method protected virtual (resolve-model)
    (let ((world (current-world)))
      (find-model~ world path)))
  
  
  (method public (set-model mdl)
    (set! model mdl)
    (when model-update
      (model-update self mdl))
    (reset-radiuses)
    (update-matrix)
    (when (and animate? animations? (find-animation~ model animation))
      (setup-morphing animation)))
  
  
  (method override (element-radiuses)
    (let ((model (cache-model)))
      (if (not model)
          (nextmethod)
        (let ((bounds (get-bounds~ model)))
          (vertex* (cuboid-radiuses bounds) scales)))))
  
  
  (method override (update-matrix)
    (matrix-multiply! matrix (make-translation-matrix& (get-x) (get-y) (get-z)) (matrix-multiply& (let ((model-matrix (and model (get-matrix~ model))))
                                                                                                    (if model-matrix
                                                                                                        (matrix-multiply& model-matrix (make-lookat-matrix& lookat))
                                                                                                      (make-lookat-matrix& lookat)))
                                                                                                  (make-scaling-matrix& (vertex-x scales) (vertex-y scales) (vertex-z scales)))))
  
  
  ;; a try for testing
  (method override (transformed-bounds)
    (let ((model (cache-model)))
      (if (not model)
          (nextmethod)
        (let ((bounds (get-bounds~ model)))
          ;; until unification
          (if (not bounds)
              (nextmethod)
            (let ((left (cuboid-left bounds))
                  (right (cuboid-right bounds))
                  (bottom (cuboid-bottom bounds))
                  (top (cuboid-top bounds))
                  (back (cuboid-back bounds))
                  (front (cuboid-front bounds)))
              (let ((v1 (matrix-transform-3x4 matrix (vertex left bottom back)))
                    (v2 (matrix-transform-3x4 matrix (vertex left bottom front)))
                    (v3 (matrix-transform-3x4 matrix (vertex left top back)))
                    (v4 (matrix-transform-3x4 matrix (vertex left top front)))
                    (v5 (matrix-transform-3x4 matrix (vertex right bottom back)))
                    (v6 (matrix-transform-3x4 matrix (vertex right bottom front)))
                    (v7 (matrix-transform-3x4 matrix (vertex right top back)))
                    (v8 (matrix-transform-3x4 matrix (vertex right top front))))
                (define (bound proc accessor)
                  (apply proc (list (accessor v1)
                                    (accessor v2)
                                    (accessor v3)
                                    (accessor v4)
                                    (accessor v5)
                                    (accessor v6)
                                    (accessor v7)
                                    (accessor v8))))
                
                (cuboid (bound min vertex-x)
                        (bound min vertex-y)
                        (bound min vertex-z)
                        (bound max vertex-x)
                        (bound max vertex-y)
                        (bound max vertex-z)))))))))
  
  
  ;;;
  ;;;; Bounds
  ;;;
  
  
  (method public (for-each-bounding-quad sphere-matrix poly proc)
    (let ((bounds (make-cuboid&)))
      (get-bounds! bounds)
      (iterate-cuboid-quads bounds sphere-matrix poly proc self)))
  
  
  ;;;
  ;;;; Material
  ;;;
  
  
  (method public (effective-material)
    (or material (get-material~ (get-mesh~ (cache-model)))))

  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method override (draw-3d-textured)
    (let ((model (cache-model)))
      (if (not model)
          (nextmethod)
        (draw-entity))))
  
  
  (method override (draw-3d)
    (let ((model (cache-model)))
      (if (not model)
          (nextmethod)
        (draw-entity))))
  
  
  (method (draw-entity (mode 'transparent))
    (let ((world (current-world)))
      (let ((mesh (get-mesh~ (cache-model)))
            (program (find-mesh-program~ world (entity-program)))
            (material (effective-material)))
        (use~ program)
        (bind-render-uniforms~ program material matrix)
        (entity-bind-uniforms program mesh matrix)
        (case mode
          ;; opaque
          ((opaque)
           (glDisable GL_BLEND)
           (glDisable GL_ALPHA_TEST)
           (draw-mesh~ program mesh))
          
          ;; transparent
          ((transparent)
           (glDisable GL_BLEND)
           (glBlendFunc GL_ONE GL_ONE_MINUS_SRC_ALPHA)
           (glEnable GL_ALPHA_TEST)
           (glAlphaFunc GL_GREATER .7)
           (draw-mesh~ program mesh)
           (glDisable GL_ALPHA_TEST)
           (glDisable GL_BLEND))
          
          ;; alpha-blend
          ((alpha-blend)
           (glEnable GL_BLEND)
           (glBlendFunc GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA)
           (glDisable GL_ALPHA_TEST)
           (draw-mesh~ program mesh)
           (glDisable GL_BLEND))
          
          ;; additive
          ((additive)
           (glEnable GL_BLEND)
           (glBlendFunc GL_SRC_COLOR GL_ONE)
           (draw-mesh~ program mesh)
           (glDisable GL_BLEND))
          
          ;; additive-alpha
          ((additive-alpha)
           (glEnable GL_BLEND)
           (glBlendFunc GL_SRC_ALPHA GL_ONE)
           (draw-mesh~ program mesh)
           (glDisable GL_BLEND))
          
          ;; modulate
          ((modulate)
           (glEnable GL_BLEND)
           (glBlendFunc GL_DST_COLOR GL_SRC_COLOR)
           (draw-mesh~ program mesh)
           (glDisable GL_BLEND))
          
          ;; vegetation
          ((vegetation)
           (let ((texture (get-texture~ material)))
             ;; alpha test
             (glBindTexture GL_TEXTURE_2D (get-id~ texture))
             (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_MAG_FILTER GL_LINEAR)
             (glEnable GL_BLEND)
             (glBlendFunc GL_ONE GL_ONE_MINUS_SRC_ALPHA)
             (glEnable GL_ALPHA_TEST)
             (glAlphaFunc GL_GREATER .7)
             (draw-mesh~ program mesh)
             (glDisable GL_ALPHA_TEST)
             ;; blend - doesn't seem to work for vegetation
             (when #f
               (glEnable GL_BLEND)
               (glBlendFunc GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA)
               (glDepthMask GL_FALSE)
               (draw-mesh~ program mesh)
               (glDepthMask GL_TRUE))
             (glBindTexture GL_TEXTURE_2D 0)))
          
          ;; character
          ((character)
           (let ((was-cull-face? (glGetBoolean* GL_CULL_FACE)))
             (glEnable GL_CULL_FACE)
             (glCullFace GL_FRONT)
             (glEnable GL_BLEND)
             (glBlendFunc GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA)
             (glEnable GL_ALPHA_TEST)
             (glAlphaFunc GL_GEQUAL .1)
             (draw-mesh~ program mesh)
             (glDisable GL_ALPHA_TEST)
             (glCullFace GL_BACK)
             (when (not was-cull-face?)
               (glDisable GL_CULL_FACE)))))
        (unbind-uniforms~ program)
        (unbind-render-uniforms~ program)
        (unuse~ program))))
  
  
  (method protected virtual (entity-program)
    (if (and animate? animations? morphing)
        'skeletal-phong
      (or program 'dynamic-phong)))
  
  
  (method protected virtual (entity-bind-uniforms program mesh matrix)
    (if (and animate? animations? morphing)
        (let ((bone-matrices (get-bone-matrices~ morphing)))
          (assert bone-matrices)
          (bind-uniforms~ program mesh matrix bone-matrices))
      (bind-uniforms~ program mesh matrix #f)))
  
  
  (method override (draw-target dye)
    (let ((model (cache-model)))
      (if (not model)
          (nextmethod dye)
        (let ((bounds (get-bounds~ model)))
          (let ((left (cuboid-left bounds))
                (right (cuboid-right bounds))
                (bottom (cuboid-bottom bounds))
                (top (cuboid-top bounds))
                (back (cuboid-back bounds))
                (front (cuboid-front bounds)))
            (gl-colorize-dye dye)
            (glLineWidth 2.)
            (glDisable GL_LIGHTING)
            (render-parallelepiped (matrix-transform-3x4 matrix (vertex left bottom back))
                                   (matrix-transform-3x4 matrix (vertex left bottom front))
                                   (matrix-transform-3x4 matrix (vertex left top back))
                                   (matrix-transform-3x4 matrix (vertex left top front))
                                   (matrix-transform-3x4 matrix (vertex right bottom back))
                                   (matrix-transform-3x4 matrix (vertex right bottom front))
                                   (matrix-transform-3x4 matrix (vertex right top back))
                                   (matrix-transform-3x4 matrix (vertex right top front))
              (lambda (proc)
                (glBegin GL_LINE_LOOP)
                (proc)
                (glEnd)))
            (glEnable GL_LIGHTING)
            (glLineWidth 1.))))))
  
  
  (method override (draw-target-circle)
    (let ((model (cache-model)))
      (if (not model)
          (nextmethod)
        (glLineWidth 2.)
        (glDisable GL_LIGHTING)
        (case (get-anchor~ model)
          ((center)
           (let ((r (/ (get-radius) 1.5))
                 (y (- (get-y) (* (/ (cuboid-height (get-bounds~ model)) 2.) (get-scale-y)))))
             (gl-horizontal-circle (vertex (get-x) y (get-z)) r (dye->color purple-dye))))
          ((bottom)
           (gl-horizontal-circle (vertex (get-x) (get-y) (get-z)) (/ (get-radius) 1.8) (dye->color purple-dye))))
        (glEnable GL_LIGHTING)
        (glLineWidth 1.))))
    
  
  ;;;
  ;;;; Animation
  ;;;
  
  
  (method public (setup-morphing (name #f))
    (let ((world (current-world)))
      (when (not morphing)
        (change-morphing name)
        (when morphing
          (set! animation-tick animate)
          (register-tick~ world animation-tick)))))
  
  
  (method public (change-morphing name (frame: frame #f))
    (let ((animation (require-animation~ (cache-model) name)))
      (when (has-bones?~ animation)
        (unless (and morphing (eq? animation (get-animation~ morphing)))
          (if (not morphing)
              (set! morphing (new Morphing animation))
            (change-animation~ morphing animation))
          (goto-time~ morphing (or frame 0.))))))
  
  
  (method public (transition-morphing name)
    (if (not morphing)
        (change-morphing name)
      (let ((animation (require-animation~ (cache-model) name))
            (transition (get-transition~ morphing)))
        (unless (or (and transition (eq? animation (get-animation~ transition)))
                    (and (not transition) (eq? animation (get-animation~ morphing))))
          (if (not (get-transition~ morphing))
              (set-transition~ morphing (new Morphing animation))
            (change-animation~ (get-transition~ morphing) animation))
          (set-transition-frame~ morphing 0.)))))
  
  
  (method public (free-morphing)
    (let ((world (current-world)))
      (when morphing
        (unregister-tick~ world animation-tick)
        (set! animation-tick #f)
        (set! morphing #f))))
  
  
  (method (animate elapse)
    (let ((world (current-world)))
      (when (and animate? animations? animation-tick morphing)
        (when (in-frustum?~ (or camera (get-eye~ world)) position)
          (animate~ morphing elapse)
          (when (transition-done?~ morphing)
            (let ((new-morphing (get-transition~ morphing)))
              (set-transition~ morphing #f)
              (set-transition-frame~ morphing #f)
              (set! morphing new-morphing)
              (goto-time~ morphing 0.)))))))
  
  
  (method (toggle-animated)
    (let ((world (current-world)))
      (if animation-tick
          (begin
            (unregister-tick~ world animation-tick)
            (set! animation-tick #f))
        (set! animation-tick animate)
        (register-tick~ world animation-tick))))
  
  
  (method (set-frame frame)
    (goto-time~ morphing frame))))
