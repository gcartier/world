;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Texture
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.texture jazz


(import (jazz.cairo)
        (jazz.graphic)
        (jazz.io)
        (jazz.opengl.glew)
        (world)
        (world.context)
        (world.external.targa)
        (world.foreign))


;;;
;;;; Image
;;;


(class Image-Texture extends Object
  
  
  (slot width      <fx>      getter generate)
  (slot height     <fx>      getter generate)
  (slot depth      <fx+>     getter generate)
  (slot data       <object>  getter generate)
  (slot target     <object>  getter generate)
  (slot id         <object>  getter generate)
  (slot min-filter <object>  getter generate)
  (slot mag-filter <object>  getter generate)
  (slot wrap       <object>  getter generate)
  (slot mipmap?    <bool>    getter generate)
  (slot metadata   <object>  getter generate)
  (slot file       <object>  accessors generate)
  
  
  (method override (initialize self width height (data: data #f) (min-filter: min-filter #f) (mag-filter: mag-filter #f) (wrap: wrap #f) (mipmap?: mipmap? #f) (metadata: metadata #f) (file: file #f))
    (set! self.width width)
    (set! self.height height)
    (set! self.depth #f)
    (set! self.data data)
    (set! self.target #f)
    (set! self.id (gl-generate-texture))
    (set! self.min-filter min-filter)
    (set! self.mag-filter mag-filter)
    (set! self.wrap wrap)
    (set! self.mipmap? mipmap?)
    (set! self.metadata metadata)
    (set! self.file file))
  
  
  (method override (destroy self)
    (glDeleteTextures* id)
    (nextmethod self))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{s}x{s}" width height))))
  
  
  (method (with-texture self thunk)
    (glBindTexture target id)
    (glTexParameteri target GL_TEXTURE_MIN_FILTER (or min-filter (if mipmap? GL_LINEAR_MIPMAP_LINEAR GL_LINEAR)))
    (glTexParameteri target GL_TEXTURE_MAG_FILTER (or mag-filter GL_LINEAR))
    (glTexParameteri target GL_TEXTURE_WRAP_S (or wrap GL_REPEAT))
    (glTexParameteri target GL_TEXTURE_WRAP_T (or wrap GL_REPEAT))
    (thunk)
    (when mipmap?
      (glGenerateMipmap target))
    (glBindTexture target 0)
    (gl-check-error))
  
  
  (method public (map-texture self (repeat?: repeat? #t))
    (set! target GL_TEXTURE_2D)
    (with-texture self
      (lambda ()
        (glTexImage2D target
                      0
                      GL_RGBA
                      width
                      height
                      0
                      GL_BGRA
                      GL_UNSIGNED_BYTE
                      data))))
  
  
  (method public (map-texture-array self textures (repeat?: repeat? #t))
    (set! target GL_TEXTURE_2D_ARRAY_EXT)
    (with-texture self
      (lambda ()
        (let ((count (length textures)))
          (glTexImage3D target 0 GL_RGBA width height count 0 GL_BGRA GL_UNSIGNED_BYTE #f)
          (for-each (lambda (texture)
                      (bind (image image-width image-height depth) texture
                        (let ((width (if repeat? width image-width))
                              (height (if repeat? height image-height))
                              (data (if (u8vector? image)
                                        (still-u8vector-body image)
                                      (cairo_image_surface_get_data (get-handle image)))))
                          (glTexSubImage3D target 0 0 0 depth width height 1 GL_BGRA GL_UNSIGNED_BYTE data))))
                    textures)
          (set! depth count)))))
  
  
  (method public (map-texture-cube self front back up down right left)
    (define (teximage target image)
      (let ((data (if (u8vector? image)
                      (still-u8vector-body image)
                    (cairo_image_surface_get_data image))))
        (glTexImage2D target
                      0
                      GL_RGBA
                      width
                      height
                      0
                      GL_BGRA
                      GL_UNSIGNED_BYTE
                      data)))
    
    (set! target GL_TEXTURE_CUBE_MAP)
    (with-texture self
      (lambda ()
        (glTexParameteri target GL_TEXTURE_WRAP_S GL_CLAMP_TO_EDGE)
        (glTexParameteri target GL_TEXTURE_WRAP_T GL_CLAMP_TO_EDGE)
        (glTexParameteri target GL_TEXTURE_WRAP_R GL_CLAMP_TO_EDGE)
        (teximage GL_TEXTURE_CUBE_MAP_POSITIVE_X front)
        (teximage GL_TEXTURE_CUBE_MAP_NEGATIVE_X back)
        (teximage GL_TEXTURE_CUBE_MAP_POSITIVE_Y up)
        (teximage GL_TEXTURE_CUBE_MAP_NEGATIVE_Y down)
        (teximage GL_TEXTURE_CUBE_MAP_POSITIVE_Z right)
        (teximage GL_TEXTURE_CUBE_MAP_NEGATIVE_Z left)))))


;;;
;;;; Cairo
;;;


(class Cairo-Texture extends Image-Texture
  
  
  (slot surface <Surface> getter generate)
  
  
  (method override (initialize self width height . rest)
    (bind-keywords ((surface #f) . others) rest
      (apply nextmethod self width height others)
      (set! self.surface (or surface (new Image-Surface (new Dimension width height))))
      (set! self.data (cairo_image_surface_get_data (get-handle self.surface)))))
  
  
  (method override (destroy self)
    (close surface)
    (nextmethod self)))


(definition public (make-cairo-texture width height . rest)
  (apply new Cairo-Texture width height rest))


;;;
;;;; File
;;;


(definition public (make-file-texture file (min-filter: min-filter #f) (mag-filter: mag-filter #f) (wrap: wrap #f) (mipmap?: mipmap? #t) (metadata: metadata #f))
  (let ((ext (get-extension file)))
    (cond ((extension=? ext "png")
           (make-png-texture file min-filter: min-filter mag-filter: mag-filter wrap: wrap mipmap?: mipmap? metadata: metadata))
          ((extension=? ext "tga")
           (make-tga-texture file min-filter: min-filter mag-filter: mag-filter wrap: wrap mipmap?: mipmap? metadata: metadata))
          (else
           (error "Unsupported texture format: {a}" ext)))))


(definition public (make-file-cairo-texture file (min-filter: min-filter #f) (mag-filter: mag-filter #f) (wrap: wrap #f) (mipmap?: mipmap? #t) (metadata: metadata #f))
  (let ((ext (get-extension file)))
    (cond ((extension=? ext "png")
           (make-png-cairo-texture file min-filter: min-filter mag-filter: mag-filter wrap: wrap mipmap?: mipmap? metadata: metadata))
          ((extension=? ext "tga")
           (make-tga-cairo-texture file min-filter: min-filter mag-filter: mag-filter wrap: wrap mipmap?: mipmap? metadata: metadata))
          (else
           (error "Unsupported texture format: {a}" ext)))))


(definition public (cairo-surface-from-file file)
  (let ((ext (get-extension file)))
    (cond ((extension=? ext "png")
           (cairo-surface-from-png file))
          ((extension=? ext "tga")
           (cairo-surface-from-tga file))
          (else
           (error "Unsupported texture format: {a}" ext)))))


;;;
;;;; PNG
;;;


(definition protected (make-png-texture file (min-filter: min-filter #f) (mag-filter: mag-filter #f) (wrap: wrap #f) (mipmap?: mipmap? #t) (metadata: metadata #f))
  (assert (exists? file))
  (bind-values (width height surf) (cairo-surface-from-png file)
    (prog1 (let ((data (cairo_image_surface_get_data surf)))
             (let ((ct (new Image-Texture width height data: data min-filter: min-filter mag-filter: mag-filter wrap: wrap mipmap?: mipmap? metadata: metadata file: file)))
               (map-texture ct)
               ct))
      (cairo_surface_destroy surf))))


(definition protected (make-png-cairo-texture file (min-filter: min-filter #f) (mag-filter: mag-filter #f) (wrap: wrap #f) (mipmap?: mipmap? #t) (metadata: metadata #f))
  (assert (exists? file))
  (bind-values (width height surf) (cairo-surface-from-png file)
    (let ((surface (new Surface surf)))
      (let ((ct (new Cairo-Texture width height surface: surface min-filter: min-filter mag-filter: mag-filter wrap: wrap mipmap?: mipmap? metadata: metadata file: file)))
        (map-texture ct)
        ct))))


(definition protected (cairo-surface-from-png file)
  (let ((surf (cairo_image_surface_create_from_png (parse file))))
    (let ((width (cairo_image_surface_get_width surf))
          (height (cairo_image_surface_get_height surf)))
      (values width height surf))))


;;;
;;;; TGA
;;;


(definition protected (make-tga-texture file (min-filter: min-filter #f) (mag-filter: mag-filter #f) (wrap: wrap #f) (mipmap?: mipmap? #t) (metadata: metadata #f))
  (assert (exists? file))
  (bind-values (width height bytes/pixel data) (load-tga file)
    (let ((ct (new Image-Texture width height data: data min-filter: min-filter mag-filter: mag-filter wrap: wrap mipmap?: mipmap? metadata: metadata file: file)))
      (map-texture ct)
      ct)))


(definition protected (make-tga-cairo-texture file (min-filter: min-filter #f) (mag-filter: mag-filter #f) (wrap: wrap #f) (mipmap?: mipmap? #t) (metadata: metadata #f))
  (assert (exists? file))
  (bind-values (width height surf) (cairo-surface-from-tga file)
    (let ((surface (new Surface surf)))
      (let ((ct (new Cairo-Texture width height surface: surface min-filter: min-filter mag-filter: mag-filter wrap: wrap mipmap?: mipmap? metadata: metadata file: file)))
        (map-texture ct)
        ct))))


(definition protected (cairo-surface-from-tga file)
  (bind-values (width height bytes/pixel data) (load-tga file)
    (let ((format CAIRO_FORMAT_ARGB32))
      (let ((stride (cairo_format_stride_for_width format width)))
        (assert (= stride (* width bytes/pixel)))
        (values width height (cairo_image_surface_create_for_data data format width height stride))))))


;;;
;;;; UV
;;;


(constant inline uv/left   0)
(constant inline uv/top    1)
(constant inline uv/right  2)
(constant inline uv/bottom 3)


(definition public inline (uv left <fl> top <fl> right <fl> bottom <fl> depth <fl>) <uv>
  (f32vector left top right bottom depth))


(definition public inline (allocate-uv left <fl> top <fl> right <fl> bottom <fl> depth <fl>) <uv>
  (f32vector left top right bottom depth))


(definition public inline (make-uv) <uv>
  (f32vector 0. 0. 0. 0. 0.))


(definition public (copy-uv uv <uv>) <uv>
  (let ((copy (make-uv)))
    (uv-copy! copy uv)
    copy))


(definition public (uv-rect uv <uv> l <fl> t <fl> r <fl> b <fl>) <uv>
  (let ((left (uv-left uv))
        (top (uv-top uv)))
    (let ((width (- (uv-right uv) left))
          (height (- (uv-bottom uv) top)))
      (allocate-uv (+ left (* l width)) (+ top (* t height)) (+ left (* r width)) (+ top (* b height)) (uv-depth uv)))))
        

(definition public inline (uv-left uv <uv>) <fl>
  (f32vector-ref uv 0))

(definition public inline (uv-top uv <uv>) <fl>
  (f32vector-ref uv 1))

(definition public inline (uv-right uv <uv>) <fl>
  (f32vector-ref uv 2))

(definition public inline (uv-bottom uv <uv>) <fl>
  (f32vector-ref uv 3))

(definition public inline (uv-depth uv <uv>) <fl>
  (f32vector-ref uv 4))


(definition public inline (uv-left-set! uv <uv> left <fl>) <void>
  (f32vector-set! uv 0 left))

(definition public inline (uv-top-set! uv <uv> top <fl>) <void>
  (f32vector-set! uv 1 top))

(definition public inline (uv-right-set! uv <uv> right <fl>) <void>
  (f32vector-set! uv 2 right))

(definition public inline (uv-bottom-set! uv <uv> bottom <fl>) <void>
  (f32vector-set! uv 3 bottom))

(definition public inline (uv-depth-set! uv <uv> depth <fl>) <void>
  (f32vector-set! uv 4 depth))


(definition public (uv=? c1 <uv> c2 <uv>) <bool>
  (and (= (uv-left c1) (uv-left c2))
       (= (uv-top c1) (uv-top c2))
       (= (uv-right c1) (uv-right c2))
       (= (uv-bottom c1) (uv-bottom c2))
       (= (uv-depth c1) (uv-depth c2))))


(definition public (uv! uv <uv> left <fl> top <fl> right <fl> bottom <fl> depth <fl>) <void>
  (uv-left-set! uv left)
  (uv-top-set! uv top)
  (uv-right-set! uv right)
  (uv-bottom-set! uv bottom)
  (uv-depth-set! uv depth))


(definition public (uv-copy! dst <uv> src <uv>) <void>
  (uv-left-set! dst (uv-left src))
  (uv-top-set! dst (uv-top src))
  (uv-right-set! dst (uv-right src))
  (uv-bottom-set! dst (uv-bottom src))
  (uv-depth-set! dst (uv-depth src)))


;;;
;;;; Coordinates
;;;


(definition public (image-coordinates image)
  (let ((world (current-world)))
    (image-rect (get-block-atlas world) image))))
