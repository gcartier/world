;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Texture
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is WorldScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2014
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See http://github.com/gcartier/world for details.


(module world.texture jazz


(import (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.platform.cairo)
        (world)
        (world.autoload)
        (world.external.targa)
        (world.foreign)
        (world.support)
        (world.syntax (phase syntax)))


;;;
;;;; Image
;;;


(class Image-Texture extends Object
  
  
  (slot width      <fx>      getter generate)
  (slot height     <fx>      getter generate)
  (slot depth      <fx+>     getter generate)
  (slot data       <object>  getter generate)
  (slot id         <object>  getter generate)
  (slot min-filter <object>  getter generate)
  (slot mag-filter <object>  getter generate)
  (slot wrap       <object>  getter generate)
  (slot parameters <object>  getter generate)
  (slot mipmap?    <bool>    getter generate)
  (slot metadata   <object>  getter generate)
  (slot file       <object>  accessors generate)
  
  
  (method override (initialize width height (data: data #f) (min-filter: min-filter #f) (mag-filter: mag-filter #f) (wrap: wrap #f) (parameters: parameters #f) (mipmap?: mipmap? #f) (metadata: metadata #f) (file: file #f))
    (set! width~self width)
    (set! height~self height)
    (set! depth~self #f)
    (set! data~self data)
    (set! id~self (gl-generate-texture))
    (set! min-filter~self min-filter)
    (set! mag-filter~self mag-filter)
    (set! wrap~self wrap)
    (set! parameters~self parameters)
    (set! mipmap?~self mipmap?)
    (set! metadata~self metadata)
    (set! file~self file))
  
  
  (method override (destroy)
    (glDeleteTextures* id)
    (nextmethod))
  
  
  (method (texture-parameters target)
    (glTexParameteri target GL_TEXTURE_MIN_FILTER (or min-filter (if mipmap? GL_LINEAR_MIPMAP_LINEAR GL_LINEAR)))
    (glTexParameteri target GL_TEXTURE_MAG_FILTER (or mag-filter GL_LINEAR))
    (glTexParameteri target GL_TEXTURE_WRAP_S (or wrap GL_REPEAT))
    (glTexParameteri target GL_TEXTURE_WRAP_T (or wrap GL_REPEAT))
    (when (and mipmap? (not (get-framebuffer-objects?)))
      (glTexParameteri target GL_GENERATE_MIPMAP GL_TRUE))
    (when parameters
      (parameters)))
  
  
  (method (texture-mipmap target)
    (when (and mipmap? (get-framebuffer-objects?))
      (glGenerateMipmapEXT target)))
  
  
  (method (with-texture target thunk)
    (glBindTexture target id)
    (texture-parameters target)
    (thunk)
    (texture-mipmap target)
    (glBindTexture target 0)
    (gl-check-error))
  
  
  (method public (map-texture (repeat?: repeat? #t))
    (let ((target GL_TEXTURE_2D))
      (with-texture target
        (lambda ()
          (glTexImage2D target
                        0
                        GL_RGBA
                        width
                        height
                        0
                        GL_BGRA
                        GL_UNSIGNED_BYTE
                        data)))))
  
  
  (method public (map-texture-array textures (repeat?: repeat? #t))
    (let ((target GL_TEXTURE_2D_ARRAY_EXT))
      (with-texture target
        (lambda ()
          (let ((count (length textures)))
            (glTexImage3D target 0 GL_RGBA width height count 0 GL_BGRA GL_UNSIGNED_BYTE #f)
            (for-each (lambda (texture)
                        (bind (surface image-width image-height depth) texture
                          (let ((width (if repeat? width image-width))
                                (height (if repeat? height image-height))
                                (data (cairo_image_surface_get_data (get-handle~ surface))))
                            (glTexSubImage3D target 0 0 0 depth width height 1 GL_BGRA GL_UNSIGNED_BYTE data))))
                      textures)
            (set! depth count)))))))


;;;
;;;; Cairo
;;;


(class Cairo-Texture extends Image-Texture
  
  
  (slot surface <Surface> getter generate)
  
  
  (method override (initialize width height . rest)
    (bind-keywords ((surface #f) . others) rest
      (apply nextmethod width height others)
      (set! surface~self (or surface (new Surface (cairo_image_surface_create CAIRO_FORMAT_ARGB32 width height))))
      (set! data~self (cairo_image_surface_get_data (get-handle~ surface~self)))))
  
  
  (method override (destroy)
    (close~ surface)
    (nextmethod)))


(definition public (make-cairo-texture width height . rest)
  (apply new Cairo-Texture width height rest))


;;;
;;;; File
;;;


(definition public (make-file-texture file (min-filter: min-filter #f) (mag-filter: mag-filter #f) (parameters: parameters #f) (mipmap?: mipmap? #t) (metadata: metadata #f))
  (let ((ext (get-extension~ file)))
    (cond ((extension=? ext "png")
           (make-png-texture file min-filter: min-filter mag-filter: mag-filter parameters: parameters mipmap?: mipmap? metadata: metadata))
          ((extension=? ext "tga")
           (make-tga-texture file min-filter: min-filter mag-filter: mag-filter parameters: parameters mipmap?: mipmap? metadata: metadata))
          (else
           (error "Unsupported texture format: {a}" ext)))))


(definition public (make-file-cairo-texture file (min-filter: min-filter #f) (mag-filter: mag-filter #f) (parameters: parameters #f) (mipmap?: mipmap? #t) (metadata: metadata #f))
  (let ((ext (get-extension~ file)))
    (cond ((extension=? ext "png")
           (make-png-cairo-texture file min-filter: min-filter mag-filter: mag-filter parameters: parameters mipmap?: mipmap? metadata: metadata))
          ((extension=? ext "tga")
           (make-tga-cairo-texture file min-filter: min-filter mag-filter: mag-filter parameters: parameters mipmap?: mipmap? metadata: metadata))
          (else
           (error "Unsupported texture format: {a}" ext)))))


(definition public (cairo-surface-from-file file)
  (let ((ext (get-extension~ file)))
    (cond ((extension=? ext "png")
           (cairo-surface-from-png file))
          ((extension=? ext "tga")
           (cairo-surface-from-tga file))
          (else
           (error "Unsupported texture format: {a}" ext)))))


;;;
;;;; PNG
;;;


(definition protected (make-png-texture file (min-filter: min-filter #f) (mag-filter: mag-filter #f) (parameters: parameters #f) (mipmap?: mipmap? #t) (metadata: metadata #f))
  (assert (exists?~ file))
  (receive (width height surf) (cairo-surface-from-png file)
    (prog1 (let ((data (cairo_image_surface_get_data surf)))
             (let ((ct (new Image-Texture width height data: data min-filter: min-filter mag-filter: mag-filter parameters: parameters mipmap?: mipmap? metadata: metadata file: file)))
               (map-texture~ ct)
               ct))
      (cairo_surface_destroy surf))))


(definition protected (make-png-cairo-texture file (min-filter: min-filter #f) (mag-filter: mag-filter #f) (parameters: parameters #f) (mipmap?: mipmap? #t) (metadata: metadata #f))
  (assert (exists?~ file))
  (receive (width height surf) (cairo-surface-from-png file)
    (let ((surface (new Surface surf)))
      (let ((ct (new Cairo-Texture width height surface: surface min-filter: min-filter mag-filter: mag-filter parameters: parameters mipmap?: mipmap? metadata: metadata file: file)))
        (map-texture~ ct)
        ct))))


(definition protected (cairo-surface-from-png file)
  (let ((surf (cairo_image_surface_create_from_png (parse~ file))))
    (let ((width (cairo_image_surface_get_width surf))
          (height (cairo_image_surface_get_height surf)))
      (values width height surf))))


;;;
;;;; TGA
;;;


(definition protected (make-tga-texture file (min-filter: min-filter #f) (mag-filter: mag-filter #f) (parameters: parameters #f) (mipmap?: mipmap? #t) (metadata: metadata #f))
  (assert (exists?~ file))
  (receive (width height bytes/pixel data) (load-tga file)
    (let ((ct (new Image-Texture width height data: data min-filter: min-filter mag-filter: mag-filter parameters: parameters mipmap?: mipmap? metadata: metadata file: file)))
      (map-texture~ ct)
      ct)))


(definition protected (make-tga-cairo-texture file (min-filter: min-filter #f) (mag-filter: mag-filter #f) (parameters: parameters #f) (mipmap?: mipmap? #t) (metadata: metadata #f))
  (assert (exists?~ file))
  (receive (width height surf) (cairo-surface-from-tga file)
    (let ((surface (new Surface surf)))
      (let ((ct (new Cairo-Texture width height surface: surface min-filter: min-filter mag-filter: mag-filter parameters: parameters mipmap?: mipmap? metadata: metadata file: file)))
        (map-texture~ ct)
        ct))))


(definition protected (cairo-surface-from-tga file)
  (receive (width height bytes/pixel data) (load-tga file)
    (let ((format CAIRO_FORMAT_ARGB32))
      (let ((stride (cairo_format_stride_for_width format width)))
        (assert (= stride (* width bytes/pixel)))
        (values width height (cairo_image_surface_create_for_data data format width height stride))))))


;;;
;;;; UV
;;;


(constant inline uv/left   0)
(constant inline uv/top    1)
(constant inline uv/right  2)
(constant inline uv/bottom 3)


(definition public inline (uv left <fl> top <fl> right <fl> bottom <fl> depth <fl>) <f32vector>
  (f32vector left top right bottom depth))


(definition public inline (make-uv) <f32vector>
  (make-f32vector 5))


(definition public (copy-uv uv <f32vector>) <f32vector>
  (let ((copy (make-uv)))
    (uv-copy! copy uv)
    copy))


(definition public inline (uv-left uv <f32vector>) <fl>
  (f32vector-ref uv 0))

(definition public inline (uv-top uv <f32vector>) <fl>
  (f32vector-ref uv 1))

(definition public inline (uv-right uv <f32vector>) <fl>
  (f32vector-ref uv 2))

(definition public inline (uv-bottom uv <f32vector>) <fl>
  (f32vector-ref uv 3))

(definition public inline (uv-depth uv <f32vector>) <fl>
  (f32vector-ref uv 4))


(definition public inline (uv-left-set! uv <f32vector> left <fl>) <void>
  (f32vector-set! uv 0 left))

(definition public inline (uv-top-set! uv <f32vector> top <fl>) <void>
  (f32vector-set! uv 1 top))

(definition public inline (uv-right-set! uv <f32vector> right <fl>) <void>
  (f32vector-set! uv 2 right))

(definition public inline (uv-bottom-set! uv <f32vector> bottom <fl>) <void>
  (f32vector-set! uv 3 bottom))

(definition public inline (uv-depth-set! uv <f32vector> depth <fl>) <void>
  (f32vector-set! uv 4 depth))


(definition public (uv=? c1 <f32vector> c2 <f32vector>) <bool>
  (and (= (uv-left c1) (uv-left c2))
       (= (uv-top c1) (uv-top c2))
       (= (uv-right c1) (uv-right c2))
       (= (uv-bottom c1) (uv-bottom c2))
       (= (uv-depth c1) (uv-depth c2))))


(definition public (uv-init! uv <f32vector> left <fl> top <fl> right <fl> bottom <fl> depth <fl>) <void>
  (uv-left-set! uv left)
  (uv-top-set! uv top)
  (uv-right-set! uv right)
  (uv-bottom-set! uv bottom)
  (uv-depth-set! uv depth))


(definition public (uv-copy! dst <f32vector> src <f32vector>) <void>
  (uv-left-set! dst (uv-left src))
  (uv-top-set! dst (uv-top src))
  (uv-right-set! dst (uv-right src))
  (uv-bottom-set! dst (uv-bottom src))
  (uv-depth-set! dst (uv-depth src)))


;;;
;;;; Coordinates
;;;


(definition public (image-coordinates image)
  (let ((world (current-world)))
    (image-rect~ (get-block-atlas~ world) image))))
