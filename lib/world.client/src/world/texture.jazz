;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; World Texture
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2013
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.texture jazz


(import (jazz.graphic)
        (jazz.graphic.opengl.glew)
        (jazz.io)
        (jazz.platform.cairo)
        (world)
        (world.autoload)
        (world.external.targa)
        (world.foreign)
        (world.support)
        (world.syntax (phase syntax)))


;;;
;;;; Image
;;;


(class Image-Texture extends Object
  
  
  (slot width      <fx>      getter generate)
  (slot height     <fx>      getter generate)
  (slot depth      <fx+>     getter generate)
  (slot data       <object>  getter generate)
  (slot id         <object>  getter generate)
  (slot min-filter <object>  getter generate)
  (slot mag-filter <object>  getter generate)
  (slot wrap       <object>  getter generate)
  (slot parameters <object>  getter generate)
  (slot mipmap?    <bool>    getter generate)
  (slot metadata   <object>  getter generate)
  (slot file       <object>  accessors generate)
  (slot array?     <object>  getter generate)
  
  
  (method override (initialize width height (data: data #f) (min-filter: min-filter #f) (mag-filter: mag-filter #f) (wrap: wrap #f) (parameters: parameters #f) (mipmap?: mipmap? #f) (metadata: metadata #f) (file: file #f))
    (set! width~self width)
    (set! height~self height)
    (set! depth~self #f)
    (set! data~self data)
    (set! id~self (gl-generate-texture))
    (set! min-filter~self min-filter)
    (set! mag-filter~self mag-filter)
    (set! wrap~self wrap)
    (set! parameters~self parameters)
    (set! mipmap?~self mipmap?)
    (set! metadata~self metadata)
    (set! file~self file)
    (set! array?~self #f))
  
  
  (method override (destroy)
    (glDeleteTextures* id)
    (nextmethod))
  
  
  (method protected (map-texture (repeat?: repeat? #t))
    (glEnable GL_TEXTURE_2D)
    (glBindTexture GL_TEXTURE_2D id)
    (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_MIN_FILTER (or min-filter (if mipmap? GL_LINEAR_MIPMAP_LINEAR GL_LINEAR)))
    (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_MAG_FILTER (or mag-filter GL_LINEAR))
    (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_WRAP_S (or wrap GL_REPEAT))
    (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_WRAP_T (or wrap GL_REPEAT))
    (when (and mipmap? (not (get-framebuffer-objects?)))
      (glTexParameteri GL_TEXTURE_2D GL_GENERATE_MIPMAP GL_TRUE))
    (when parameters
      (parameters))
    (glTexImage2D GL_TEXTURE_2D
                  0
                  GL_RGBA
                  width
                  height
                  0
                  GL_BGRA
                  GL_UNSIGNED_BYTE
                  data)
    (when (and mipmap? (get-framebuffer-objects?))
      (glGenerateMipmapEXT GL_TEXTURE_2D))
    (glBindTexture GL_TEXTURE_2D 0)
    (gl-check-error)
    (set! array? #f))
  
  
  (method protected (map-textures textures (repeat?: repeat? #t))
    (let ((count (length textures)))
      (glBindTexture GL_TEXTURE_2D_ARRAY_EXT id)
      (glTexParameteri GL_TEXTURE_2D_ARRAY_EXT GL_TEXTURE_MIN_FILTER (or min-filter (if mipmap? GL_LINEAR_MIPMAP_LINEAR GL_LINEAR)))
      (glTexParameteri GL_TEXTURE_2D_ARRAY_EXT GL_TEXTURE_MAG_FILTER (or mag-filter GL_LINEAR))
      (glTexParameteri GL_TEXTURE_2D_ARRAY_EXT GL_TEXTURE_WRAP_S (or wrap GL_REPEAT))
      (glTexParameteri GL_TEXTURE_2D_ARRAY_EXT GL_TEXTURE_WRAP_T (or wrap GL_REPEAT))
      (when (and mipmap? (not (get-framebuffer-objects?)))
        (glTexParameteri GL_TEXTURE_2D_ARRAY_EXT GL_GENERATE_MIPMAP GL_TRUE))
      (when parameters
        (parameters))
      (glTexImage3D GL_TEXTURE_2D_ARRAY_EXT 0 GL_RGBA width height count 0 GL_BGRA GL_UNSIGNED_BYTE #f)
      (for-each (lambda (texture)
                  (bind (surface image-width image-height depth) texture
                    (let ((width (if repeat? width image-width))
                          (height (if repeat? height image-height))
                          (data (cairo_image_surface_get_data (get-handle~ surface))))
                      (glTexSubImage3D GL_TEXTURE_2D_ARRAY_EXT 0 0 0 depth width height 1 GL_BGRA GL_UNSIGNED_BYTE data))))
                textures)
      (when (and mipmap? (get-framebuffer-objects?))
        (glGenerateMipmapEXT GL_TEXTURE_2D_ARRAY_EXT))
      (glBindTexture GL_TEXTURE_2D_ARRAY_EXT 0)
      (gl-check-error)
      (set! depth count))
    (set! array? #t))
  
  
  (method (textured-quad bl tl tr br)
    (glColor3f 1. 1. 1.)
    (glBindTexture GL_TEXTURE_2D id)
    (glBegin GL_QUADS)
    (glTexCoord2f 0. 1.)
    (bl)
    (glTexCoord2f 1. 1.)
    (tl)
    (glTexCoord2f 1. 0.)
    (tr)
    (glTexCoord2f 0. 0.)
    (br)
    (glEnd)
    (glBindTexture GL_TEXTURE_2D 0)))


;;;
;;;; Cairo
;;;


(class Cairo-Texture extends Image-Texture
  
  
  (slot surface <Surface> getter generate)
  
  
  (method override (initialize width height . rest)
    (bind-keywords ((surface #f) . others) rest
      (apply nextmethod width height others)
      (set! surface~self (or surface (new Surface (cairo_image_surface_create CAIRO_FORMAT_ARGB32 width height))))
      (set! data~self (cairo_image_surface_get_data (get-handle~ surface~self)))))
  
  
  (method override (destroy)
    (close~ surface)
    (nextmethod)))


(definition public (make-cairo-texture width height . rest)
  (apply new Cairo-Texture width height rest))


;;;
;;;; File
;;;


(definition public (make-file-texture file (min-filter: min-filter #f) (mag-filter: mag-filter #f) (parameters: parameters #f) (mipmap?: mipmap? #t) (metadata: metadata #f))
  (let ((ext (get-extension~ file)))
    (cond ((extension=? ext "png")
           (make-png-texture file min-filter: min-filter mag-filter: mag-filter parameters: parameters mipmap?: mipmap? metadata: metadata))
          ((extension=? ext "tga")
           (make-tga-texture file min-filter: min-filter mag-filter: mag-filter parameters: parameters mipmap?: mipmap? metadata: metadata))
          (else
           (error "Unsupported texture format: {a}" ext)))))


(definition public (make-file-cairo-texture file (min-filter: min-filter #f) (mag-filter: mag-filter #f) (parameters: parameters #f) (mipmap?: mipmap? #t) (metadata: metadata #f))
  (let ((ext (get-extension~ file)))
    (cond ((extension=? ext "png")
           (make-png-cairo-texture file min-filter: min-filter mag-filter: mag-filter parameters: parameters mipmap?: mipmap? metadata: metadata))
          ((extension=? ext "tga")
           (make-tga-cairo-texture file min-filter: min-filter mag-filter: mag-filter parameters: parameters mipmap?: mipmap? metadata: metadata))
          (else
           (error "Unsupported texture format: {a}" ext)))))


(definition public (cairo-surface-from-file file)
  (let ((ext (get-extension~ file)))
    (cond ((extension=? ext "png")
           (cairo-surface-from-png file))
          ((extension=? ext "tga")
           (cairo-surface-from-tga file))
          (else
           (error "Unsupported texture format: {a}" ext)))))


;;;
;;;; PNG
;;;


(definition protected (make-png-texture file (min-filter: min-filter #f) (mag-filter: mag-filter #f) (parameters: parameters #f) (mipmap?: mipmap? #t) (metadata: metadata #f))
  (assert (exists?~ file))
  (receive (width height surf) (cairo-surface-from-png file)
    (prog1 (let ((data (cairo_image_surface_get_data surf)))
             (let ((ct (new Image-Texture width height data: data min-filter: min-filter mag-filter: mag-filter parameters: parameters mipmap?: mipmap? metadata: metadata file: file)))
               (map-texture~ ct)
               ct))
      (cairo_surface_destroy surf))))


(definition protected (make-png-cairo-texture file (min-filter: min-filter #f) (mag-filter: mag-filter #f) (parameters: parameters #f) (mipmap?: mipmap? #t) (metadata: metadata #f))
  (assert (exists?~ file))
  (receive (width height surf) (cairo-surface-from-png file)
    (let ((surface (new Surface surf)))
      (let ((ct (new Cairo-Texture width height surface: surface min-filter: min-filter mag-filter: mag-filter parameters: parameters mipmap?: mipmap? metadata: metadata file: file)))
        (map-texture~ ct)
        ct))))


(definition protected (cairo-surface-from-png file)
  (let ((surf (cairo_image_surface_create_from_png (parse~ file))))
    (let ((width (cairo_image_surface_get_width surf))
          (height (cairo_image_surface_get_height surf)))
      (values width height surf))))


;;;
;;;; TGA
;;;


(definition protected (make-tga-texture file (min-filter: min-filter #f) (mag-filter: mag-filter #f) (parameters: parameters #f) (mipmap?: mipmap? #t) (metadata: metadata #f))
  (assert (exists?~ file))
  (receive (width height bytes/pixel data) (load-tga file)
    (let ((ct (new Image-Texture width height data: data min-filter: min-filter mag-filter: mag-filter parameters: parameters mipmap?: mipmap? metadata: metadata file: file)))
      (map-texture~ ct)
      ct)))


(definition protected (make-tga-cairo-texture file (min-filter: min-filter #f) (mag-filter: mag-filter #f) (parameters: parameters #f) (mipmap?: mipmap? #t) (metadata: metadata #f))
  (assert (exists?~ file))
  (receive (width height surf) (cairo-surface-from-tga file)
    (let ((surface (new Surface surf)))
      (let ((ct (new Cairo-Texture width height surface: surface min-filter: min-filter mag-filter: mag-filter parameters: parameters mipmap?: mipmap? metadata: metadata file: file)))
        (map-texture~ ct)
        ct))))


(definition protected (cairo-surface-from-tga file)
  (receive (width height bytes/pixel data) (load-tga file)
    (let ((format CAIRO_FORMAT_ARGB32))
      (let ((stride (cairo_format_stride_for_width format width)))
        (assert (= stride (* width bytes/pixel)))
        (values width height (cairo_image_surface_create_for_data data format width height stride))))))


;;;
;;;; UV
;;;


(constant uv/left   0)
(constant uv/top    1)
(constant uv/right  2)
(constant uv/bottom 3)


(definition public inline (uv left <fl> top <fl> right <fl> bottom <fl> depth <fl>) <f32vector>
  (f32vector left top right bottom depth))


(definition public inline (make-uv) <f32vector>
  (make-f32vector 5))


(definition public (copy-uv uv <f32vector>) <f32vector>
  (let ((copy (make-uv)))
    (uv-copy! copy uv)
    copy))


(definition public inline (uv-left uv <f32vector>) <fl>
  (f32vector-ref uv 0))

(definition public inline (uv-top uv <f32vector>) <fl>
  (f32vector-ref uv 1))

(definition public inline (uv-right uv <f32vector>) <fl>
  (f32vector-ref uv 2))

(definition public inline (uv-bottom uv <f32vector>) <fl>
  (f32vector-ref uv 3))

(definition public inline (uv-depth uv <f32vector>) <fl>
  (f32vector-ref uv 4))


(definition public inline (uv-left-set! uv <f32vector> left <fl>) <void>
  (f32vector-set! uv 0 left))

(definition public inline (uv-top-set! uv <f32vector> top <fl>) <void>
  (f32vector-set! uv 1 top))

(definition public inline (uv-right-set! uv <f32vector> right <fl>) <void>
  (f32vector-set! uv 2 right))

(definition public inline (uv-bottom-set! uv <f32vector> bottom <fl>) <void>
  (f32vector-set! uv 3 bottom))

(definition public inline (uv-depth-set! uv <f32vector> depth <fl>) <void>
  (f32vector-set! uv 4 depth))


(definition public (uv=? c1 <f32vector> c2 <f32vector>) <bool>
  (and (= (uv-left c1) (uv-left c2))
       (= (uv-top c1) (uv-top c2))
       (= (uv-right c1) (uv-right c2))
       (= (uv-bottom c1) (uv-bottom c2))
       (= (uv-depth c1) (uv-depth c2))))


(definition public (uv-init! uv <f32vector> left <fl> top <fl> right <fl> bottom <fl> depth <fl>) <void>
  (uv-left-set! uv left)
  (uv-top-set! uv top)
  (uv-right-set! uv right)
  (uv-bottom-set! uv bottom)
  (uv-depth-set! uv depth))


(definition public (uv-copy! dst <f32vector> src <f32vector>) <void>
  (uv-left-set! dst (uv-left src))
  (uv-top-set! dst (uv-top src))
  (uv-right-set! dst (uv-right src))
  (uv-bottom-set! dst (uv-bottom src))
  (uv-depth-set! dst (uv-depth src)))


;;;
;;;; Coordinates
;;;


(definition public (image-coordinates image)
  (let ((world (current-world)))
    (image-rect~ (get-block-atlas~ world) image))))
