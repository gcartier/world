;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Processor Tier
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.processor.tier jazz


(require (dialect.development))

(import (jazz.associative)
        (jazz.component)
        (jazz.debuggee)
        (jazz.event)
        (jazz.graphic)
        (jazz.io)
        (jazz.markup)
        (jazz.network)
        (jazz.presence)
        (jazz.presence.transmission)
        (jazz.snapshot)
        (world)
        (world.assets)
        (world.autoload)
        (world.change)
        (world.context)
        (world.history)
        (world.id)
        (world.network)
        (world.processor.assets)
        (world.scripting)
        (world.settings)
        (world.server.client)
        (world.server.serving)
        (world.stub)
        (world.support)
        (world.task)
        (world.tier)
        (world.zone))


;;;
;;;; Tier
;;;


(definition delayed-world-asset-entries
  #f)


(class Processor-Tier extends Serving-Tier
  
  
  (slot hits             initialize 0   getter generate)
  (slot remote-server    initialize #f  getter generate)
  (slot server-path      initialize #f  getter generate)
  (slot zone             initialize #f  getter generate)
  
  
  (method override (initialize self)
    (nextmethod self #f))
  
  
  (method protected (setup self dir)
    (set! directory dir)
    ;; prepare assets
    (let ((assets-dir {Directory Universe "assets"}))
      (set! universe-assets (new Remote-Assets 'universe assets-dir)))
    (let ((assets-dir (new-directory directory "world")))
      (set! world-assets (new Processor-Assets 'processor assets-dir))
      (setup-remote-index world-assets delayed-world-asset-entries)
      (set! delayed-world-asset-entries #f)))
  
  
  (method override (make-zone-assets self zone-dir)
    (new Remote-Assets 'zone (new-directory zone-dir "assets")))
  
  
  ;;;
  ;;;; Register
  ;;;
  
  
  (method override (tier-literal->id self literal)
    (calling-server self
      (lambda ()
        (register-literal remote-server literal))))
  
  
  (method override (tier-id->literal self id)
    (calling-server self
      (lambda ()
        (registered-id remote-server id))))
  
  
  ;;;
  ;;;; Incoming
  ;;;
  
  
  (method package (processor-setup self server server-path processor-id processor-no world-asset-entries zone)
    (set! remote-server server)
    (set! self.server-path server-path)
    (set-client-id/no processor-id processor-no)
    (set! delayed-world-asset-entries (list->entries world-asset-entries))
    (set! self.zone zone)
    (add-snapshot-property 'live.zone zone))
  
  
  (method package (processor-quit self)
    (quit))
  
  
  (method package (client-enter self client client-uuid client-id client-no character-name character-avatar character-dye character-script character-role character-admin?)
    (let ((tier (current-tier))
          (world (current-world))
          (zone (current-zone))
          (me (current-me+)))
      (let ((existing-delegate (find-delegate-by-name self character-name))
            (existing-player (find-player zone character-name)))
        (let ((delegate (cond (existing-delegate
                               (reconnect-client self client existing-delegate client-uuid)
                               existing-delegate)
                              (else
                               (new Client-Delegate client 'entered client-uuid client-id client-no character-name character-avatar character-dye character-script character-role character-admin? #f)))))
          (unless existing-delegate
            (set! delegates (cons delegate delegates)))
          ;; retrieve player
          (let ((player (or existing-player (player-retrieve self client-id client-no character-name character-avatar character-dye character-script)))
                (player-delegate delegate))
            ;; collect other players for client
            (define (collect-other-players)
              (define (player-info player delegate)
                (let ((name (get-name player))
                      (avatar (get-avatar player))
                      (dye (get-color player))
                      (id (get-id player))
                      (no (get-no player))
                      (mode (get-mode player))
                      (position (get-position player))
                      (lookat (get-lookat player))
                      (script (get-script delegate))
                      (camera (player-camera player)))
                  (list name avatar dye id no mode position lookat script (get-position camera) (get-lookat camera))))
              
              (let ((players
                      (collect (lambda (delegate)
                                 (and (neq? delegate player-delegate)
                                      (let ((name (get-name delegate)))
                                        (let ((existing (find-player zone name)))
                                          (player-info existing delegate)))))
                               delegates)))
                (if (not me)
                    players
                  (cons (player-info me player-delegate) players))))
            
            (let ((player-id (get-id player))
                  (player-no client-no)
                  (player-mode (get-mode player))
                  (player-position (get-position player))
                  (player-lookat (get-lookat player))
                  (player-script (get-script player-delegate))
                  (other-players (collect-other-players)))
              ;; broadcast entering player to other players
              (unless existing-player
                (for-each (lambda (delegate)
                            (unless (eq? delegate player-delegate)
                              (when (eq? (get-state delegate) 'ready)
                                (let ((client (get-client delegate)))
                                  (calling-client tier delegate
                                    (lambda ()
                                      (processor-entered client client-id client-no character-name character-avatar character-dye character-script player-id player-no player-mode player-position player-lookat player-script)))))))
                          delegates))
              ;; rebroadcast draws
              (rebroadcast-draws)
              (let (;; open test quicky to send form as a string
                    (form (call-with-input-file (path-settings (get-moniker zone)) read-content-string))
                    (zone-asset-entries (entries->list (get-entries (get-index (get-repository (get-zone-assets world))))))
                    (spawnpoint (get-spawnpoint zone))
                    ;; todo
                    (player-spawnpoint (get-player-spawnpoint zone))
                    (camera (player-camera player))
                    (zone-daytime (sun-angle->daytime zone (get-sun-angle zone))))
                (list form
                      zone-asset-entries
                      spawnpoint
                      (or player-spawnpoint spawnpoint)
                      player-id
                      player-no
                      player-position
                      player-lookat
                      (get-position camera)
                      (get-lookat camera)
                      zone-daytime
                      other-players))))))))
  
  
  (method package (client-ready self client)
    (let ((delegate (find-delegate self client)))
      ;; together robust
      (when delegate
        (set-state delegate 'ready))))
  
  
  (method package (client-retrieve self client character-name)
    (let ((zone (current-zone)))
      (let ((player (find-player zone character-name)))
        (let ((camera (player-camera player)))
          (list (get-position camera)
                (get-lookat camera))))))
  
  
  (method package (client-save self client character-name camera-position camera-lookat)
    (let ((zone (current-zone)))
      (let ((player (find-player zone character-name)))
        ;; aec robust
        (when player
          (let ((camera (player-camera player)))
            (set-position camera camera-position)
            (set-lookat camera camera-lookat))
          ;; store player
          (store-player self player)))))
  
  
  @reconnection-too-fragile
  (method package (client-disconnect self client)
    (let ((delegate (find-delegate self client)))
      (when delegate
        (set-disconnected? delegate #t))))
  
  
  (method package (client-reconnect self client)
    (let ((delegate (find-delegate self client)))
      (when delegate
        (set-disconnected? delegate #f))))
  
  
  (method package (client-kick self client)
    (let ((delegate (find-delegate self client)))
      (when delegate
        (kick-client self delegate))))
  
  
  (method package (client-exit self client character-name)
    (let ((tier (current-tier))
          (zone (current-zone)))
      (let ((player (find-player zone character-name)))
        ;; aec robust
        (when player
          ;; remove player
          (remove-element zone player)
          ;; find server client
          (let ((player-delegate (find-delegate self client)))
            ;; broadcast exiting player to other players
            (for-each (lambda (delegate)
                        (unless (eq? delegate player-delegate)
                          (when (eq? (get-state delegate) 'ready)
                            (let ((client (get-client delegate)))
                              (calling-client tier delegate
                                (lambda ()
                                  (processor-exited client character-name)))))))
                      delegates)
            ;; unregister client
            (set! delegates (remove! player-delegate delegates))
            ;; update state
            (set-state player-delegate 'exited)
            ;; closing remote
            (closing-remote-proxy-safe client))))))
  
  
  (method override (delayed-disconnect-client self delegate (reason: reason #f))
    (disconnect-client self delegate reason: reason))
  
  
  (method override (disconnect-client self delegate (reason: reason #f))
    ;; let server handle disconnection
    (calling-server self
      (lambda ()
        (client-disconnect remote-server (get-client delegate) reason)))
    @reconnection-too-fragile
    (set-disconnected? delegate #t))
  
  
  (method (reconnect-client self client delegate uuid)
    (set-disconnected? delegate #f)
    (set-client delegate client)
    (set-state delegate 'entered)
    (set-alive delegate (current-seconds))
    (set-exception delegate #f)
    (set-exception-stack delegate #f)
    (set-exception-time delegate #f)
    (set-uuid delegate uuid))
  
  
  (method (kick-client self delegate)
    (let ((client (get-client delegate)))
      (disconnect-remote-proxy client)
      (set! delegates (remove! delegate delegates))))
  
  
  (method (player-retrieve self client-id client-no character-name character-avatar character-dye character-script)
    (let ((zone (current-zone)))
      (let ((file (player-file self character-name)))
        (let ((player
                (if (exists? file)
                    (let ((player (instantiate (read-form file))))
                      (register-id player client-id)
                      (register-no player client-no)
                      (set-me? player #f)
                      (set-name player character-name)
                      (set-avatar player character-avatar)
                      (set-color player character-dye)
                      player)
                  (let ((units '(world.camera world.player)))
                    (let ((tag '(<Player> (<Camera>)))
                          (data (new Data zone-version 'jazz units #f)))
                      (let ((form (construct-form tag (imports-locator units) data)))
                        (set-origin form file)
                        (let ((player (instantiate form)))
                          (register-id player client-id)
                          (register-no player client-no)
                          (set-me? player #f)
                          (set-name player character-name)
                          (set-avatar player character-avatar)
                          (set-color player character-dye)
                          (let ((dot-file (new-file directory ".player")))
                            (if (exists? dot-file)
                                (let ((dot-player (instantiate (read-form dot-file))))
                                  (set-position player (get-position dot-player))
                                  (set-lookat player (get-lookat dot-player)))
                              (set-position player (find-spawnpoint zone))
                              (set-lookat player (find-spawnlookat zone))))
                          player)))))))
          (add-element zone player)
          player))))
  
  
  (method (store-player self player)
    (let ((file (player-file self (get-name player))))
      (create-directories file)
      (let ((designer (new Former form: (get-form player) reference: player)))
        (define (save-camera)
          (let ((camera (player-camera player)))
            (set-property designer camera 'position (get-position camera))
            (set-property designer camera 'lookat (get-lookat camera))))
        
        (define (save-player)
          (set-property designer player 'position (get-position player))
          (set-property designer player 'lookat (get-lookat player)))
        
        (save-camera)
        (save-player)
        (save designer))))
  
  
  (method override (player-file self name)
    (new-file (new-directory directory "players") (format "{a}.player" name)))
  
  
  (method package (client-mode self client mode)
    (let ((zone (current-zone)))
      (let ((delegate (find-delegate self client)))
        (set-mode delegate mode)
        (let ((player (find-player zone (get-name delegate))))
          ;; aec robust
          (when player
            (set-mode player mode)))
        (broadcast-mode self delegate mode))))
  
  
  (method (broadcast-mode self client-delegate mode)
    (let ((character-name (get-name client-delegate)))
      (for-each (lambda (delegate)
                  (unless (eq? delegate client-delegate)
                    (when (eq? (get-state delegate) 'ready)
                      (let ((client (get-client delegate)))
                        (calling-client self delegate
                          (lambda ()
                            (mode-update client character-name mode)))))))
                delegates)))
  
  
  (method package (client-update self client sent changes)
    (increase! hits)
    (when debug-sequence?
      ;; rebase sequence for tests
      (world.change:iterate-changes changes
        (lambda (change offset)
          (let ((sequence-no (world.history:next-sequence-no!)))
            (f64vector-set! changes (+ offset 5) (cast <fl> sequence-no))))))
    (forward-changes sent (current-seconds) changes)
    (with-outgoing-mutex
      (lambda ()
        (push-client-changes changes))))
  
  
  (method package (retrieve-region self region-index)
    (let ((zone (current-zone)))
      (boolean (load-region zone region-index))))
  
  
  (method package (retrieve-chunk self region-index chunk-index chunk-digest)
    (let ((zone (current-zone)))
      (let ((region (load-region zone region-index)))
        (let ((chunk (load-chunk region chunk-index)))
          (and @always-retrieve (not (equal? (get-digest chunk) chunk-digest))
               (let ((chunk-raw (get-raw chunk)))
                 chunk-raw))))))
  
  
  (method override (retrieve-entity self id)
    (let ((world (current-world)))
      (let ((entity (find-entity id)))
        ;; quick hack for test
        (when (not entity)
          (debug 'entity id 'not 'found)
          (set! entity (new Creature id: id name: 'NOT-FOUND model: 'Wolf)))
        ;; quick hack for players
        (when (is? entity Player)
          (debug 'player id 'retrieved)
          (set! entity (new Creature id: id name: 'PLAYER model: 'Wolf)))
        ;; quick first draft we should probably use jazz serialization
        (let ((class (class-of entity)))
          (cons (class->class-name world class) (package class entity))))))
  
  
  (method package (retrieve-zone-asset self path)
    (let ((world (current-world)))
      (let ((repository (get-repository (get-zone-assets world))))
        (let ((entry (find-entry repository path)))
          (and entry
               (bind (path digest seconds) entry
                 (list (retrieve-object repository digest) digest)))))))
  
  
  (method package (upload-zone-asset self content digest)
    (let ((world (current-world)))
      (let ((repository (get-repository (get-zone-assets world))))
        (store-object repository content digest))))
  
  
  (method package (update-zone-assets self client changes)
    (let ((world (current-world)))
      (let ((repository (get-repository (get-zone-assets world))))
        (let ((delegate (find-delegate self client)))
          (update-changes repository changes)
          (broadcast-assets self delegate changes)))))
  
  
  (method (broadcast-assets self client-delegate changes)
    (for-each (lambda (delegate)
                (unless (eq? delegate client-delegate)
                  (when (eq? (get-state delegate) 'ready)
                    (let ((client (get-client delegate)))
                      (calling-client self delegate
                        (lambda ()
                          (zone-assets-update client changes)))))))
              delegates))
  
  
  (method package (pause self)
    (let ((world (current-world))
          (history (current-history)))
      (pause-world world)
      (for-each (lambda (delegate)
                  (when (eq? (get-state delegate) 'ready)
                    (calling-client self delegate
                      (lambda ()
                        (pause-client (get-client delegate))))))
                delegates)))
  
  
  (method package (unpause self)
    (let ((world (current-world))
          (history (current-history)))
      (for-each (lambda (delegate)
                  (when (eq? (get-state delegate) 'ready)
                    (calling-client self delegate
                      (lambda ()
                        (unpause-client (get-client delegate))))))
                delegates)
      (unpause-world world)))
  
  
  (method package (attach self debugger)
    (delay-event
      (lambda ()
        (setup-debuggee debugger: debugger)
        (start-repl-thread (current-thread) #f (current-console-port))
        (select-debugger-console)
        (current-input-port (console-input-port))
        (current-output-port (console-output-port))
        (ready-to-controller))))
  
  
  (method package (detach self)
    (current-input-port (standard-input-port))
    (current-output-port (standard-output-port))
    (detach-from-controller))
  
  
  (method package (admin-command self client command arguments)
    (let ((zone (current-zone)))
      (case command
        ((dayduration)
         (bind (duration) arguments
           (if (unspecified? duration)
               (get-day-duration zone)
             (set-day-duration zone duration)
             (broadcast-dayduration self duration)
             (unspecified))))
        ((daytime)
         (bind (time) arguments
           (if (unspecified? time)
               (get-daytime zone)
             (goto-daytime zone (effective-daytime zone time))
             (broadcast-daytime self time)
             (unspecified))))
        (else
         (format "Unknown command: {s}" command)))))
  
  
  (method (broadcast-dayduration self duration)
    (for-each (lambda (delegate)
                (when (eq? (get-state delegate) 'ready)
                  (let ((client (get-client delegate)))
                    (calling-client self delegate
                      (lambda ()
                        (dayduration-client client duration))))))
              delegates))
  
  
  (method (broadcast-daytime self time)
    (for-each (lambda (delegate)
                (when (eq? (get-state delegate) 'ready)
                  (let ((client (get-client delegate)))
                    (calling-client self delegate
                      (lambda ()
                        (daytime-client client time))))))
              delegates))
  
  
  ;;;
  ;;;; Outgoing
  ;;;
  
  
  (method (calling-server self thunk)
    (thunk))
  
  
  (method package (broadcast-processor-update self changes)
    (let ((tier (current-tier)))
      (for-each (lambda (delegate)
                  (when (eq? (get-state delegate) 'ready)
                    (let ((client (get-client delegate)))
                      (calling-client tier delegate
                        (lambda ()
                          (processor-update client (current-seconds) changes))))))
                delegates)))
  
  
  (method (broadcast-processor-draw self id color alpha dts pts duration background slide?)
    (let ((tier (current-tier)))
      (for-each (lambda (delegate)
                  (when (eq? (get-state delegate) 'ready)
                    (let ((client (get-client delegate)))
                      (calling-client tier delegate
                        (lambda ()
                          (processor-draw client id color alpha dts pts duration background slide?))))))
                delegates)))
  
  
  ;;;
  ;;;; Assets
  ;;;
  
  
  (method package (retrieve-asset self path)
    (let ((info (calling-server self
                  (lambda ()
                    (retrieve-world-asset remote-server path)))))
      (if (not info)
          (error "Unable to retrieve asset: {a}" path)
        info)))
  
  
  (method package (world-assets-update self changes)
    (update-changes (get-remote-index world-assets) changes)
    (removed-update world-assets changes)))


;;;
;;;; Slave
;;;


(definition protected (setup-processor)
  (set-tier-kind 'processor)
  (set-current-tier (new Processor-Tier))
  (let ((remote-processor (load-object (get-local-register) 'world.processor.remote 'world-remote-processor)))
    (slave-setup master-process remote-processor master-cookie)))


(definition protected (ready-processor)
  (let ((remote-processor (load-object (get-local-register) 'world.processor.remote 'world-remote-processor)))
    (slave-ready master-process remote-processor master-cookie))))
