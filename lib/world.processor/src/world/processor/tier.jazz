;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; Processor Tier
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.processor.tier jazz


(require (dialect.development))

(import (jazz.component)
        (jazz.debuggee)
        (jazz.event)
        (jazz.graphic)
        (jazz.io)
        (jazz.markup)
        (jazz.network)
        (jazz.presence)
        (jazz.presence.transmission)
        (world)
        (world.autoload)
        (world.change)
        (world.context)
        (world.history)
        (world.id)
        (world.network)
        (world.scripting)
        (world.settings)
        (world.server.client)
        (world.server.serving)
        (world.support)
        (world.tier))


;;;
;;;; Tier
;;;


(class Processor-Tier extends Serving-Tier
  
  
  (slot delegates        initialize '() getter generate)
  (slot hits             initialize 0   getter generate)
  (slot remote-server    initialize #f  getter generate)
  (slot server-path      initialize #f  getter generate)
  (slot zone             initialize #f  getter generate)
  
  
  (method override (initialize self)
    (nextmethod self #f)
    (set-presence-process-handler
      (lambda (proc connection)
        (catch (connection-exception? exc
                 ;; todo
                 )
          (proc connection)))))
  
  
  (method protected (setup self dir)
    (set! directory dir)
    ;; should a processor have its own assets?
    (set! assets #f)
    ;; kinda of a hack around not being able to call server
    ;; as it is in the middle of the client change-zone call
    (delay-event
      (lambda ()
        (let ((id (make-unique-id)))
          (set-client-id/no id (literal->id id self))))))
  
  
  ;;;
  ;;;; Register
  ;;;
  
  
  (method override (tier-literal->id self literal)
    (calling-server self
      (lambda ()
        (register-literal remote-server literal))))
  
  
  (method override (tier-id->literal self id)
    (calling-server self
      (lambda ()
        (registered-id remote-server id))))
  
  
  ;;;
  ;;;; Incoming
  ;;;
  
  
  (method package (processor-setup self server server-path zone)
    (set! remote-server server)
    (set! self.server-path server-path)
    (set! self.zone zone))
  
  
  (method package (processor-quit self)
    (quit))
  
  
  (method package (client-enter self client client-uuid client-id client-no character-name character-avatar character-script character-role)
    (let ((tier (current-tier))
          (zone (current-zone))
          (me (current-me+)))
      (let ((reconnected-delegate (find-delegate-by-name self character-name))
            (existing-player (find-player zone character-name)))
        (let ((delegate (if (not reconnected-delegate)
                            (new Client-Delegate client 'entered client-uuid client-id client-no character-name character-avatar character-script character-role)
                          (set-client reconnected-delegate client)
                          (set-alive reconnected-delegate (current-seconds))
                          (set-exception reconnected-delegate #f)
                          (set-exception-stack reconnected-delegate #f)
                          (set-exception-time reconnected-delegate #f)
                          reconnected-delegate)))
          (unless reconnected-delegate
            (set! delegates (cons delegate delegates)))
          ;; retrieve player
          (let ((player (or existing-player (player-retrieve self client-id client-no character-name character-avatar character-script)))
                (player-delegate delegate))
            ;; collect other players for client
            (define (collect-other-players)
              (define (player-info player delegate)
                (let ((name (get-name player))
                      (avatar (get-avatar player))
                      (id (get-id player))
                      (no (get-no player))
                      (position (get-position player))
                      (lookat (get-lookat player))
                      (script (get-script delegate))
                      (camera (player-camera player)))
                  (list name avatar id no position lookat script (get-position camera) (get-lookat camera))))
              
              (let ((players
                      (collect (lambda (delegate)
                                 (and (neq? delegate player-delegate)
                                      (let ((name (get-name delegate)))
                                        (let ((existing (find-player zone name)))
                                          (player-info existing delegate)))))
                               delegates)))
                (if (or (not me) (admin-me? me))
                    players
                  (cons (player-info me player-delegate) players))))
            
            (let ((player-id (get-id player))
                  (player-no client-no @gazno (get-no player))
                  (player-position (get-position player))
                  (player-lookat (get-lookat player))
                  (player-script (get-script player-delegate))
                  (other-players (collect-other-players)))
              ;; broadcast entering player to other players
              (for-each (lambda (delegate)
                          (unless (eq? delegate player-delegate)
                            (let ((client (get-client delegate)))
                              (calling-client tier delegate
                                (lambda ()
                                  (processor-entered client client-id client-no character-name character-avatar character-script player-id player-no player-position player-lookat player-script))))))
                        delegates)
              ;; rebroadcast draws
              (rebroadcast-draws)
              (let (;; open test quicky to send form as a string
                    (form (call-with-input-file (path-settings (get-moniker zone)) read-content-string))
                    (spawnpoint (get-spawnpoint zone))
                    ;; todo
                    (player-spawnpoint (get-player-spawnpoint zone))
                    (camera (player-camera player)))
                (list form spawnpoint (or player-spawnpoint spawnpoint) player-id player-no player-position player-lookat (get-position camera) (get-lookat camera) other-players))))))))
  
  
  (method package (client-save self client character-name camera-position camera-lookat)
    (let ((zone (current-zone)))
      ;; aec robust
      (let ((player (find-player zone character-name)))
        (when player
          (let ((camera (player-camera player)))
            (set-position camera camera-position)
            (set-lookat camera camera-lookat))))))
  
  
  (method package (client-exit self client character-name)
    (let ((tier (current-tier))
          (zone (current-zone)))
      ;; aec robust
      (let ((player (find-player zone character-name)))
        (when player
          ;; store player
          (player-store self player)
          ;; find server client
          (let ((player-delegate (find-delegate self client)))
            ;; broadcast exiting player to other players
            (for-each (lambda (delegate)
                        (unless (eq? delegate player-delegate)
                          (let ((client (get-client delegate)))
                            (calling-client tier delegate
                              (lambda ()
                                (processor-exited client character-name))))))
                      delegates)
            ;; unregister client
            (set! delegates (remove! player-delegate delegates))
            ;; update state
            (set-state player-delegate 'exited))))))
  
  
  (method (player-retrieve self client-id client-no character-name character-avatar character-script)
    (let ((zone (current-zone)))
      (let ((file (player-file self character-name)))
        (let ((player
                (if (exists? file)
                    (let ((player (instantiate (read-form file))))
                      (register-id player client-id)
                      (register-no player client-no)
                      (set-me? player #f)
                      (set-name player character-name)
                      (set-avatar player character-avatar)
                      player)
                  (let ((units '(world.camera world.player)))
                    (let ((tag '(<Player> (<Camera>)))
                          (data (new Data zone-version 'jazz units #f)))
                      (let ((form (construct-form tag (imports-locator units) data)))
                        (set-origin form file)
                        (let ((player (instantiate form)))
                          (register-id player client-id)
                          (register-no player client-no)
                          (set-me? player #f)
                          (set-name player character-name)
                          (set-avatar player character-avatar)
                          (set-position player (find-spawnpoint zone))
                          (set-lookat player (find-spawnlookat zone))
                          player)))))))
          (add-element zone player)
          player))))
  
  
  (method (player-store self player)
    (let ((zone (current-zone)))
      (let ((file (player-file self (get-name player))))
        (create-directories file)
        (let ((designer (new Former form: (get-form player) reference: player)))
          (define (save-camera)
            (let ((camera (player-camera player)))
              (set-property designer camera 'position (get-position camera))
              (set-property designer camera 'lookat (get-lookat camera))))
          
          (define (save-player)
            (set-property designer player 'position (get-position player))
            (set-property designer player 'lookat (get-lookat player)))
          
          (save-camera)
          (save-player)
          (save designer)))
      (remove-element zone player)))
  
  
  (method override (player-file self name)
    (let ((dir (get-directory (current-tier))))
      (new-file (new-directory dir "players") (format "{a}.player" name))))
  
  
  (method package (client-update self client sent changes)
    (increase! hits)
    (when debug-sequence?
      ;; rebase sequence for tests
      (world.change:iterate-changes changes
        (lambda (change offset)
          (let ((sequence-no (world.history:next-sequence-no!)))
            (f64vector-set! changes (+ offset 5) (cast <fl> sequence-no))))))
    (forward-changes sent (current-seconds) changes)
    (with-outgoing-mutex
      (lambda ()
        (push-client-changes changes))))
  
  
  (method package (retrieve-region self region-index)
    (let ((zone (current-zone)))
      (boolean (load-region zone region-index))))
  
  
  (method package (retrieve-chunk self region-index chunk-index chunk-digest)
    (let ((zone (current-zone)))
      (let ((region (load-region zone region-index)))
        (let ((chunk (load-chunk region chunk-index)))
          (and @always-retrieve (not (equal? (get-digest chunk) chunk-digest))
               (let ((chunk-raw (get-raw chunk)))
                 chunk-raw))))))
  
  
  (method override (retrieve-entity self id)
    (let ((world (current-world)))
      (let ((entity (find-entity id)))
        ;; quick hack for test
        (when (not entity)
          (debug 'entity id 'not 'found)
          (set! entity (new Creature id: id name: 'NOT-FOUND model: 'Wolf)))
        ;; quick hack for players
        (when (is? entity Player)
          (debug 'player id 'retrieved)
          (set! entity (new Creature id: id name: 'PLAYER model: 'Wolf)))
        ;; quick first draft we should probably use jazz serialization
        (let ((class (class-of entity)))
          (cons (class->class-name world class) (package class entity))))))
  
  
  (method package (pause self)
    (let ((world (current-world))
          (history (current-history)))
      (pause-world world)
      (for-each (lambda (delegate)
                  (calling-client self delegate
                    (lambda ()
                      (pause-client (get-client delegate)))))
                delegates)))
  
  
  (method package (unpause self)
    (let ((world (current-world))
          (history (current-history)))
      (for-each (lambda (delegate)
                  (calling-client self delegate
                    (lambda ()
                      (unpause-client (get-client delegate)))))
                delegates)
      (unpause-world world)))
  
  
  (method (find-delegate self target)
    (find-if (lambda (delegate)
               (proxy=? (get-client delegate) target))
             delegates))
  
  
  (method (find-delegate-by-name self target)
    (find-if (lambda (delegate)
               (equal? (get-name delegate) target))
             delegates))
  
  
  ;;;
  ;;;; Outgoing
  ;;;
  
  
  (method (calling-server self thunk)
    (thunk))
  
  
  (method package (broadcast-processor-update self changes)
    (let ((tier (current-tier)))
      (for-each (lambda (delegate)
                  (let ((client (get-client delegate)))
                    (calling-client tier delegate
                      (lambda ()
                        (processor-update client (current-seconds) changes)))))
                delegates)))
  
  
  (method (broadcast-processor-draw self id color alpha dts pts duration background slide?)
    (let ((tier (current-tier)))
      (for-each (lambda (delegate)
                  (let ((client (get-client delegate)))
                    (calling-client tier delegate
                      (lambda ()
                        (processor-draw client id color alpha dts pts duration background slide?)))))
                delegates))))


;;;
;;;; Slave
;;;


(definition protected (setup-processor)
  (set-tier-kind 'processor)
  (set-current-tier (new Processor-Tier))
  (let ((remote-processor (load-object (get-local-register) 'world.processor.remote 'world-remote-processor)))
    (slave-setup master-process remote-processor master-cookie)))


(definition protected (ready-processor)
  (let ((remote-processor (load-object (get-local-register) 'world.processor.remote 'world-remote-processor)))
    (slave-ready master-process remote-processor master-cookie))))
