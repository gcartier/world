;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Processor
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.processor jazz


(require (dialect.development))

(import (jazz.component)
        (jazz.debuggee)
        (jazz.digest)
        (jazz.evaluate)
        (jazz.event)
        (jazz.io)
        (jazz.jml)
        (jazz.jrm)
        (jazz.network)
        (jazz.runtime)
        (jazz.settings)
        (jazz.snapshot)
        (jazz.time)
        (world)
        (world.autoload)
        (world.settings)
        (world.server.client)
        (world.server.serving)
        (world.syntax (phase syntax))
        (world.tier)
        (world.work))


;;;
;;;; Tier
;;;


(class Processor-Tier extends Serving-Tier
  
  
  (slot processor getter generate)
  
  
  (method override (initialize dir)
    (nextmethod dir)
    (set! processor (current-processor)))
  
  
  ;;;
  ;;;; Register
  ;;;
  
  
  (method override (tier-literal->id literal)
    (calling-server
      (lambda ()
        (register-literal~ (get-remote-server~ processor) literal))))
  
  
  (method override (tier-id->literal id)
    (calling-server
      (lambda ()
        (registered-id~ (get-remote-server~ processor) id))))
  
  
  ;;;
  ;;;; Outgoing
  ;;;
  
  
  (method (calling-server thunk)
    ;; longer timeout while in development
    ;; as we might be running under a debugger
    (parameterize ((receive-timeout 60))
      (thunk))))


;;;
;;;; Processor
;;;


(class Processor extends Object
  
  
  (slot clients          initialize '() getter generate)
  (slot hits             initialize 0   getter generate)
  (slot remote-processor                getter generate)
  (slot remote-master    initialize #f  getter generate)
  (slot remote-cookie    initialize #f  getter generate)
  (slot remote-server    initialize #f  getter generate)
  (slot server-name      initialize #f  getter generate)
  
  
  (method override (initialize)
    (set! remote-processor (load-object~ (get-local-register) 'world.processor.remote 'world-remote-processor)))
  
  
  ;;;
  ;;;; Incoming
  ;;;
  
  
  (method (processor-setup master cookie server server-name worker)
    (set! remote-master master)
    (set! remote-cookie cookie)
    (set! remote-server server)
    (set! server-name~self server-name)
    (connect-remote worker)
    (set-worker worker))
  
  
  (method (processor-quit)
    (quit))
  
  
  (method (client-join client client-id character-name character-avatar)
    (let ((tier (current-tier))
          (zone (current-zone)))
      (debug-processor 'client-join character-name character-avatar)
      (let ((reconnected-client-state (find-client-state-by-name character-name))
            (existing-player (find-player~ zone character-name)))
        (let ((client-state (if (not reconnected-client-state)
                                (new Client-State client client-id character-name character-avatar)
                              (set-client~ reconnected-client-state client)
                              (set-alive~ reconnected-client-state (current-seconds))
                              (set-exception~ reconnected-client-state #f)
                              (set-exception-time~ reconnected-client-state #f)
                              reconnected-client-state)))
          (unless reconnected-client-state
            (set! clients (cons client-state clients)))
          ;; retrieve player
          (let ((player (or existing-player (player-retrieve client-id character-name character-avatar)))
                (player-client-state client-state))
            ;; collect other players for client
            (define (collect-other-players)
              (define (player-info player)
                (let ((id (get-id~ player))
                      (name (get-name~ player))
                      (avatar (get-avatar~ player))
                      (position (get-position~ player))
                      (lookat (get-lookat~ player)))
                  (list id name avatar position lookat)))
              
              (let ((me (current-me+))
                    (players
                      (collect (lambda (client-state)
                                 (unless (eq? client-state player-client-state)
                                   (let ((name (get-name~ client-state)))
                                     (let ((existing (find-player~ zone name)))
                                       (player-info existing)))))
                               clients)))
                (if (not me)
                    players
                  (cons (player-info me) players))))
            
            (let ((player-position (get-position~ player))
                  (player-lookat (get-lookat~ player))
                  (other-players (collect-other-players)))
              ;; broadcast entering player to other players
              (for-each (lambda (client-state)
                          (unless (eq? client-state player-client-state)
                            (let ((client (get-client~ client-state)))
                              (calling-client~ tier client-state
                                (lambda ()
                                  (server-entered~ client client-id character-name character-avatar player-position player-lookat))))))
                        clients)
              (let (;; open test quicky to send form as a string
                    (form (call-with-input-file (path-settings (get-moniker~ zone)) read-content-string))
                    (spawnpoint (get-spawnpoint~ zone)))
                (list form spawnpoint player-position player-lookat other-players))))))))
  
  
  (method (client-leave client character-name)
    (let ((tier (current-tier))
          (zone (current-zone)))
      (debug-processor 'client-leave character-name)
      ;; aec robust
      (let ((player (find-player~ zone character-name)))
        (when player
          ;; store player
          (player-store player)
          ;; find server client
          (let ((player-client-state (find-client-state client)))
            ;; broadcast exiting player to other players
            (for-each (lambda (client-state)
                        (unless (eq? client-state player-client-state)
                          (let ((client (get-client~ client-state)))
                            (calling-client~ tier client-state
                              (lambda ()
                                (server-exited~ client character-name))))))
                      clients)
            ;; unregister client
            (set! clients (remove! player-client-state clients)))))))
  
  
  (method (player-retrieve client-id character-name character-avatar)
    (let ((zone (current-zone)))
      (let ((file (new-file~ (players-dir) (format "{a}.player" character-name))))
        (let ((player
                (if (exists?~ file)
                    (let ((player (instantiate~ (read-form file))))
                      (register-id~ player client-id)
                      (set-name~ player character-name)
                      (set-avatar~ player character-avatar)
                      (set-parent~ player zone)
                      player)
                  (let ((units '(world.data)))
                    (let ((tag '(<Player> (<Camera>)))
                          (data (new Data zone-version 'jazz units #f)))
                      (let ((form (construct-form tag (imports-locator units) data)))
                        (set-origin~ form file)
                        (let ((player (instantiate~ form)))
                          (register-id~ player client-id)
                          (set-name~ player character-name)
                          (set-avatar~ player character-avatar)
                          (set-parent~ player zone)
                          (set-position~ player (find-spawnpoint~ zone))
                          (set-lookat~ player (find-spawnlookat~ zone))
                          player)))))))
          (set-billboard-name~ player character-name)
          (add-element~ zone player)
          player))))
  
  
  (method (player-store player)
    (let ((world (current-world))
          (zone (current-zone)))
      (let ((file (new-file~ (players-dir) (format "{a}.player" (get-name~ player)))))
        (create-directories~ file)
        (let ((designer (new Former form: (get-form~ player) reference: player)))
          (define (save-camera)
            (let ((eye (get-eye~ world))
                  (camera (player-camera~ player)))
              (set-property~ designer camera 'position (get-position~ eye))
              (set-property~ designer camera 'lookat (get-lookat~ eye))))
          
          (define (save-player)
            (set-property~ designer player 'position (get-position~ player))
            (set-property~ designer player 'lookat (get-lookat~ player)))
          
          (save-camera)
          (save-player)
          (save~ designer)))
      (remove-element~ zone player)))
  
  
  (method (players-dir)
    (let ((tier (current-tier)))
      (new-directory~ (get-directory~ tier) "players")))
  
  
  (method (retrieve-region region-x region-z)
    (let ((zone (current-zone)))
      (debug-processor 'retrieve-region region-x region-z)
      (boolean (get-region~ zone region-x region-z))))
  
  
  (method (retrieve-chunk region-x region-z chunk-x chunk-z chunk-digest)
    (let ((zone (current-zone)))
      (let ((region (get-region~ zone region-x region-z)))
        (when region
          (let ((chunk (get-chunk~ region chunk-x chunk-z create?: #t)))
            (when chunk
              (unless (equal? (get-digest~ chunk) chunk-digest)
                (let ((chunk-raw (get-raw~ chunk)))
                  (debug-processor 'retrieve-chunk region-x region-z chunk-x chunk-z (u8vector-length chunk-raw))
                  chunk-raw))))))))
  
  
  (method (debug-processor . rest)
    (when (world-setting 'world.processor.debug? #f)
      (apply debug 'processor rest)))
  
  
  (method (find-client-state target)
    (find-if (lambda (client)
               (proxy=? (get-client~ client) target))
             clients))
  
  
  (method (find-client-state-by-name target)
    (find-if (lambda (client)
               (equal? (get-name~ client) target))
             clients)))


;;;
;;;; Ready
;;;


(definition protected (setup-processor)
  (let ((processor (new Processor)))
    (set-current-processor processor)
    (let ((master (command-argument "master"))
          (cookie (integer-argument "master-cookie")))
      (receive (host port alternate-port) (parse-host/service master)
        (assert (or (get-controller-debugger) (not (get-remote-listener)))
          (start-remote-listener host: host))
        (let ((remote-register (connect-remote-register host port #t)))
          (let ((master (load-object~ remote-register 'world.master 'world-remote-master))
                (processor (get-remote-processor~ processor)))
            (slave-setup~ master processor cookie)))))))


(definition protected (ready-processor)
  (let ((processor (current-processor)))
    (let ((master (get-remote-master~ processor))
          (processor (get-remote-processor~ processor))
          (cookie (get-remote-cookie~ processor)))
      (slave-ready~ master processor cookie)))))
