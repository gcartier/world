;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Processor
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.processor jazz


(require (dialect.development))

(import (jazz.component)
        (jazz.debuggee)
        (jazz.digest)
        (jazz.evaluate)
        (jazz.event)
        (jazz.io)
        (jazz.jml)
        (jazz.jrm)
        (jazz.jrm.transmission)
        (jazz.network)
        (jazz.runtime)
        (jazz.settings)
        (jazz.snapshot)
        (jazz.time)
        (world)
        (world.assets)
        (world.autoload)
        (world.change)
        (world.history)
        (world.id)
        (world.network)
        (world.settings)
        (world.server.client)
        (world.server.serving)
        (world.support)
        (world.syntax (phase syntax))
        (world.tier)
        (world.work))


;;;
;;;; Tier
;;;


(class Processor-Tier extends Serving-Tier
  
  
  (slot processor getter generate)
  
  
  (method override (initialize dir)
    (nextmethod dir)
    (set! processor (current-processor))
    (set! assets (gather-assets 'tier (new-directory~ directory "assets")))
    ;; aec quicky
    (set-remote-problem-handler
      (lambda (process)
        (catch (connection-problem? obj
                 obj)
          (process))))
    (start-remote-listener)
    ;; kinda of a hack around not being able to call server
    ;; as it is in the middle of the client change-zone call
    (delay-event
      (lambda ()
        (let ((id (make-unique-id)))
          (set-client-id/no id (literal->id id self))))))
  
  
  ;;;
  ;;;; Register
  ;;;
  
  
  (method override (tier-literal->id literal)
    (calling-server
      (lambda ()
        (register-literal~ (get-remote-server~ processor) literal))))
  
  
  (method override (tier-id->literal id)
    (calling-server
      (lambda ()
        (registered-id~ (get-remote-server~ processor) id))))
  
  
  ;;;
  ;;;; Retrieve
  ;;;
  
  
  (method override (retrieve-entity id)
    (find-entity id))
  
  
  ;;;
  ;;;; Outgoing
  ;;;
  
  
  (method (calling-server thunk)
    ;; longer timeout while in development
    ;; as we might be running under a debugger
    (parameterize ((receive-timeout 60))
      (thunk)))


;;;
;;;; Processor
;;;


(class Processor extends Object
  
  
  (slot delegates        initialize '() getter generate)
  (slot hits             initialize 0   getter generate)
  (slot remote-processor                getter generate)
  (slot remote-master    initialize #f  getter generate)
  (slot remote-cookie    initialize #f  getter generate)
  (slot remote-server    initialize #f  getter generate)
  (slot server-name      initialize #f  getter generate)
  (slot zone             initialize #f  getter generate)
  
  
  (method override (initialize)
    (set! remote-processor (load-object~ (get-local-register) 'world.processor.remote 'world-remote-processor)))
  
  
  ;;;
  ;;;; Outgoing
  ;;;
  
  
  (method (broadcast-processor-update changes)
    (let ((tier (current-tier)))
      (for-each (lambda (delegate)
                  (let ((client (get-client~ delegate)))
                    (calling-client~ tier delegate
                      (lambda ()
                        (server-update~ client (current-seconds) changes)))))
                delegates)))
  
  
  ;;;
  ;;;; Incoming
  ;;;
  
  
  (method (processor-setup master cookie server server-name zone worker)
    (set! remote-master master)
    (set! remote-cookie cookie)
    (set! remote-server server)
    (set! server-name~self server-name)
    (set! zone~self zone)
    (set-worker (and worker (connect-remote-proxy worker))))
  
  
  (method (processor-quit)
    (quit))
  
  
  (method (client-join client client-id client-no character-name character-avatar character-script)
    (let ((tier (current-tier))
          (zone (current-zone)))
      (let ((reconnected-delegate (find-delegate-by-name character-name))
            (existing-player (find-player~ zone character-name)))
        (let ((delegate (if (not reconnected-delegate)
                            (new Client-Delegate client client-id client-no character-name character-avatar character-script)
                          (set-client~ reconnected-delegate client)
                          (set-alive~ reconnected-delegate (current-seconds))
                          (set-exception~ reconnected-delegate #f)
                          (set-exception-time~ reconnected-delegate #f)
                          reconnected-delegate)))
          (unless reconnected-delegate
            (set! delegates (cons delegate delegates)))
          ;; retrieve player
          (let ((player (or existing-player (player-retrieve client-id character-name character-avatar)))
                (player-delegate delegate))
            ;; collect other players for client
            (define (collect-other-players)
              (define (player-info player)
                (let ((name (get-name~ player))
                      (avatar (get-avatar~ player))
                      (id (get-id~ player))
                      (position (get-position~ player))
                      (lookat (get-lookat~ player)))
                  (list name avatar id position lookat)))
              
              (let ((me (current-me+))
                    (players
                      (collect (lambda (delegate)
                                 (and (neq? delegate player-delegate)
                                      (let ((name (get-name~ delegate)))
                                        (let ((existing (find-player~ zone name)))
                                          (player-info existing)))))
                               delegates)))
                (if (or (not me) (admin-me?~ me))
                    players
                  (cons (player-info me) players))))
            
            (let ((player-id (get-id~ player))
                  (player-position (get-position~ player))
                  (player-lookat (get-lookat~ player))
                  (other-players (collect-other-players)))
              ;; broadcast entering player to other players
              (for-each (lambda (delegate)
                          (unless (eq? delegate player-delegate)
                            (let ((client (get-client~ delegate)))
                              (calling-client~ tier delegate
                                (lambda ()
                                  (server-entered~ client client-id client-no character-name character-avatar character-script player-id player-position player-lookat))))))
                        delegates)
              (let (;; open test quicky to send form as a string
                    (form (call-with-input-file (path-settings (get-moniker~ zone)) read-content-string))
                    (spawnpoint (get-spawnpoint~ zone))
                    ;; todo
                    (player-spawnpoint (get-player-spawnpoint~ zone)))
                (list form spawnpoint (or player-spawnpoint spawnpoint) player-id player-position player-lookat other-players))))))))
  
  
  (method (client-leave client character-name)
    (let ((tier (current-tier))
          (zone (current-zone)))
      ;; aec robust
      (let ((player (find-player~ zone character-name)))
        (when player
          ;; store player
          (player-store player)
          ;; find server client
          (let ((player-delegate (find-delegate client)))
            ;; broadcast exiting player to other players
            (for-each (lambda (delegate)
                        (unless (eq? delegate player-delegate)
                          (let ((client (get-client~ delegate)))
                            (calling-client~ tier delegate
                              (lambda ()
                                (server-exited~ client character-name))))))
                      delegates)
            ;; unregister client
            (set! delegates (remove! player-delegate delegates)))))))
  
  
  (method (player-retrieve client-id character-name character-avatar)
    (let ((zone (current-zone)))
      (let ((file (new-file~ (players-dir) (format "{a}.player" character-name))))
        (let ((player
                (if (exists?~ file)
                    (let ((player (instantiate~ (read-form file))))
                      (register-id~ player client-id)
                      (set-me?~ player #f)
                      (set-name~ player character-name)
                      (set-avatar~ player character-avatar)
                      player)
                  (let ((units '(world.data)))
                    (let ((tag '(<Player> (<Camera>)))
                          (data (new Data zone-version 'jazz units #f)))
                      (let ((form (construct-form tag (imports-locator units) data)))
                        (set-origin~ form file)
                        (let ((player (instantiate~ form)))
                          (register-id~ player client-id)
                          (set-me?~ player #f)
                          (set-name~ player character-name)
                          (set-avatar~ player character-avatar)
                          (set-position~ player (find-spawnpoint~ zone))
                          (set-lookat~ player (find-spawnlookat~ zone))
                          player)))))))
          (set-billboard-name~ player character-name)
          (add-element~ zone player)
          player))))
  
  
  (method (player-store player)
    (let ((world (current-world))
          (zone (current-zone)))
      (let ((file (new-file~ (players-dir) (format "{a}.player" (get-name~ player)))))
        (create-directories~ file)
        (let ((designer (new Former form: (get-form~ player) reference: player)))
          (define (save-camera)
            (let ((eye (get-eye~ world))
                  (camera (player-camera~ player)))
              ;; useless at the moment as server doesnt have camera info
              (set-property~ designer camera 'position (get-position~ eye))
              (set-property~ designer camera 'lookat (get-lookat~ eye))))
          
          (define (save-player)
            (set-property~ designer player 'position (get-position~ player))
            (set-property~ designer player 'lookat (get-lookat~ player)))
          
          (save-camera)
          (save-player)
          (save~ designer)))
      (remove-element~ zone player)))
  
  
  (method (players-dir)
    (let ((tier (current-tier)))
      (new-directory~ (get-directory~ tier) "players")))
  
  
  (method (client-update client sent changes)
    (increase! hits)
    (when debug-sequence?
      ;; rebase sequence for tests
      (world.change:iterate-changes changes
        (lambda (change offset)
          (let ((sequence-no (world.history:next-sequence-no!)))
            (f64vector-set! changes (+ offset 5) (cast <fl> sequence-no))))))
    (forward-changes sent (current-seconds) changes)
    (with-outgoing-mutex
      (lambda ()
        (push-client-changes changes))))
  
  
  (method (retrieve-region region-index)
    (let ((zone (current-zone)))
      (boolean (load-region~ zone region-index))))
  
  
  (method (retrieve-chunk region-index chunk-index chunk-digest)
    (let ((zone (current-zone)))
      (let ((region (load-region~ zone region-index)))
        (let ((chunk (load-chunk~ region chunk-index)))
          (and @always-retrieve (not (equal? (get-digest~ chunk) chunk-digest))
               (let ((chunk-raw (get-raw~ chunk)))
                 chunk-raw))))))
  
  
  (method (retrieve-entity id)
    (let ((world (current-world)))
      (let ((entity (find-entity id)))
        ;; quick hack for test
        (when (not entity)
          (debug 'entity id 'not 'found)
          (set! entity (new Creature id: id name: 'NOT-FOUND model: 'Wolf)))
        ;; quick hack for players
        (when (is? entity Player)
          (debug 'player id 'retrieved)
          (set! entity (new Creature id: id name: 'PLAYER model: 'Wolf)))
        ;; quick first draft we should probably use jazz serialization
        (let ((class (class-of entity)))
          (cons (class->class-name~ world class) (package~ class entity))))))
  
  
  (method (find-delegate target)
    (find-if (lambda (delegate)
               (proxy=? (get-client~ delegate) target))
             delegates))
  
  
  (method (find-delegate-by-name target)
    (find-if (lambda (delegate)
               (equal? (get-name~ delegate) target))
             delegates)))


;;;
;;;; Ready
;;;


(definition protected (setup-processor)
  (let ((processor (new Processor)))
    (set-current-processor processor)
    (let ((master (command-argument "master"))
          (cookie (integer-argument "master-cookie"))
          (host (command-argument "host"))
          (service (integer-argument "service")))
      (assert (not (get-remote-listener))
        (start-remote-listener host: host service: service))
      (receive (host port alternate-port) (parse-host/service master)
        (let ((remote-register (connect-remote-register host port #t)))
          (let ((master (load-object~ remote-register 'world.master 'world-remote-master))
                (processor (get-remote-processor~ processor)))
            (slave-setup~ master processor cookie)))))))


(definition protected (ready-processor)
  (let ((processor (current-processor)))
    (let ((master (get-remote-master~ processor))
          (processor (get-remote-processor~ processor))
          (cookie (get-remote-cookie~ processor)))
      (slave-ready~ master processor cookie)))))
