;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Processor
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.processor jazz


(require (dialect.development))

(import (jazz.component)
        (jazz.debuggee)
        (jazz.digest)
        (jazz.evaluate)
        (jazz.event)
        (jazz.io)
        (jazz.jml)
        (jazz.jrm)
        (jazz.jrm.protocol)
        (jazz.network)
        (jazz.runtime)
        (jazz.settings)
        (jazz.snapshot)
        (jazz.time)
        (world)
        (world.assets)
        (world.autoload)
        (world.change)
        (world.network)
        (world.settings)
        (world.server.client)
        (world.server.serving)
        (world.syntax (phase syntax))
        (world.tier)
        (world.work))


;;;
;;;; Tier
;;;


(class Processor-Tier extends Serving-Tier
  
  
  (slot processor getter generate)
  
  
  (method override (initialize dir)
    (nextmethod dir)
    (set! processor (current-processor))
    (set! assets (gather-assets 'tier (new-directory~ directory "assets")))
    ;; aec quicky
    (set-remote-problem-handler
      (lambda (process)
        (catch (connection-problem? obj
                 obj)
          (process)))))
  
  
  ;;;
  ;;;; Register
  ;;;
  
  
  (method override (tier-literal->id literal)
    (calling-server
      (lambda ()
        (register-literal~ (get-remote-server~ processor) literal))))
  
  
  (method override (tier-id->literal id)
    (calling-server
      (lambda ()
        (registered-id~ (get-remote-server~ processor) id))))
  
  
  ;;;
  ;;;; Outgoing
  ;;;
  
  
  (method (calling-server thunk)
    ;; longer timeout while in development
    ;; as we might be running under a debugger
    (parameterize ((receive-timeout 60))
      (thunk)))
  
  
  ;;;
  ;;;; Debug
  ;;;
  
  
  (method (debug-processor . rest)
    (processor-debug~ (get-remote-server~ processor) (get-remote-processor~ processor) rest)))


;;;
;;;; Processor
;;;


(class Processor extends Object
  
  
  (slot clients          initialize '() getter generate)
  (slot hits             initialize 0   getter generate)
  (slot remote-processor                getter generate)
  (slot remote-master    initialize #f  getter generate)
  (slot remote-cookie    initialize #f  getter generate)
  (slot remote-server    initialize #f  getter generate)
  (slot server-name      initialize #f  getter generate)
  (slot zone             initialize #f  getter generate)
  
  
  (method override (initialize)
    (set! remote-processor (load-object~ (get-local-register) 'world.processor.remote 'world-remote-processor)))
  
  
  ;;;
  ;;;; Outgoing
  ;;;
  
  
  (method (broadcast-processor-update changes)
    (let ((tier (current-tier)))
      (for-each (lambda (client-state)
                  (let ((client (get-client~ client-state)))
                    (calling-client~ tier client-state
                      (lambda ()
                        (server-update~ client changes)))))
                clients)))
  
  
  ;;;
  ;;;; Incoming
  ;;;
  
  
  (method (processor-setup master cookie server server-name zone worker)
    (set! remote-master master)
    (set! remote-cookie cookie)
    (set! remote-server server)
    (set! server-name~self server-name)
    (set! zone~self zone)
    (connect-remote worker)
    (set-worker worker))
  
  
  (method (processor-quit)
    (quit))
  
  
  (method (client-join client client-id client-no character-name character-avatar)
    (let ((tier (current-tier))
          (zone (current-zone)))
      (debug-processor 'client-join character-name character-avatar)
      (let ((reconnected-client-state (find-client-state-by-name character-name))
            (existing-player (find-player~ zone character-name)))
        (let ((client-state (if (not reconnected-client-state)
                                (new Client-State client client-id client-no character-name character-avatar)
                              (set-client~ reconnected-client-state client)
                              (set-alive~ reconnected-client-state (current-seconds))
                              (set-exception~ reconnected-client-state #f)
                              (set-exception-time~ reconnected-client-state #f)
                              reconnected-client-state)))
          (unless reconnected-client-state
            (set! clients (cons client-state clients)))
          ;; retrieve player
          (let ((player (or existing-player (player-retrieve client-id character-name character-avatar)))
                (player-client-state client-state))
            ;; collect other players for client
            (define (collect-other-players)
              (define (player-info player)
                (let ((name (get-name~ player))
                      (avatar (get-avatar~ player))
                      (id (get-id~ player))
                      (position (get-position~ player))
                      (lookat (get-lookat~ player)))
                  (list name avatar id position lookat)))
              
              (let ((me (current-me+))
                    (players
                      (collect (lambda (client-state)
                                 (and (neq? client-state player-client-state)
                                      (let ((name (get-name~ client-state)))
                                        (let ((existing (find-player~ zone name)))
                                          (player-info existing)))))
                               clients)))
                (if (not me)
                    players
                  (cons (player-info me) players))))
            
            (let ((player-id (get-id~ player))
                  (player-position (get-position~ player))
                  (player-lookat (get-lookat~ player))
                  (other-players (collect-other-players)))
              ;; broadcast entering player to other players
              (for-each (lambda (client-state)
                          (unless (eq? client-state player-client-state)
                            (let ((client (get-client~ client-state)))
                              (calling-client~ tier client-state
                                (lambda ()
                                  (server-entered~ client client-id client-no character-name character-avatar player-id player-position player-lookat))))))
                        clients)
              (let (;; open test quicky to send form as a string
                    (form (call-with-input-file (path-settings (get-moniker~ zone)) read-content-string))
                    (spawnpoint (get-spawnpoint~ zone)))
                (list form spawnpoint player-id player-position player-lookat other-players))))))))
  
  
  (method (client-leave client character-name)
    (let ((tier (current-tier))
          (zone (current-zone)))
      (debug-processor 'client-leave character-name)
      ;; aec robust
      (let ((player (find-player~ zone character-name)))
        (when player
          ;; store player
          (player-store player)
          ;; find server client
          (let ((player-client-state (find-client-state client)))
            ;; broadcast exiting player to other players
            (for-each (lambda (client-state)
                        (unless (eq? client-state player-client-state)
                          (let ((client (get-client~ client-state)))
                            (calling-client~ tier client-state
                              (lambda ()
                                (server-exited~ client character-name))))))
                      clients)
            ;; unregister client
            (set! clients (remove! player-client-state clients)))))))
  
  
  (method (player-retrieve client-id character-name character-avatar)
    (let ((zone (current-zone)))
      (let ((file (new-file~ (players-dir) (format "{a}.player" character-name))))
        (let ((player
                (if (exists?~ file)
                    (let ((player (instantiate~ (read-form file))))
                      (register-id~ player client-id)
                      (set-name~ player character-name)
                      (set-avatar~ player character-avatar)
                      player)
                  (let ((units '(world.data)))
                    (let ((tag '(<Player> (<Camera>)))
                          (data (new Data zone-version 'jazz units #f)))
                      (let ((form (construct-form tag (imports-locator units) data)))
                        (set-origin~ form file)
                        (let ((player (instantiate~ form)))
                          (register-id~ player client-id)
                          (set-name~ player character-name)
                          (set-avatar~ player character-avatar)
                          (set-position~ player (find-spawnpoint~ zone))
                          (set-lookat~ player (find-spawnlookat~ zone))
                          player)))))))
          (set-billboard-name~ player character-name)
          (add-element~ zone player)
          player))))
  
  
  (method (player-store player)
    (let ((world (current-world))
          (zone (current-zone)))
      (let ((file (new-file~ (players-dir) (format "{a}.player" (get-name~ player)))))
        (create-directories~ file)
        (let ((designer (new Former form: (get-form~ player) reference: player)))
          (define (save-camera)
            (let ((eye (get-eye~ world))
                  (camera (player-camera~ player)))
              (set-property~ designer camera 'position (get-position~ eye))
              (set-property~ designer camera 'lookat (get-lookat~ eye))))
          
          (define (save-player)
            (set-property~ designer player 'position (get-position~ player))
            (set-property~ designer player 'lookat (get-lookat~ player)))
          
          (save-camera)
          (save-player)
          (save~ designer)))
      (remove-element~ zone player)))
  
  
  (method (players-dir)
    (let ((tier (current-tier)))
      (new-directory~ (get-directory~ tier) "players")))
  
  
  (method (client-update client changes)
    (increase! hits)
    ;; should probably be applied by a task when application
    (forward-changes changes)
    (outgoing-push-changes changes))
  
  
  (method (retrieve-region region-x region-y region-z)
    (let ((zone (current-zone)))
      (debug-processor 'retrieve-region region-x region-y region-z)
      (boolean (load-region~ zone region-x region-y region-z))))
  
  
  (method (retrieve-chunk region-x region-y region-z chunk-x chunk-z chunk-digest)
    (let ((zone (current-zone)))
      (let ((region (load-region~ zone region-x region-y region-z)))
        (let ((chunk (load-chunk~ region chunk-x chunk-z)))
          (and (not (equal? (get-digest~ chunk) chunk-digest))
               (let ((chunk-raw (get-raw~ chunk)))
                 (debug-processor 'retrieve-chunk region-x region-y region-z chunk-x chunk-z (u8vector-length chunk-raw))
                 chunk-raw))))))
  
  
  (method (debug-processor . rest)
    (when (world-setting 'world.processor.debug? #f)
      (apply debug 'processor rest)))
  
  
  (method (find-client-state target)
    (find-if (lambda (client)
               (proxy=? (get-client~ client) target))
             clients))
  
  
  (method (find-client-state-by-name target)
    (find-if (lambda (client)
               (equal? (get-name~ client) target))
             clients)))


;;;
;;;; Ready
;;;


(definition protected (setup-processor)
  (let ((processor (new Processor)))
    (set-current-processor processor)
    (let ((master (command-argument "master"))
          (cookie (integer-argument "master-cookie")))
      (receive (host port alternate-port) (parse-host/service master)
        (assert (or (not (get-remote-listener)) master)
          (start-remote-listener host: host))
        (let ((remote-register (connect-remote-register host port #t)))
          (let ((master (load-object~ remote-register 'world.master 'world-remote-master))
                (processor (get-remote-processor~ processor)))
            (slave-setup~ master processor cookie)))))))


(definition protected (ready-processor)
  (let ((processor (current-processor)))
    (let ((master (get-remote-master~ processor))
          (processor (get-remote-processor~ processor))
          (cookie (get-remote-cookie~ processor)))
      (slave-ready~ master processor cookie)))))
