;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; World Processor
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2016
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module world.processor jazz


(require (dialect.development))

(import (jazz.component)
        (jazz.debuggee)
        (jazz.digest)
        (jazz.evaluate)
        (jazz.event)
        (jazz.io)
        (jazz.jml)
        (jazz.jrm)
        (jazz.jrm.transmission)
        (jazz.network)
        (jazz.runtime)
        (jazz.settings)
        (jazz.snapshot)
        (jazz.time)
        (world)
        (world.assets)
        (world.autoload)
        (world.change)
        (world.id)
        (world.network)
        (world.settings)
        (world.server.client)
        (world.server.serving)
        (world.syntax (phase syntax))
        (world.tier)
        (world.work))


;;;
;;;; Tier
;;;


(class Processor-Tier extends Serving-Tier
  
  
  (slot processor getter generate)
  
  
  (method override (initialize dir)
    (nextmethod dir)
    (set! processor (current-processor))
    (set! assets (gather-assets 'tier (new-directory~ directory "assets")))
    ;; aec quicky
    (set-remote-problem-handler
      (lambda (process)
        (catch (connection-problem? obj
                 obj)
          (process)))))
  
  
  ;;;
  ;;;; Register
  ;;;
  
  
  (method override (tier-literal->id literal)
    (calling-server
      (lambda ()
        (register-literal~ (get-remote-server~ processor) literal))))
  
  
  (method override (tier-id->literal id)
    (calling-server
      (lambda ()
        (registered-id~ (get-remote-server~ processor) id))))
  
  
  ;;;
  ;;;; Outgoing
  ;;;
  
  
  (method (calling-server thunk)
    ;; longer timeout while in development
    ;; as we might be running under a debugger
    (parameterize ((receive-timeout 60))
      (thunk)))
  
  
  ;;;
  ;;;; Debug
  ;;;
  
  
  (method (debug-processor . rest)
    (processor-debug~ (get-remote-server~ processor) (get-remote-processor~ processor) rest)))


;;;
;;;; Processor
;;;


(class Processor extends Object
  
  
  (slot delegates        initialize '() getter generate)
  (slot hits             initialize 0   getter generate)
  (slot remote-processor                getter generate)
  (slot remote-master    initialize #f  getter generate)
  (slot remote-cookie    initialize #f  getter generate)
  (slot remote-server    initialize #f  getter generate)
  (slot server-name      initialize #f  getter generate)
  (slot zone             initialize #f  getter generate)
  
  
  (method override (initialize)
    (set! remote-processor (load-object~ (get-local-register) 'world.processor.remote 'world-remote-processor)))
  
  
  ;;;
  ;;;; Outgoing
  ;;;
  
  
  (method (broadcast-processor-update changes)
    (let ((tier (current-tier)))
      (for-each (lambda (delegate)
                  (let ((client (get-client~ delegate)))
                    (calling-client~ tier delegate
                      (lambda ()
                        (server-update~ client (current-seconds) changes)))))
                delegates)))
  
  
  ;;;
  ;;;; Incoming
  ;;;
  
  
  (method (processor-setup master cookie server server-name zone worker)
    (set! remote-master master)
    (set! remote-cookie cookie)
    (set! remote-server server)
    (set! server-name~self server-name)
    (set! zone~self zone)
    (connect-remote-proxy worker)
    (set-worker worker))
  
  
  (method (processor-quit)
    (quit))
  
  
  (method (client-join client client-id client-no character-name character-avatar)
    (let ((tier (current-tier))
          (zone (current-zone)))
      (debug-processor 'client-join character-name character-avatar)
      (let ((reconnected-delegate (find-delegate-by-name character-name))
            (existing-player (find-player~ zone character-name)))
        (let ((delegate (if (not reconnected-delegate)
                            (new Client-Delegate client client-id client-no character-name character-avatar)
                          (set-client~ reconnected-delegate client)
                          (set-alive~ reconnected-delegate (current-seconds))
                          (set-exception~ reconnected-delegate #f)
                          (set-exception-time~ reconnected-delegate #f)
                          reconnected-delegate)))
          (unless reconnected-delegate
            (set! delegates (cons delegate delegates)))
          ;; retrieve player
          (let ((player (or existing-player (player-retrieve client-id character-name character-avatar)))
                (player-delegate delegate))
            ;; collect other players for client
            (define (collect-other-players)
              (define (player-info player)
                (let ((name (get-name~ player))
                      (avatar (get-avatar~ player))
                      (id (get-id~ player))
                      (position (get-position~ player))
                      (lookat (get-lookat~ player)))
                  (list name avatar id position lookat)))
              
              (let ((me (current-me+))
                    (players
                      (collect (lambda (delegate)
                                 (and (neq? delegate player-delegate)
                                      (let ((name (get-name~ delegate)))
                                        (let ((existing (find-player~ zone name)))
                                          (player-info existing)))))
                               delegates)))
                (if (or (not me) (admin-me?~ me))
                    players
                  (cons (player-info me) players))))
            
            (let ((player-id (get-id~ player))
                  (player-position (get-position~ player))
                  (player-lookat (get-lookat~ player))
                  (other-players (collect-other-players)))
              ;; broadcast entering player to other players
              (for-each (lambda (delegate)
                          (unless (eq? delegate player-delegate)
                            (let ((client (get-client~ delegate)))
                              (calling-client~ tier delegate
                                (lambda ()
                                  (server-entered~ client client-id client-no character-name character-avatar player-id player-position player-lookat))))))
                        delegates)
              (let (;; open test quicky to send form as a string
                    (form (call-with-input-file (path-settings (get-moniker~ zone)) read-content-string))
                    (spawnpoint (get-spawnpoint~ zone)))
                (list form spawnpoint player-id player-position player-lookat other-players))))))))
  
  
  (method (client-leave client character-name)
    (let ((tier (current-tier))
          (zone (current-zone)))
      (debug-processor 'client-leave character-name)
      ;; aec robust
      (let ((player (find-player~ zone character-name)))
        (when player
          ;; store player
          (player-store player)
          ;; find server client
          (let ((player-delegate (find-delegate client)))
            ;; broadcast exiting player to other players
            (for-each (lambda (delegate)
                        (unless (eq? delegate player-delegate)
                          (let ((client (get-client~ delegate)))
                            (calling-client~ tier delegate
                              (lambda ()
                                (server-exited~ client character-name))))))
                      delegates)
            ;; unregister client
            (set! delegates (remove! player-delegate delegates)))))))
  
  
  (method (player-retrieve client-id character-name character-avatar)
    (let ((zone (current-zone)))
      (let ((file (new-file~ (players-dir) (format "{a}.player" character-name))))
        (let ((player
                (if (exists?~ file)
                    (let ((player (instantiate~ (read-form file))))
                      (register-id~ player client-id)
                      (set-name~ player character-name)
                      (set-avatar~ player character-avatar)
                      player)
                  (let ((units '(world.data)))
                    (let ((tag '(<Player> (<Camera>)))
                          (data (new Data zone-version 'jazz units #f)))
                      (let ((form (construct-form tag (imports-locator units) data)))
                        (set-origin~ form file)
                        (let ((player (instantiate~ form)))
                          (register-id~ player client-id)
                          (set-name~ player character-name)
                          (set-avatar~ player character-avatar)
                          (set-position~ player (find-spawnpoint~ zone))
                          (set-lookat~ player (find-spawnlookat~ zone))
                          player)))))))
          (set-billboard-name~ player character-name)
          (add-element~ zone player)
          player))))
  
  
  (method (player-store player)
    (let ((world (current-world))
          (zone (current-zone)))
      (let ((file (new-file~ (players-dir) (format "{a}.player" (get-name~ player)))))
        (create-directories~ file)
        (let ((designer (new Former form: (get-form~ player) reference: player)))
          (define (save-camera)
            (let ((eye (get-eye~ world))
                  (camera (player-camera~ player)))
              ;; useless at the moment as server doesnt have camera info
              (set-property~ designer camera 'position (get-position~ eye))
              (set-property~ designer camera 'lookat (get-lookat~ eye))))
          
          (define (save-player)
            (set-property~ designer player 'position (get-position~ player))
            (set-property~ designer player 'lookat (get-lookat~ player)))
          
          (save-camera)
          (save-player)
          (save~ designer)))
      (remove-element~ zone player)))
  
  
  (method (players-dir)
    (let ((tier (current-tier)))
      (new-directory~ (get-directory~ tier) "players")))
  
  
  (method (client-update client sent changes)
    (increase! hits)
    (forward-changes sent (current-seconds) changes)
    (outgoing-push-changes changes))
  
  
  (method (retrieve-region region-index)
    (let ((zone (current-zone)))
      (debug-processor 'retrieve-region region-index)
      (boolean (load-region~ zone region-index))))
  
  
  (method (retrieve-chunk region-index chunk-index chunk-digest)
    (let ((zone (current-zone)))
      (let ((region (load-region~ zone region-index)))
        (let ((chunk (load-chunk~ region chunk-index)))
          (and @always-retrieve (not (equal? (get-digest~ chunk) chunk-digest))
               (let ((chunk-raw (get-raw~ chunk)))
                 (debug-processor 'retrieve-chunk region-index chunk-index (u8vector-length chunk-raw))
                 chunk-raw))))))
  
  
  (method (retrieve-entity id)
    (let ((world (current-world)))
      (let ((entity (find-entity id)))
        (assert entity
          @debug
          (debug 'package entity)
          ;; quick first draft we should probably use jazz serialization
          (let ((class (class-of entity)))
            (cons (class->class-name~ world class) (package~ class entity)))))))
  
  
  (method (debug-processor . rest)
    (when (world-setting 'world.processor.debug? #f)
      (apply debug 'processor rest)))
  
  
  (method (find-delegate target)
    (find-if (lambda (delegate)
               (proxy=? (get-client~ delegate) target))
             delegates))
  
  
  (method (find-delegate-by-name target)
    (find-if (lambda (delegate)
               (equal? (get-name~ delegate) target))
             delegates)))


;;;
;;;; Ready
;;;


(definition protected (setup-processor)
  (let ((processor (new Processor)))
    (set-current-processor processor)
    (let ((master (command-argument "master"))
          (cookie (integer-argument "master-cookie")))
      (receive (host port alternate-port) (parse-host/service master)
        (assert (or (not (get-remote-listener)) master)
          (start-remote-listener host: host))
        (let ((remote-register (connect-remote-register host port #t)))
          (let ((master (load-object~ remote-register 'world.master 'world-remote-master))
                (processor (get-remote-processor~ processor)))
            (slave-setup~ master processor cookie)))))))


(definition protected (ready-processor)
  (let ((processor (current-processor)))
    (let ((master (get-remote-master~ processor))
          (processor (get-remote-processor~ processor))
          (cookie (get-remote-cookie~ processor)))
      (slave-ready~ master processor cookie)))))
