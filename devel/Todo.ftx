{Formatted-Text
 formats:
 ({Format Base}
  {Format Heading1}
  {Format Base left-margin: 16 bulleted?: #t}
  {Format Base left-margin: 48 bulleted?: #t}
  {Format Heading2}
  {Format Base left-margin: 0 bulleted?: #f}
  {Format Heading2 left-margin: 16 bulleted?: #t}
  {Format Heading2 left-margin: 48 bulleted?: #t}
  {Format Heading2 left-margin: 80 bulleted?: #t}
  {Format Heading2 left-margin: 112 bulleted?: #t}
  {Format Heading2 left-margin: 0 bulleted?: #f}
  {Format Heading1 left-margin: 16 bulleted?: #t}
  {Format Heading1 left-margin: 48 bulleted?: #t}
  {Format Heading3}
  {Format Heading1 left-margin: 0 bulleted?: #f})

 styles:
 ({Text-Style Base}
  {Text-Style Heading1}
  {Text-Style Heading2}
  {Text-Style Heading3})

 paragraphs:
 ((1 ("TODO" 1))
  (1)
  (1)
  (2 ("Editor multi-player" 0))
  (11 ("Interface" 0))
  (11 ("List of models" 0))
  (2 ("Fix hit test problems" 0))
  (11 ("SXML pour pouvoir importer collada" 0))
  (11 ("Animations" 0))
  (5)
  (5)
  (11 ("Optimize memory usage" 0))
  (11 ("Understand why we still need to have the glut dll" 0))
  (11 ("We are redoing all the camera stuff all the time in draw-world" 0))
  (11 ("Understand why we had to do (glCullFace GL_FRONT) in Actor instead of a global GL_BACK" 0))
  (12 ("Sprites render correctly with GL_BACK and using the same code!" 0))
  (11 ("Understand why activating (glEnable GL_CULL_FACE) globally reduces frame rate" 0))
  (11 ("Add to the walker the ability to define type aliases so I can do <vertex> equivalent to <f32vector>" 0))
  (11 ("Writing to the z-buffer must be disabled when rendering transparent (alpha <1) objects.  We still want the depth test to be in effect, though.  So: (glDepthMask GL_FALSE) -> draw alpha object -> (glDepthMask GL_TRUE).  It's also generally better to render all opaque objects in your scene first, then disable the depth mask and draw all your transparent objects at once, at the end." 0))
  (11 ("We are probably missing many update-area calls that should go together with update-position" 0))
  (14)
  (14)
  (4 ("Alain" 2))
  (6 ("Relate orthographic and perspective zooming (AM) #1" 0))
  (7 ("General case: ortho vs plane!? or use camera direction!?" 0))
  (2 ("Limit strafing to game boundaries (AM)" 0))
  (3 ("Vertical boundary will solve block starting at exactly floor level" 0))
  (2 ("Fix pitch for flight mode (AM)" 0))
  (2 ("Improve fustrum culling to cull more than only backward facing sectors" 0))
  (2 ("Improvements to hit-test #6" 0))
  (2 ("Make it so the grid is always on the correct side #4" 0))
  (2 ("Implemented player sphere rolling in every direction #5" 0))
  (2 ("Variable gravity game #7" 0))
  (5)
  (5)
  (4 ("Guillaume" 2))
  (6 ("Optimize memory usage of frustum culling" 0))
  (1)
  (1)
  (4 ("Marc" 2))
  (6 ("Look at generated C code" 0))
  (6 ("Optimize code" 0))
  (6 ("Optimize memory" 0))
  (7 ("Constant data" 0))
  (11 ("Can a f32vector be passed directly to a FFI?" 0))
  (6 ("Show Marc the almost never ending augmentation of the memory in applications" 0))
  (7 ("Look at Commit Size" 0))
  (6 ("Could floats and/or doubles be made to be Gambit immediate types" 0))
  (7 ("At least on 64 bit architectures" 0))
  (6 ("How many bytes do a fl take?" 0))
  (6 ("What can be done vs the huge advantage that C has of being able to stack allocate a vertex for example that it can then pass to a function that will put its result in it" 0))
  (7 ("C++ even enables this implicitly when passing parameters around so that you get the expressiveness of functional calls with no memory allocation" 0))
  (7 ("Can we extend the basic block float optimization for vertices" 0))
  (6 ("Do I understand correctly that anything <fl> is a double (F64)" 0))
  (7 ("If so is there any way to use floats (F32)" 0))
  (6 ("Is there any difference between" 0))
  (7 ("C code that defines foo + c-external to it and" 0))
  (7 ("Define foo c-lambda inlining the code" 0))
  (7 ("Because an advantage of the first approach is that you can name the parameters" 0))
  (8 ("Could the FFI be extended to allow naming parameters" 0))
  (6 ("It's annoying that a (time <something that doesn't allocate memory) reports -32 bytes allocated" 0))
  (6 ("Can time be made to output to a specific port" 0))
  (6 ("Look at ray-triangle-distance" 0))
  (7 ("Jazz code" 0))
  (7 ("Jazz generated Gambit code" 0))
  (7 ("C generated code" 0))
  (7 ("JVM?" 0))
  (7 ("(##f32-vector-ref v n) va bien generer v[n]?" 0))
  (7 ("More efficient version than my f32-ref" 0))
  (6 ("In ray-intersects-sphere?" 0))
  (7 ("(f32-set! det! (sqrt (f32-ref det!)))" 0))
  (8 ("sqrt seems to always allocate even if generated code is ##sqrt" 0))
  (6 ("Any ideas on my hack (!?) of preallocating outside the geometry functions" 0))
  (6 ("Can float print precision be controlled port-wise?" 0))
  (10)
  (10)
  (6 ("Answers" 0))
  (7 ("Gambit used only double internaly in generate code" 0))
  (7 ("Use ##flsqrt" 0))
  (7 ("Float -> 24 (12 bytes)" 0))
  (10)
  (1)
  (4 ("Window" 2))
  (2 ("Fullscreen toggle" 0))
  (2 ("Not play keyboard events when application is inactive" 0))
  (5)
  (5)
  (4 ("Windows" 2))
  (6 ("Remove the opengl-fullscreen? hack" 0))
  (6 ("Should we use AdjustWindowRectEx when creating window handle" 0))
  (0)
  (0)
  (4 ("Projection" 2))
  (6 ("Relate orthographic and perspective zooming (AM)" 0))
  (0)
  (5)
  (4 ("Camera" 2))
  (2 ("Limit strafing to game boundaries (AM)" 0))
  (3 ("Vertical boundary will solve block starting at exactly floor level" 0))
  (2 ("Fix pitch for flight mode (AM)" 0))
  (0)
  (0)
  (4 ("Lighting" 2))
  (0)
  (0)
  (4 ("Keyboard" 2))
  (2 ("Input devices" 0))
  (0)
  (0)
  (4 ("Editor" 2))
  (6 ("We will need to be able to load levels directly to components when no edition is desired" 0))
  (5)
  (0)
  (4 ("History" 2))
  (2 ("Integrate non-actor state like:" 0))
  (3 ("World win/lose state" 0))
  (3 ("Color of win block" 0))
  (2 ("Try rendering non-now as a dimmed version" 0))
  (2 ("Save history to file (save in snapshot!?)" 0))
  (0)
  (0)
  (4 ("Live" 2))
  (5)
  (5)
  (4 ("Evaluate" 2))
  (2 ("Add / remove / modify slots" 0))
  (2 ("Support for top-down code that calls a not yet defined method" 0))
  (3 ("Complete work on delayed evaluation" 0))
  (2 ("Add info to evaluate-hook so it can recompile a shader" 0))
  (0)
  (0)
  (4 ("Areas" 2))
  (6 ("Need to unlink (remove from hashtable) empty areas" 0))
  (7 ("This is not so easy as one thing that makes the implementation simple is that areas are created on consultation" 0))
  (0)
  (0)
  (4 ("Hit Test" 2))
  (2 ("Do I do the trivial test of not calling hit testing when there is no movement?" 0))
  (2 ("For a very large game, I suppose the engine won't be moving unimportant mobs like wolves if there is no player near!?" 0))
  (2 ("Need to return the minimum value, e.g. continue iterating in case another objects is even closer" 0))
  (3 ("Return all objects hit that are at the minimal value" 0))
  (2 ("Maybe my heuristic approach should be based on the vector of the movement!?" 0))
  (3 ("For example, if we move .5 in x and .2 in y, then favor the x when there is conflicting solutions!?" 0))
  (2 ("Debug why my commit \"Returning multiple hit objects allow a common border\" is never returning more than one object" 0))
  (0)
  (0)
  (4 ("World" 2))
  (6 ("Use components to save / load the world!?" 0))
  (7 ("I think the best approach is to still use the Jazz module system" 0))
  (8 ("Gives us identification of classes and forms" 0))
  (8 ("Enables everything to be compiled or interpreted" 0))
  (7 ("Add a define-form!?" 0))
  (8 ("Could be referenced from a form (<f>) " 0))
  (8 ("Represents the structure but without the inheritence or behavior changes" 0))
  (6 ("Think about object composition" 0))
  (7 ("How can we make the player a sphere, composed from other objects, ..." 0))
  (0)
  (0)
  (4 ("Engine" 2))
  (6 ("To implement that the floor is always at the bottom of the screen in orthogonal projection for 2d games we need to do more that doing nothing as we currently do, as a resize that is not proportional will create problems" 0))
  (6 ("It pretty boils down to interpolation vs simulation" 0))
  (7 ("A good example that doesn't work well with interpolation is gravity" 0))
  (8 ("A jump that lags and is interpolated can make us miss the intended platform" 0))
  (7 ("A simulation approach where we redo the small ticks we missed solves the previous problem" 0))
  (8 ("But will not work if we are really getting behind in TPS" 0))
  (7 ("Maybe choose approach based on TPS!?" 0))
  (7 ("Is this interpolation vs simulation logic extensible to the problem of managing lag in a network game?" 0))
  (10)
  (10)
  (4 ("OpenGL" 2))
  (10)
  (10)
  (4 ("Textures" 2))
  (6 ("Consider saving the texture pack to file!?" 0))
  (7 ("(export-to-png file)" 0))
  (7 ("Problem is how to preserve indexing in the pack" 0))
  (10)
  (10)
  (4 ("Shaders" 2))
  (10)
  (10)
  (4 ("Gaia" 2))
  (6 ("Jedi binaries" 0))
  (6 ("World binaries" 0))
  (7 ("Include Jazz binaries!?" 0))
  (6 ("Focus on interpreted development" 0))
  (7 ("Make sure it can be compiled if the build environment is available" 0))
  (10)
  (10)
  (4 ("Game" 2))
  (6 ("Add boost pills on the floor that can be used to go faster, jump higher, ..." 0))
  (0)
  (0)
  (4 ("Look" 2))
  (5)
  (5)
  (4 ("Walker" 2))
  (6 ("Add type aliases so for example we can type (vertex+ v1 <vertex> v2 <vertex>) <vertex>" 0))
  (6 ("Add ref / set! syntax. Maybe" 0))
  (7 ("vert.x" 0))
  (7 ("(set! vert.x ...)" 0))
  (6 ("It will need to be composable" 0))
  (7 ("lookat.sight.x" 0))
  (6 ("How would it work with f32?" 0))
  (7 ("f.val !?" 0))
  (6 ("Also support v.0, v.1, ... !?" 0))
  (5)
  (5)
  (4 ("Foreing" 2))
  (6 ("OpenGL has functions that take a vector as parameter like glVertex3fv. Maybe this could be done by using homogenous vectors of floats!?" 0))
  (7 ("In Gambit FFI converter macro" 0))
  (8 ("begin part does the convertion" 0))
  (8 ("end part does the cleanup if needed" 0))
  (8 ("note that it receives the i index so it could use C's concatenation operation to access an offset in the previous argument!?" 0))
  (0)
  (0)
  (4 ("Performance" 2))
  (6 ("FFI overhead" 0))
  (7 ("Pure FFI calls render of metropolis: 35/s" 0))
  (7 ("All done in C: 70/s" 0))
  (7 ("Marc suggested try using ##code to see if it is the argument conversion part of the FFI call that is costly (done by a function call)" 0))
  (6 ("Need to optimize get-red, ... color getters as it doesn't make sense to cache RGBA everywhere" 0))
  (0)
  (0)
  (4 ("Memory" 2))
  (10 ("10/06/01 metropolis moving around" 0))
  (6 ("GC: 1.0s 2%" 0))
  (6 ("Tick: 21/s 0%" 0))
  (6 ("Render: 21/s 82%" 0))
  (10 ("10/06/01 after removing gl- calls" 0))
  (6 ("GC: 1.0s 2%" 0))
  (6 ("Tick: 26/s 0%" 0))
  (6 ("Render: 26/s 88%" 0))
  (10)
  (10 ("12/06/06 metropolis determine-eye-occlusion test" 0))
  (6 ("11 real" 0))
  (6 ("16 cpu" 0))
  (6 ("23 megs" 0))
  (10 ("12/06/08 after floating point optimizations" 0))
  (6 ("4 real" 0))
  (6 ("0 cpu" 0))
  (6 ("1 meg" 0))
  (10)
  (6 ("Difficult to optimize memory and gcs while draw-info and draw-counters generate tons of memory themselves" 0))
  (10)
  (0)
  (4 ("Network" 2))
  (10)
  (10)
  (4 ("Deployment" 2))
  (6 ("Fix locating of the resources directory in devel and in deployment" 0))
  (6 ("Try reducing size of zipped application" 0))
  (7 ("Remove packages like jazz.ui by moving pure window stuff into a separate package" 0))
  (7 ("Add a means to not register exported symbols at runtime" 0))
  (0)
  (0)
  (4 ("Release" 2))
  (6 ("Needed for a release" 0))
  (7 ("Generational GC" 0))
  (0)
  (0)
  (4 ("Platforms" 2))
  (2 ("Port to other platforms" 0))
  (3 ("Can glut be used without any sacrifice?" 0))
  (2 ("Port to mobiles" 0))
  (3 ("Be wary of Cairo uses" 0))
  (3 ("Be extra wary of Jazz UI uses" 0))
  (0)
  (0)
  (4 ("Notes" 2))
  (6 ("In first person mode, with the camera far away and perpendicular to a flat level" 0))
  (7 ("When we then move in the level, the camera automatically follows exactly like in orthographic projection!" 0))
  (6 ("In first person" 0))
  (7 ("Camera rotates around the player" 0))
  (6 ("Else" 0))
  (7 ("Camera rotates around the eye" 0))
  (6 ("A 'See through walls effect' can be obtained by having" 0))
  (7 ("The following drawing order" 0))
  (8 ("Objects outside the walls" 0))
  (8 ("Player" 0))
  (8 ("Walls" 0))
  (7 ("When camera is brougt close enough to player so he becomes alpha < 1. then the z-buffer will" 0))
  (8 ("draw the player over the objects but they will still be visible and" 0))
  (8 ("not draw the walls as they are behind the player that OpenGL thinks completely covers them!" 0))
  (0))}
